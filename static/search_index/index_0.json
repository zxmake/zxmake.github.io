{"/get_started/zh/tutorial/quick-start.html":{"title":"","content":" class: heading_no_counter # 快速开始 ## 创建工程 创建一个名叫 `hello` 的 `c` 控制台工程： ```bash $ xmake create language c project ./hello # 或 $ xmake create l c P ./hello ``` 执行完后，将会生成一个简单工程结构： ``` ./hello/ ├── src │ └── main.c └── xmake.lua ``` 其中 `xmake.lua` 是工程描述文件，内容非常简单，告诉 xmake 添加 `src` 目录下的所有 `.c` 源文件： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"hello\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 目前支持的语言如下： * c/c++ * objc/c++ * cuda * asm * swift * dlang * golang * rust > 如果你想了解更多参数选项，请运行: `xmake create help`。 ## 构建工程 ```bash $ cd hello $ xmake ``` ## 运行程序 ```bash $ xmake run hello ``` ## 调试程序 首先你需要切换到 debug 模式去重新编译程序。 ```bash $ xmake config m debug $ xmake ``` 然后执行下面的命令去开始调试： ```bash $ xmake run d hello ``` xmake 将会使用调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。 ```bash (gdb) b main Breakpoint 1 at 0x115c: file src/main.c, line 4. (gdb) r Starting program: /tmp/test xmake/hello/build/linux/x86_64/debug/hello [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64 linux gnu/libthread_db.so.1\". Breakpoint 1, main (argc 1, argv 0x7fffffffdac8) at src/main.c:4 4 printf(\"hello world!\\n\"); (gdb) ``` 如果想要使用指定的调试器： ```bash $ xmake f debugger gdb $ xmake run d hello ``` > 你也可以使用简写的命令行选项，例如: `xmake r` 或者 `xmake run`。"},"/get_started/zh/tutorial/project-examples.html":{"title":"","content":" class: heading_no_counter # 工程例子 以下是一些常用的工程例子，更多的 examples 可以到 [project examples](https://github.com/TOMO CAT/xmake/tree/master/tests/projects) 中查看。 我们也可以通过 `xmake create` 命令创建各种常用的空工程来快速开始，具体对于这个命令的介绍以及支持的工程模板可以敲下面的命令查看： ```bash xmake create help ``` ## 可执行程序 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") end) ``` 完整例子请执行下面的命令来创建： ```bash xmake create l c t console test ``` ## 静态库程序 ```lua target(\"library\", function() set_kind(\"static\") add_files(\"src/library/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") add_deps(\"library\") end) ``` 通过 `add_deps` 将一个静态库自动链接到 test 可执行程序。 完整例子请执行下面的命令来创建： ```bash xmake create l c t static test ``` ## 动态库程序 ```lua target(\"library\", function() set_kind(\"shared\") add_files(\"src/library/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") add_deps(\"library\") end) ``` 通过 `add_deps` 将一个动态库自动链接到 test 可执行程序。 完整例子请执行下面的命令来创建： ```bash xmake create l c t shared test ``` ## Wasm 程序 所有 c/c++ 程序，我们都可以编译成 Wasm，无需任何 xmake.lua 配置改动，只需要切换到 wasm 编译平台进行编译。 ```bash $ xmake f p wasm $ xmake ``` 详细的 Wasm 编译配置见：[Wasm 配置](/zh cn/guide/configuration?id wasm) 另外，在编译带有 ` preload file assets/xxx.md` 设置的文件时候，我们也可以通过配置，简化对它的设置。 ```lua target(\"test5\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_values(\"wasm.preloadfiles\", \"src/xxx.md\") add_values(\"wasm.preloadfiles\", \"src/xxx2.md\") end) ``` ## Qt 程序 创建一个空工程： ```bash $ xmake create t qt.console test $ xmake create t qt.static test $ xmake create t qt.shared test $ xmake create t qt.quickapp test $ xmake create t qt.widgetapp test ``` 更多工程模板见：`xmake create help`。 默认会自动探测 Qt 环境，当然也可以指定 Qt SDK 环境目录： ```bash $ xmake f qt ~/Qt/Qt5.9.1 ``` 上述指定的 MingW SDK 用的是 Qt 下 Tools 目录自带的环境，当然如果有其他第三方 MingW 编译环境，也可以手动指定, 具体可以参考：[MingW 编译配置](/zh cn/guide/configuration?id mingw)。 更多详情可以参考：[#160](https://github.com/xmake io/xmake/issues/160) 另外，当前 xmake 也支持 Qt/Wasm，详情见：[Wasm 配置](/zh cn/guide/configuration?id wasm) ```bash $ xmake f p wasm ``` ### 静态库程序 ```lua target(\"qt_static_library\", function() add_rules(\"qt.static\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ### 动态库程序 ```lua target(\"qt_shared_library\", function() add_rules(\"qt.shared\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ### 控制台程序 ```lua target(\"qt_console\", function() add_rules(\"qt.console\") add_files(\"src/*.cpp\") end) ``` ### Quick 应用程序 ```lua target(\"qt_quickapp\", function() add_rules(\"qt.quickapp\") add_files(\"src/*.cpp\") add_files(\"src/qml.qrc\") end) ``` > 如果使用的自己编译的 static 版本 QT SDK，那么需要切换到 `add_rules(\"qt.quickapp_static\")` 静态规则才行，因为链接的库是不同的，需要做静态链接。 ### Quick Plugin 程序 完整例子见：[quickplugin example](https://github.com/xmake io/xmake/tree/master/tests/projects/qt/quickplugin) ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"demo\", function() add_rules(\"qt.qmlplugin\") add_headerfiles(\"src/*.h\") add_files(\"src/*.cpp\") set_values(\"qt.qmlplugin.import_name\", \"My.Plugin\") end) ``` ### Widgets 应用程序 ```lua target(\"qt_widgetapp\", function() add_rules(\"qt.widgetapp\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add_files(\"src/mainwindow.h\") 添加带有 Q_OBJECT 的meta头文件 end) ``` ### Android 应用程序 可以直接切到 android 平台编译 Quick/Widgets 应用程序，生成 apk 包，并且可通过 `xmake install` 命令安装到设备： ```bash $ xmake create t quickapp_qt l c++ appdemo $ cd appdemo $ xmake f p android ndk ~/Downloads/android ndk r19c/ android_sdk ~/Library/Android/sdk/ c $ xmake [ 0%]: compiling.qt.qrc src/qml.qrc [ 50%]: cache compiling.release src/main.cpp [100%]: linking.release libappdemo.so [100%]: generating.qt.app appdemo.apk ``` 然后安装到设备： ```bash $ xmake install installing appdemo ... installing build/android/release/appdemo.apk .. Success install ok!👌 ``` ### 目前支持的 Qt SDK #### 来自 Qt 官方提供的 SDK 安装包 在 macos 上通常能自动探测到，但是也可以手动指定 Qt SDK 路径。 ```bash $ xmake f qt [qt sdk path] ``` #### 来自 Ubuntu Apt 安装包 使用 apt 安装完 Qt SDK，xmake 也能够自动检测到。 ```bash $ sudo apt install y qtcreator qtbase5 dev $ xmake ``` #### 来自 msys2/pacman 的 Qt Mingw 安装包 xmake 也支持从 pacman 安装的 Qt Mingw SDK ```bash $ pacman S mingw w64 x86_64 qt5 mingw w64 x86_64 qt creator $ xmake ``` #### 来自 aqtinstall 脚本的 Qt SDK 包 [aqtinstall](https://github.com/miurahr/aqtinstall) 安装的 Qt SDK 是完全基于官方 SDK 结构的，所以 xmake 也完全支持。 但是，通常需要自己指定 SDK 路径。 ```bash $ xmake f qt [Qt SDK] ``` #### 跨平台 Qt 交叉编译 对于跨平台 Qt 开发，xmake 支持为主机工具和目标平台使用单独的 SDK。这在为不同于开发机器的平台构建 Qt 应用程序时特别有用。 ` qt_host` 选项允许您指定与构建机器兼容的 Qt 工具的位置，而 ` qt` 指向目标平台的 SDK： ```bash $ xmake f qt [target Qt sdk] qt_host [host Qt sdk] ``` **重要注意事项**： * 确保主机和目标 Qt 版本匹配，否则可能会导致构建问题。 * 本机部署工具（如 `windeployqt` 和 `macdeployqt`）必须在各自的平台上运行，因此跨平台任务（如 `xmake install`）可能会失败。 #### 来自 xmake repo 仓库的 Qt 包 xmake 现在官方提供了 Qt5 SDK 的各种模块包，可以自动集成使用，无需任何手动安装。 只需要配置集成包就行了，xmake 会自动处理 Qt 的安装集成，并且自动编译项目。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"qt5widgets\") target(\"test\", function() add_rules(\"qt.widgetapp\") add_packages(\"qt5widgets\") add_headerfiles(\"src/*.h\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add files with Q_OBJECT meta (only for qt.moc) add_files(\"src/mainwindow.h\") end) ``` 除了 `qt5widgets` 包，仓库还提供了 `qt5gui`, `qt5network` 等包，可以使用。 配置完，只需要执行： ```bash $ xmake ``` #### 来自 vcpkg/conan 的 Qt 包 暂时还没时间支持，请尽量使用上面的方式集成 Qt SDK。 ## umdf 驱动程序 ```lua target(\"echo\", function() add_rules(\"wdk.driver\", \"wdk.env.umdf\") add_files(\"driver/*.c\") add_files(\"driver/*.inx\") add_includedirs(\"exe\") end) target(\"app\", function() add_rules(\"wdk.binary\", \"wdk.env.umdf\") add_files(\"exe/*.cpp\") end) ``` ### wdm 驱动程序 ```lua target(\"kcs\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") add_values(\"wdk.man.flags\", \" prefix Kcs\") add_values(\"wdk.man.resource\", \"kcsCounters.rc\") add_values(\"wdk.man.header\", \"kcsCounters.h\") add_values(\"wdk.man.counter_header\", \"kcsCounters_counters.h\") add_files(\"*.c\", \"*.rc\", \"*.man\") end) ``` ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") add_values(\"wdk.tracewpp.flags\", \" func:TracePrint((LEVEL,FLAGS,MSG,...))\") add_files(\"*.c\", {rule \"wdk.tracewpp\"}) add_files(\"*.rc\", \"*.inf\") add_files(\"*.mofmsdsm.mof\") add_files(\"msdsm.mof\", {values {wdk_mof_header \"msdsmwmi.h\"}}) end) ``` ### 生成驱动包 可以通过以下命令生成 .cab 驱动包： ```bash $ xmake [ppackage] $ xmake [ppackage] o outputdir ``` 输出的目录结构如下： ``` drivers sampledsm debug/x86/sampledsm.cab release/x64/sampledsm.cab debug/x86/sampledsm.cab release/x64/sampledsm.cab ``` ### 驱动签名 默认编译禁用签名，可以通过 `set_values(\"wdk.sign.mode\", ...)` 设置签名模式来启用签名。 #### 测试签名 测试签名一般本机调试时候用，可以使用 xmake 自带的 test 证书来进行签名，例如： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") end) ``` 不过这种情况下，需要用户手动在管理员模式下，执行一遍：`$xmake l utils.wdk.testcert install`，来生成和注册 test 证书到本机环境。 这个只需要执行一次就行了，后续就可以正常编译和签名了。 当然也可以使用本机已有的有效证书去签名。 从 sha1 来选择合适的证书进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") set_values(\"wdk.sign.thumbprint\", \"032122545DCAA6167B1ADBE5F7FDF07AE2234AAA\") end) ``` 从 store/company 来选择合适的证书进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") set_values(\"wdk.sign.store\", \"PrivateCertStore\") set_values(\"wdk.sign.company\", \"tboox.org(test)\") end) ``` #### 正式签名 通过指定对应的正式签名证书文件进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"release\") set_values(\"wdk.sign.company\", \"xxxx\") set_values(\"wdk.sign.certfile\", path.join(os.projectdir(), \"xxxx.cer\")) end) ``` ### 生成低版本驱动 如果想在 wdk10 环境编译生成 win7, win8 等低版本系统支持的驱动，可以通过设置 `wdk.env.winver` 来切换系统版本： ```lua set_values(\"wdk.env.winver\", \"win10\") set_values(\"wdk.env.winver\", \"win10_rs3\") set_values(\"wdk.env.winver\", \"win81\") set_values(\"wdk.env.winver\", \"win8\") set_values(\"wdk.env.winver\", \"win7\") set_values(\"wdk.env.winver\", \"win7_sp1\") set_values(\"wdk.env.winver\", \"win7_sp2\") set_values(\"wdk.env.winver\", \"win7_sp3\") ``` 我们也可以手动指定编译的目标程序支持的 windows 版本： ```bash $ xmake f wdk_winver [win10_rs3win8win7win7_sp1] $ xmake ``` ## iOS/MacOS 程序 ### App 应用程序 用于生成 `*.app/*.ipa` 应用程序，同时支持 iOS/MacOS。 ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") end) ``` > 可以支持直接添加 `*.metal` 文件，xmake 会自动生成 default.metallib 提供给应用程序加载使用。 #### 创建工程 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.macapp l objc test $ xmake create t xcode.iosapp l objc test ``` #### 编译 ```bash $ xmake f p [iphoneosmacosx] $ xmake [ 18%]: compiling.xcode.release src/Assets.xcassets [ 27%]: processing.xcode.release src/Info.plist [ 72%]: compiling.xcode.release src/Base.lproj/Main.storyboard [ 81%]: compiling.xcode.release src/Base.lproj/LaunchScreen.storyboard [ 45%]: cache compiling.release src/ViewController.m [ 63%]: cache compiling.release src/AppDelegate.m [ 54%]: cache compiling.release src/SceneDelegate.m [ 36%]: cache compiling.release src/main.m [ 90%]: linking.release test [100%]: generating.xcode.release test.app [100%]: build ok! ``` #### 配置签名 对于 iOS 程序，默认会检测系统先用可用签名来签名 app，当然我们也可以手动指定其他签名证书： ```bash $ xmake f p iphoneos xcode_codesign_identity 'Apple Development: xxx@gmail.com (T3NA4MRVPU)' xcode_mobile_provision 'iOS Team Provisioning Profile: org.tboox.test xcode_bundle_identifier org.tboox.test' $ xmake ``` 如果每次这么配置签名觉得繁琐的话，可以设置到 `xmake global` 全局配置中，也可以在 xmake.lua 中对每个 target 单独设置： ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") add_values(\"xcode.bundle_identifier\", \"org.tboox.test\") add_values(\"xcode.codesign_identity\", \"Apple Development: xxx@gmail.com (T3NA4MRVPU)\") add_values(\"xcode.mobile_provision\", \"iOS Team Provisioning Profile: org.tboox.test\") end) ``` 那如何知道我们需要的签名配置呢？一种就是在 xcode 里面查看，另外 xmake 也提供了一些辅助工具可以 dump 出当前可用的所有签名配置： ```bash $ xmake l private.tools.codesign.dump codesign identities { \"Apple Development: waruqi@gmail.com (T3NA4MRVPU)\" \"AF73C231A0C35335B72761BD3759694739D34EB1\" } mobile provisions { \"iOS Team Provisioning Profile: org.xmake.test\" \"<?xml version \"1.0\" encoding \"UTF 8\"?> <!DOCTYPE plist PUBLIC \" //Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList 1.0.dtd\"> <plist version \"1.0\"> <dict> \t<key>AppIDName</key> \t<string>XC org xmake test5</string> \t<key>ApplicationIdentifierPrefix</key> \t<array> \t<string>43AAQM58X3</string> ... ``` 我们也提供了其他辅助工具来对已有的 ipa/app 程序进行重签名，例如： ```bash $ xmake l utils.ipa.resign test.ipatest.app [codesign_identity] [mobile_provision] [bundle_identifier] ``` 其中，后面的签名参数都是可选的，如果没设置，那么默认会探测使用一个有效的签名： ```bash $ xmake l utils.ipa.resign test.ipa $ xmake l utils.ipa.resign test.app \"Apple Development: cat@gmail.com (T3NA4MRVPU)\" $ xmake l utils.ipa.resign test.ipa \"Apple Development: cat@gmail.com (T3NA4MRVPU)\" iOS Team Provisioning Profile: org.xmake.test\" org.xmake.test ``` #### 运行应用程序 目前仅支持运行macos程序： ```bash $ xmake run ``` 效果如下： ![](/assets/img/guide/macapp.png) #### 生成程序包 如果是 iOS 程序会生成 ipa 安装包，如果是 macos 会生成 dmg （dmg 包生成暂时还在开发中）。 ```bash $ xmake package output: build/iphoneos/release/arm64/test.ipa package ok! ``` 我们也提供了辅助工具，来对指定 app 程序进行打包： ```bash $ xmake l utils.ipa.package test.app output.ipa [iconfile.png] ``` #### 安装 如果是 iOS 程序会安装 ipa 到设备，如果是 macos 会安装 app 到 /Applications 目录。 ```bash $ xmake install ``` 我们也提供了辅助工具，来对指定ipa/app程序安装到设备： ```bash $ xmake l utils.ipa.install test.app $ xmake l utils.ipa.install test.ipa ``` #### 卸载 > 目前仅支持 macos 程序卸载 ```bash $ xmake uninstall ``` ### Framework 库程序 ```lua target(\"test\", function() add_rules(\"xcode.framework\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.framework l objc test ``` 另外，xmake 还提供了带有 framework 库使用的完整 iosapp/macapp 空工程模板，可以完整体验 framework 的编译，依赖使用以及集成到 app 应用程序中。 同时，如果我们开启了模拟器，xmake 可以支持直接 `xmake install` 和 `xmake run` 将 app 安装到模拟器并加载运行。 ```bash $ xmake create t xcode.iosapp_with_framework l objc testapp $ cd testapp $ xmake f p iphoneos a x86_64 $ xmake $ xmake install $ xmake run ``` ### Bundle程序 ```lua target(\"test\", function() add_rules(\"xcode.bundle\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.bundle l objc test ``` ## Protobuf程序 ### 使用c库 ```lua add_requires(\"protobuf c\") target(\"console_c\", function() set_kind(\"binary\") add_packages(\"protobuf c\") add_rules(\"protobuf.c\") add_files(\"src/*.c\") add_files(\"src/*.proto\") end) ``` 我们还可以设置 `proto_public true` 来导出 proto 的头文件搜索目录，开放给其他父 target 继承使用。 ```lua add_packages(\"protobuf c\", {public true}) add_files(\"src/**.proto\", {proto_public true}) ``` 注：由于 protobuf 生成的头文件引用了 protobuf c 包的头文件，因此，我们也需要将包的头文件标记为 `{public true}` 对外导出它。 ### 使用c++库 ```lua add_requires(\"protobuf cpp\") target(\"console_c++\", function() set_kind(\"binary\") set_languages(\"c++11\") add_packages(\"protobuf cpp\") add_rules(\"protobuf.cpp\") add_files(\"src/*.cpp\") add_files(\"src/*.proto\") end) ``` 我们还可以设置 `proto_public true` 来导出 proto 的头文件搜索目录，开放给其他父 target 继承使用。 ```lua add_packages(\"protobuf cpp\", {public true}) add_files(\"src/**.proto\", {proto_public true}) ``` 注：由于 protobuf 生成的头文件引用了 protobuf cpp 包的头文件，因此，我们也需要将包的头文件标记为 `{public true}` 对外导出它。 ## Cuda程序 创建一个空工程： ```bash $ xmake create P test l cuda $ cd test $ xmake ``` ```lua define target target(\"cuda_console\", function() set_kind(\"binary\") add_files(\"src/*.cu\") generate SASS code for SM architecture of current host add_cugencodes(\"native\") generate PTX code for the virtual architecture to guarantee compatibility add_cugencodes(\"compute_30\") end) ``` > 默认构建会启用 device link。（参见 [Separate Compilation and Linking of CUDA C++ Device Code](https://devblogs.nvidia.com/separate compilation linking cuda device code/)） > 如果要显式禁用 device link，可以通过 `set_policy(\"build.cuda.devlink\", false)` 来设置。 > cuda 源文件中的 device 函数需要被 device link 且只 device link 一次。在 `shared` 或 `binary` 的 target 上 xmake 会自动进行 device link ，这时它们依赖的 `static` target 也会同时被 device link ，因此默认情况下 `static` target 不会被 device link。然而，如果最终的 `shared` 或 `binary` 的 target 不包含任何 cuda 源文件，则不会发生 device link 阶段，导致出现 undefined reference 错误。这种情况下，需要手动为 `static` target 指定 `add_values(\"cuda.build.devlink\", true)`. 默认会自动探测 cuda 环境，当然也可以指定 Cuda SDK 环境目录，或者指定 cuda 版本（此时将在默认安装目录进行查找）： ```bash $ xmake f cuda /usr/local/cuda 9.1/ $ xmake f cuda 9.1 $ xmake ``` 更多详情可以参考：[#158](https://github.com/xmake io/xmake/issues/158) ## Lex & Yacc程序 ```lua target(\"calc\", function() set_kind(\"binary\") add_rules(\"lex\", \"yacc\") add_files(\"src/*.l\", \"src/*.y\") end) ``` ## OpenMP 程序 我们不需要额外配置 rules，仅仅通过一个通用的 openmp 包就可以实现相同的效果。 ```lua add_requires(\"openmp\") target(\"loop\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"openmp\") end) ``` ## Fortran 程序 我们可以通过下面的命令，快速创建一个基于 fortran 的空工程： ```bash $ xmake create l fortran t console test ``` 它的xmake.lua内容如下： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.f90\") end) ``` 更多代码例子可以到这里查看：[Fortran Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/fortran) ## Go 程序 xmake 也支持 go 程序的构建，也提供了空工程的创建命令支持: ```bash $ xmake create l go t console test ``` xmake.lua 内容如下: ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.go\") end) ``` 更多例子见：[Go Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/go) ## Dlang 程序 创建空工程： ```bash $ xmake create l dlang t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") end) ``` xmake 也提供对 dub 包管理的支持，可以快速集成 dlang 的第三方依赖包： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"dub::log 0.4.3\", {alias \"log\"}) add_requires(\"dub::dateparser\", {alias \"dateparser\"}) add_requires(\"dub::emsi_containers\", {alias \"emsi_containers\"}) add_requires(\"dub::stdx allocator\", {alias \"stdx allocator\"}) add_requires(\"dub::mir core\", {alias \"mir core\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") add_packages(\"log\", \"dateparser\", \"emsi_containers\", \"stdx allocator\", \"mir core\") end) ``` 不过还有一些不完善的地方，比如目前必须手动配置所有级联依赖包，会稍微繁琐些，后续有待改进。 更多例子见：[Dlang Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/dlang) ## Rust程序 创建空工程： ```bash $ xmake create l rust t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") end) ``` 更多例子见：[Rust Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/rust) ### 添加 Cargo 包依赖 例子: https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cargo_deps ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::base64 0.13.0\") add_requires(\"cargo::flate2 1.0.17\", {configs {features \"zlib\"}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::base64\", \"cargo::flate2\") end) ``` ### 集成 Cargo.toml 的依赖包 上面直接使用 `add_requires(\"cargo::base64 0.13.0\")` 的方式集成依赖，会有一个问题： 如果依赖很多，并且有几个依赖都共同依赖了相同的子依赖，那么会出现重定义问题，因此如果我们使用完整的 Cargo.toml 去管理依赖就不会存在这个问题。 例如： ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::test\", {configs {cargo_toml path.join(os.projectdir(), \"Cargo.toml\")}}) target(\"test\") set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::test\") ``` 完整例子见：[cargo_deps_with_toml](https://github.com/xmake io/xmake/blob/dev/tests/projects/rust/cargo_deps_with_toml/xmake.lua) ### 使用 cxxbridge 在 c++ 中调用 rust 例子: [https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library](https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library) ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cargo::cxx 1.0\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.rs\") set_values(\"rust.cratetype\", \"staticlib\") add_packages(\"cargo::cxx\") end) target(\"test\", function() set_kind(\"binary\") add_rules(\"rust.cxxbridge\") add_deps(\"foo\") add_files(\"src/main.cc\") add_files(\"src/bridge.rsx\") end) ``` foo.rs ```rust #[cxx::bridge] mod foo { extern \"Rust\" { fn add(a: i32, b: i32) > i32; } } pub fn add(a: i32, b: i32) > i32 { return a + b; } ``` 我们还需要在 c++ 项目中添加桥接文件 bridge.rsx ```rust #[cxx::bridge] mod foo { extern \"Rust\" { fn add(a: i32, b: i32) > i32; } } ``` main.cc ```c++ #include <stdio.h> #include \"bridge.rs.h\" int main(int argc, char** argv) { printf(\"add(1, 2) %d\\n\", add(1, 2)); return 0; } ``` ### 在 Rust 中调用 C++ 例子: [https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/rust_call_cxx_library](https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/rust_call_cxx_library) ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.cc\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.rs\") end) ``` main.rs ```rust extern \"C\" { \tfn add(a: i32, b: i32) > i32; } fn main() { unsafe { \t println!(\"add(1, 2) {}\", add(1, 2)); } } ``` foo.cc ```c++ extern \"C\" int add(int a, int b) { return a + b; } ``` ## Swift 程序 创建空工程： ```bash $ xmake create l swift t console test ``` xmake.lua内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.swift\") end) ``` 更多例子见：[Swift Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/swift) ## Objc 程序 创建空工程： ```bash $ xmake create l objc t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.m\") end) ``` 更多例子见：[Objc Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/objc++) ## Objc 程序 创建空工程： ```bash $ xmake create l objc t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.m\") end) ``` 更多例子见：[Objc Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/objc++) ## Zig 程序 创建空工程： ```bash $ xmake create l zig t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.zig\") end) ``` 更多例子见：[Zig Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/zig) ## Linux Bpf 程序 xmake 支持 bpf 程序构建，同时支持 linux 以及 android 平台，能够自动拉取 llvm 和 android ndk 工具链。 更多详情见：[#1274](https://github.com/xmake io/xmake/issues/1274) ```lua add_rules(\"mode.release\", \"mode.debug\") add_rules(\"platform.linux.bpf\") add_requires(\"linux tools\", {configs {bpftool true}}) add_requires(\"libbpf\") if is_plat(\"android\") then add_requires(\"ndk > 22.x\") set_toolchains(\"@ndk\", {sdkver \"23\"}) else add_requires(\"llvm > 10.x\") set_toolchains(\"@llvm\") add_requires(\"linux headers\") end target(\"minimal\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"linux tools\", \"linux headers\", \"libbpf\") set_license(\"GPL 2.0\") end) ``` ## Vala 程序 xmake 支持构建 Vala 程序，我们需要应用 `add_rules(\"vala\")` 规则，并且 glib 包是必须的。 相关 issues: [#1618](https://github.com/xmake io/xmake/issues/1618) `add_values(\"vala.packages\")` 用于告诉 valac，项目需要哪些包，它会引入相关包的 vala api，但是包的依赖集成，还是需要通过 `add_requires(\"lua\")` 下载集成。 ### 控制台程序 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"lua\", \"glib\") target(\"test\", function() set_kind(\"binary\") add_rules(\"vala\") add_files(\"src/*.vala\") add_packages(\"lua\", \"glib\") add_values(\"vala.packages\", \"lua\") end) ``` ### 静态库程序 我们能够通过 `add_values(\"vala.header\", \"mymath.h\")` 设置导出的接口头文件名，通过 `add_values(\"vala.vapi\", \"mymath 1.0.vapi\")` 设置导出的 vapi 文件名。 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"glib\") target(\"mymath\", function() set_kind(\"static\") add_rules(\"vala\") add_files(\"src/mymath.vala\") add_values(\"vala.header\", \"mymath.h\") add_values(\"vala.vapi\", \"mymath 1.0.vapi\") add_packages(\"glib\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"mymath\") add_rules(\"vala\") add_files(\"src/main.vala\") add_packages(\"glib\") end) ``` ### 动态库程序 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"glib\") target(\"mymath\", function() set_kind(\"shared\") add_rules(\"vala\") add_files(\"src/mymath.vala\") add_values(\"vala.header\", \"mymath.h\") add_values(\"vala.vapi\", \"mymath 1.0.vapi\") add_packages(\"glib\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"mymath\") add_rules(\"vala\") add_files(\"src/main.vala\") add_packages(\"glib\") end) ``` 更多例子：[Vala examples](https://github.com/xmake io/xmake/tree/master/tests/projects/vala) ## Pascal 程序 我们能够支持构建 Pascal 程序，相关 issues 见：[#388](https://github.com/xmake io/xmake/issues/388) ### 控制台程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.pas\") end) ``` ### 动态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.pas\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.pas\") end) ``` 更多例子：[Pascal examples](https://github.com/xmake io/xmake/tree/master/tests/projects/pascal) ## Swig 模块 xmake 支持构建 Swig 模块，我们提供了 `swig.c` 和 `swig.cpp` 规则，分别对应支持生成 c/c++ 模块接口代码，配合 xmake 的包管理系统实现完全自动化的模块和依赖包整合。 相关 issues: [#1622](https://github.com/xmake io/xmake/issues/1622) ### Lua/C 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"lua\") target(\"example\", function() add_rules(\"swig.c\", {moduletype \"lua\"}) add_files(\"src/example.i\", {swigflags \" no old metatable bindings\"}) add_files(\"src/example.c\") add_packages(\"lua\") end) ``` ### Python/C 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"python 3.x\") target(\"example\", function() add_rules(\"swig.c\", {moduletype \"python\"}) add_files(\"src/example.i\", {scriptdir \"share\"}) add_files(\"src/example.c\") add_packages(\"python\") end) ``` ### Python/C++ 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"python 3.x\") target(\"example\", function() add_rules(\"swig.cpp\", {moduletype \"python\"}) add_files(\"src/example.i\", {scriptdir \"share\"}) add_files(\"src/example.cpp\") add_packages(\"python\") end) ``` ### Java/C 模块 [完整例子](https://github.com/xmake io/xmake/blob/dev/tests/projects/swig/java_c) ```lua make sure you config to an enviroment with jni.h for example: xmake f c p android target(\"example\", function() set_kind('shared') set moduletype to java add_rules(\"swig.c\", {moduletype \"java\"}) test jar build add_rules(\"swig.c\", {moduletype \"java\" , buildjar true}) use swigflags to provider package name and output path of java files add_files(\"src/example.i\", {swigflags { \" package\", \"com.example\", \" outdir\", \"build/java/com/example/\" }}) add_files(\"src/example.c\") add_includedirs(\"src\") before_build(function() ensure output path exists before running swig os.mkdir(\"build/java/com/example/\") end) end) ``` 我们也可以配置 ```lua add_rules(\"swig.c\", {moduletype \"java\", buildjar true}) ``` 去同时构建 jar 包，方便直接使用。 ## C++20 模块 ### 快速开始 xmake 采用 `.mpp` 作为默认的模块扩展名，但是也同时支持 `.ixx`, `.cppm`, `.mxx` 等扩展名。 目前 xmake 已经完整支持 gcc11/clang/msvc 的 C++20 Modules 构建支持，并且能够自动分析模块间的依赖关系，实现最大化并行编译。 ```lua set_languages(\"c++20\") target(\"class\", function() set_kind(\"binary\") add_files(\"src/*.cpp\", \"src/*.mpp\") end) ``` 更多例子见：[C++ Modules](https://github.com/xmake io/xmake/tree/master/tests/projects/c%2B%2B/modules) ### Cpp Only 工程 xmake 对 C++20 模块的实现进行了重构和升级，新增了对 Headerunits 的支持，我们可以在模块中引入 Stl 和 用户头文件模块。 相关的补丁见：[#2641](https://github.com/xmake io/xmake/pull/2641)。 注：通常我们至少需要添加一个 `.mpp` 文件，才能开启 C++20 modules 编译，如果只有 cpp 文件，默认是不会开启模块编译的。 但是，如果我们仅仅只是想在 cpp 文件中使用模块的 Headerunits 特性，比如引入一些 stl Headerunits 在 cpp 中使用， 那么我们也可以通过设置 `set_policy(\"build.c++.modules\", true)` 来强行开启 C++ Modules 编译，例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") set_languages(\"c++20\") set_policy(\"build.c++.modules\", true) end) ``` ### 模块的分发和集成 #### 分发 C++ Modules 包 我们先使用 xmake.lua 维护模块的构建，并通过指定 `{install true}`，来告诉 xmake 哪些模块文件需要安装对外分发。 ```lua add_rules(\"mode.release\", \"mode.debug\") set_languages(\"c++20\") target(\"foo\", function() set_kind(\"static\") add_files(\"*.cpp\") add_files(\"*.mpp\", { install true }) end) ``` 然后，我们把它做成包，可以提交到 [xmake repo](https://github.com/xmake io/xmake repo) 仓库，当然也可以直接做成本地包，或者私有仓库包。 这里，为了方便测试验证，我们仅仅通过 `set_sourcedir` 将它做成本地包。 ```lua package(\"foo\", function() set_sourcedir(path.join(os.scriptdir(), \"src\")) on_install(function(package) import(\"package.tools.xmake\").install(package, {}) end) end) ``` #### 集成 C++ Modules 包 然后，我们通过 `add_requires(\"foo\")` 的包集成接口，对 C++ Modules 包进行快速集成使用。 由于 foo 的模块包，我们放在私有仓库中定义，所以我们通过 `add_repositories(\"my repo my repo\")` 引入自己的包仓库。 如果，包已经提交到 xmake repo 官方仓库，就不需要额外配置它。 ```lua add_rules(\"mode.release\", \"mode.debug\") set_languages(\"c++20\") add_repositories(\"my repo my repo\") add_requires(\"foo\", \"bar\") target(\"packages\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"foo\", \"bar\") set_policy(\"build.c++.modules\", true) end) ``` 集成好包后，我们就可以执行 `xmake` 命令，一键下载、编译、集成 C++ Modules 包来使用。 ```bash $ xmake checking for platform ... linux checking for architecture ... x86_64 note: install or modify (m) these packages (pass y to skip confirm)? in my repo: > foo latest > bar latest please input: y (y/n/m) > install bar latest .. ok > install foo latest .. ok [ 0%]: generating.module.deps src/main.cpp [ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/b/bar/latest/4e0143c97b65425b855ad5fd03038b6a/modules/bar/bar.mpp [ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/f/foo/latest/4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp [ 14%]: compiling.module.release bar [ 14%]: compiling.module.release foo [ 57%]: compiling.release src/main.cpp [ 71%]: linking.release packages [100%]: build ok! ``` 注：每个包安装后，会在包路径下，存储维护模块的 meta info 文件，这是 `p2473r1.pdf` 中约定的一种格式规范，也许它不是最终的标准，但这并不影响我们现在去使用模块的分发。 ```bash $ cat ./build/.packages/f/foo/latest/4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp.meta info {\"_VENDOR_extension\":{\"xmake\":{\"name\":\"foo\",\"file\":\"foo.mpp\"}},\"definitions\":{},\"include_paths\":{}} ``` 完整的例子工程见：[C++ Modules 包分发例子工程](https://github.com/xmake io/xmake/tree/master/tests/projects/c%2B%2B/modules/packages) ### 支持 C++23 Std Modules [Arthapz](https://github.com/Arthapz) 也帮忙改进了对 C++23 Std Modules 的支持。 目前三个编译器对它的支持进展： #### Clang 目前最新的 clang 似乎也还没完全支持 C++23 std modules，当前还是 draft patch 状态，[#D135507](https://reviews.llvm.org/D135507)。 但是，Xmake 也对它进行了支持，如果大家想要尝鲜，可以自行合入这个 patch，然后使用 xmake 来测试。 另外，低版本的 clang 也有对非标准的 std modules 做了实验性支持。 我们还是可以在低版本 clang 中尝试性使用 xmake 来构建 std modules，尽管它可能还只是个玩具（会遇到很多问题）。 相关讨论见：[#3255](https://github.com/xmake io/xmake/pull/3255) #### Gcc 目前还不支持。 ## 合并静态库 ### 自动合并 target 库 我们可以通过设置 `build.merge_archive` 策略，启用自动合并依赖的所有静态库，例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"add\", function() set_kind(\"static\") add_files(\"src/add.c\") add_files(\"src/subdir/add.c\") end) target(\"sub\", function() set_kind(\"static\") add_files(\"src/sub.c\") add_files(\"src/subdir/sub.c\") end) target(\"mul\", function() set_kind(\"static\") add_deps(\"add\", \"sub\") add_files(\"src/mul.c\") set_policy(\"build.merge_archive\", true) end) ``` mul 静态库自动合并了 add 和 sub 静态库，生成一个包含 add/sub 代码的完整 libmul.a 库。 这个合并相对比较稳定完善，支持 ar 和 msvc/lib.exe，也支持交叉编译工具链生成的静态库合并，也支持带有重名 obj 文件的静态库。 ### 合并指定的静态库文件 如果自动合并不满足需求，我们也可以主动调用 `utils.archive.merge_archive` 模块在 `after_link` 阶段合并指定的静态库列表。 ```lua target(\"test\", function() after_link(function (target) import(\"utils.archive.merge_staticlib\") merge_staticlib(target, \"libout.a\", {\"libfoo.a\", \"libbar.a\"}) end) end) ``` ### 使用 add_files 合并静态库 其实，我们之前的版本已经支持通过 `add_files(\"*.a\")` 来合并静态库。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"*.a\") add_files(\"*.c\") end) ``` 但是它有一些缺陷：如果使用 ar，可能会存在 .obj 对象文件同名冲突导致合并失败，因此推荐使用上文介绍的合并方式，更加的稳定可靠，也更加的简单。 相关 issues: [#1638](https://github.com/xmake io/xmake/issues/1638) ### 自定义脚本合并静态库 > 在这个例子中我们在 package 准备安装时将所有的 lib 静态库合并成一个，方便用户集成使用： ```lua on_install(function(package) local archivefile \"libxcore.a\" local tmpfile os.tmpfile() local mrifile io.open(tmpfile, \"w\") mrifile:print(\"create %s\", archivefile) for _, libraryfile in ipairs(os.files(\"lib/*.a\")) do cprint(format(\"${bright blue}[info]${clear} merge static lib [%s] to [%s]\", libraryfile, archivefile)) mrifile:print(\"addlib %s\", libraryfile) end mrifile:print(\"save\") mrifile:print(\"end\") mrifile:close() os.vrunv(\"ar\", {\" M\"}, {stdin tmpfile}) os.rm(tmpfile) end) ``` ## Nim 程序 xmake 支持 Nimlang 项目，相关 issues 见：[#1756](https://github.com/xmake io/xmake/issues/1756) ### 创建空工程 我们可以使用 `xmake create` 命令创建空工程。 ```bash xmake create l nim t console test xmake create l nim t static test xmake create l nim t shared test ``` ### 控制台程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake v [ 33%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache o:b uild/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### 静态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.nim\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake v [ 33%]: linking.release libfoo.a /usr/local/bin/nim c opt:speed nimcache:build/.gens/foo/macosx/x86_64/release/nimcache app :staticlib noMain passC: DNimMain NimMain_B6D5BD02 passC: DNimMainInner NimMainInner_B6D5B D02 passC: DNimMainModule NimMainModule_B6D5BD02 passC: DPreMain PreMain_B6D5BD02 passC: D PreMainInner PreMainInner_B6D5BD02 o:build/macosx/x86_64/release/libfoo.a src/foo.nim [ 66%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache pa ssL: Lbuild/macosx/x86_64/release passL: lfoo o:build/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### 动态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.nim\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake rv [ 33%]: linking.release libfoo.dylib /usr/local/bin/nim c opt:speed nimcache:build/.gens/foo/macosx/x86_64/release/nimcache app :lib noMain o:build/macosx/x86_64/release/libfoo.dylib src/foo.nim [ 66%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache pa ssL: Lbuild/macosx/x86_64/release passL: lfoo o:build/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### C 代码混合编译 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ### Nimble 依赖包集成 完整例子见：[Nimble Package Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/nim/nimble_package) ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"nimble::zip >0.3\") target(\"test, function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"nimble::zip\") end) ``` main.nim ```nim import zip/zlib echo zlibVersion() ``` ### Native 依赖包集成 完整例子见：[Native Package Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/nim/native_package) ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"zlib\") end) ``` main.nim ```nim proc zlibVersion(): cstring {.cdecl, importc} echo zlibVersion() ``` ## Keil/MDK 嵌入式程序 相关例子工程：[Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/embed/mdk/hello) xmake 会自动探测 Keil/MDK 安装的编译器，相关 issues [#1753](https://github.com/xmake io/xmake/issues/1753)。 使用 armcc 编译 ```bash $ xmake f p cross a cortex m3 toolchain armcc c $ xmake ``` 使用 armclang 编译 ```bash $ xmake f p cross a cortex m3 toolchain armclang c $ xmake ``` ### 可执行程序 ```lua target(\"hello\", function() add_deps(\"foo\") add_rules(\"mdk.binary\") add_files(\"src/*.c\", \"src/*.s\") add_includedirs(\"src/lib/cmsis\") set_runtimes(\"microlib\") end) ``` 需要注意的是，目前一些 mdk 程序都使用了 microlib 库运行时，它需要编译器加上 `__MICROLIB` 宏定义，链接器加上 ` library_type microlib` 等各种配置。 我们可以通过 `set_runtimes(\"microlib\")` 直接设置到 microlib 运行时库，可以自动设置上所有相关选项。 ### 静态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() add_rules(\"mdk.static\") add_files(\"src/foo/*.c\") set_runtimes(\"microlib\") end) ``` ## Keil/C51 嵌入式程序 ### 可执行程序 ```lua target(\"hello\", function() add_rules(\"c51.binary\") set_toolchains(\"c51\") add_files(\"src/main.c\") end) ``` ## Lua 模块 参考 [https://github.com/xmake io/luarocks build xmake](https://github.com/xmake io/luarocks build xmake) 如果你的 lua 模块含有 C 代码，你可以使用 [LuaNativeObjects](https://github.com/Neopallium/LuaNativeObjects) 去从 lua 代码生成 C 代码。 参考[例子](https://github.com/Freed Wu/rime.nvim/blob/main/xmake.lua)。 ## Nodejs 模块 参考[例子](https://github.com/tonyfettes/coc rime/blob/master/xmake.lua)。 ## Linux 内核驱动模块 xmake 完整支持了 Linux 内核驱动模块的构建，这也许首个也是唯一一个支持编译 Linux 内核驱动的第三方构建工具了。 ### Hello world 模块 完整例子：[Linux Kernel Driver Modules](https://github.com/xmake io/xmake/tree/master/tests/projects/linux/driver/hello) 它的配置非常简单，只需要配置上支持模块的 linux headers 包，然后应用 `platform.linux.module` 构建规则就行了。 ```lua add_requires(\"linux headers\", {configs {driver_modules true}}) target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") add_packages(\"linux headers\") set_license(\"GPL 2.0\") end) ``` 然后直接执行 xmake 命令，一键编译，生成内核驱动模块 hello.ko。 ```bash $ xmake [ 20%]: cache compiling.release src/add.c [ 20%]: cache compiling.release src/hello.c [ 60%]: linking.release build/linux/x86_64/release/hello.ko [100%]: build ok! ``` 我们也可以看完整构建命令参数。 ```bash $ xmake v [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/linux/x86_64/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/linux/x86_64/release/src/hello.c.o src/hello.c [ 60%]: linking.release build/linux/x86_64/release/hello.ko /usr/bin/ld m elf_x86_64 r o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/release/src/add.c.o build/.objs/hello/linux/x86_64/release/src/hello.c.o /usr/src/linux headers 5.11.0 41 generic/scripts/mod/modpost m a o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.c /usr/bin/ld m elf_x86_64 r build id sha1 T /usr/src/linux headers 5.11.0 41 generic/scripts/module.lds o build/linux/x86_64/release/hello.ko build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.o ``` 通过 `add_requires(\"linux headers\", {configs {driver_modules true}})` 配置包，xmake 会自动优先从系统中查找对应的 linux headers 包。 如果没找到，xmake 也会自动下载它，然后自动配置构建带有 driver modules 的内核源码后，使用它继续构建内核模块。 ### 自定义 linux headers 路径 有很多用户反馈，大多数情况下，linux 内核驱动构建都是基于定制版的 linux kernel，因此需要能够自定义配置 linux headers 路径，而不是走远程依赖包模式。 其实，我们通过自己重写 linux headers 包，也是可以做到这一点的。 ```lua package(\"linux headers\") on_fetch(function (package, opt) return {includedirs \"/usr/src/linux headers 5.0/include\"} end) package_end() add_requires(\"linux headers\") target(\"test\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") add_packages(\"linux headers\") end) ``` 不过这样，也许还有点繁琐，因此我们支持更加方便的设置 linux headers 路径。 ```lua target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") set_values(\"linux.driver.linux headers\", \"/usr/src/linux headers 5.11.0 41 generic\") end) ``` 我们也可以通过定义 option 选项，将 linux headers 路径作为 `xmake f linux headers /usr/src/linux headers` 的方式传入。 ```lua option(\"linux headers\", {showmenu true, description \"Set linux headers path.\"}) target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") set_values(\"linux.driver.linux headers\", \"$(linux headers)\") end) ``` 更多详情见：[#1923](https://github.com/xmake io/xmake/issues/1923) ### 交叉编译 我们也支持内核驱动模块的交叉编译，比如在 Linux x86_64 上使用交叉编译工具链来构建 Linux Arm/Arm64 的驱动模块。 我们只需要准备好自己的交叉编译工具链，通过 ` sdk ` 指定它的根目录，然后配置切换到 ` p cross` 平台， 最后指定需要构建的架构 arm/arm64 即可。 这里用到的交叉工具链，可以从这里下载: [Download toolchains](https://releases.linaro.org/components/toolchain/binaries/latest 7/aarch64 linux gnu/) 更多，交叉编译配置文档，见：[配置交叉编译](/zh cn/guide/configuration?id common cross compilation configuration) > 目前仅仅支持 arm/arm64 交叉编译架构，后续会支持更多的平台架构。 #### 构建 Arm 驱动模块 ```bash $ xmake f p cross a arm sdk /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf c $ xmake v checking for arm linux gnueabihf g++ ... /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf g++ checking for the linker (ld) ... arm linux gnueabihf g++ checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf g++ ... ok checking for flags ( fPIC) ... ok checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc ... ok checking for flags ( fPIC) ... ok checking for flags ( O2) ... ok checking for ccache ... /usr/bin/ccache [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/cross/arm/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/cross/arm/release/src/hello.c.o src/hello.c checking for flags ( MMD MF) ... ok checking for flags ( fdiagnostics color always) ... ok [ 60%]: linking.release build/cross/arm/release/hello.ko /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf ld EB r o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.o build/.objs/hello/cross/arm/release/src/add.c.o build/.objs/hello/cross/arm/release/src/hello.c.o /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/mod/modpost m a o build/.objs/hello/cross/arm/release/build/cross/arm/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.c /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf ld EB be8 r build id sha1 T /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/module.lds o build/cross/arm/release/hello.ko build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.o [100%]: build ok! ``` #### 构建 Arm64 驱动模块 ```bash $ xmake f p cross a arm64 sdk /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu c checking for aarch64 linux gnu g++ ... /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++ checking for the linker (ld) ... aarch64 linux gnu g++ checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++ ... ok checking for flags ( fPIC) ... ok checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc ... ok checking for flags ( fPIC) ... ok checking for flags ( O2) ... ok checking for ccache ... /usr/bin/ccache [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/cross/arm64/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/cross/arm64/release/src/hello.c.o src/hello.c checking for flags ( MMD MF) ... ok checking for flags ( fdiagnostics color always) ... ok [ 60%]: linking.release build/cross/arm64/release/hello.ko /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu ld EL maarch64elf r o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/src/add.c.o build/.objs/hello/cross/arm64/release/src/hello.c.o /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/mod/modpost m a o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.c /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu ld EL maarch64elf r build id sha1 T /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/module.lds o build/cross/arm64/release/hello.ko build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o [100%]: build ok! ``` ## ASN.1 程序 ASN.1 程序，需要借助 [ASN.1 Compiler](https://github.com/vlm/asn1c) 去生成相关的 .c 文件参与项目编译。 而 Xmake 内置提供了 `add_rules(\"asn1c\")` 规则去处理 `.c` 文件生成，`add_requires(\"asn1c\")` 自动拉取集成 ASN.1 编译器工具。 下面是一个基础的配置例子： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"asn1c\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_files(\"src/*.asn1\") add_rules(\"asn1c\") add_packages(\"asn1c\") end) ``` 具体见 [完整例子工程](https://github.com/xmake io/xmake/tree/master/tests/projects/c/asn1c)。 ## Verilog 仿真程序 ### iVerilog 仿真器 通过 `add_requires(\"iverilog\")` 配置，我们能够自动拉取 iverilog 工具链包，然后使用 `set_toolchains(\"@iverilog\")` 自动绑定工具链来编译工程。 ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") end) ``` #### 设置抽象配置 ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") add_defines(\"TEST\") add_includedirs(\"inc\") set_languages(\"v1800 2009\") end) ``` 我们可以通过 `set_languages(\"v1800 2009\")` 来设置切换 Verilog 的语言标准。 目前支持的一些取值和映射关系如下： ```lua [\"v1364 1995\"] \" g1995\" [\"v1364 2001\"] \" g2001\" [\"v1364 2005\"] \" g2005\" [\"v1800 2005\"] \" g2005 sv\" [\"v1800 2009\"] \" g2009\" [\"v1800 2012\"] \" g2012\" ``` #### 设置自定义 flags ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") add_values(\"iverilogs.flags\", \" DTEST\") end) ``` #### 构建工程 ```bash $ xmake checking for iverilog ... iverilog checking for vvp ... vvp [ 50%]: linking.iverilog hello.vvp [100%]: build ok! ``` #### 运行程序 ```bash $ xmake run hello world! LXT2 info: dumpfile hello.vcd opened for output. src/main.v:6: $finish called at 0 (1s) ``` 更多完整例子：[iVerilog Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/embed/iverilog) ### Verilator 仿真器 通过 `add_requires(\"verilator\")` 配置，我们能够自动拉取 verilator 工具链包，然后使用 `set_toolchains(\"@verilator\")` 自动绑定到工具链来编译工程。 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_files(\"src/*.cpp\") end) ``` verilator 工程，我们需要一个额外的 `sim_main.cpp` 文件参与编译，作为程序的入口代码。 ``` #include \"hello.h\" #include \"verilated.h\" int main(int argc, char** argv) { VerilatedContext* contextp new VerilatedContext; contextp >commandArgs(argc, argv); hello* top new hello{contextp}; while (!contextp >gotFinish()) { top >eval(); } delete top; delete contextp; return 0; } ``` #### 设置抽象配置 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_defines(\"TEST\") add_includedirs(\"inc\") set_languages(\"v1800 2009\") end) ``` 我们可以通过 `set_languages(\"v1800 2009\")` 来设置切换 Verilog 的语言标准。 目前支持的一些取值和映射关系如下： ```lua Verilog [\"v1364 1995\"] \"+1364 1995ext+v\", [\"v1364 2001\"] \"+1364 2001ext+v\", [\"v1364 2005\"] \"+1364 2005ext+v\", SystemVerilog [\"v1800 2005\"] \"+1800 2005ext+v\", [\"v1800 2009\"] \"+1800 2009ext+v\", [\"v1800 2012\"] \"+1800 2012ext+v\", [\"v1800 2017\"] \"+1800 2017ext+v\", ``` #### 设置自定义 flags ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_files(\"src/*.cpp\") add_values(\"verilator.flags\", \" trace\", \" timing\") end) ``` #### 构建工程 ```bash $ xmake [ 0%]: compiling.verilog src/main.v [ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__Slow.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0__Slow.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello.cpp [ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated_threads.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello__Syms.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h07139e86__0.cpp [ 15%]: cache compiling.release src/sim_main.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0.cpp [ 84%]: linking.release hello [100%]: build ok! ``` #### 运行程序 ```bash $ xmake run ruki 2:hello ruki$ xmake run hello world! src/main.v:4: Verilog $finish ``` 更多完整例子：[Verilator](https://github.com/xmake io/xmake/tree/master/tests/projects/embed/verilator) #### 编译静态库 我们也提供了 `verilator.static` 规则来编译生成 verilator 静态库。 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.static\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") end) target(\"test\", function() add_deps(\"hello\") add_files(\"src/*.cpp\") end) ``` ## Cppfront 程序 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cppfront\") target(\"test\", function() add_rules(\"cppfront\") set_kind(\"binary\") add_files(\"src/*.cpp2\") add_packages(\"cppfront\") end) ``` ## Cosmocc 程序 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cosmocc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"@cosmocc\") end) ```"},"/get_started/zh/tutorial/builtin-variables.html":{"title":"","content":" class: heading_no_counter # 内置变量 xmake 提供了 `$(varname)` 的语法，来支持内置变量的获取，例如： ```lua add_cxflags(\" I$(buildir)\") ``` 它将会在在实际编译的时候，将内置的 `buildir` 变量转换为实际的构建输出目录：` I./build` 一般内置变量可用于在传参时快速获取和拼接变量字符串，例如： ```lua target(\"test\", function() 添加工程源码目录下的源文件 add_files(\"$(projectdir)/src/*.c\") 添加构建目录下的头文件搜索路径 add_includedirs(\"$(buildir)/inc\") end) ``` 也可以在自定义脚本的模块接口中使用，例如： ```lua target(\"test\", function() on_run(function (target) 复制当前脚本目录下的头文件到输出目录 os.cp(\"$(scriptdir)/xxx.h\", \"$(buildir)/inc\") end) end) ``` 所有的内置变量，也可以通过 [val](#val) 接口，来获取他们的值。 这种使用内置变量的方式，使得描述编写更加的简洁易读，下面是一些 xmake 内置的变量，可以直接获取： 接口 描述 [$(os)](#varos) 获取当前编译平台的操作系统 [$(host)](#varhost) 获取本机操作系统 [$(tmpdir)](#vartmpdir) 获取临时目录 [$(curdir)](#varcurdir) 获取当前目录 [$(buildir)](#varbuildir) 获取构建输出目录 [$(scriptdir)](#varscriptdir) 获取工程描述脚本目录 [$(globaldir)](#varglobaldir) 获取全局配置目录 [$(configdir)](#varconfigdir) 获取本地工程配置目录 [$(programdir)](#varprogramdir) xmake 安装脚本目录 [$(projectdir)](#varprojectdir) 获取工程根目录 [$(shell)](#varshell) 执行外部 shell 命令 [$(env)](#varenv) 获取外部环境变量 [$(reg)](#varreg) 获取 windows 注册表配置项的值 当然这种变量模式，也是可以扩展的，默认通过 `xmake f var val` 命令，配置的参数都是可以直接获取，例如： ```lua target(\"test\", function() add_defines(\" DTEST $(var)\") end) ``` > 所有 `xmake f xxx ...` 配置的参数值，都是可以通过内置变量获取到，例如：`xmake f arch x86` 对应 `$(arch)`，其他的还有 `$(plat)`, `$(mode)` 等等。 > 具体有哪些参数，可以通过：`xmake f h` 查看。 既然支持直接从配置选项中获取，那么当然也就能很方便的扩展自定义的选项，来获取自定义的变量了，具体如何自定义选项见：[option](#option) ## var.$(os) 获取当前编译平台的操作系统。 如果当前编译的是 iphoneos，那么这个值就是：`ios`，以此类推。 ## var.$(host) 获取本机操作系统。 指的是当前本机环境的主机系统，如果你是在 macOS 上编译，那么系统就是：`macosx` ## var.$(tmpdir) 获取临时目录。 一般用于临时存放一些非永久性文件。 ## var.$(curdir) 获取当前目录。 一般默认是执行 `xmake` 命令时的工程根目录，当然如果通过 [os.cd](#os cd) 改变了目录的话，这个值也会一起改变。 ## var.$(buildir) 获取当前的构建输出目录。 默认一般为当前工程根目录下的：`./build` 目录，也可以通过执行：`xmake f o /tmp/build` 命令来修改默认的输出目录。 ## var.$(scriptdir) 获取当前工程描述脚本的目录。 也就是对应 `xmake.lua` 所在的目录路径。 ## var.$(globaldir) 全局配置目录。 xmake 的 `xmake gglobal` 全局配置命令，数据存储的目录路径，在里面可以放置一些自己的插件、平台脚本。 默认为：`~/.config` ## var.$(configdir) 当前工程配置目录。 当前工程的配置存储目录，也就是 `xmake fconfig` 配置命令的存储目录，默认为：`projectdir/.config` ## var.$(programdir) xmake 安装脚本目录。 也就是 `XMAKE_PROGRAM_DIR` 环境变量所在目录，我们也可以通过设置这个环境量，来修改 xmake 的加载脚本，实现版本切换。 ### var.$(projectdir) 工程根目录。 也就是 `xmake P xxx` 命令中指定的目录路径，默认不指定就是 `xmake` 命令执行时的当前目录，一般用于定位工程文件。 ## var.$(shell) 执行外部 shell 命令。 除了内置的变量处理，xmake 还支持原生 shell 的运行，来处理一些 xmake 内置不支持的功能 例如，现在有个需求，我想用在编译 linux 程序时，调用 `pkg config` 获取到实际的第三方链接库名，可以这么做： ```lua target(\"test\", function() set_kind(\"binary\") if is_plat(\"linux\") then add_ldflags(\"$(shell pkg config libs sqlite3)\") end end) ``` 当然，xmake 有自己的自动化第三库检测机制，一般情况下不需要这么麻烦，而且 lua 自身的脚本化已经很不错了。 但是这个例子可以说明，xmake 是完全可以通过原生 shell，来与一些第三方的工具进行配合使用。 ## var.$(env) 获取外部环境变量。 例如，可以通过获取环境变量中的路径： ```lua target(\"test\", function() add_includedirs(\"$(env PROGRAMFILES)/OpenSSL/inc\") end) ```"},"/get_started/zh/tutorial/FAQ.html":{"title":"","content":" class: heading_no_counter # FAQ ## 怎样获取更多参数选项信息？ 获取主菜单的帮助信息，里面有所有 action 和 plugin 的列表描述。 ```bash $ xmake [ h help] ``` 获取配置菜单的帮助信息，里面有所有配置选项的描述信息，以及支持平台、架构列表。 ```bash $ xmake f [ h help] ``` 获取 action 和 plugin 命令菜单的帮助信息，里面有所有内置命令和插件任务的参数使用信息。 ```bash $ xmake [actionplugin] [ h help] ``` 例如，获取 `run` 命令的参数信息 : ```bash $ xmake run help ``` ## 怎样实现静默构建，不输出任何信息？ ```bash $ xmake [ q quiet] ``` ## 如果 xmake 运行失败了怎么办？ 可以先尝试清除下配置，重新构建下： ```bash $ xmake f c $ xmake ``` 如果还是失败了，请加上 ` v` 或者 ` verbose` 选项重新执行 xmake 后，获取更加详细的输出信息 例如： ```hash $ xmake [ v verbose] ``` 并且可以加上 ` D` 选项获取出错时的 xmake 的调试栈信息和其他更详细的诊断信息 , 然后你可以提交这些信息到 [issues](https://github.com/TOMO CAT/xmake/issues)。 ```bash $ xmake v D ``` ## 怎样看实时编译警告信息 ? 为了避免刷屏，在构建时候，默认是不实时输出警告信息的，如果想要看的话可以加上 ` w` 选项启用编译警告输出就行了。 ```bash $ xmake [ w warning] ``` ## 怎样基于源码自动生成 xmake.lua？ 如果你想临时写一两个测试代码、或者手上有一些移植过来的零散源码想要快速编译运行，可以不用专门写 xmake.lua，直接运行： ```bash $ xmake ``` xmake 会自动扫描分析当前的源码目录，识别程序结构和类型，生成一个 xmake.lua，并且会尝试直接构建它。 如果编译成功，可以直接运行： ```bash $ xmake run ``` 当然，如果仅仅只是想要生成 xmake.lua，默认不去构建，可以执行： ```bash $ xmake f y ``` 更多相关介绍，请参考文章：[xmake 新增智能代码扫描编译模式，无需手写任何 make 文件](https://tboox.org/cn/2017/01/07/build without makefile/) ## 为什么 xmake.lua 会被执行多遍？ xmake.lua 里面分描述域和脚本域，在描述域里面会对各种配置域进行分阶段多次解析，有可能会执行多遍，因此不要在描述域写复杂的脚本。 如果要写各种复杂脚本，请在脚本域内进行配置，`target/on_load` 的脚本域里面同样可以灵活配置各种 target 相关设置，并且提供更强大的 lua 脚本模块支持。 更多细节见：[描述语法说明](/zh cn/guide/syntax_description) ## 如何调试 Xmake 源码? ### 下载源码 由于 xmake 使用了 git submodules 维护子模块，因此我们可以通过下面几种方式拉取完整源码。 #### 使用 git 拉取 ```bash $ git clone recursive https://github.com/TOMO CAT/xmake.git ``` 或者 ```bash $ git clone https://github.com/TOMO CAT/xmake.git $ git submodule update init ``` #### 从 Github Releases 下载源码包 由于 github 本身的 downloads 附件下载不支持归档 submodules，因此 Xmake 每次发版都会完整打包一份额外的 tar 包源码上传到 Releases 上。 因此，不要下载错误的链接地址 不完整源码：<https://github.com/TOMO CAT/xmake/archive/refs/tags/v3.0.4.tar.gz> 完整源码包：<https://github.com/TOMO CAT/xmake/releases/download/v3.0.4/xmake v3.0.4.tar.gz> ```bash wget https://github.com/TOMO CAT/xmake/releases/download/v3.0.4/xmake v3.0.4.tar.gz tar xvf xmake v3.0.4.tar.gz C xmake cd xmake ``` > Xmake 的 tar 源码包没有顶层 xmake 根目录，因此解压时候最好带上 ` C xmake` 指定下输出目录。 ### 编译源码 类 unix 平台环境编译 Xmake，我们只需要在源码根目录执行 make 就行了。 ```bash $ cd xmake $ ./configure $ make ``` ### 加载调试 如果编译完成，我们就可以加载刚刚编译好的 Xmake 二进制 core 程序，然后运行本地的 Lua 脚本了。 在 Linux/macOS/FreeBSD 上只需要运行： ```bash $ cd xmake $ source scripts/srcenv.profile ``` 就能进入本地源码调试环境。 我们也可以运行： ```bash $ xmake l os.programdir ``` 来验证我们是否真的加载了本地的 Lua 脚本环境。 ### 调试 core 二进制 通常调试 Xmake 的 Lua 脚本，只需要直接修改当前源码目录的 Lua 脚本就行了，实时生效的，我们并不需要重复编译 core 二进制。 但是如果是 Xmake 的 C 端 core 程序有问题，需要调试或者加模块，那么就需要重复编译了。 编译完成，也是实时生效的，我们可以在 C 代码里通过： ```c xu_trace_i(\"hello %s\", \"xmake\"); ``` 来格式化打印各种输出。 如果是 sv 等 Xmake 依赖的各种 submodules 子模块有问题，需要调试。 我们也可以直接进入子模块源码，修改后重新编译执行。 但是，如果需要贡献修复补丁，我们需要提交 pr 给子模块的仓库才行，补丁合并后，作者会在特定时间同步到到 xmake 源码仓库。 ### 断点调试 xmake 也支持 Lua 断点调试支持，配合 [VSCode EmmyLua](https://github.com/EmmyLua/VSCode EmmyLua) 插件，我们可以很方便的在 VSCode 中断点调试 xmake 自身源码。 首先，我们需要在 VSCode 的插件市场安装 VSCode EmmyLua 插件，然后执行下面的命令更新下 xmake repo 仓库保持最新。 ```bash xrepo update repo ``` > Xmake 也需要保持最新版本。 然后，在自己的工程目录下执行以下命令： ```bash $ xrepo env b emmylua_debugger xmake build ``` 其中 `xrepo env b emmylua_debugger` 用于绑定 EmmyLua 调试器插件环境，而 ` ` 后面的参数，就是我们实际需要被调试的 xmake 命令。 通常我们仅仅调试 `xmake build` 构建，如果想要调试其他命令，可以自己调整，比如想要调试 `xmake install o /tmp` 安装命令，那么可以改成： ```bash $ xrepo env b emmylua_debugger xmake install o /tmp ``` 执行完上面的命令后，它不会立即退出，会一直处于等待调试状态，有可能没有任何输出。 这个时候，我们不要急着退出它，继续打开 VSCode，并在 VSCode 中打开 Xmake 的 Lua 脚本源码目录。 也就是这个目录：[Xmake Lua Scripts](https://github.com/xmake io/xmake/tree/master/xmake)，我们可以下载的本地，也可以直接打开 Xmake 安装目录中的 lua 脚本目录。 然后切换到 VSCode 的调试 Tab 页，点击 `RunDebug` > `Emmylua New Debug` 就能连接到我们的 `xmake build` 命令调试端，开启调试。 如下图所示，默认的起始断点会自动中断到 `debugger:_start_emmylua_debugger` 内部，我们可以点击单步跳出当前函数，就能进入 main 入口。 ![](./image/xmake debug.png) 然后设置自己的断点，点击继续运行，就能中断到自己想要调试的代码位置。 我们也可以在项目工程的配置脚本中设置断点，也可以实现快速调试自己的配置脚本，而不仅仅是 xmake 自身源码。 ![](./image/xmake debug2.png) ### 远程调试 xmake 也能支持远程调试，在虚拟机中调试往往体验不佳，因此通常会远程连到其他主机上去调试 xmake 源码。 我们先在远程机器上开启远程编译服务： ```bash $ xmake service ``` 然后本机打开需要构建的工程目录，执行远程连接，然后执行 `xmake service sync xmakesrc ` 去同步本地源码： ```bash $ xmake service connect $ xmake service sync xmakesrc ~/projects/personal/xmake/xmake/ $ xmake build $ xmake run ``` 这样，我们就能本地修改 xmake 脚本源码，然后同步到远程机器上，再远程执行 xmake 构建命令获取对应的调试输出，以及分析构建行为。 我们也能够通过 `xmake service pull ` 命令，回拉远程的文件到本地，进行分析。 > 注：详细的远程编译特性说明，见 [远程编译文档](http://xmake.io/#/zh cn/features/remote_build)。 ![](./image/xmake remote.png) ## 如何调试仓库包? 调试的方式有很多种，这里我主要介绍最常使用的调试方式，那就是直接拉取 xmake repo 仓库来调试。 ```bash $ git clone https://github.com/xmake io/xmake repo.git $ xmake l scripts/test.lua vD shallow zlib ``` 使用上面 test.lua 脚本命令来调试包，我们可以重复安装测试指定的包，` shallow` 告诉 xmake 每次测试不去重复完整安装它的所有依赖包，仅仅测试按照当前包。 我们也可以测试指定的平台，架构，编译模式， vs_runtime 和动态库，静态库等等。 ```bash $ xmake l scripts/test.lua vD shallow p mingw mingw /xxx/sdk zlib $ xmake l scripts/test.lua vD shallow p iphoneos a arm64 zlib $ xmake l scripts/test.lua vD shallow k shared vs_runtime MD zlib $ xmake l scripts/test.lua vD shallow m debug zlib ``` ### 调试本地包源码 有时候，由于包的源码和构建脚本有问题，我们需要修改一些代码才能继续测试安装，如果通过 add_patches/io.replace 的方式在 on_install 里面去修改调试，非常繁琐。 因此，我们可以通过指定 ` d package_sourcedir` 方式，直接让测试脚本进入我们预先下载好的包源码目录，测试编译安装，我们每次的代码修改不会被重置。 ```bash $ xmake l scripts/test.lua vD shallow d /tmp/zlib 1.2.11 zlib ``` 等修改调试通过后，我们再根据改动，通过 `git diff > fix.patch` 生成补丁文件，通过 `add_patches` 配置应用补丁包，来修复包的安装。 ### 远程调试包源码 我们也可以远程调试包，先开启远程服务： ```bash $ xmake service ``` 然后传入 ` remote` 参数，即可实现远程包编译测试。 ```bash $ xmake l scripts/test.lua vD shallow remote /tmp/zlib 1.2.11 zlib ``` ## 下载包提示证书校验失败怎么办？ ```bash curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.se/docs/sslcerts.html curl failed to verify the legitimacy of the server and therefore could not establish a secure connection to it. To learn more about this situation and how to fix it, please visit the web page mentioned above. ``` 如果你在使用 Xmake 安装依赖包时候，遇到上面的证书验证问题，你可以尝试更新 curl 证书去修复它，或者直接全局配置禁用证书验证来绕过它。 ```bash $ xmake g insecure ssl y ``` 当然，禁用证书验证会带来一定的安全性风险，不过好在 xmake repo 仓库中的包，有严格的 sha256 校验，即使下载被劫持，最终也会 xmake 的 sha256 校验检测到，作为无效下载。"},"/get_started/zh/tutorial/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 ## 命名规范 接口的命名，是有按照预定义的一些规范来命名的，这样更加方便理解和易于使用，目前命名按照如下一些规则： 接口规则 描述 `is_`, `has_` 前缀的接口 表示为条件判断 `set_` 前缀的接口 表示为覆盖设置 `add_` 前缀的接口 表示为追加设置 `s` 后缀的接口 表示支持多值传入，例如：`add_files(\"*.c\", \"test.cpp\")` `on_` 前缀的接口 表示为覆盖内置脚本 `before_` 前缀的接口 表示为在内置脚本运行前，执行此脚本 `after_` 前缀的接口 表示为在内置脚本运行后，执行此脚本 `scope(\"name\")` 的接口 表示为定义一个描述域，例如：`target(\"xxx\")`, `option(\"xxx\")` 描述域 / 描述设置 建议缩进表示 ## 条件判断 条件判断的 api，一般用于必须要处理特定平台的编译逻辑的场合。通常跟 lua 的 if 语句配合使用。 ### is_os #### 判断当前构建目标的操作系统 ```lua 如果当前操作系统是 ios if is_os(\"ios\") then add_files(\"src/xxx/*.m\") end ``` 目前支持的操作系统有： * linux * android * macosx * ios ### is_arch #### 判断当前编译架构 用于检测编译配置：`xmake f a armv7` ```lua 如果当前架构是 x86_64 或者 i386 if is_arch(\"x86_64\", \"i386\") then add_files(\"src/xxx/*.c\") end 如果当前平台是 armv7, arm64, armv7s, armv7 a if is_arch(\"armv7\", \"arm64\", \"armv7s\", \"armv7 a\") then ... end ``` 如果像上面那样一个个去判断所有 arm 架构，也许会很繁琐，毕竟每个平台的架构类型很多，xmake 提供了比 [add_files](#targetadd_files) 更强的 lua 正则表达式匹配模式，来更加简洁的进行判断： ```lua 如果当前平台是 arm 平台 if is_arch(\"arm.*\") then ... end ``` 用 `.*` 就可以匹配所有了。 ### is_plat #### 判断当前编译平台 用于检测编译配置：`xmake f p iphoneos` ```lua 如果当前平台是 android if is_plat(\"android\") then add_files(\"src/xxx/*.c\") end 如果当前平台是 macosx 或者 iphoneos if is_plat(\"macosx\", \"iphoneos\") then add_frameworks(\"Foundation\") end ``` 目前支持的平台有： * cross * linux * macosx * android * iphoneos * watchos 当然你也可以自己扩展添加自己的平台，甚至直接指定自己的平台名： ```bash $ xmake f p other sdk ... ``` 如果指定的平台名不存在，就会自动切到 `cross` 平台进行交叉编译，但是却可以通过 `is_plat(\"other\")` 来判断自己的平台逻辑。 ### is_host #### 判断当前主机环境的操作系统 有些编译平台是可以在多个不同的操作系统进行构建的，例如：android 的 ndk 就支持 linux 和 macOS 环境。 这个时候就可以通过这个接口，区分当前是在哪个系统环境下进行的构建。 ```lua 如果当前主机环境是 linux if is_host(\"linux\") then add_includedirs(\"/usr/includess\") else add_includedirs(\".\") end ``` 目前支持的主机环境有： * linux * macosx 你也可以通过 [$(host)](/zh cn/manual/builtin_variables?id varhost) 内置变量或者 [os.host](/zh cn/manual/builtin_modules?id oshost) 接口，来进行获取 ### is_cross #### 判断当前平台是否为交叉编译 如果当前的目标架构和平台，不是当前的主机平台，属于交叉编译，这个接口就会返回 true。 ### is_mode #### 判断当前编译模式 用于检测编译配置：`xmake f m debug` 编译模式的类型并不是内置的，可以自由指定，一般指定：`debug`, `release`, `profile` 这些就够用了，当然你也可以在 xmake.lua 使用其他模式名来判断。 ```lua 如果当前编译模式是 debug if is_mode(\"debug\") then 添加 DEBUG 编译宏 add_defines(\"DEBUG\") 启用调试符号 set_symbols(\"debug\") 禁用优化 set_optimize(\"none\") end 如果是 release 或者 profile 模式 if is_mode(\"release\", \"profile\") then 如果是 release 模式 if is_mode(\"release\") then 隐藏符号 set_symbols(\"hidden\") strip 所有符号 set_strip(\"all\") 忽略帧指针 add_cxflags(\" fomit frame pointer\") add_mxflags(\" fomit frame pointer\") 如果是 profile 模式 else 启用调试符号 set_symbols(\"debug\") end 添加扩展指令集 add_vectorexts(\"sse2\", \"sse3\", \"ssse3\", \"mmx\") end ``` ### is_kind #### 判断当前编译类型 判断当前是否编译的是动态库还是静态库，用于检测编译配置：`xmake f k [staticshared]` 一般用于如下场景： ```lua target(\"test\") 通过配置设置目标的 kind set_kind(\"$(kind)\") add_files(\"src/*c\") 如果当前编译的是静态库，那么添加指定文件 if is_kind(\"static\") then add_files(\"src/xxx.c\") end ``` 编译配置的时候，可手动切换，编译类型： ```bash # 编译静态库 $ xmake f k static $ xmake ``` ```bash # 编译动态库 $ xmake f k shared $ xmake ``` ### is_config #### 判断指定配置是否为给定的值 用于判断指定配置是否为给定的值，可用于描述域。 例如： ```console $ xmake f test hello1 ``` ```lua 自定义一个配置选项到命令行菜单 option(\"test\", function() set_showmenu(true) set_description(\"The test config option\") end) 如果自定义的 test 配置值是 hello1 或者 hello2 if is_config(\"test\", \"hello1\", \"hello2\") then add_defines(\"HELLO\") end ``` 可以用来根据配置值增加对应的依赖包，例如： ```lua 根据 lua_flavor 的配置值，选择依赖 lua 还是 luajit option(\"lua_flavor\", function() set_showmenu(true) set_values(\"luajit\", \"lua\") end) if is_config(\"lua_flavor\", \"luajit\") then add_requires(\"luajit\") elseif is_config(\"lua_flavor\", \"lua\") then add_requires(\"lua\") end ``` 不仅如此，我们还可以设置模式匹配规则去判断值，例如： ```lua 如果自定义的 test 配置值带有 hello 前缀 if is_config(\"test\", \"hello.*\") then add_defines(\"HELLO\") end ``` > 此接口不仅能够判断通过 [option](#option) 定义的自定义配置选项，同时还能判断内置的全局配置、本地配置 ### has_config #### 判断配置是否启用或者存在 用于检测自定义或者内置的编译配置是否存在或启用，可用于描述域。 例如以下配置情况，都会返回 true: ```console # 启用某个配置选项（如果是 boolean 类型配置） $ xmake f test1 y $ xmake f test1 yes $ xmake f test1 true # 设置某个配置选项的值 $ xmake f test2 value ``` ```lua 如果 test1 或者 test2 被设置或者启用 if has_config(\"test1\", \"test2\") then add_defines(\"TEST\") end ``` 而下面的情况则会禁用配置，返回 false： ```console # 禁用配置（如果是 boolean 类型配置） $ xmake f test1 n $ xmake f test1 no $ xmake f test1 false ``` > 此接口不仅能够判断内置的全局配置、本地配置，同时还可以判断通过 [option](#option) 定义的自定义配置选项。 ### has_package #### 判断依赖包是否启用或者存在 此接口用于检测远程依赖包是否存在或启用，可用于描述域。 一般配合 [add_requires](/zh cn/manual/global_interfaces?id add_requires) 一起使用，例如： ```lua add_requires(\"tbox\", {optional true}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"tbox\") if has_package(\"tbox\") then add_defines(\"HAVE_TBOX\") end end) ``` 如果通过 `add_requires` 添加的可选依赖包，远程下载安装失败，或者当前平台不支持导致实际上没有被正常安装上，那么 `has_package` 就会返回 false，表示不存在，然后对其他 flags 定义甚至源文件编译控制做一些特殊处理。 > 此接口跟 [has_config](#has_config) 的区别在于，[has_config](#has_config) 用于 [option](#option)，而它用于 [add_requires](#add_requires)。 ## 全局接口 全局接口影响整个工程描述，被调用后，后面被包含进来的所有子 `xmake.lua` 都会受影响。 ### includes #### 添加子工程文件和目录 我们能够使用此接口添加工程子文件 (xmake.lua) 或者带有 xmake.lua 的工程子目录。 ``` projectdir subdirs xmake.lua src ``` 添加子工程目录： ```lua includes(\"subdirs\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 或者添加子工程文件： ```lua includes(\"subdirs/xmake.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 我们也可以通过模式匹配的方式，递归添加多个工程子目录文件： ```lua includes(\"**/xmake.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` includes 包含内置的一些辅助配置脚本，例如： ```lua includes(\"@builtin/check\") ``` 会引入内置提供的一些检测辅助接口。 还有 ```lua includes(\"@builtin/qt\") ``` 会引入一些内置的 Qt 相关辅助接口。 其中 `@builtin` 是告诉 xmake 从内置的 includes 目录中引入配置脚本。 也就是这个路径下的配置文件：[includes](https://github.com/xmake io/xmake/tree/master/xmake/includes) 我们可以向上面那样，按目录整个引入，也可以引入单个配置文件，例如： ```lua includes(\"@builtin/check/check_cfuncs.lua\") ``` 仅仅引入 check 目录下 check_cfuncs 相关的辅助脚本。 而通过 `@builtin` 我们就能很好的区分是引入当前用户工程目录下的文件，还是 xmake 安装目录下的内置文件。 ### set_project #### 设置工程名 设置工程名，在 doxygen 自动文档生成插件、工程文件生成插件中会用到，一般设置在 xmake.lua 的最开头，当然放在其他地方也是可以的 ```lua 设置工程名 set_project(\"xutil\") 设置工程版本 set_version(\"1.5.1\") ``` ### set_version #### 设置工程版本 设置项目版本，可以放在 xmake.lua 任何地方，一般放在最开头，例如： ```lua set_version(\"1.5.1\") ``` 支持 buildversion 的配置： ```lua set_version(\"1.5.1\", {build \"%Y%m%d%H%M\"}) ``` 我们也能够添加版本宏定义到头文件，请参考：[add_configfiles](/manual/project_target?id add template configuration files) > 我们可以全局设置版本，但现在我们也可以在 target 域去单独设置它。 同时支持配置 soname 版本，用于控制 so/dylib 动态库的版本兼容性控制。 我们可以配置 soname 的版本后缀名称，xmake 会在编译、安装动态库的时候，自动生成符号链接，执行指定版本的动态库。 例如，如果我们配置： ```lua set_version(\"1.0.1\", {soname true}) ``` xmake 会自动解析版本号的 major 版本作为 soname 版本，生成的结构如下： ``` └── lib ├── libfoo.1.0.1.dylib ├── libfoo.1.dylib > libfoo.1.0.1.dylib └── libfoo.dylib > libfoo.1.dylib ``` 当然，我们也可以指定 soname 到特定的版本命名： ```lua set_version(\"1.0.1\", {soname \"1.0\"}) > libfoo.so.1.0, libfoo.1.0.dylib set_version(\"1.0.1\", {soname \"1\"}) > libfoo.so.1, libfoo.1.dylib set_version(\"1.0.1\", {soname \"A\"}) > libfoo.so.A, libfoo.A.dylib set_version(\"1.0.1\", {soname \"\"}) > libfoo.so, libfoo.dylib ``` 而如果没设置 soname，那么默认不开启 soname 版本兼容控制： ```lua set_version(\"1.0.1\") > libfoo.so, libfoo.dylib ``` ### set_xmakever #### 设置最小 xmake 版本 用于处理 xmake 版本兼容性问题，如果项目的 `xmake.lua`，通过这个接口设置了最小 xmake 版本支持，那么用户环境装的 xmake 低于要求的版本，就会提示错误。 一般情况下，建议默认对其进行设置，这样对用户比较友好，如果 `xmake.lua` 中用到了高版本的 api 接口，用户那边至少可以知道是否因为版本不对导致的构建失败。 设置如下： ```lua 设置最小版本为：2.1.0，低于此版本的 xmake 编译此工程将会提示版本错误信息 set_xmakever(\"2.1.0\") ``` ### add_moduledirs #### 添加模块目录 xmake 内置的扩展模块都在 `xmake/modules` 目录下，可通过 [import](#import) 来导入他们，如果自己在工程里面实现了一些扩展模块， 可以放置在这个接口指定的目录下，import 也就会能找到，并且优先进行导入。 ### add_plugindirs #### 添加插件目录 xmake 内置的插件都是放在 `xmake/plugins` 目录下，但是对于用户自定义的一些特定工程的插件，如果不想放置在 xmake 安装目录下，那么可以在 `xmake.lua` 中进行配置指定的其他插件路径。 ```lua 将当前工程下的 plugins 目录设置为自定义插件目录 add_plugindirs(\"$(projectdir)/plugins\") ``` 这样，xmake 在编译此工程的时候，也就加载这些插件。 ### get_config #### 获取给定的配置值 此接口用于快速获取给定的配置值，可用于描述域。 ```lua if get_config(\"myconfig\") \"xxx\" then add_defines(\"HELLO\") end ``` ### set_config #### 设置给定的默认配置值 此接口从 2.2.2 版本开始引入，用于快速在 xmake.lua 中设置一个默认配置值，仅用于描述域。 之前很多配置，包括编译工具链，构建目录等只能通过 `$ xmake f name value` 的方式来配置，如果我们想写死在 xmake.lua 提供一个默认值，就可以通过下面的方式来配置： ```lua set_config(\"name\", \"value\") set_config(\"buildir\", \"other/buildir\") set_config(\"cc\", \"gcc\") set_config(\"ld\", \"g++\") ``` 不过，我们还是可以通过 `$ xmake f name value` 的方式，去修改 xmake.lua 中的默认配置。 ### add_requires #### 添加需要的依赖包 xmake 的依赖包管理是完全支持语义版本选择的，例如：\"~1.6.1\"，对于语义版本的具体描述见：[https://semver.org/](https://semver.org/) ##### 语义版本 ```lua add_requires(\"tbox 1.6.*\", \"pcre 8.x\", \"libpng ^1.18\") add_requires(\"libpng ~1.16\", \"zlib 1.1.2 > 1.2.11 <1.3.0\") ``` 目前 xmake 使用的语义版本解析器是 [uael](https://github.com/uael) 贡献的 [sv](https://github.com/uael/sv) 库，里面也有对版本描述写法的详细说明，可以参考下：[版本描述说明](https://github.com/uael/sv#versions) ##### 最近版本 当然，如果我们对当前的依赖包的版本没有特殊要求，那么可以直接这么写： ```lua add_requires(\"tbox\", \"libpng\", \"zlib\") ``` 默认，没设置版本号，xmake 会选取最近版本的包，等价于 `add_requires(\"zlib latest\")` ##### 分支选择 这会使用已知的最新版本包，或者是 master 分支的源码编译的包，如果当前包有 git repo 地址，我们也能指定特定分支版本： ```lua add_requires(\"tbox master\") add_requires(\"tbox dev\") ``` 如果指定的依赖包当前平台不支持，或者编译安装失败了，那么 xmake 会编译报错，这对于有些必须要依赖某些包才能工作的项目，这是合理的。 但是如果有些包是可选的依赖，即使没有也可以正常编译使用的话，可以设置为可选包： ##### Git commit 选择 我们可以对 git 维护的包直接指定 git commit 来选择版本。 ```lua add_requires(\"tbox e807230557aac69e4d583c75626e3a7ebdb922f8\") ``` ##### 可选包 ```lua add_requires(\"zlib\", {optional true}) ``` ##### 禁用系统包 默认的设置，xmake 会去优先检测系统库是否存在（如果没设置版本要求），如果用户完全不想使用系统库以及第三方包管理提供的库，那么可以设置： ```lua add_requires(\"zlib\", {system false}) ``` ##### 禁用包校验 默认包安装，对于下载的包都是会去自动校验完整性，避免被篡改，但是如果安装一些未知新版本的包，就不行了。 用户可以通过 `{verify false}` 强行禁用包完整性校验来临时安装他们（但通常不推荐这么做）。 ```lua add_requires(\"zlib\", {verify false}) ``` ##### 使用调试包 如果我们想同时源码调试依赖包，那么可以设置为使用 debug 版本的包（当然前提是这个包支持 debug 编译）： ```lua add_requires(\"zlib\", {debug true}) ``` 如果当前包还不支持 debug 编译，可在仓库中提交修改编译规则，对 debug 进行支持，例如： ```lua package(\"openssl\", function() on_install(\"linux\", \"macosx\", function (package) os.vrun(\"./config %s prefix \\\"%s\\\"\", package:debug() and\" debug\"or\"\", package:installdir()) os.vrun(\"make j4\") os.vrun(\"make install\") end) end) ``` ##### 作为私有包使用 如果这个包，我们仅仅用于包定义，不想对外默认导出 links/linkdirs 信息，可以作为私有包提供。 这通常对于做包时候，很有用。 ```lua package(\"test\") add_deps(\"zlib\", {private true}) on_install(function (package) local zlib package:dep(\"zlib\"):fetch() TODO end) ``` 如果自己定义的一个 test 包，私有依赖一个 zlib 包，等待 zlib 安装完成后，获取里面的包文件信息做进一步处理安装，但是 zlib 包本身不会再对外导出 links/linkdirs。 尽管，`add_requires` 也支持这个选项，但是不对外导出 links/linkdirs，所以通常不会去这么用，仅仅对于做包很有帮助。 ##### 使用动态库 默认的包安装的是静态库，如果要启用动态库，可以配置如下： ```lua add_requires(\"zlib\", {configs {shared true}}) ``` > 当然，前提是这个包的定义里面，有对 `package:config(\"shared\")` 判断处理，官方 xmake repo 仓库里面，通常都是严格区分支持的。 ##### 禁用 pic 支持 默认安装的 linux 包，都是开启 pic 编译的，这对于动态库中依赖静态库非常有用，但如果想禁用 pic，也是可以的。 ```lua add_requires(\"zlib\", {configs {pic false}}) ``` ##### 特定配置包 某些包在编译时候有各种编译选项，我们也可以传递进来： ```lua add_requires(\"boost\", {configs {context true, coroutine true}}) ``` 比如上面，安装的 boost 包，是启用了它内部的一些子模块特性（带有协程模块支持的包）。 当然，具体支持哪些配置，每个包都是不同的，可以通过 `xmake require info boost` 命令查看里面的 configs 部分列表。 因为，每个包定义里面，都会有自己的配置选项，并且通过 `package:config(\"coroutine\")` 在安装时候去判断启用它们。 ##### 安装第三方管理器的包 目前支持安装下面这些第三方包管理器中包。 * Conan (conan::openssl/1.1.1g) * Conda (conda::libpng 1.3.67) * Vcpkg (vcpkg::ffmpeg) * Homebrew/Linuxbrew (brew::pcre2/libpcre2 8) * Pacman on archlinux/msys2 (pacman::libcurl) * Apt on ubuntu/debian (apt::zlib1g dev) * Clib (clib::clibs/bytes@0.0.4) * Dub (dub::log 0.4.3) * Portage on Gentoo/Linux (portage::libhandy) 例如添加 conan 的依赖包： ```lua add_requires(\"conan::zlib/1.2.11\", {alias \"zlib\", debug true}) add_requires(\"conan::openssl/1.1.1g\", {alias \"openssl\", configs {options \"OpenSSL:shared True\"}}) target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"openssl\", \"zlib\") ``` 执行 xmake 进行编译后： ```console ruki:test_package ruki$ xmake checking for the architecture ... x86_64 checking for the Xcode directory ... /Applications/Xcode.app checking for the SDK version of Xcode ... 10.14 note: try installing these packages (pass y to skip confirm)? > conan::zlib/1.2.11 (debug) > conan::openssl/1.1.1g please input: y (y/n) > installing conan::zlib/1.2.11 .. ok > installing conan::openssl/1.1.1g .. ok [0%]: cache compiling.release src/main.c [100%]: linking.release test ``` 关于这个的完整介绍和所有第三方包的安装使用，可以参考文档：[第三方依赖包安装](https://xmake.io/#/zh cn/package/remote_package?id %e7%ac%ac%e4%b8%89%e6%96%b9%e4%be%9d%e8%b5%96%e5%8c%85%e5%ae%89%e8%a3%85) ##### 另一种简化的配置语法 我们通常使用的常用配置语法： ```lua add_requires(\"boost> 1.78.0\", {configs {iostreams true, system true, thread true}}) ``` 对于大部分 boolean 配置，我们可以通过下面的写法，去简化配置。 ```lua add_requires(\"boost[iostreams,system,thread] > 1.78.0\") ``` 这对于 `xrepo install` 独立 cli 命令下带复杂配置的安装，会省事不少，用户可以根据自己的喜好需求，选择使用。 ```console xrepo install boost[iostreams,system,thread] ``` 另外，除了 boolean 配置，还支持 string 和 array 配置值。boolean 值，也可以设置 ` n/y` 去禁用和启用。 ```lua add_requires(\"boost[iostreams,system,thread,key value] > 1.78.0\") add_requires(\"boost[iostreams y,thread n] > 1.78.0\") add_requires(\"ffmpeg[shared,debug,codecs [foo,bar,zoo]]\") ``` ### add_requireconfs #### 设置指定依赖包的配置 我们可以用这个接口来对 `add_requires()` 定义的包和它的依赖包的配置进行扩充和改写，它有下面几种用法。 ##### 扩充指定包的配置 这是基本用法，比如我们已经通过 `add_requires(\"zlib\")` 声明了一个包，想要在后面对这个 zlib 的配置进行扩展，改成动态库编译，可以通过下面的方式配置。 ```lua add_requires(\"zlib\") add_requireconfs(\"zlib\", {configs {shared true}}) ``` 它等价于 ```lua add_requires(\"zlib\", {configs {shared true}}) ``` ##### 设置通用的默认配置 上面的用法，我们还看不出有什么实际用处，但如果依赖多了就能看出效果了，比如下面这样： ```lua add_requires(\"zlib\", {configs {shared true}}) add_requires(\"pcre\", {configs {shared true}}) add_requires(\"libpng\", {configs {shared true}}) add_requires(\"libwebp\", {configs {shared true}}) add_requires(\"libcurl\", {configs {shared false}}) ``` 是不是非常繁琐，如果我们用上 `add_requireconfs` 来设置默认配置，就可以极大的简化成下面的配置： ```lua add_requireconfs(\"*\", {configs {shared true}}) add_requires(\"zlib\") add_requires(\"pcre\") add_requires(\"libpng\") add_requires(\"libwebp\") add_requires(\"libcurl\", {configs {shared false}}) ``` 上面的配置，我们通过 `add_requireconfs(\"*\", {configs {shared true}})` 使用模式匹配的方式，设置所有的依赖包默认走动态库编译安装。 但是，我们又通过 `add_requires(\"libcurl\", {configs {shared false}})` 将 libcurl 进行了特殊配置，强制走静态库编译安装。 最终的配置结果为：zlib/pcre/libpng/libwebp 是 shared 库，libcurl 是静态库。 我们通过模式匹配的方式，可以将一些每个包的常用配置都放置到统一的 `add_requireconfs` 中去预先配置好，极大简化每个 `add_requires` 的定义。 > 默认情况下，对于相同的配置，xmake 会优先使用 add_requires 中的配置，而不是 add_requireconfs。 如果 `add_requires(\"zlib 1.2.11\")` 中设置了版本，就会优先使用 add_requires 的配置，完全忽略 add_requireconfs 里面的版本配置，当然我们也可以通过 override 来完全重写 `add_requires` 中指定的版本。 ```lua add_requires(\"zlib 1.2.11\") add_requireconfs(\"zlib\", {override true, version \"1.2.10\"}) ``` ##### 改写包依赖配置 其实 `add_requireconfs` 最大的用处是可以让用户改写安装包的特定依赖包的配置。 什么意思呢，比如我们项目中集成使用 libpng 这个包，并且使用了动态库版本，但是 libpng 内部依赖的 zlib 库其实还是静态库版本。 ```lua add_requires(\"libpng\", {configs {shared true}}) ``` 那如果我们想让 libpng 依赖的 zlib 包也改成动态库编译，应该怎么配置呢？这就需要 `add_requireconfs` 了。 ```lua add_requires(\"libpng\", {configs {shared true}}) add_requireconfs(\"libpng.zlib\", {configs {shared true}}) ``` 通过 `libpng.zlib` 依赖路径的写法，指定内部某个依赖，改写内部依赖配置。 如果依赖路径很深，比如 `foo > bar > xyz` 的依赖链，我们可以写成：`foo.bar.xyz` 我们也可以改写 libpng 依赖的内部 zlib 库版本： ```lua add_requires(\"libpng\") add_requireconfs(\"libpng.zlib\", {override true, version \"1.2.10\"}) ``` ##### 级联依赖的模式匹配 如果一个包的依赖非常多，且依赖层次也很深，怎么办呢，比如 libwebp 这个包，它的依赖有： ``` libwebp libpng zlib cmake libjpeg libtiff zlib giflib cmake ``` 如果我想改写 libwebp 里面的所有的依赖库都加上特定配置，那么挨个配置，就会非常繁琐，这个时候就需要 `add_requireconfs()` 的递归依赖模式匹配来支持了。 ```lua add_requires(\"libwebp\") add_requireconfs(\"libwebp.**cmake\", {configs {cxflags \" DTEST\"}}) ``` 上面的配置，我们将 libwebp 中所以的库依赖就额外加上了 ` DTEST` 来编译，但是 cmake 依赖属于构建工具依赖，我们可以通过 `xxx` 的方式排除它。 这里的模式匹配写法，与 `add_files()` 非常类似。 我们在给几个例子，比如这回我们只改写 libwebp 下单级的依赖配置，启用调试库： ```lua add_requires(\"libwebp\") add_requireconfs(\"libwebp.*cmake\", {debug true}) ``` ### add_repositories #### 添加依赖包仓库 如果需要的包不在官方仓库 [xmake repo](https://github.com/xmake io/xmake repo) 中，我们可以提交贡献代码到仓库进行支持。 但如果有些包仅用于个人或者私有项目，我们可以建立一个私有仓库 repo，仓库组织结构可参考：[xmake repo](https://github.com/xmake io/xmake repo) 比如，现在我们有一个一个私有仓库 repo：`git@github.com:myrepo/xmake repo.git` 我们可以通过此接口来添加： ```lua add_repositories(\"my repo git@github.com:myrepo/xmake repo.git\") ``` 如果我们只是想添加一两个私有包，这个时候特定去建立一个 git repo 太小题大做了，我们可以直接把包仓库放置项目里面，例如： ``` projectdir myrepo packages t/tbox/xmake.lua z/zlib/xmake.lua src main.c xmake.lua ``` 上面 myrepo 目录就是自己的私有包仓库，内置在自己的项目里面，然后在 xmake.lua 里面添加一下这个仓库位置： ```lua add_repositories(\"my repo myrepo\") ``` 这个可以参考 [benchbox](https://github.com/tboox/benchbox) 项目，里面就内置了一个私有仓库。 注：其中 myrepo 是 xmake 命令执行目录的相对路径，它不会自动根据配置文件所在目录自动转换，如果想要设置到相对于当前 xmake.lua 文件的路径，可以通过 rootdir 参数指定。 ```lua add_repositories(\"my repo myrepo\", {rootdir os.scriptdir()}) ``` 不过这个参数设置只有 v2.5.7 以上版本才支持。 ### set_defaultplat #### 设置默认的编译平台 用于设置工程默认的编译平台，如果没有设置，默认平台跟随当前系统平台，也就是 os.host()。 比如，在 macOS 上默认编译平台是 macosx，如果当前项目是 ios 项目，那么可以设置默认编译平台为 iphoneos。 ```lua set_defaultplat(\"iphoneos\") ``` 它等价于，`xmake f p iphoneos`。 ### set_defaultarchs #### 设置默认的编译架构 用于设置工程默认的编译架构，如果没有设置，默认平台跟随当前系统架构，也就是 os.arch()。 ```lua set_defaultplat(\"iphoneos\") set_defaultarchs(\"arm64\") ``` 它等价于，`xmake f p iphoneos a arm64`。 我们也可以设置多个平台下的默认架构。 ```lua set_defaultarchs(\"iphoneosarm64\", \"windowsx64\") ``` 在 iphoneos 上默认编译 arm64 架构，在 windows 上默认编译 x64 架构。 ### set_defaultmode #### 设置默认的编译模式 用于设置工程默认的编译模式，如果没有设置，默认是 release 模式编译。 ```lua set_defaultmode(\"releasedbg\") ``` 它等价于，`xmake f m releasedbg`。 ### set_allowedplats #### 设置允许编译的平台列表 用于设置工程支持的编译平台列表，如果用户指定了其他平台，会提示错误，这通常用于限制用户指定错误的无效平台。 如果没有设置，那么没有任何平台限制。 ```lua set_allowedplats(\"windows\", \"mingw\") ``` 设置当前项目仅仅支持 windows 和 mingw 平台。 ### set_allowedarchs #### 设置允许编译的平台架构 用于设置工程支持的编译架构列表，如果用户指定了其他架构，会提示错误，这通常用于限制用户指定错误的无效架构。 如果没有设置，那么没有任何架构限制。 ```lua set_allowedarchs(\"x64\", \"x86\") ``` 当前项目，仅仅支持 x64/x86 平台。 我们也可以同时指定多个平台下允许的架构列表。 ```lua set_allowedarchs(\"windowsx64\", \"iphoneosarm64\") ``` 设置当前项目在 windows 上仅仅支持 x64 架构，并且在 iphoneos 上仅仅支持 arm64 架构。 ### set_allowedmodes #### 设置允许的编译模式列表 用于设置工程支持的编译模式列表，如果用户指定了其他模式，会提示错误，这通常用于限制用户指定错误的无效模式。 如果没有设置，那么没有任何模式限制。 ```lua set_allowedmodes(\"release\", \"releasedbg\") ``` 设置当前项目仅仅支持 release/releasedbg 两个编译模式。 ## 辅助接口 ### 自动检测辅助接口 xmake 提供了一些内置的辅助函数，可以直接使用 includes 导入，具体有哪些内置函数可以看下：[Helper functions](https://github.com/xmake io/xmake/tree/master/xmake/includes) 我们可以使用这些接口，检测 links, c/c++ type, includes 和 编译器特性，并且写入宏定义到 config.h 其中，我们提供了两类接口，`check_xxx` 和 `configvar_check_xxx`，带有 `configvar_` 前缀的接口会在检测通过后，写入 `add_configfiles` 指定的 config.h.in 模板文件。 而 `check_xxx` 仅仅只是定义相关 macros 参与编译，但不会持久化到 `config.h.in` 中去。 相关 issues 见： * [#342](https://github.com/xmake io/xmake/issues/342) * [#1715](https://github.com/xmake io/xmake/issues/1715) 我们可以一次性引入所有检测接口： ```lua includes(\"@builtin/check\") ``` 当然我们也可以按需引入单个脚本： ```lua includes(\"@builtin/check/check_links.lua\") ``` 而原有的引入路径，没有区分是否为用户路径，不方便管理维护，且容易被用户配置干扰，后面会逐步废弃。 #### 检测 links 我们可以通过尝试链接来检测指定的 links 是否通过。 ```lua includes(\"check_links.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_links(\"HAS_PTHREAD\", {\"pthread\", \"m\", \"dl\"}) end) ``` config.h.in ```c ${define HAS_PTHREAD} ``` config.h ```c #define HAS_PTHREAD 1 /* #undef HAS_PTHREAD */ ``` #### 检测 c/c++ 类型 我们也能够检测 c/c++ 类型是否存在。 `configvar_check_ctypes` 用于检测 c 代码类型，`configvar_check_cxxtypes` 用于检测 c++ 代码类型。 ```lua includes(\"check_ctypes.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_ctypes(\"HAS_WCHAR\", \"wchar_t\") configvar_check_ctypes(\"HAS_WCHAR_AND_FLOAT\", {\"wchar_t\", \"float\"}) end) ``` config.h.in ```c ${define HAS_WCHAR} ${define HAS_WCHAR_AND_FLOAT} ``` config.h ```c /* #undef HAS_WCHAR */ /* #undef HAS_WCHAR_AND_FLOAT */ ``` #### 检测 c/c++ 函数 `configvar_check_cfuncs` 用于检测 c 代码函数，`configvar_check_cxxfuncs` 用于检测 c++ 代码函数。 ```lua includes(\"check_cfuncs.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_cfuncs(\"HAS_SETJMP\", \"setjmp\", {includes {\"signal.h\", \"setjmp.h\"}}) end) ``` config.h.in ```c ${define HAS_SETJMP} ``` config.h ```c #define HAS_SETJMP 1 /* #undef HAS_SETJMP */ ``` #### 检测 c/c++ 头文件 `configvar_check_cincludes` 用于检测 c 代码头文件，`configvar_check_cxxincludes` 用于检测 c++ 代码头文件。 ```lua includes(\"check_cincludes.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_cincludes(\"HAS_STRING_H\", \"string.h\") configvar_check_cincludes(\"HAS_STRING_AND_STDIO_H\", {\"string.h\", \"stdio.h\"}) end) ``` config.h.in ```c ${define HAS_STRING_H} ${define HAS_STRING_AND_STDIO_H} ``` config.h ```c /* #undef HAS_STRING_H */ #define HAS_STRING_AND_STDIO_H 1 ``` #### 检测 c/c++ 代码片段 `configvar_check_csnippets` 用于检测 c 代码片段，`configvar_check_cxxsnippets` 用于检测 c++ 代码片段。 ```lua includes(\"check_csnippets.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_csnippets(\"HAS_STATIC_ASSERT\", \"_Static_assert(1, \\\"\\\");\") end) ``` config.h.in ```c ${define HAS_STATIC_ASSERT} ``` config.h ```c #define HAS_STATIC_ASSERT 1 ``` xmake 对 check_csnippets 做了改进，新增 `tryrun` 和 `output` 参数去尝试运行和捕获输出。 ```lua includes(\"check_csnippets.lua\") target(\"test\") set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") check_csnippets(\"HAS_INT_4\", \"return (sizeof(int) 4)? 0 : 1;\", {tryrun true}) check_csnippets(\"INT_SIZE\", 'printf(\"%d\", sizeof(int)); return 0;', {output true, number true}) configvar_check_csnippets(\"HAS_LONG_8\", \"return (sizeof(long) 8)? 0 : 1;\", {tryrun true}) configvar_check_csnippets(\"PTR_SIZE\", 'printf(\"%d\", sizeof(void*)); return 0;', {output true, number true}) ``` 如果启用捕获输出，`config.h.in` 的 `${define PTR_SIZE}` 会自动生成 `#define PTR_SIZE 4`。 其中，`number true` 设置，可以强制作为 number 而不是字符串值，否则默认会定义为 `#define PTR_SIZE \"4\"` #### 检测编译器特性 ```lua includes(\"check_features.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_features(\"HAS_CONSTEXPR\", \"cxx_constexpr\") configvar_check_features(\"HAS_CONSEXPR_AND_STATIC_ASSERT\", {\"cxx_constexpr\", \"c_static_assert\"}, {languages \"c++11\"}) end) ``` config.h.in ```c ${define HAS_CONSTEXPR} ${define HAS_CONSEXPR_AND_STATIC_ASSERT} ``` config.h ```c /* #undef HAS_CONSTEXPR */ #define HAS_CONSEXPR_AND_STATIC_ASSERT 1 ``` 所有 c 编译器特性列表： 特性名 c_static_assert c_restrict c_variadic_macros c_function_prototypes 所有 c++ 编译器特性列表： 特性名 cxx_variable_templates cxx_relaxed_constexpr cxx_aggregate_default_initializers cxx_contextual_conversions cxx_attribute_deprecated cxx_decltype_auto cxx_digit_separators cxx_generic_lambdas cxx_lambda_init_captures cxx_binary_literals cxx_return_type_deduction cxx_decltype_incomplete_return_types cxx_reference_qualified_functions cxx_alignof cxx_attributes cxx_inheriting_constructors cxx_thread_local cxx_alias_templates cxx_delegating_constructors cxx_extended_friend_declarations cxx_final cxx_nonstatic_member_init cxx_override cxx_user_literals cxx_constexpr cxx_defaulted_move_initializers cxx_enum_forward_declarations cxx_noexcept cxx_nullptr cxx_range_for cxx_unrestricted_unions cxx_explicit_conversions cxx_lambdas cxx_local_type_template_args cxx_raw_string_literals cxx_auto_type cxx_defaulted_functions cxx_deleted_functions cxx_generalized_initializers cxx_inline_namespaces cxx_sizeof_member cxx_strong_enums cxx_trailing_return_types cxx_unicode_literals cxx_uniform_initialization cxx_variadic_templates cxx_decltype cxx_default_function_template_args cxx_long_long_type cxx_right_angle_brackets cxx_rvalue_references cxx_static_assert cxx_extern_templates cxx_func_identifier cxx_variadic_macros cxx_template_template_parameters c++17 特性检测： 特性名 cxx_aggregate_bases cxx_aligned_new cxx_capture_star_this cxx_constexpr cxx_deduction_guides cxx_enumerator_attributes cxx_fold_expressions cxx_guaranteed_copy_elision cxx_hex_float cxx_if_constexpr cxx_inheriting_constructors cxx_inline_variables cxx_namespace_attributes cxx_noexcept_function_type cxx_nontype_template_args cxx_nontype_template_parameter_auto cxx_range_based_for cxx_static_assert cxx_structured_bindings cxx_template_template_args cxx_variadic_using c++20 特性检测： 特性名 cxx_aggregate_paren_init cxx_char8_t cxx_concepts cxx_conditional_explicit cxx_consteval cxx_constexpr cxx_constexpr_dynamic_alloc cxx_constexpr_in_decltype cxx_constinit cxx_deduction_guides cxx_designated_initializers cxx_generic_lambdas cxx_impl_coroutine cxx_impl_destroying_delete cxx_impl_three_way_comparison cxx_init_captures cxx_modules cxx_nontype_template_args cxx_using_enum cstd 和 c++ std 版本支持，相关 issues: [#1715](https://github.com/xmake io/xmake/issues/1715) ```lua configvar_check_features(\"HAS_CXX_STD_98\", \"cxx_std_98\") configvar_check_features(\"HAS_CXX_STD_11\", \"cxx_std_11\", {languages \"c++11\"}) configvar_check_features(\"HAS_CXX_STD_14\", \"cxx_std_14\", {languages \"c++14\"}) configvar_check_features(\"HAS_CXX_STD_17\", \"cxx_std_17\", {languages \"c++17\"}) configvar_check_features(\"HAS_CXX_STD_20\", \"cxx_std_20\", {languages \"c++20\"}) configvar_check_features(\"HAS_C_STD_89\", \"c_std_89\") configvar_check_features(\"HAS_C_STD_99\", \"c_std_99\") configvar_check_features(\"HAS_C_STD_11\", \"c_std_11\", {languages \"c11\"}) configvar_check_features(\"HAS_C_STD_17\", \"c_std_17\", {languages \"c17\"}) ``` #### 检测内置宏定义 编译器存在一些内置的宏定义，比如：`__GNUC__` 等，我们可以通过 `check_macros` 和 `configvar_check_macros` 辅助脚本来检测它们是否存在。 相关 issues: [#1715](https://github.com/xmake io/xmake/issues/1715) ```lua 检测宏是否定义 configvar_check_macros(\"HAS_GCC\", \"__GNUC__\") 检测宏没有被定义 configvar_check_macros(\"NO_GCC\", \"__GNUC__\", {defined false}) 检测宏条件 configvar_check_macros(\"HAS_CXX20\", \"__cplusplus> 202002L\", {languages \"c++20\"}) ``` #### 检测类型大小 在先前的版本中，我们可以通过 `check_csnippets` 和 `output true` 的方式，来实现类型检测。 ```lua check_csnippets(\"INT_SIZE\", 'printf(\"%d\", sizeof(int)); return 0;', {output true, number true}) ``` 但是这种方式，是通过尝试运行测试代码，然后获取运行输出结果，提取类型大小信息。 这对于交叉编译，就不适用了。 xmake 新增了 `check_sizeof` 辅助接口，可以通过直接解析测试程序的二进制文件，提取类型大小信息。 由于不需要运行测试，这种方式不仅可以支持交叉编译，而且对检测效率也有极大的提升，使用也更加的简单。 ```lua includes(\"@builtin/check\") target(\"test\", function() set_kind(\"static\") add_files(\"*.cpp\") check_sizeof(\"LONG_SIZE\", \"long\") check_sizeof(\"STRING_SIZE\", \"std::string\", {includes \"string\"}) end) ``` ```bash $ xmake f c checking for LONG_SIZE ... 8 checking for STRING_SIZE ... 24 ``` 另外，我也可以通过 `target:check_sizeof` 在脚本域进行检测。 #### 检测大小端 xmake 新增了 `check_bigendian` 接口，来判断当前编译目标是否为大端模式。 ```lua includes(\"@builtin/check\") target(\"test\", function() set_kind(\"static\") add_files(\"*.cpp\") check_bigendian(\"IS_BIG_ENDIAN\") end) ``` 如果检测通过，当前是大端模式，那么会定义 `IS_BIG_ENDIAN 1`。"},"/get_started/zh/theme/switch-themes.html":{"title":"","content":" class: heading_no_counter # 切换主题 如果用户不喜欢 xmake 默认的显示配色和风格，我们可以通过下面的全局配置命令，来切换到 xmake 提供的其他一些配置主题上去，例如： ```bash $ xmake g theme dark ``` 默认的主题名为 default，这里我们通过切换到 dark 风格主题，来适配一些终端背景很浅的场景，提供更加深色的色彩输出，避免看不清。 如果我们要切回默认主题，可以直接敲： ```bash $ xmake g c ``` 或者 ```bash $ xmake g theme default ```"},"/get_started/zh/theme/builtin-themes.html":{"title":"","content":" class: heading_no_counter # 内置主题 ## 默认主题 这个也就是咱们安装 xmake 后默认的显示主题，主题名：default，它默认会提供色彩输出，适合一些深色背景的终端。 <img src \"/assets/img/theme/default.png\" width \"60%\" /> 我们也可以通过下面的命令切回默认主题： ```bash $ xmake g theme default ``` ## Ninja 主题 构建进度风格类似 ninja，采用单行进度条，不再回滚进度，用户可以根据自己的喜好设置。 除了进度展示不同外，其他都跟默认主题的配置相同。 ```bash $ xmake g theme ninja ``` <img src \"/assets/img/theme/ninja.png\" width \"60%\" /> ## Emoji 主题 这个主题部分输出通过 emoji 字符代替之前的色彩输出。 ```bash $ xmake g theme emoji ``` <img src \"/assets/img/theme/emoji.png\" width \"60%\" /> ## Dark 主题 这个主题主要是对一些终端背景是浅色系（比如淡黄色等），导致一些警告输出（默认也是黄色）重合不可见，所以把主题配色变成深色系，提高可见性。 ```bash $ xmake g theme dark ``` ## Light 主题 这个主题主要是对一些终端背景是深色系，导致一些输出重合不可见，所以把主题配色变成浅色系，提高可见性。 ```bash $ xmake g theme light ``` ## Plain 主题 这个主题，其实就是完全禁用色彩、emoji 输出，主要是应对一些不支持 colors code 的终端导致显示乱码的问题，也是最朴素的主题风格。 ```bash $ xmake g theme plain ```"},"/get_started/zh/toolchain/builtin-toolchains.html":{"title":"","content":" class: heading_no_counter # 内置工具链 ## Gcc 如果 linux 上安装了 gcc 工具链，通常 xmake 都会优先探测使用，当然我们也可以手动切换到 gcc 来构建。 ```console $ xmake f toolchain gcc c $ xmake ``` ### 使用指定版本的 Gcc 如果用户额外安装了 gcc 11, gcc 10 等特定版本的 gcc 工具链，在本地的 gcc 程序命名可能是 `/usr/bin/gcc 11`。 一种办法是通过 `xmake f cc gcc 11 cxx gcc 11 ld g++ 11` 挨个指定配置来切换，但非常繁琐。 所以，xmake 也提供了更加快捷的切换方式： ```console $ xmake f toolchain gcc 11 c $ xmake ``` 只需要指定 `gcc 11` 对应的版本名，就可以快速切换整个 gcc 工具链。 ## Clang 在 macOS 和 linux，通常 xmake 也会优先尝试去自动探测和使用它，当然我们也可以手动切换。 ```console $ xmake f toolchain clang c $ xmake ``` ## LLVM 除了独立 clang 编译器，如果用户安装了完整 llvm 工具链，我们也可以整个切换过去，包括 `llvm ar` 等工具。 ```console $ xmake f toolchain llvm sdk /xxxx/llvm $ xmake ``` 如果是手动下载的 llvm sdk，我们需要额外指定 llvm sdk 根目录，确保 xmake 能找到它，当然，如果用户已经安装到 PATH 目录下，` sdk` 参数的设置也是可选的。 ## Circle xmake 新增了 circle 编译器的支持，这是个新的 C++20 编译器，额外附带了一些有趣的编译期元编程特性，有兴趣的同学可以到官网查看：<https://www.circle lang.org/> ```console $ xmake f toolchain circle $ xmake ``` ## Tinyc [Tiny C 编译器](https://bellard.org/tcc/) 非常的轻量，在一些不想安装 msvc/llvm 等重量型编译器的情况下，使用它可能快速编译一些 c 代码。 ```console $ xmake f toolchain tinycc $ xmake ``` 使用的时候，请先把 tinycc 编译器加入 PATH 环境。 我们也可以使用远程工具链自动下载集成它，真正做到全平台一键编译，无任何用户手动安装操作。 ```lua add_requires(\"tinycc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"@tinycc\") end) ``` ## Armcc for Keil/MDK 对 Keil/MDK 下 armcc 的工具链支持，相关 issue 见：[#1753](https://github.com/xmake io/xmake/issues/1753) ```console xmake f p cross a cortex m3 toolchain armcc c xmake ``` 这个工具链主要用于嵌入式交叉编译，所以指定了 ` p cross` 交叉编译平台，` a cortex m3` 指定使用的 cpu，这里复用了 ` a/ arch` 参数。 ## Armclang for Keil/MDK 对 Keil/MDK 下 armclang 的工具链支持，相关 issue 见：[#1753](https://github.com/xmake io/xmake/issues/1753) ```console xmake f p cross a cortex m3 toolchain armclang c xmake ``` 这个工具链主要用于嵌入式交叉编译，所以指定了 ` p cross` 交叉编译平台，` a cortex m3` 指定使用的 cpu，这里复用了 ` a/ arch` 参数。 ## GNU RM 另外一个嵌入式 arm 的交叉工具链，官网：<https://developer.arm.com/tools and software/open source software/developer tools/gnu toolchain/gnu rm> ```console $ xmake f toolchain gnu rm c $ xmake ``` ## SDCC 也是一个嵌入式的 arm 编译工具链。 ```console $ xmake f toolchain sdcc a stm8 $ xmake ``` 我们可以指定 ` a stm8` 切换 cpu 架构，目前支持的有： stm8 mcs51 z80 z180 r2k r3ka s08 hc08 ## Zig 如果要构建 Zig 程序，我们默认执行 xmake 就能自动使用 zig 工具链，但前提是 zig 已经在 PATH 环境下。 ```console $ xmake ``` 当然，我们也可以手动设置它。 ```console $ xmake f toolchain zig c $ xmake ``` 也可以指定 zig 编译器的路径。 ```console $ xmake f toolchain zig zc /xxxx/zig c $ xmake ``` ### Zig CC 我们也可以使用 zig 提供的 `zig cc` 编译器去编译 C/C++ 代码。 ```console $ xmake f cc \"zig cc\" cxx \"zig cc\" ld \"zig c++\" c $ xmake ``` ### 交叉编译 另外，我们也可以使用 zig 实现交叉编译。 ```console $ xmake f p cross cross riscv64 linux musl toolchain zig $ xmake ``` 或者编译 arm64 架构： ```console $ xmake f toolchain zig a arm64 c $ xmake ``` ## Emcc (WASM) 如果要编译 wasm 程序，我们只需要切换到 wasm 平台，默认就会使用 emcc 工具链去编译。 ```console $ xmake f p wasm $ xmake ``` ## Wasi (WASM) 这是另外一个启用了 WASI 的 Wasm 工具链，我们需要手动切换使用。 ```console $ xmake f p wasm toolchain wasi $ xmake ``` ## Icc (Intel C/C++ Compiler) 我们也可以切换到 Intel 的 C/C++ 编译器去使用。 ```console $ xmake f toolchain icc c $ xmake ``` ## Ifort (Intel Fortain Compiler) 我们也可以切换到 Intel 的 Fortran 编译器去使用。 ```console $ xmake f toolchain ifort c $ xmake ``` ## gfortran 除了 Intel 的 Fortran 编译器，我们还有 gnu fortran 编译器可用。 ```console $ xmake f toolchain gfortran c $ xmake ``` ## fpc (Free Pascal) 对于 pascal 程序，xmake 默认就会使用 fpc 编译器来编译。 ```console $ xmake ``` 当然，我们也可以手动切换。 ```console $ xmake f toolchain fpc c $ xmake ``` ## Dlang 对于 dlang 程序，xmake 默认就会使用 dmd 编译器来编译。 ```console $ xmake ``` 当然，我们也可以手动切换。 ```console $ xmake f toolchain dlang c $ xmake ``` 需要注意的是，此处的 dlang 工具链其实内部包含了对 `dmd`, `ldc2` 和 `gdc` 的自动探测和切换。 ## Cuda 对于 Cuda 程序，我们需要手动切换到 cuda 工具链。 ```console $ xmake f toolchain cuda c $ xmake ``` 我们也可以手动切换 nvcc 内部调用的 C/C++ 编译器。 ```console $ xmake f toolchain cuda cu ccbin clang c $ xmake ``` ## 汇编器 关于独立的汇编器工具链，xmake 支持：yasm, nasm, fasm 三个，可以随意切换，如果没设置，默认使用 gcc/clang/msvc 自带的汇编器。 ```console $ xmake f toolchain nasm c $ xmake ``` 也可以单独指定汇编器路径 ```console $ xmake f toolchain nasm as /xxx/nasm c $ xmake ``` ## Go golang 编译工具链，默认编译 go 程序会自动启用。 ```console $ xmake ``` ## Rust rust 编译工具链，默认编译 rust 程序会自动启用。 ```console $ xmake ``` 目前 rust 工具链还可以支持 android 等交叉编译环境。 ```console $ xmake f p android ndk ~/android ndk r20b c $ xmake ``` ## NDK Android 的 NDK 编译工具链，只要启用 android 平台，就会默认启用。 ```console $ xmake f p android ndk ~/android ndk r20b c $ xmake ``` 如果 ` ndk` 参数不指定，xmake 也会默认从 AndroidSDK/ndk bundle 目录，以及 `$ANDROID_NDK_HOME`, `ANDROID_NDK_ROOT` 等环境变量中去探测它。 另外，我们也可以设置导全局的 `xmake g ndk ` 配置中，避免每次重复设置。"},"/get_started/zh/toolchain/custom-toolchains.html":{"title":"","content":" class: heading_no_counter # 自定义工具链 xmake 支持在用户的项目 xmake.lua 中自定义工具链，例如： ```lua define toolchain toolchain(\"myclang\", function() mark as standalone toolchain set_kind(\"standalone\") set toolset set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") add_defines(\"MYCLANG\") check toolchain on_check(function (toolchain) return import(\"lib.detect.find_tool\")(\"clang\") end) on load on_load(function (toolchain) get march local march is_arch(\"x86_64\", \"x64\") and \" m64\" or \" m32\" init flags for c/c++ toolchain:add(\"cxflags\", march) toolchain:add(\"ldflags\", march) toolchain:add(\"shflags\", march) if not is_plat(\"windows\") and os.isdir(\"/usr\") then for _, includedir in ipairs({\"/usr/local/include\", \"/usr/include\"}) do if os.isdir(includedir) then toolchain:add(\"includedirs\", includedir) end end for _, linkdir in ipairs({\"/usr/local/lib\", \"/usr/lib\"}) do if os.isdir(linkdir) then toolchain:add(\"linkdirs\", linkdir) end end end init flags for objc/c++ (with ldflags and shflags) toolchain:add(\"mxflags\", march) init flags for asm toolchain:add(\"asflags\", march) end) end) ``` 然后通过下面的命令切到自己定义的工具链就行了： ```bash $ xmake f toolchain myclang ``` 当然，我们也可以通过 `set_toolchains` 接口直接对指定 target 切换设置到自定义工具链。 在自定义工具前，我们可以通过先运行以下命令，查看完整的内置工具链列表，确保 xmake 没有提供，如果有的话，直接使用就行了，没必要自己定义： ```bash $ xmake show l toolchains ``` 下面是自定义 toolchain 目前支持的接口列表： 接口 描述 [toolchain](#toolchain) 定义工具链 [set_kind](#toolchainset_kind) 设置工具链类型 [set_toolset](#toolchainset_toolset) 设置工具集 [set_sdkdir](#toolchainset_sdkdir) 设置工具链 sdk 目录路径 [set_bindir](#toolchainset_bindir) 设置工具链 bin 目录路径 [on_check](#toolchainon_check) 检测工具链 [on_load](#toolchainonon_load) 加载工具链 [toolchain_end](#toolchain_end) 结束定义工具链 [add_includedirs](/zh cn/manual/project_target?id targetadd_includedirs) 添加头文件搜索目录 [add_defines](/zh cn/manual/project_target?id targetadd_defines) 添加宏定义 [add_undefines](/zh cn/manual/project_target?id targetadd_undefines) 取消宏定义 [add_cflags](/zh cn/manual/project_target?id targetadd_cflags) 添加 c 编译选项 [add_cxflags](/zh cn/manual/project_target?id targetadd_cxflags) 添加 c/c++ 编译选项 [add_cxxflags](/zh cn/manual/project_target?id targetadd_cxxflags) 添加 c++ 编译选项 [add_mflags](/zh cn/manual/project_target?id targetadd_mflags) 添加 objc 编译选项 [add_mxflags](/zh cn/manual/project_target?id targetadd_mxflags) 添加 objc/objc++ 编译选项 [add_mxxflags](/zh cn/manual/project_target?id targetadd_mxxflags) 添加 objc++ 编译选项 [add_scflags](/zh cn/manual/project_target?id targetadd_scflags) 添加 swift 编译选项 [add_asflags](/zh cn/manual/project_target?id targetadd_asflags) 添加汇编编译选项 [add_gcflags](/zh cn/manual/project_target?id targetadd_gcflags) 添加 go 编译选项 [add_dcflags](/zh cn/manual/project_target?id targetadd_dcflags) 添加 dlang 编译选项 [add_rcflags](/zh cn/manual/project_target?id targetadd_rcflags) 添加 rust 编译选项 [add_cuflags](/zh cn/manual/project_target?id targetadd_cuflags) 添加 cuda 编译选项 [add_culdflags](/zh cn/manual/project_target?id targetadd_culdflags) 添加 cuda 设备链接选项 [add_ldflags](/zh cn/manual/project_target?id targetadd_ldflags) 添加链接选项 [add_arflags](/zh cn/manual/project_target?id targetadd_arflags) 添加静态库归档选项 [add_shflags](/zh cn/manual/project_target?id targetadd_shflags) 添加动态库链接选项 [add_languages](/zh cn/manual/project_target?id targetadd_languages) 添加语言标准 [add_frameworks](/zh cn/manual/project_target?id targetadd_frameworks) 添加链接框架 [add_frameworkdirs](/zh cn/manual/project_target?id targetadd_frameworkdirs) 添加链接框架 ## toolchain ### 定义工具链 可以在用户项目 xmake.lua 中定义，也可以通过 includes 独立到单独的 xmake.lua 去专门定义各种工具链 ```lua toolchain(\"myclang\", function() set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") end) ``` ### 定义交叉工具链 我们也可以在 xmake.lua 中针对不同的交叉工具链 sdk 进行自定义配置，通常只需要指定 sdkdir，xmake 就可以自动检测其他的配置，比如 cross 等信息，例如: ```lua toolchain(\"my_toolchain\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/arm linux musleabi cross\") end) target(\"hello\", function() set_kind(\"binary\") add_files(\"apps/hello/*.c\") end) ``` 这是一个最精简的交叉工具链配置，仅仅设置了对应的 sdk 路径，然后通过 `set_kind(\"standalone\")` 将其标记为完整独立的工具链。 这个时候，我们就可以通过命令行 ` toolchain my_toolchain` 去手动切换到此工具链来使用。 ```console xmake f toolchain my_toolchain xmake ``` 另外，我们还可以直接在 xmake.lua 中通过 `set_toolchains` 将其绑定到对应的 target 上去，那么仅仅只在编译此 target 时候，才会切换到我们自定义的工具链。 ```lua toolchain(\"my_toolchain\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/arm linux musleabi cross\") end) target(\"hello\", function() set_kind(\"binary\") add_files(\"apps/hello/*.c\") set_toolchains(\"my_toolchain\") end) ``` 这样，我们不再需要手动切换工具链了，只需要执行 xmake，就会默认自动切换到 my_toolchain 工具链。 这对于嵌入式开发来讲尤其有用，因为嵌入式平台的交叉编译工具链非常多，我们经常需要各种切换来完成不同平台的编译。 因此，我们可以将所有的工具链定义放置到独立的 lua 文件中去定义，例如： ``` projectdir xmake.lua toolchains my_toolchain1.lua my_toolchain2.lua ... ``` 然后，我们只需要再 xmake.lua 中通过 includes 去引入它们，并根据不同的自定义平台，绑定不同的工具链： ```lua includes(\"toolchains/*.lua\") target(\"hello\", function() set_kind(\"binary\") add_files(\"apps/hello/*.c\") if is_plat(\"myplat1\") then set_toolchains(\"my_toolchain1\") elseif is_plat(\"myplat2\") then set_toolchains(\"my_toolchain2\") end end) ``` 这样，我们就可以编译的时候，直接快速切换指定平台，来自动切换对应的工具链了。 ```console xmake f p myplat1 xmake ``` 如果，有些交叉编译工具链结构复杂，自动检测还不足够，那么可以根据实际情况，使用 `set_toolset`, `set_cross` 和 `set_bindir` 等接口，针对性的配置上其他的设置。 例如下面的例子，我们还额外添加了一些 cxflags/ldflags 以及内置的系统库 links。 ```lua toolchain(\"my_toolchain\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/arm linux musleabi cross\") on_load(function (toolchain) add flags for arch if toolchain:is_arch(\"arm\") then toolchain:add(\"cxflags\", \" march armv7 a\", \" msoft float\", {force true}) toolchain:add(\"ldflags\", \" march armv7 a\", \" msoft float\", {force true}) end toolchain:add(\"ldflags\", \" static\", {force true}) toolchain:add(\"syslinks\", \"gcc\", \"c\") end) end) ``` 更多自定义工具链的例子，我们可以看下面的接口文档，也可以到 xmake 的源码的目录参考内置的工具链定义：[内部工具链列表](https://github.com/xmake io/xmake/blob/master/xmake/toolchains/) ## toolchain:set_kind ### 设置工具链类型 目前仅支持设置为 `standalone` 类型，表示当前工具链是独立完整的工具链，包括 cc/cxx/ld/sh/ar 等编译器、归档器、链接器等一整套工具集的配置。 通常用于某个 target 被同时设置了多个工具链的情况，但同时只能生效一个独立工具链，通过此配置可以保证生效的工具链存在互斥关系，比如 gcc/clang 工具链不会同时生效。 而像 yasm/nasm 这种局部工具链，属于附加的局部工具链扩展，不用设置 standalone，因为 clang/yasm 两个工具链有可能同时存在。 > 只要记住，存在完整编译环境的工具链，都设置为 standalone 就行。 ## toolchain:set_toolset 设置工具集。 用于设置每个单独工具名和路径，例如： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") end) ``` 关于这个接口的详情，可以看下：[target.set_toolset](/zh cn/manual/project_target?id targetset_toolset) ## toolchain:set_sdkdir 设置工具链 sdk 目录路径。 通常我们可以通过 `xmake f toolchain myclang sdk xxx` 来配置 sdk 目录，但是每次配置比较繁琐，我们也可以通过此接口预先配置到 xmake.lua 中去，方便快速切换使用。 ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/sdkdir\") set_toolset(\"cc\", \"clang\") end) ``` ## toolchain:set_bindir 设置工具链 bin 目录路径。 通常我们可以通过 `xmake f toolchain myclang bin xxx` 来配置 sdk 目录，但是每次配置比较繁琐，我们也可以通过此接口预先配置到 xmake.lua 中去，方便快速切换使用。 ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_bindir(\"/tmp/sdkdir/bin\") set_toolset(\"cc\", \"clang\") end) ``` ## toolchain:on_check 检测工具链。 用于检测指定工具链所在 sdk 或者程序在当前系统上是否存在，通常用于多个 standalone 工具链的情况，进行自动探测和选择有效工具链。 而对于 `xmake f toolchain myclang` 手动指定的场景，此检测配置不是必须的，可以省略。 ```lua toolchain(\"myclang\", function() on_check(function (toolchain) return import(\"lib.detect.find_tool\")(\"clang\") end) end) ``` ## toolchain:on_load 加载工具链。 对于一些复杂的场景，我们可以在 on_load 中动态灵活的设置各种工具链配置，比在描述域设置更加灵活，更加强大： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") on_load(function (toolchain) set toolset toolchain:set(\"toolset\", \"cc\", \"clang\") toolchain:set(\"toolset\", \"ld\", \"clang++\") init flags local march toolchain:is_arch(\"x86_64\", \"x64\") and \" m64\" or \" m32\" toolchain:add(\"cxflags\", march) toolchain:add(\"ldflags\", march) toolchain:add(\"shflags\", march) end) end) ```"},"/get_started/zh/toolchain/remote-toolchains.html":{"title":"","content":" class: heading_no_counter # 远程工具链 我们可以拉取指定的工具链来集成编译项目，xmake 也支持将依赖包切换到对应的远程工具链参与编译后集成进来。 相关例子代码见：[Toolchain/Packages Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/package) 相关的 issue [#1217](https://github.com/xmake io/xmake/issues/1217) ## 拉取指定版本的 llvm 工具链 我们使用 llvm 10 中的 clang 来编译项目。 ```lua add_requires(\"llvm 10.x\", {alias \"llvm 10\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"llvm@llvm 10\") end) ``` ## 拉取交叉编译工具链 我们也可以拉取指定的交叉编译工具链来编译项目。 ```lua add_requires(\"muslcc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"@muslcc\") end) ``` ## 拉取工具链并且集成对应工具链编译的依赖包 我们也可以使用指定的 muslcc 交叉编译工具链去编译和集成所有的依赖包。 ```lua add_requires(\"muslcc\") add_requires(\"zlib\", \"libogg\", {system false}) set_toolchains(\"@muslcc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\", \"libogg\") end) ``` 完整例子见：[Examples (muslcc)](https://github.com/xmake io/xmake/blob/master/tests/projects/package/toolchain_muslcc/xmake.lua) ## 拉取集成 Zig 工具链 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"zig 0.7.x\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.zig\") set_toolchains(\"@zig\") end) ```"},"/get_started/zh/rule/index.html":{"title":"","content":" class: heading_no_counter # rule xmake 不仅原生支持多语言文件的构建，还允许用户通过自定义构建规则实现复杂的未知文件构建。 自定义构建规则可以使用 `set_extensions` 将一组文件扩展名关联到它们。 一旦这些扩展与规则相关联，稍后对 `add_files` 的调用将自动使用此自定义规则。 这是一个示例规则，它将使用 Pandoc 将添加到构建目标的 Markdown 文件转换为 HTML 文件： ```lua define a build rule for a markdown file rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build_file(function (target, sourcefile, opt) import(\"core.project.depend\") import(\"utils.progress\") it only for v2.5.9, we need use print to show progress below v2.5.8 make sure build directory exists os.mkdir(target:targetdir()) replace .md with .html local targetfile path.join(target:targetdir(), path.basename(sourcefile) .. \".html\") only rebuild the file if its changed since last run depend.on_changed(function () call pandoc to make a standalone html file from a markdown file os.vrunv('pandoc', {\" s\", \" f\", \"markdown\", \" t\", \"html\", \" o\", targetfile, sourcefile}) progress.show(opt.progress, \"${color.build.object}markdown %s\", sourcefile) end, {files sourcefile}) end) end) target(\"test\", function() set_kind(\"object\") make the test target support the construction rules of the markdown file add_rules(\"markdown\") adding a markdown file to build add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` 还有一种以 `on_build_files` 形式代替 `on_build_file` 的方法，它允许您在一个函数调用中处理整个文件集。 第二种称为 `on_buildcmd_file` 和 `on_buildcmd_files` 的形式是声明性的；它不是运行任意 Lua 来构建目标，而是运行 Lua 来了解这些目标是如何构建的。 > `buildcmd` 的优点是可以将这些规则导出到根本不需要 xmake 即可运行的 makefile。 我们可以使用 buildcmd 进一步简化它，如下所示： ```lua define a build rule for a markdown file rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_buildcmd_file(function (target, batchcmds, sourcefile, opt) make sure build directory exists batchcmds:mkdir(target:targetdir()) replace .md with .html local targetfile path.join(target:targetdir(), path.basename(sourcefile) .. \".html\") call pandoc to make a standalone html file from a markdown file batchcmds:vrunv('pandoc', {\" s\", \" f\", \"markdown\", \" t\", \"html\", \" o\", targetfile, sourcefile}) batchcmds:show_progress(opt.progress, \"${color.build.object}markdown %s\", sourcefile) only rebuild the file if its changed since last run batchcmds:add_depfiles(sourcefile) end) end) target(\"test\", function() set_kind(\"object\") make the test target support the construction rules of the markdown file add_rules(\"markdown\") adding a markdown file to build add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` 无论文件扩展名如何，文件都可以分配给特定规则。您可以通过在添加文件时设置 `rule` 自定义属性来完成此操作，如下例所示： ```lua target(\"test\", function() ... add_files(\"src/test/*.md.in\", {rule \"markdown\"}) end) ``` 一个 target 可以叠加应用多个 rules 去更加定制化实现自己的构建行为，甚至支持不同的构建环境。 > 通过 `add_files(\"*.md\", {rule \"markdown\"})` 方式指定的规则，优先级高于 `add_rules(\"markdown\")` 设置的规则。"},"/get_started/zh/rule/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 ## rule 定义规则： ```lua rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build_file(function (target, sourcefile, opt) os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. \".html\")) end) end) ``` ## rule:add_deps 关联依赖可以绑定一批规则，也就是不必对 target 挨个去使用 `add_rules()` 添加规则，只需要应用一个规则，就能生效它和它的所有依赖规则。 例如： ```lua rule(\"foo\", function() add_deps(\"bar\") end) rule(\"bar\", function() ... end) ``` 我们只需要 `add_rules(\"foo\")`，就能同时应用 foo 和 bar 两个规则。 但是，默认情况下，依赖之间是不存在执行的先后顺序的，foo 和 bar 的 `on_build_file` 等脚本是并行执行的，顺序未定义。 如果要严格控制执行顺序，可以配置 `add_deps(\"bar\", {order true})`，告诉 xmake，我们需要根据依赖顺序来执行同级别的脚本。 例如： ```lua rule(\"foo\", function() add_deps(\"bar\", {order true}) on_build_file(function (target, sourcefile) end) end) rule(\"bar\", function() on_build_file(function (target, sourcefile) end) end) ``` bar 的 `on_build_file` 将会被先执行。 不过，这种控制依赖的方式，只适合 foo 和 bar 两个规则都是自定义规则，如果想要将自己的规则插入到 xmake 的内置规则之前执行，这就不适用了。 这个时候，我们需要使用更加灵活的动态规则创建和注入的方式，去修改内置规则。 例如，我们想在内置的 `c++.build` 规则之前，执行自定义 cppfront 规则的 `on_build_file` 脚本，我们可以通过下面的方式来实现。 ```lua rule(\"cppfront\", function() set_extensions(\".cpp2\") on_load(function (target) local rule target:rule(\"c++.build\"):clone() rule:add(\"deps\", \"cppfront\", {order true}) target:rule_add(rule) end) on_build_file(function (target, sourcefile, opt) print(\"build cppfront file\") end) end) target(\"test\", function() set_kind(\"binary\") add_rules(\"cppfront\") add_files(\"src/*.cpp\") add_files(\"src/*.cpp2\") end) ``` ## rule:add_imports 为所有自定义脚本预先导入扩展模块。 使用方式和说明请见：[target:add_imports](#targetadd_imports)，用法相同。 ## rule:set_extensions 设置规则支持的文件扩展类型。 通过设置支持的扩展文件类型，将规则应用于带这些后缀的文件上，例如： ```lua 定义一个 markdown 文件的构建规则 rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build_file(function (target, sourcefile, opt) os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. \".html\")) end) end) target(\"test\", function() set_kind(\"binary\") 使 test 目标支持 markdown 文件的构建规则 add_rules(\"markdown\") 添加 markdown 文件的构建 add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` ## rule:on_load 自定义加载脚本。 用于实现自定规则的加载脚本，当加载 target 的时候，会被执行，可在里面自定义设置一些 target 配置，例如： ```lua rule(\"test\", function() on_load(function (target) target:add(\"defines\", \"TEST\") end) end) ``` ## rule:on_link 自定义链接脚本。 用于实现自定规则的链接脚本，会覆盖被应用的 target 的默认链接行为，例如： ```lua rule(\"test\", function() on_link(function (target) end) end) ``` ## rule:on_config 自定义配置脚本。 在 `xmake config` 执行完成后，Build 之前会执行此脚本，通常用于编译前的配置工作。它与 on_load 不同的是，on_load 只要 target 被加载就会执行，执行时机更早。 如果一些配置，无法在 on_load 中过早配置，那么都可以在 on_config 中去配置它。 另外，它的执行时机比 before_build 还要早，大概的执行流程如下： ``` on_load > after_load > on_config > before_build > on_build > after_build ``` ## rule:on_build 自定义编译脚本。 用于实现自定规则的构建脚本，会覆盖被应用的 target 的默认构建行为，例如： ```lua rule(\"markdown\", function() on_build(function (target) end) end) ``` ## rule:on_clean 自定义清理脚本。 用于实现自定规则的清理脚本会，覆盖被应用的 target 的默认清理行为，例如： ```lua rule(\"markdown\", function() on_clean(function (target) remove sourcefile.html end) end) ``` ## rule:on_package 自定义打包脚本。 用于实现自定规则的打包脚本，覆盖被应用的 target 的默认打包行为, 例如： ```lua rule(\"markdown\", function() on_package(function (target) package sourcefile.html end) end) ``` ## rule:on_install 自定义安装脚本。 用于实现自定规则的安装脚本，覆盖被应用的 target 的默认安装行为, 例如： ```lua rule(\"markdown\", function() on_install(function (target) end) end) ``` ## rule:on_uninstall 自定义卸载脚本。 用于实现自定规则的卸载脚本，覆盖被应用的 target 的默认卸载行为, 例如： ```lua rule(\"markdown\", function() on_uninstall(function (target) end) end) ``` ## rule:on_build_file 自定义编译脚本，一次处理一个源文件。 ```lua rule(\"markdown\", function() on_build_file(function (target, sourcefile, opt) print(\"%%%d: %s\", opt.progress, sourcefile) end) end) ``` 其中第三个参数 opt 是可选参数，用于获取一些编译过程中的信息状态，例如：opt.progress 为当期的编译进度。 ## rule:on_buildcmd_file 自定义批处理编译脚本，一次处理一个源文件。 这个接口里面的脚本不会直接构建源文件，但是会通过 batchcmds 对象，构造一个批处理命令行任务， xmake 在实际执行构建的时候，一次性执行这些命令。 这对于 `xmake project` 此类工程生成器插件非常有用，因为生成器生成的第三方工程文件并不支持 `on_build_files` 此类内置脚本的执行支持。 但是 `on_buildcmd_files` 构造的最终结果，就是一批原始的 cmd 命令行，可以直接给其他工程文件作为 custom commands 来执行。 另外，相比 `on_build_files`，它也简化对扩展文件的编译实现，更加的可读易配置，对用户也更加友好。 ```lua rule(\"foo\", function() set_extensions(\".xxx\") on_buildcmd_file(function (target, batchcmds, sourcefile, opt) batchcmds:vrunv(\"gcc\", {\" o\", objectfile, \" c\", sourcefile}) batchcmds:add_depfiles(\"/xxxxx/dependfile.h\", ...) batchcmds:add_depvalues(...) batchcmds:set_depmtime(os.mtime(...)) batchcmds:set_depcache(\"xxxx.d\") end) end) ``` 除了 `batchcmds:vrunv`，我们还支持一些其他的批处理命令，例如： ```lua batchcmds:show(\"hello %s\", \"xmake\") batchcmds:vrunv(\"gcc\", {\" o\", objectfile, \" c\", sourcefile}, {envs {LD_LIBRARY_PATH \"/xxx\"}}) batchcmds:mkdir(\"/xxx\") and cp, mv, rm, ln .. batchcmds:compile(sourcefile_cx, objectfile, {configs {includedirs sourcefile_dir, languages (sourcekind \"cxx\" and \"c++11\")}}) batchcmds:link(objectfiles, targetfile, {configs {linkdirs \"\"}}) ``` 同时，我们在里面也简化对依赖执行的配置，下面是一个完整例子： ```lua rule(\"lex\", function() set_extensions(\".l\", \".ll\") on_buildcmd_file(function (target, batchcmds, sourcefile_lex, opt) imports import(\"lib.detect.find_tool\") get lex local lex assert(find_tool(\"flex\") or find_tool(\"lex\"), \"lex not found!\") get c/c++ source file for lex local extension path.extension(sourcefile_lex) local sourcefile_cx path.join(target:autogendir(), \"rules\", \"lex_yacc\", path.basename(sourcefile_lex) .. (extension \".ll\" and \".cpp\" or \".c\")) add objectfile local objectfile target:objectfile(sourcefile_cx) table.insert(target:objectfiles(), objectfile) add commands batchcmds:show_progress(opt.progress, \"${color.build.object}compiling.lex %s\", sourcefile_lex) batchcmds:mkdir(path.directory(sourcefile_cx)) batchcmds:vrunv(lex.program, {\" o\", sourcefile_cx, sourcefile_lex}) batchcmds:compile(sourcefile_cx, objectfile) add deps batchcmds:add_depfiles(sourcefile_lex) local dependfile target:dependfile(objectfile) batchcmds:set_depmtime(os.mtime(dependfile)) batchcmds:set_depcache(dependfile) end) end) ``` `add_depfiles` 设置这个目标文件依赖的源文件。`set_depmtime` 设置目标文件的修改时间，如果有任意源文件的修改时间大于它，则认为需要重新生成这个目标文件。这里使用 dependfile 而不是 objectfile 的原因见 [issues 748](https://github.com/xmake io/xmake/issues/748)。`set_depcache` 设置存储依赖信息的文件。 关于这个的详细说明和背景，见：[issue 1246](https://github.com/xmake io/xmake/issues/1246) ## rule:on_build_files 自定义编译脚本，一次处理多个源文件。 大部分的自定义构建规则，每次都是处理单独一个文件，输出一个目标文件，例如：a.c > a.o 但是，有些情况下，我们需要同时输入多个源文件一起构建生成一个目标文件，例如：a.c b.c d.c > x.o 对于这种情况，我们可以通过自定义这个脚本来实现： ```lua rule(\"markdown\", function() on_build_files(function (target, sourcebatch, opt) build some source files for _, sourcefile in ipairs(sourcebatch.sourcefiles) do ... end end) end) ``` ## rule:on_buildcmd_files 自定义批处理编译脚本，一次处理多个源文件。 关于这个的详细说明，见：[rule:on_buildcmd_file](#ruleon_buildcmd_file) ```lua rule(\"foo\", function() set_extensions(\".xxx\") on_buildcmd_files(function (target, batchcmds, sourcebatch, opt) for _, sourcefile in ipairs(sourcebatch.sourcefiles) do batchcmds:vrunv(\"gcc\", {\" o\", objectfile, \" c\", sourcefile}) end end) end) ``` ## rule:before_config 自定义配置前脚本。 用于实现自定义 target 配置前的执行脚本，例如： ```lua rule(\"test\", function() before_config(function (target) end) end) ``` 它会在 on_config 之前被执行。 ## rule:before_link 自定义链接前脚本。 用于实现自定义 target 链接前的执行脚本，例如： ```lua rule(\"test\", function() before_link(function (target) end) end) ``` ## rule:before_build 自定义编译前脚本。 用于实现自定义 target 构建前的执行脚本，例如： ```lua rule(\"markdown\", function() before_build(function (target) end) end) ``` ## rule:before_clean 自定义清理前脚本。 用于实现自定义 target 清理前的执行脚本，例如： ```lua rule(\"markdown\", function() before_clean(function (target) end) end) ``` ## rule:before_package 自定义打包前脚本。 用于实现自定义 target 打包前的执行脚本, 例如： ```lua rule(\"markdown\", function() before_package(function (target) end) end) ``` ## rule:before_install 自定义安装前脚本。 用于实现自定义 target 安装前的执行脚本，例如： ```lua rule(\"markdown\", function() before_install(function (target) end) end) ``` ## rule:before_uninstall 自定义卸载前脚本。 用于实现自定义 target 卸载前的执行脚本，例如： ```lua rule(\"markdown\", function() before_uninstall(function (target) end) end) ``` ## rule:before_build_file 自定义编译前脚本，一次处理一个源文件。 跟 [rule:on_build_file](#ruleon_build_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:before_buildcmd_file 自定义编译前批处理脚本，一次处理一个源文件。 跟 [rule:on_buildcmd_file](#ruleon_buildcmd_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:before_build_files 自定义编译前脚本，一次处理多个源文件。 跟 [rule:on_build_files](#ruleon_build_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:before_buildcmd_files 自定义编译前批处理脚本，一次处理多个源文件。 跟 [rule:on_buildcmd_files](#ruleon_buildcmd_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:after_config 自定义配置后脚本。 用于实现自定义 target 配置后的执行脚本，例如： ```lua rule(\"test\", function() after_config(function (target) end) end) ``` 它会在 on_config 之后被执行。 ## rule:after_link 自定义链接后脚本。 用于实现自定义 target 链接后的执行脚本，用法跟 [rule:before_link](#rulebefore_link) 类似。 ## rule:after_build 自定义编译后脚本。 用于实现自定义 target 构建后的执行脚本，用法跟 [rule:before_build](#rulebefore_build) 类似。 ## rule:after_clean 自定义清理后脚本。 用于实现自定义 target 清理后的执行脚本，用法跟 [rule:before_clean](#rulebefore_clean) 类似。 ## rule:after_package 自定义打包后脚本。 用于实现自定义 target 打包后的执行脚本, 用法跟 [rule:before_package](#rulebefore_package) 类似。 ## rule:after_install 自定义安装后脚本。 用于实现自定义 target 安装后的执行脚本，用法跟 [rule:before_install](#rulebefore_install) 类似。 ## rule:after_uninstall 自定义卸载后脚本。 用于实现自定义 target 卸载后的执行脚本，用法跟 [rule:before_uninstall](#rulebefore_uninstall) 类似。 ## rule:after_build_file 自定义编译后脚本，一次处理一个源文件。 跟 [rule:on_build_file](#ruleon_build_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之后， 一般用于对某些编译后对象文件进行后期处理。 ## rule:after_buildcmd_file 自定义编译后批处理脚本，一次处理一个源文件。 跟 [rule:on_buildcmd_file](#ruleon_buildcmd_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之后， 一般用于对某些编译后对象文件进行后期处理。 ## rule:after_build_files 自定义编译后脚本，一次处理多个源文件。 跟 [rule:on_build_files](#ruleon_build_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之后， 一般用于对某些编译后对象文件进行后期处理。 ## rule:after_buildcmd_files 自定义编译后批处理脚本，一次处理多个源文件。 跟 [rule:on_buildcmd_files](#ruleon_buildcmd_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之后， 一般用于对某些编译后对象文件进行后期处理。"},"/get_started/zh/rule/builtin-rules.html":{"title":"","content":" class: heading_no_counter # 内建规则 xmake 提供了一些内置规则去简化日常 xmake.lua 描述，以及一些常用构建环境的支持。 我们可以通过运行以下命令，查看完整的内置规则列表： ```bash $ xmake show l rules ``` ## mode.debug 为当前工程 xmake.lua 添加 debug 编译模式的配置规则，例如： ```lua add_rules(\"mode.debug\") ``` 相当于： ```lua if is_mode(\"debug\") then set_symbols(\"debug\") set_optimize(\"none\") end ``` 我们可以通过：`xmake f m debug` 来切换到此编译模式。 ## mode.release 为当前工程 xmake.lua 添加 release 编译模式的配置规则，例如： ```lua add_rules(\"mode.release\") ``` > 此模式默认不会带调试符号。 相当于： ```lua if is_mode(\"release\") then set_symbols(\"hidden\") set_optimize(\"fastest\") set_strip(\"all\") end ``` 我们可以通过：`xmake f m release` 来切换到此编译模式。 ## mode.releasedbg 为当前工程 xmake.lua 添加 releasedbg 编译模式的配置规则，例如： ```lua add_rules(\"mode.releasedbg\") ``` > 与 release 模式相比，此模式还会额外开启调试符号，这通常是非常有用的。 相当于： ```lua if is_mode(\"releasedbg\") then set_symbols(\"debug\") set_optimize(\"fastest\") set_strip(\"all\") end ``` 我们可以通过：`xmake f m releasedbg` 来切换到此编译模式。 ## mode.minsizerel 为当前工程 xmake.lua 添加 minsizerel 编译模式的配置规则，例如： ```lua add_rules(\"mode.minsizerel\") ``` > 与 release 模式相比，此模式更加倾向于最小代码编译优化，而不是速度优先。 相当于： ```lua if is_mode(\"minsizerel\") then set_symbols(\"hidden\") set_optimize(\"smallest\") set_strip(\"all\") end ``` 我们可以通过：`xmake f m minsizerel` 来切换到此编译模式。 ## mode.check 为当前工程 xmake.lua 添加 check 编译模式的配置规则，一般用于内存检测，例如： ```lua add_rules(\"mode.check\") ``` 相当于： ```lua if is_mode(\"check\") then set_symbols(\"debug\") set_optimize(\"none\") add_cxflags(\" fsanitize address\", \" ftrapv\") add_mxflags(\" fsanitize address\", \" ftrapv\") add_ldflags(\" fsanitize address\") end ``` 我们可以通过：`xmake f m check` 来切换到此编译模式。 ## mode.profile 为当前工程 xmake.lua 添加 profile 编译模式的配置规则，一般用于性能分析，例如： ```lua add_rules(\"mode.profile\") ``` 相当于： ```lua if is_mode(\"profile\") then set_symbols(\"debug\") add_cxflags(\" pg\") add_ldflags(\" pg\") end ``` 我们可以通过：`xmake f m profile` 来切换到此编译模式。 ## mode.coverage 为当前工程 xmake.lua 添加 coverage 编译模式的配置规则，一般用于覆盖分析，例如： ```lua add_rules(\"mode.coverage\") ``` 相当于： ```lua if is_mode(\"coverage\") then add_cxflags(\" coverage\") add_mxflags(\" coverage\") add_ldflags(\" coverage\") end ``` 我们可以通过：`xmake f m coverage` 来切换到此编译模式。 ## mode.valgrind 此模式提供 valgrind 内存分析检测支持。 ```lua add_rules(\"mode.valgrind\") ``` 我们可以通过：`xmake f m valgrind` 来切换到此编译模式。 ## mode.asan 此模式提供 AddressSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.asan\") ``` 我们可以通过：`xmake f m asan` 来切换到此编译模式。 ## mode.tsan 此模式提供 ThreadSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.tsan\") ``` 我们可以通过：`xmake f m tsan` 来切换到此编译模式。 ## mode.lsan 此模式提供 LeakSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.lsan\") ``` 我们可以通过：`xmake f m lsan` 来切换到此编译模式。 ## mode.ubsan 此模式提供 UndefinedBehaviorSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.ubsan\") ``` 我们可以通过：`xmake f m ubsan` 来切换到此编译模式。 ## qt.static 用于编译生成 Qt 环境的静态库程序： ```lua target(\"test\", function() add_rules(\"qt.static\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ## qt.shared 用于编译生成 Qt 环境的动态库程序： ```lua target(\"test\", function() add_rules(\"qt.shared\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ## qt.console 用于编译生成 Qt 环境的控制台程序： ```lua target(\"test\", function() add_rules(\"qt.console\") add_files(\"src/*.cpp\") end) ``` ## qt.quickapp 用于编译生成 Qt 环境的 Quick(qml) ui 应用程序。 ```lua target(\"test\", function() add_rules(\"qt.quickapp\") add_files(\"src/*.cpp\") add_files(\"src/qml.qrc\") end) ``` ## qt.quickapp_static 用于编译生成 Qt 环境的 Quick(qml) ui 应用程序（静态链接版本）。 > 需要切换到静态库版本 Qt SDK ```lua target(\"test\", function() add_rules(\"qt.quickapp_static\") add_files(\"src/*.cpp\") add_files(\"src/qml.qrc\") end) ``` ## qt.widgetapp 用于编译 Qt Widgets(ui/moc) 应用程序 ```lua target(\"test\", function() add_rules(\"qt.widgetapp\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add_files(\"src/mainwindow.h\") 添加带有 Q_OBJECT 的 meta 头文件 end) ``` ## qt.widgetapp_static 用于编译 Qt Widgets(ui/moc) 应用程序（静态库版本） > 需要切换到静态库版本 Qt SDK ```lua target(\"test\", function() add_rules(\"qt.widgetapp_static\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add_files(\"src/mainwindow.h\") 添加带有 Q_OBJECT 的 meta 头文件 end) ``` 更多 Qt 相关描述见：[#160](https://github.com/xmake io/xmake/issues/160) ## xcode.bundle 用于编译生成 ios/macos bundle 程序 ```lua target(\"test\", function() add_rules(\"xcode.bundle\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` ## xcode.framework 用于编译生成 ios/macos framework 程序 ```lua target(\"test\", function() add_rules(\"xcode.framework\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` ## xcode.application 用于编译生成 ios/macos 应用程序 ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") end) ``` ## plugin.compile_commands.autoupdate 我们也可以使用这个规则来自动更新生成 compile_commandss.json ```lua add_rules(\"plugin.compile_commands.autoupdate\", {outputdir \".vscode\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` ## utils.symbols.export_list 我们可以在 xmake.lua 里面直接定义导出的符号列表，例如： ```lua target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.c\") add_rules(\"utils.symbols.export_list\", {symbols { \"add\", \"sub\"}}) end) ``` 或者，在 `*.export.txt` 文件中添加导出的符号列表。 ```lua target(\"foo2\", function() set_kind(\"shared\") add_files(\"src/foo.c\") add_files(\"src/foo.export.txt\") add_rules(\"utils.symbols.export_list\") end) ``` 完整的工程例子见：[导出符号例子](https://github.com/xmake io/xmake/tree/dev/tests/projects/c/shared_library_export_list) ## utils.install.cmake_importfiles 可以使用此规则在安装 target 目标库文件的时候，导出 .cmake 文件，用于其他 cmake 项目的库导入和查找。 ## utils.install.pkgconfig_importfiles 可以使用此规则在安装 target 目标库文件的时候，导出 pkgconfig/.pc 文件，用于其他项目的库导入和查找。 ## utils.bin2c 可以使用此规则，在项目中引入一些二进制文件，并见他们作为 c/c++ 头文件的方式提供开发者使用，获取这些文件的数据。 比如，我们可以在项目中，内嵌一些 png/jpg 资源文件到代码中。 ```lua target(\"console\", function() set_kind(\"binary\") add_rules(\"utils.bin2c\", {extensions {\".png\", \".jpg\"}}) add_files(\"src/*.c\") add_files(\"res/*.png\", \"res/*.jpg\") end) ``` > extensions 的设置是可选的，默认后缀名是 .bin 然后，我们就可以通过 `#include \"filename.png.h\"` 的方式引入进来使用，xmake 会自动帮你生成对应的头文件，并且添加对应的搜索目录。 ```c static unsigned char g_png_data[] { #include \"image.png.h\" }; int main(int argc, char** argv) { printf(\"image.png: %s, size: %d\\n\", g_png_data, sizeof(g_png_data)); return 0; } ``` 生成头文件内容类似： ```console cat build/.gens/test/macosx/x86_64/release/rules/c++/bin2c/image.png.h 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x78, 0x6D, 0x61, 0x6B, 0x65, 0x21, 0x0A, 0x00 ``` ## utils.glsl2spv 可以使用此规则，在项目中引入 `*.vert/*.frag` 等 glsl shader 文件，然后实现自动编译生成 `*.spv` 文件。 另外，我们还支持以 C/C++ 头文件的方式，二进制内嵌 spv 文件数据，方便程序使用。 ### 编译生成 spv 文件 xmake 会自动调用 glslangValidator 或者 glslc 去编译 shaders 生成 .spv 文件，然后输出到指定的 `{outputdir \"build\"}` 目录下。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"glslang\", {configs {binaryonly true}}) target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.glsl2spv\", {outputdir \"build\"}) add_files(\"src/*.c\") add_files(\"src/*.vert\", \"src/*.frag\") add_packages(\"glslang\") end) ``` > 注，这里的 `add_packages(\"glslang\")` 主要用于引入和绑定 glslang 包中的 glslangValidator，确保 xmake 总归能够使用它。 当然，如果用户自己系统上已经安装了它，也可以不用额外绑定这个包，不过我还是建议添加一下。 ### 编译生成 c/c++ 头文件 我们也可以内部借助 bin2c 模块，将编译后的 spv 文件生成对应的二进制头文件，方便用户代码中直接引入，我们只需要启用 `{bin2c true}`。: ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"glslang\", {configs {binaryonly true}}) target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.glsl2spv\", {bin2c true}) add_files(\"src/*.c\") add_files(\"src/*.vert\", \"src/*.frag\") add_packages(\"glslang\") end) ``` 然后我们可以在代码这么引入： ```c static unsigned char g_test_vert_spv_data[] { #include \"test.vert.spv.h\" }; static unsigned char g_test_frag_spv_data[] { #include \"test.frag.spv.h\" }; ``` 跟 bin2c 规则的使用方式类似，完整例子见：[glsl2spv example](https://github.com/xmake io/xmake/tree/master/tests/projects/other/glsl2spv) ## utils.hlsl2spv 除了 `utils.glsl2spv` 规则，我们现在还支持 `utils.hlsl2spv` 规则。 ```bash add_rules(\"mode.debug\", \"mode.release\") add_requires(\"glslang\", {configs {binaryonly true}}) target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.hlsl2spv\", {bin2c true}) add_files(\"src/*.c\") add_files(\"src/*.hlsl\", \"src/*.hlsl\") add_packages(\"directxshadercompiler\") end) ``` ## python.library 我们可以用这个规则，配合 pybind11 生成 python 库模块，它会调整 python 库的模块名。 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"pybind11\") target(\"example\", function() add_rules(\"python.library\") add_files(\"src/*.cpp\") add_packages(\"pybind11\") set_languages(\"c++11\") end) ``` 带有 soabi： ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"pybind11\") target(\"example\", function() add_rules(\"python.library\", {soabi true}) add_files(\"src/*.cpp\") add_packages(\"pybind11\") set_languages(\"c++11\") end) ``` ## nodejs.module 构建 nodejs 模块。 ```lua add_requires(\"node addon api\") target(\"foo\", function() set_languages(\"cxx17\") add_rules(\"nodejs.module\") add_packages(\"node addon api\") add_files(\"*.cc\") end) ``` ## utils.ipsc ipsc 编译器规则支持，使用方式如下： ```lua target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.ispc\", {header_extension \"_ispc.h\"}) set_values(\"ispc.flags\", \" target host\") add_files(\"src/*.ispc\") add_files(\"src/*.cpp\") end) ```"},"/get_started/zh/tutorial/install.html":{"title":"","content":" class: heading_no_counter # 安装 ## 源码编译安装 ### 安装 > 切记，xmake 不建议在 root 下安装和使用，所以尽量不要在 root 下拉取源码编译安装。 ```bash git clone https://github.com/TOMO CAT/xmake.git cd ./xmake bash scripts/install.sh ``` 如果没有外网环境，可以通过 gitee 镜像拉取（xmake repo 也会自动切到 gitee 源）： ```bash git clone https://gitee.com/tomocat/xmake.git ``` 安装完后检查是否安装完成： ```bash xmake version ``` ### 启用 Luajit 对于一些大型项目（比如包含 300+ targets），我们可以启用 Luajit 加速构建，提升构建速度。 ```bash bash scripts/install.sh runtime luajit ``` ### 仅更新 lua 脚本 这个开发者本地调试 xmake 源码才需要： ```bash ./scripts/get.sh __local__ __install_only__ ``` ### 编译 xmake bundle 包 默认编译方式会安装 xmake 二进制和 Lua 脚本，这样做的好处是方便源码调试 Lua 脚本，但是不方便发布和迁移，可以只编译 xmake 二进制： ```bash # TODO: ``` ### root 下安装 xmake 不推荐 root 下安装使用，因为这很不安全。因此以 root 用户运行 xmake 会打印一条 warning 日志，用户可以设置环境变量 `XMAKE_ROOT y` 屏蔽相关的报警，用户需要随时注意root下误操作系统文件文件的风险。 ### 启用 ccache 默认情况下 xmake 用的是内部的 xcache，但可能会出现一些非预期的 bug。如果需要启用 ccache，可以手动安装 ccache，xmake会自动检测并使用。 ## 更新升级 我们可以通过 `xmake update` 命令来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个 tag 版本： ```bash # 如果不是 force 的话, xmake 版本一样就会跳过安装, 不会精确到 git tag / branch # 例如 xmake v3.0.4+dev.39db22335 版本也会跳过 xmake update force diagnosis verbose v3.0.4 ``` 我们也可以指定更新到 master/dev 分支版本： ```bash xmake update master xmake update dev ``` 从指定 git 源更新： ```bash # 指定 github 源 xmake update github:TOMO CAT/xmake#master # 指定 gitee 源 xmake update gitee:tomocat/xmake#dev ``` 如果 xmake/core 没动过，仅仅更新 xmake 的 lua 脚本改动，可以加 ` s/ scriptonly` 快速更新 lua 脚本： ```bash xmake update scriptonly force dev ``` ## 卸载 最后，我们如果要卸载 xmake，也是支持的： ```bash rm rf /usr/local/share/xmake rm /usr/local/bin/xrepo rm /usr/local/bin/xmake ```"},"/get_started/zh/tutorial/build-policies.html":{"title":"","content":" class: heading_no_counter # 构建策略 xmake 有很多的默认行为，比如：自动检测和映射 flags、跨 target 并行构建等，虽然提供了一定的智能化处理，但众口难调，不一定满足所有的用户的使用习惯和需求。 因此 xmake 提供默认构建策略的修改设置，开放给用户一定程度上的可配置性。 它主要通过 [set_policy](https://xmake.io/#/zh cn/manual/project_target?id targetset_policy) 接口来配置。 我们通常可以用它来配置修改 target，package 以及工程整体的一些行为策略。 使用方式如下： ```lua set_policy(\"check.auto_ignore_flags\", false) ``` 只需要在项目根域设置这个配置，就可以禁用 flags 的自动检测和忽略机制，另外 `set_policy` 也可以针对某个特定的 target 局部生效。 ```lua target(\"test\", function() set_policy(\"check.auto_ignore_flags\", false) end) ``` > 另外，如果设置的策略名是无效的，xmake 也会有警告提示。 如果要获取当前 xmake 支持的所有策略配置列表和描述，可以执行下面的命令： ```bash $ xmake l core.project.policy.policies { \"check.auto_map_flags\" { type \"boolean\", description \"Enable map gcc flags to the current compiler and linker automatically.\", default true }, \"build.across_targets_in_parallel\" { type \"boolean\", description \"Enable compile the source files for each target in parallel.\", default true }, \"check.auto_ignore_flags\" { type \"boolean\", description \"Enable check and ignore unsupported flags automatically.\", default true } } ``` 我们也可以通过命令行的方式去设置修改内部的策略: ```bash $ xmake f policies package.fetch_only ``` 默认设置策略名，就是启用状态，当然我们也可以指定设置其他值，禁用它。 ```bash $ xmake f policies package.precompiled:n ``` 或者同时配置多个策略值，用逗号分割。 ```bash $ xmake f policies package.precompiled:n,package.install_only ``` ### check.auto_ignore_flags xmake 默认会对所有 `add_cxflags`, `add_ldflags` 接口设置的原始 flags 进行自动检测，如果检测当前编译器和链接器不支持它们，就会自动忽略。 这通常是很有用的，像一些可选的编译 flags，即使不支持也能正常编译，但是强行设置上去，其他用户在编译的时候，有可能会因为编译器的支持力度不同，出现一定程度的编译失败。 但由于自动检测并不保证100%可靠，有时候会有一定程度的误判，所以某些用户并不喜欢这个设定（尤其是针对交叉编译工具链，更容易出现失败）。 目前如果检测失败，会有警告提示避免用户莫名躺坑，例如： ```bash warning: add_ldflags(\" static\") is ignored, please pass `{force true}` or call `set_policy(\"check.auto_ignore_flags\", false)` if you want to set it. ``` 根据提示，我们可以自己分析判断，是否需要强制设置这个 flags，一种就是通过： ```lua add_ldflags(\" static\", {force true}) ``` 来显示的强制设置上它，跳过自动检测，这对于偶尔的 flags 失败，是很有效快捷的处理方式，但是对于交叉编译时候，一堆的 flags 设置检测不过的情况下，每个都设置 force 太过于繁琐。 这个时候，我们就可以通过 `set_policy` 来对某个 target 或者整个 project 直接禁用默认的自动检测行为： ```lua set_policy(\"check.auto_ignore_flags\", false) target(\"test\", function() add_ldflags(\" static\") end) ``` 然后我们就可以随意设置各种原始 flags，xmake 不会去自动检测和忽略他们了。 ### check.auto_map_flags 这是 xmake 的另外一个对 flags 的智能分析处理，通常像 `add_links`, `add_defines` 这种 xmake 内置的 api 去设置的配置，是具有跨平台特性的，不同编译器平台会自动处理成对应的原始 flags。 但是，有些情况，用户还是需要自己通过 `add_cxflags`, `add_ldflags` 设置原始的编译链接 flags，这些 flags 并不能很好的跨编译器。 就拿 ` O0` 的编译优化 flags 来说，虽然有 `set_optimize` 来实现跨编译器配置，但如果用户直接设置 `add_cxflags(\" O0\")` 呢？gcc/clang 下可以正常处理，但是 msvc 下就不支持了。 也许我们能通过 `if is_plat() then` 来分平台处理，但很繁琐，因此 xmake 内置了 flags 的自动映射功能。 基于 gcc flags 的普及性，xmake 采用 gcc 的 flags 命名规范，对其根据不同的编译实现自动映射，例如： ```lua add_cxflags(\" O0\") ``` 这一行设置，在 gcc/clang 下还是 ` O0`，但如果当前是 msvc 编译器，那边会自动映射为 msvc 对应 ` Od` 编译选项来禁用优化。 整个过程，用户是完全无感知的，直接执行 xmake 就可以跨编译器完成编译。 > 当然，目前的自动映射实现还不是很成熟，没有 100% 覆盖所有 gcc 的 flags，所以还是有不少 flags 是没去映射的。 也有部分用户并不喜欢这种自动映射行为，那么我们可以通过下面的设置完全禁用这个默认的行为： ```bash set_policy(\"check.auto_map_flags\", false) ``` ### build.across_targets_in_parallel 这个策略也是默认开启的，主要用于跨 target 间执行并行构建，v2.3.3 之前的版本，并行构建只能针对单个 target 内部的所有源文件， 跨 target 的编译，必须要要等先前的 target 完全 link 成功，才能执行下一个 target 的编译，这在一定程度上会影响编译速度。 然而每个 target 的源文件是可以完全并行化处理的，最终在一起执行 link 过程，v2.3.3 之后的版本通过这个优化，构建速度提升了30%。 当然，如果有些特殊的 target 里面的构建源文件要依赖先前的 target（尤其是一些自定义 rules 的情况，虽然很少遇到），我们也可以通过下面的设置禁用这个优化行为： ```bash set_policy(\"build.across_targets_in_parallel\", false) ``` ### build.fence 由于配置 `set_policy(\"build.across_targets_in_parallel\", false)` 存在局限性，它会限制父 target 和它的所有依赖的子 target 之间的并行度，影响的范围有点大。 而我们做 codegen 时候，有时候仅仅只是想对其中某个依赖的 target 限制并行度，作为 codegen 程序，提前让它完成编译。 这个时候，`build.across_targets_in_parallel` 就无法精细控制了，编译速度也无法达到最优。 因此，我们新增了 `build.fence` 策略，它可以仅仅只针对特定的子 target 限制并行编译链接。 相关的背景细节，可以看下：[#5003](https://github.com/xmake io/xmake/issues/5003) 例如： ```lua target(\"autogen\", function() set_default(false) set_kind(\"binary\") set_plat(os.host()) set_arch(os.arch()) add_files(\"src/autogen.cpp\") set_languages(\"c++11\") set_policy(\"build.fence\", true) end) target(\"test\", function() set_kind(\"binary\") add_deps(\"autogen\") add_rules(\"autogen\") add_files(\"src/main.cpp\") add_files(\"src/*.in\") end) ``` 其中 autogen 目标程序需要在 test 程序的源码被编译前，就要完成编译链接，因为 test 目标需要运行 autogen 程序，去动态生成一些源码参与编译。 而针对 autogen 配置 `set_policy(\"build.fence\", true)` 就可以实现这个目的。 ### build.merge_archive 如果设置了这个策略，那么使用 `add_deps()` 依赖的目标库不再作为链接存在，而是直接把它们合并到父目标库中去。 例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"add\", function() set_kind(\"static\") add_files(\"src/add.c\") add_files(\"src/subdir/add.c\") end) target(\"sub\", function() set_kind(\"static\") add_files(\"src/sub.c\") add_files(\"src/subdir/sub.c\") end) target(\"mul\", function() set_kind(\"static\") add_deps(\"add\", \"sub\") add_files(\"src/mul.c\") set_policy(\"build.merge_archive\", true) end) target(\"test\", function() add_deps(\"mul\") add_files(\"src/main.c\") end) ``` libmul.a 静态库会自动合并 libadd.a 和 libsub.a 两个子依赖的静态库。 ### build.ccache Xmake 默认是开启内置的编译缓存的，通过设置这个策略，可以显式禁用缓存。 ```lua set_policy(\"build.ccache\", false) ``` 当然，我们也可以命令行去禁用它。 ```bash $ xmake f ccache n ``` 或者 ```bash $ xmake f policies build.ccache:n ``` ### build.warning 默认编译通常不会实时回显警告输出，我们通常需要使用 `xmake w` 开启，或者通过 `xmake g build_warning y` 来全局开启它。 现在，我们也可以在 xmake.lua 配置中去默认启用警告回显输出。 ```lua set_policy(\"build.warning\", true) set_warnings(\"all\", \"extra\") ``` 这个时候，即使我们执行 `xmake` 命令，也能直接回显警告输出。 ### build.optimization.lto xmake 改进了对 LTO 链接时优化的支持，对 gcc/clang/msvc 等不同平台下都进行了适配，只需要启用这个策略，就能对特定 target 开启 LTO。 ```lua set_policy(\"build.optimization.lto\", true) ``` 我们也可以通过命令行选项快速开启。 ```bash $ xmake f policies build.optimization.lto ``` ### build.cuda.devlink 可以通过这个配置，显示开启对特定目标的设备链接。 这通常用于 Cuda 项目的构建，以及非 Cuda binary/shared 依赖 Cuda static 目标的情况，这个时候，Cuda static 目标就需要显示配置这个，开启设备链接。 ```lua target(\"test\", function() set_kind(\"static\") set_policy(\"build.cuda.devlink\", true) end) ``` 而默认 Cuda binary/shared 是开启 devlink 的，我们也可以通过策略显示禁用它。 关于这个的详细背景说明，见：[#1976](https://github.com/xmake io/xmake/issues/1976) ### build.sanitizer.address Address Sanitizer（ASan）是一个快速的内存错误检测工具，由编译器内置支持，通常我们需要在编译和链接的 flags 中同时配置 ` fsanitize address` 才能正确开启。 而我们可以通过开启这个策略，就可以快速全局启用它，这会使得编译出来的程序，直接支持 ASan 检测。 例如，我们可以通过命令行的方式去启用： ```bash $ xmake f policies build.sanitizer.address ``` 也可以通过接口配置去全局启用： ```lua set_policy(\"build.sanitizer.address\", true) ``` 当然，我们也可以单独对某个特定的 target 去配置开启。 另外，如果全局配置它，我们就可以同时对所有依赖包也生效。 ```lua set_policy(\"build.sanitizer.address\", true) add_requires(\"zlib\") add_requires(\"libpng\") ``` 它等价于，对每个包依次设置 asan 配置。 ```lua add_requires(\"zlib\", {configs {asan true}}) add_requires(\"libpng\", {configs {asan true}}) ``` > `add_rules(\"mode.asan\", \"mode.tsan\", \"mode.ubsan\", \"mode.msan\")` 将被废弃，尽可能使用这些新的策略，因为这些构建模式无法同步对依赖包生效。 另外，我们也可以同时生效多个 sanitizer 检测，例如： ```lua set_policy(\"build.sanitizer.address\", true) set_policy(\"build.sanitizer.undefined\", true) ``` 或者 ``` $ xmake f policies build.sanitizer.address,build.sanitizer.undefined ``` ### build.sanitizer.thread 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测线程安全问题。 ### build.sanitizer.memory 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测内存问题。 ### build.sanitizer.leak 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测内存泄漏问题。 ### build.sanitizer.undefined 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测 undefined 问题。 ### build.always_update_configfiles 这个策略用于对 `add_configfiles` 配置文件的自动生成行为。默认情况下，xmake 仅仅只会在首次 `xmake config` 时候，或者 xmake.lua 配置有改动的是否，才会触发 configfiles 的重新生成。 之后的每次构建，只要配置没有变化，就不会重新生成 configfiles。 但是，如果我们的 configfiles 中有使用 GIT_COMMIT 等变量，想要每次构建时候，总是重新生成最新的配置，那么可以配置它。 具体使用背景，可以看下：[#4747](https://github.com/xmake io/xmake/issues/4747) ### build.intermediate_directory 配置启用或禁用构建的内部子目录。 默认情况下，执行 `xmake` 编译项目会自动在 build 目录下根据平台。架构，编译模式生成子目录，分别存储对象文件，目标文件。例如： ```bash build/ └── macosx └── x86_64 └── release └─test ``` 如果配置禁用此策略，那么生成的产物将会直接生成到 build 根目录下。变成： ```bash build/ └─ test ``` ### build.rpath 配置启用或者禁用构建时的 target rpath 设置。 默认情况下，如果 `target(foo)` 依赖动态库 bar，那么生成的 foo 可执行文件会自动加上 bar 的 rpath，这能保证用户直接执行 foo 程序，也能正确找到 bar。 如果你想禁用这个行为，可以显式配置禁用它。 ### install.rpath 尽管构建后的程序，会被设置 rpath，但是当 `xmake install` 安装后，它构建时候的 rpath 就不一定完全适用了，因此 xmake 会自动修改调整 rpath，使得安装后的程序，同样可以找到它的依赖库。 不过前提是，用户自己先得通过 `add_rpathdirs(\"/xxx\", {installonly true})` 去配置独立的安装 rpath。 而我们也可以通过这个 policy 去禁用默认的安装阶段 rpath 设置行为。 ### run.autobuild 这个策略用于调整 `xmake run` 的行为，默认情况下，执行 `xmake run` 并不会自动构建目标程序，如果程序还没被编译，就是提示用户手动构建一下。 而开启这个策略，我们就可以在运行程序前，先自动构建对应的目标程序。 ```bash $ xmake f policies run.autobuild $ xmake run ``` 如果想要全局生效这个策略，可以全局开启它。 ```bash $ xmake g policies run.autobuild ``` ### preprocessor.linemarkers 通常用户编译缓存中，预处理器的生成策略，默认开启，如果配置关闭这个策略，那么缓存生成的预处理文件内容将不包含 linemarkers 信息，这会极大减少预处理文件大小。 也会提升缓存的处理效率，但是缺点就是会丢失源码行信息，如果遇到编译错误，将无法看到准确的出错代码行。 ### preprocessor.gcc.directives_only 这也是用于预处理器的策略，默认开启，这会提升 gcc 下编译缓存预处理的效率，但是如果源文件中包含 `__DATE__`, `__TIME__` 等宏，就会导致缓存出现不一致。 因此，可以根据自身工程代码，按需关闭此策略，确保生成的结果一致。 ### package.requires_lock 可用于开启 `add_requires()` 引入的依赖包的版本锁定。 具体看下：[依赖包的锁定和升级](https://xmake.io/#/zh cn/package/remote_package?id %e4%be%9d%e8%b5%96%e5%8c%85%e7%9a%84%e9%94%81%e5%ae%9a%e5%92%8c%e5%8d%87%e7%ba%a7) ### package.fetch_only 如果开启这个策略，那么所有的依赖包仅仅只会从系统获取，不会从远程下载安装。 ### package.install_only 如果开启这个策略，那么所有的依赖包仅仅只会走远程下载安装，不会从系统查找获取。 ### package.librarydeps.strict_compatibility 默认禁用，如果启用它，那么当前包和它的所有库依赖包之间会保持严格的兼容性，任何依赖包的版本更新，都会强制触发当前包的重新编译安装。 以确保所有的包都是二进制兼容的，不会因为某个依赖包接口改动，导致和其他已被安装的其他包一起链接时候，发生链接和运行错误。 ```lua package(\"foo\") add_deps(\"bar\", \"zoo\") set_policy(\"package.librarydeps.strict_compatibility\", true) ``` 例如，如果 bar 或者 zoo 的版本有更新，那么 foo 也会重新编译安装。 ### package.strict_compatibility 默认禁用，如果启用它，那么当前包和其他所有依赖它的包之间会保持严格的兼容性，这个包的版本更新，都会强制触发其他父包的重新编译安装。 以确保所有的包都是二进制兼容的，不会因为某个依赖包接口改动，导致和其他已被安装的其他包一起链接时候，发生链接和运行错误。 ```lua package(\"foo\", function() set_policy(\"package.strict_compatibility\", true) end) package(\"bar\", function() add_deps(\"foo\") end) package(\"zoo\", function() add_deps(\"foo\") end) ``` 例如，如果 foo 的版本有更新，那么 bar 和 zoo 都会被强制重新编译安装。 ### package.install_always 每次运行 `xmake f c` 重新配置的时候，总是会重新安装包，这对于本地第三方源码包集成时候比较有用。 因为，用户可能随时需要修改第三方源码，然后重新编译集成它们。 之前只能通过每次修改包版本号，来触发重新编译，但是有了这个策略，就能每次都会触发重编。 ```lua add_rules(\"mode.debug\", \"mode.release\") package(\"foo\", function() add_deps(\"cmake\") set_sourcedir(path.join(os.scriptdir(), \"foo\")) set_policy(\"package.install_always\", true) on_install(function (package) local configs {} table.insert(configs, \" DCMAKE_BUILD_TYPE \" .. (package:debug() and \"Debug\" or \"Release\")) table.insert(configs, \" DBUILD_SHARED_LIBS \" .. (package:config(\"shared\") and \"ON\" or \"OFF\")) import(\"package.tools.cmake\").install(package, configs) end) on_test(function (package) assert(package:has_cfuncs(\"add\", {includes \"foo.h\"})) end) end) add_requires(\"foo\") target(\"demo\", function() set_kind(\"binary\") add_files(\"src/main.c\") add_packages(\"foo\") end) ``` ### package.download.http_headers 设置包下载的 http headers 如果有些包的 url 下载，需要设置特定 http headers，才能通过下载，可以通过这个策略来指定。 ```lua package(\"xxx\") set_policy(\"package.download.http_headers\", \"TEST1: foo\", \"TEST2: bar\") ``` 我们也可以设置指定的 urls 的 http headers： ```lua add_urls(\"https://github.com/madler/zlib/archive/$(version).tar.gz\", { http_headers {\"TEST1: foo\", \"TEST2: bar\"} }) ```"},"/get_started/zh/tutorial/syntax-description.html":{"title":"","content":" class: heading_no_counter # 语法描述 xmake 的工程描述文件 xmake.lua 虽然基于 lua 语法，但是为了使得更加方便简洁得编写项目构建逻辑，xmake 对其进行了一层封装，使得编写 xmake.lua 不会像写 makefile 那样繁琐 基本上写个简单的工程构建描述，只需四行就能搞定，例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` ## 域配置语法 我们默认约定的域配置语法，尽管非常简洁，但是对自动格式化缩进和 IDE 不是很友好。 ```lua target(\"foo\") set_kind(\"binary\") add_files(\"src/*.cpp\") target_end() ``` 另外，它不能自动结束当前 target 作用域，用户需要显式调用 `target_end()`。 虽然，上面我们提到，可以使用 `do end` 模式来解决自动缩进问题，但是需要 `target_end()` 的问题还是存在。 ```lua target(\"bar\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end target_end() ``` 我们提供了一种更好的可选域配置语法，来解决自动缩进，target 域隔离问题，例如： ```lua add_defines(\"ROOT\") target(\"foo\", function () set_kind(\"binary\") add_files(\"src/*.cpp\") add_defines(\"FOO\") end) target(\"bar\", function () set_kind(\"binary\") add_files(\"src/*.cpp\") add_defines(\"BAR\") end) ``` foo 和 bar 两个域是完全隔离的，我们即使在它们中间配置其他设置，也不会影响它们，另外，它还对 LSP 非常友好。 > 因此我们约定，xmake.lua 的域配置语法，默认采用可选的 `function () end` 模式，其他模式后续可能会被移除。 ## 配置分离 xmake.lua 采用二八原则实现了描述域、脚本域两层分离式配置。 什么是二八原则呢，简单来说，大部分项目的配置，80% 的情况下，都是些基础的常规配置，比如：`add_cxflags`, `add_links`等， 只有剩下不到 20% 的地方才需要额外做些复杂来满足一些特殊的配置需求。 而这剩余的 20% 的配置通常比较复杂，如果直接充斥在整个 xmake.lua 里面，会把整个项目的配置整个很混乱，非常不可读。 因此，xmake 通过描述域、脚本域两种不同的配置方式，来隔离 80% 的简单配置以及 20% 的复杂配置，使得整个 xmake.lua 看起来非常的清晰直观，可读性和可维护性都达到最佳。 ### 描述域 对于刚入门的新手用户，或者仅仅是维护一些简单的小项目，通过完全在描述配置就已经完全满足需求了，那什么是描述域呢？它长这样： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") add_syslinks(\"pthread\") end) ``` 一眼望去，其实就是个 `set_xxx`/`add_xxx` 的配置集，对于新手，完全可以不把它当做 lua 脚本，仅仅作为普通的，但有一些基础规则的配置文件就行了。 如果因为，看着有括号，还是像脚本语言的函数调用，那我们也可以这么写（是否带括号看个人喜好）： ```lua target \"test\"     set_kind \"binary\"     add_files \"src/*.c\"     add_defines \"DEBUG\"     add_syslinks \"pthread\" ``` 这是不是看着更像配置文件了？其实描述域就是配置文件，类似像 json 等 key/values 的配置而已，所以即使完全不会 lua 的新手，也是能很快上手的。 而且，对于通常的项目，仅通过 `set_xxx/add_xxx` 去配置各种项目设置，已经完全满足需求了。 这也就是开头说的：80% 的情况下，可以用最简单的配置规则去简化项目的配置，提高可读性和可维护性，这样对用户和开发者都会非常的友好，也更加直观。 如果我们要针对不同平台，架构做一些条件判断怎么办？没关系，描述域除了基础配置，也是支持条件判断，以及 for 循环的： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") if is_plat(\"linux\", \"macosx\") then add_links(\"pthread\", \"m\", \"dl\") end end) ``` ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") for _, name in ipairs({\"pthread\", \"m\", \"dl\"}) do add_links(name) end end) ``` 这是不是看着有点像 lua 了？虽说，平常可以把它当做普通配置问题，但是 xmake 毕竟基于 lua，所以描述域还是支持 lua 的基础语言特性的。 > 不过需要注意的是，描述域虽然支持 lua 的脚本语法，但在描述域尽量不要写太复杂的 lua 脚本，比如一些耗时的函数调用和 for 循环 并且在描述域，主要目的是为了设置配置项，因此 xmake 并没有完全开放所有的模块接口，很多接口在描述域是被禁止调用的， 即使开放出来的一些可调用接口，也是完全只读的，不耗时的安全接口，比如：`os.getenv()` 等读取一些常规的系统信息，用于配置逻辑的控制。 > 另外需要注意一点，xmake.lua 是会被多次解析的，用于在不同阶段解析不同的配置域：比如：`option()`, `target()` 等域。 因此，不要想着在 xmake.lua 的描述域，写复杂的 lua 脚本，也**不要在描述域调用 print 去显示信息，因为会被执行多遍**。 ### 脚本域 限制描述域写复杂的 lua，各种 lua 模块和接口都用不了？怎么办？这个时候就是脚本域出场的时候了。 如果用户已经完全熟悉了 xmake 的描述域配置，并且感觉有些满足不了项目上的一些特殊配置维护了，那么我们可以在脚本域做更加复杂的配置逻辑： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_load(function (target) if is_plat(\"linux\", \"macosx\") then target:add(\"links\", \"pthread\", \"m\", \"dl\") end end) after_build(function (target) import(\"core.project.config\") local targetfile target:targetfile() os.cp(targetfile, path.join(config.buildir(), path.filename(targetfile))) print(\"build %s\", targetfile) end) end) ``` 只要是类似：`on_xxx`, `after_xxx`, `before_xxx` 等字样的 function body 内部的脚本，都属于脚本域。 在脚本域中，用户可以干任何事，xmake 提供了 import 接口可以导入 xmake 内置的各种 lua 模块，也可以导入用户提供的 lua 脚本。 我们可以在脚本域实现你想实现的任意功能，甚至写个独立项目出来都是可以的。 对于一些脚本片段，不是很臃肿的话，像上面这么内置写写就足够了，如果需要实现更加复杂的脚本，不想充斥在一个 xmake.lua 里面，可以把脚本分离到独立的 lua 文件中去维护。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_load(\"modules.test.load\") on_install(\"modules.test.install\") end) ``` 我们可以把自定义的脚本放置到 xmake.lua 对应目录下，`modules/test/load.lua` 和 `modules/test/install.lua` 中独立维护。 这些独立的 lua 脚本里面，我们还可以通过[import](/zh cn/manual/builtin_modules?id import)导入各种内置模块和自定义模块进来使用，就跟平常写lua, java 没啥区别。 而对于脚本的域的不同阶段，`on_load` 主要用于 target 加载时候，做一些动态化的配置（注意这里不像描述域，只会执行一遍）。 其他阶段，还有很多，比如：`on/after/before`_`build/install/package/run` 等，具体看下后面的 target api 手册部分吧，这里就不细说了。 ## 配置类型 在描述域配置中，分配置域和配置项，配置域里面可以通过 `set_xxx`/`add_xxx` 的接口，配置各种配置项。 ```lua target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 像上述配置中，target 就属于配置域，它下面的所有 `set_xx`/`add_xxx` 接口配置都属于配置项，对这个 target 局部生效。 我们可以把它理解成局部作用域，类似 c 里面的 block 块： ``` target(\"test1\") { set_kind(\"binary\") add_files(\"src/*.c\") } target(\"test2\") { set_kind(\"binary\") add_files(\"src/*.c\") } ``` 不过，为了简化写法，xmake 约定每个新定义的 target 域开始，上一个配置域就自动结束了，当然，如果这样用户觉得有困扰，也可以手动配置离开域： ```lua target(\"test1\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() target(\"test2\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() ``` ### 配置域 目前提供的配置域有：`target()`, `option()`, `task()`, `package()` 每个域的详细说明，见：[API手册](/zh cn/manual/project_target) ### 配置项 只要是带有 `set_xxx` 和 `add_xxx` 字样的配置，都属于配置项，一个配置域里面可以设置多个配置项。 关于配置项的规范说明，见：[接口规范](/zh cn/manual/specification) ## 作用域 xmake 的描述语法是按作用域划分的，主要分为： 外部作用域 内部作用域 接口作用域 那哪些属于外部，哪些又属于内部呢，看看下面的注释，就知道个大概了： ```lua 外部作用域 target(\"test\", function() 外部作用域 set_kind(\"binary\") add_files(\"src/*.c\") on_run(function () 内部作用域 end) after_package(function () 内部作用域 end) end) 外部作用域 task(\"hello\", function() 外部作用域 on_run(function () 内部作用域 end) end) ``` 简单的说，就是在自定义脚本 `function () end` 之内的都属于内部作用域，也就是脚本作用域，其他地方都是都属于于外部作用域。。 ### 外部作用域 对于大部分工程来说，并不需要很复杂的工程描述，也不需要自定义脚本支持，只需要简单的 `set_xxx` 或者 `add_xxx` 就能满足需求了 那么根据二八定律，80% 的情况下，我们只需要这么写： ```lua target(\"test\", function() set_kind(\"static\") add_files(\"src/test/*.c\") end) target(\"demo\", function() add_deps(\"test\") set_kind(\"binary\") add_links(\"test\") add_files(\"src/demo/*.c\") end) ``` 不需要复杂的 api 调用，也不需要各种繁琐的变量定义，以及 if 判断 和 for 循环，要的就是简洁可读，一眼看过去，就算不懂 lua 语法也没关系 就当做简单的描述语法，看上去有点像函数调用而已，会点编程的基本一看就知道怎么配置。 为了做到简洁、安全，在这个作用域内，很多 lua 内置 api 是不开放出来的，尤其是跟写文件、修改操作环境相关的，仅仅提供一些基本的只读接口，和逻辑操作 目前外部作用域开放的 lua 内置 api 有： table string pairs ipairs print os 当然虽然内置 lua api 提供不多，但 xmake 还提供了很多扩展 api，像描述 api 就不多说，详细可参考：[API手册](/zh cn/manual/builtin_modules) 还有些辅助 api，例如： dirs：扫描获取当前指定路径中的所有目录 files：扫描获取当前指定路径中的所有文件 format: 格式化字符串，string.format 的简写版本 还有变量定义、逻辑操作也是可以使用的，毕竟是基于 lua 的，该有的基础语法，还是要有的，我们可以通过 if 来切换编译文件： ```lua target(\"test\", function() set_kind(\"static\") if is_plat(\"iphoneos\") then add_files(\"src/test/ios/*.c\") else add_files(\"src/test/*.c\") end end) ``` 需要注意的是，变量定义分全局变量和局部变量，局部变量只对当前 xmake.lua 有效，不影响子 xmake.lua ```lua 局部变量，只对当前xmake.lua有效 local var1 0 全局变量，影响所有之后 includes() 包含的子 xmake.lua var2 1 includes(\"src\") ``` ### 内部作用域 也称插件、脚本作用域，提供更加复杂、灵活的脚本支持，一般用于编写一些自定义脚本、插件开发、自定义 task 任务、自定义模块等等 一般通过 `function () end` 包含，并且被传入到 `on_xxx`, `before_xxx` 和 `after_xxx` 接口内的，都属于自作用域。 例如： ```lua 自定义脚本 target(\"hello\", function() after_build(function () 内部作用域 end) end) 自定义任务、插件 task(\"hello\", function() on_run(function () 内部作用域 end) end) ``` 在此作用域中，不仅可以使用大部分 lua 的 api，还可以使用很多 xmake 提供的扩展模块，所有扩展模块，通过 import 来导入 具体可参考：[import模块导入文档](/zh cn/manual/builtin_modules?id import) 这里我们给个简单的例子，在编译完成后，对 ios 目标程序进行 ldid 签名： ```lua target(\"iosdemo\", function() set_kind(\"binary\") add_files(\"*.m\") after_build(function (target) 执行签名，如果失败，自动中断，给出高亮错误信息 os.run(\"ldid S$(projectdir)/entitlements.plist %s\", target:targetfile()) end) end) ``` 需要注意的是，在内部作用域中，所有的调用都是启用异常捕获机制的，如果运行出错，会自动中断 xmake，并给出错误提示信息 因此，脚本写起来，不需要繁琐的 `if retval then` 判断，脚本逻辑更加一目了然 ### 接口作用域 在外部作用域中的所有描述api设置，本身也是有作用域之分的，在不同地方调用，影响范围也不相同，例如： ```lua 全局根作用域，影响所有 target，包括 includes() 中的子工程 target 设置 add_defines(\"DEBUG\") 定义或者进入 demo 目标作用域（支持多次进入来追加设置） target(\"demo\", function() set_kind(\"shared\") add_files(\"src/*.c\") 当前 target 作用域，仅仅影响当前 target add_defines(\"DEBUG2\") end) 选项设置，仅支持局部设置，不受全局 api 设置所影响 option(\"test\", function() 当前选项的局部作用域 set_default(false) end) 其他target设置， DDEBUG 也会被设置上 target(\"demo2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) 重新进入demo目标作用域 target(\"demo\", function() 追加宏定义，只对当前demo目标有效 add_defines(\"DEBUG3\") end) ``` 通常情况下，进入另一个 target/option 域设置，会自动离开上个 target/option 域，但是有时候为了比较一些作用域污染情况，我们可以显示离开某个域，例如： ```lua option(\"test\") set_default(false) option_end() target(\"demo\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() ``` 调用 `option_end()`, `target_end()` 即可显式的离开当前 target/option 域设置。 ### 代码格式化 由于默认的描述域配置语法的缩进并不符合 lua 格式规范，因此 lua language server 是不支持对它进行格式化处理的。 如果想要让 IDE，编辑器更好的对配置进行格式化缩进支持，我么可以通过 `do end` 的写法来处理： ```lua target(\"bar\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end target(\"foo\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end ``` 这样，Lua LSP 就能把它作为标准的 lua 代码进行正确的格式化，是否需要这么做，看用户自己的需求。 如果没有代码自动格式化的使用习惯，那就不需要这么做。 ## 多级配置 在脚本域我们可以通过 import 导入各种丰富的扩展模块来使用，而在描述域我们可以通过[includes](/#/zh cn/manual/global_interfaces?id includes)接口，来引入项目子目录下的 xmake.lua 配置。 记住：xmake 的 includes 是按照 tree 结构来处理配置关系的，子目录下的 xmake.lua 里面的 target 配置会继承父 xmake.lua 中的根域配置，例如： 目前有如下项目结构： ``` projectdir xmake.lua src xmake.lua ``` `projectdir/xmake.lua` 是项目的根 xmake.lua 配置，而 `src/xmake.lua` 是项目的子配置。 `projectdir/xmake.lua` 内容： ```lua add_defines(\"ROOT\") target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST1\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST2\") end) includes(\"src\") ``` 里面全局根域配置了 `add_defines(\"ROOT\")`，会影响下面的所有 target 配置，包括 includes 里面子 xmake.lua 中的所有 target 配置，所以这个是全局总配置。 而在 test1/test2 里面的 `add_defines(\"TEST1\")` 和 `add_defines(\"TEST2\")` 属于局部配置，只对当前 target 生效。 `src/xmake.lua` 内容： ```lua add_defines(\"ROOT2\") target(\"test3\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST3\") end) ``` 在 `src/xmake.lua` 子配置中，也有个全局根域，配置了 `add_defines(\"ROOT2\")`，这个属于子配置根域，只对当前子 xmake.lua 里面所有 target 生效，也会对下级 includes 里面的子 xmake.lua 中 target 生效，因为之前说了，xmake 是 tree 状结构的配置继承关系。 所以，这几个 target 的最终配置结果依次是： ``` target(\"test1\"): DROOT DTEST1 target(\"test2\"): DROOT DTEST2 target(\"test3\"): DROOT DROOT2 DTEST3 ``` ## 语法简化 xmake.lua 的配置域语法，非常灵活，可以在相关域做各种复杂灵活的配置，但是对于许多精简的小块配置，这个时候就稍显冗余了： ```lua option(\"test1\", function() set_default(true) set_showmenu(true) set_description(\"test1 option\") end) option(\"test2\", function() set_default(true) set_showmeu(true) end) option(\"test3\", function() set_default(\"hello\") end) ``` 对于上面的这些小块 option 域设置，我们可以简化下成单行描述： ```lua option(\"test1\", {default true, showmenu true, description \"test1 option\"}) option(\"test2\", {default true, showmenu true}) option(\"test3\", {default \"hello\"}) ``` 除了 option 域，对于其他域也是支持这种简化写法的，例如： ```lua target(\"demo\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 简化为： ```lua target(\"demo\", {kind \"binary\", files \"src/*.c\"}) ``` 或者 ```lua target(\"demo\", { kind \"binary\", files \"src/*.c\" }) ``` 当然，如果配置需求比较复杂的，还是原有的多行设置方式更加方便，这个就看自己的需求来评估到底使用哪种方式了。"},"/get_started/zh/tutorial/configuration.html":{"title":"","content":" class: heading_no_counter # 配置说明 通过 `xmake fconfig` 配置命令，设置构建前的相关配置信息，详细参数选项，请运行: `xmake f help`。 > **Tips**: > 你可以使用命令行缩写来简化输入，也可以使用全名，例如: > > * `xmake f` 或者 `xmake config` > * `xmake f p linux` 或者 `xmake config plat linux` ## 目标平台 ### 主机平台 ```bash $ xmake ``` > xmake将会自动探测当前主机平台，默认自动生成对应的目标程序。 ### Linux ```bash $ xmake f p linux [ a i386x86_64] $ xmake ``` ### Android ```bash $ xmake f p android ndk ~/files/android ndk r10e/ [ a armeabi v7aarm64 v8a] $ xmake ``` 如果要手动指定 ndk 中具体某个工具链，而不是使用默认检测的配置，可以通过[ bin](# bin)来设置，例如： ```bash $ xmake f p android ndk ~/files/android ndk r10e/ a arm64 v8a bin ~/files/android ndk r10e/toolchains/aarch64 linux android 4.9/prebuilt/darwin x86_64/bin ``` [ bin](# bin)主要用于设置选择编译工具的具体 bin 目录，这个的使用跟[交叉编译](#交叉编译配置)中的[ bin](# bin)的行为是一致的。 > 如果手动设置了 bin 目录，没有通过检测，可以看下是否 ` arch ` 参数没有匹配对。 ### iPhoneOS ```bash $ xmake f p iphoneos [ a armv7armv7sarm64i386x86_64] $ xmake ``` 由于 m1 设备上模拟器也支持 arm64 架构，因此之前单纯从 arch 去区分是否为模拟器，已无法满足需求。 因此我们新增了一个参数配置去区分是否为模拟器目标。 ```bash $ xmake f p iphoneos appledev simulator $ xmake f p watchos appledev simulator $ xmake f p appletvos appledev simulator ``` ### Mac Catalyst 我们也可以指定构建 Mac Catalyst 程序。 ```bash $ xmake f appledev catalyst ``` ### Apple WatchOS ```bash $ xmake f p watchos [ a i386armv7k] $ xmake ``` ### Wasm (WebAssembly) 此平台用于编译 WebAssembly 程序（内部会使用 emcc 工具链），在切换此平台之前，我们需要先进入 Emscripten 工具链环境，确保 emcc 等编译器可用。 ```bash $ xmake f p wasm $ xmake ``` xmake 也支持 Qt for wasm 编译，只需要： ```bash $ xmake f p wasm [ qt ~/Qt] $ xmake ``` 其中 ` qt` 参数设置是可选的，通常 xmake 都能检测到 qt 的 sdk 路径。 需要注意的一点是，Emscripten 和 Qt SDK 的版本是有对应关系的，不匹配的版本，可能会有 Qt/Wasm 之间的兼容问题。 关于版本对应关系，可以看下：[https://wiki.qt.io/Qt_for_WebAssembly](https://wiki.qt.io/Qt_for_WebAssembly) 更多详情见：[https://github.com/xmake io/xmake/issues/956](https://github.com/xmake io/xmake/issues/956) 除了 emscripten 以外，还有一个常用的 wasm 工具链 wasi sdk，用于构建基于 wasi 的程序，我们仅仅只需要切换工具链即可。 ```bash $ xmake f p wasm toolchain wasi $ xmake ``` ### HarmonyOS (鸿蒙) xmake 也提供了鸿蒙 OS 平台的 native 工具链编译支持： ```bash $ xmake f p harmony ``` xmake 会自动探测默认的 SDK 路径，当然我们也可以指定 Harmony SDK 路径。 ```bash $ xmake f p Harmony sdk /Users/ruki/Library/Huawei/Sdk/openharmony/10/native ``` ## 交叉编译配置 通常，如果我们需要在当前 pc 环境编译生成其他设备上才能运行的目标文件时候，就需要通过对应的交叉编译工具链来编译生成它们，比如在 macos 上编译 linux 的程序，或者在 linux 上编译其他嵌入式设备的目标文件等。 通常的交叉编译工具链都是基于 gcc/clang 的，大都具有类似如下的结构： ``` /home/toolchains_sdkdir bin arm linux armeabi gcc arm linux armeabi ld ... lib libxxx.a include xxx.h ``` 每个工具链都有对应的 include/lib 目录，用于放置一些系统库和头文件，例如 libc, stdc++ 等，而 bin 目录下放置的就是编译工具链一系列工具。例如： ``` arm linux armeabi ar arm linux armeabi as arm linux armeabi c++ arm linux armeabi cpp arm linux armeabi g++ arm linux armeabi gcc arm linux armeabi ld arm linux armeabi nm arm linux armeabi strip ``` 其中 `arm linux armeabi ` 前缀就是 cross，通过用来标示目标平台和架构，主要用于跟主机自身的 gcc/clang 进行区分。 里面的 gcc/g++ 就是 c/c++ 的编译器，通常也可以作为链接器使用，链接的时候内部会去调用 ld 来链接，并且自动追加一些 c++ 库。 cpp 是预处理器，as 是汇编器，ar 用于生成静态库，strip 用于裁剪掉一些符号信息，使得目标程序会更加的小。nm 用于查看导出符号列表。 ### 自动探测和编译 如果我们的交叉编译工具链是上文的结构，xmake 会自动检测识别这个 sdk 的结构，提取里面的 cross，以及 include/lib 路径位置，用户通常不需要做额外的参数设置，只需要配置好 sdk 根目录就可以编译了，例如： ```bash $ xmake f p cross sdk /home/toolchains_sdkdir $ xmake ``` 其中，` p cross` 用于指定当前的平台是交叉编译平台，` sdk ` 用于指定交叉工具链的根目录。 > 注：我们也可以指定 ` p linux` 平台来配置交叉编译，效果是一样的，唯一的区别是额外标识了 linux 平台名，方便 xmake.lua 里面通过 `is_plat(\"linux\")` 来判断平台。 这个时候，xmake 会去自动探测 gcc 等编译器的前缀名 cross：`arm linux armeabi `，并且编译的时候，也会自动加上**链接库**和**头文件**的搜索选项，例如： ``` I/home/toolchains_sdkdir/include L/home/toolchains_sdkdir/lib ``` 这些都是 xmake 自动处理的，不需要手动配置他们。 ### 手动配置编译 如果上面的自动检测对某些工具链，还无法完全通过编译，就需要用户自己手动设置一些交叉编译相关的配置参数，来调整适应这些特殊的工具链了，下面我会逐一讲解如何配置。 ### 设置工具链 bin 目录 对于不规则工具链目录结构，靠单纯地[ sdk](# sdk)选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的 bin 目录位置。 例如：一些特殊的交叉工具链的，编译器bin目录，并不在 `/home/toolchains_sdkdir/bin` 这个位置，而是独立到了 `/usr/opt/bin`。 这个时候，我们可以在设置了 sdk 参数的基础上追加 bin 目录的参数设置，来调整工具链的 bin 目录。 ```bash $ xmake f p cross sdk /home/toolchains_sdkdir bin /usr/opt/bin $ xmake ``` ### 设置交叉工具链工具前缀 像 `aarch64 linux android ` 这种，通常如果你配置了` sdk` 或者 ` bin` 的情况下，xmake 会去自动检测的，不需要自己手动设置。 但是对于一些极特殊的工具链，一个目录下同时有多个 cross 前缀的工具 bin 混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个 bin。 例如，toolchains 的 bin 目录下同时存在两个不同的编译器： ``` /opt/bin armv7 linux gcc aarch64 linux gcc ``` 我们现在想要选用 armv7 的版本，那么我们可以追加 ` cross ` 配置编译工具前缀名，例如： ```bash $ xmake f p cross sdk /usr/toolsdk bin /opt/bin cross armv7 linux ``` ### 设置 c/c++ 编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p cross sdk /user/toolsdk cc armv7 linux clang cxx armv7 linux clang++ ``` 当然，我们也可以指定编译器全路径。 ` cc` 用于指定 c 编译器名，` cxx` 用于指定 c++ 编译器名。 > 注：如果存在 CC/CXX 环境变量的话，会优先使用当前环境变量中指定的值。 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 这个时候我们可以通过： ```bash xmake f cxx clang++@/home/xxx/c++mips.exe ``` 设置 c++mips.exe 编译器作为类 clang++ 的使用方式来编译。 也就是说，在指定编译器为 `c++mips.exe` 的同时，告诉 xmake，它跟 clang++ 用法和参数选项基本相同。 ### 设置 c/c++ 链接器 如果还要继续细分选择链接器，则继续追加相关链接器选项，例如： ```bash $ xmake f p cross sdk /user/toolsdk ld armv7 linux clang++ sh armv7 linux clang++ ar armv7 linux ar ``` ld 指定可执行程序链接器，sh 指定共享库程序链接器，ar 指定生成静态库的归档器。 注：如果存在 LD/SH/AR 环境变量的话，会优先使用当前环境变量中指定的值。 ### 设置头文件和库搜索目录 如果 sdk 里面还有额外的其他 include/lib 目录不在标准的结构中，导致交叉编译找不到库和头文件，那么我们可以通过 ` includedirs` 和 ` linkdirs` 来追加搜索路径，然后通过 ` links` 添加额外的链接库。 ```bash $ xmake f p cross sdk /usr/toolsdk includedirs /usr/toolsdk/xxx/include linkdirs /usr/toolsdk/xxx/lib links pthread ``` > 注：如果要指定多个搜索目录，可以通过 `:` 或者 `;` 来分割，也就是不同主机平台的路径分隔符，linux/macos下用`:`，win下用`;`。 ### 设置编译和链接选项 我们也可以根据实际情况通过 ` cflags`, ` cxxflags`，` ldflags`，` shflags` 和 ` arflags` 额外配置一些编译和链接选项。 * cflags: 指定c编译参数 * cxxflags：指定c++编译参数 * cxflags: 指定c/c++编译参数 * asflags: 指定汇编器编译参数 * ldflags: 指定可执行程序链接参数 * shflags: 指定动态库程序链接参数 * arflags: 指定静态库的生成参数 例如： ```bash $ xmake f p cross sdk /usr/toolsdk cflags \" DTEST I/xxx/xxx\" ldflags \" lpthread\" ``` ### 项目描述设置 #### set_toolchains 这对某个特定的 target 单独切换设置不同的工具链，和 set_toolset 不同的是，此接口是对完整工具链的整体切换，比如 cc/ld/sh 等一系列工具集。 这也是推荐做法，因为像 gcc/clang 等大部分编译工具链，编译器和链接器都是配套使用的，要切就得整体切，单独零散的切换设置会很繁琐。 比如我们切换 test 目标到 clang+yasm 两个工具链： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"clang\", \"yasm\") end) ``` #### set_toolset 如果觉得每次通过命令行配置比较繁琐，有些配置可以通过在 xmake.lua 预先配置好，来简化命令配置，比如编译器的指定，就可以通过 `set_toolset` 来对每个 target 单独设置。 ```lua target(\"test\", function() set_kind(\"binary\") set_toolset(\"cxx\", \"clang\") set_toolset(\"ld\", \"clang++\") end) ``` 强制 test 目标的编译器和链接器使用 clang 编译器，或者指定交叉编译工具链中的编译器名或者路径。 #### set_config 我们也可以通过 `set_config` 来设置在 `xmake f/config` 命令中的每个配置参数的默认值，这是个全局 api，对每个 target 都会生效。 ```lua set_config(\"cflags\", \" DTEST\") set_config(\"sdk\", \"/home/xxx/tooksdk\") set_config(\"cc\", \"gcc\") set_config(\"ld\", \"g++\") ``` 不过，我们还是可以通过 `xmake f name value` 的方式，去修改 xmake.lua 中的默认配置。 ### 自定义编译平台 如果某个交叉工具链编译后目标程序有对应的平台需要指定，并且需要在 xmake.lua 里面根据不同的交叉编译平台，还需要配置一些额外的编译参数，那么上文的 ` p cross` 设置就不能满足需求了。 其实，` p/ plat ` 参数也可以设置为其他自定义的值，只需要跟 `is_plat` 保持对应关系就可以，所有非内置平台名，都会默认采用交叉编译模式，例如： ```bash $ xmake f p myplat sdk /usr/local/arm xxx gcc/ $ xmake ``` 我们传入了 myplat 自定义平台名，作为当前交叉工具链的编译平台，然后 xmake.lua 里面我们对这个平台，配置下对应的设置： ```lua if is_plat(\"myplat\") then add_defines(\"TEST\") end ``` 通过这种方式，xmake 就可以很方便的扩展处理各种编译平台，用户可以自己扩展支持 freebsd, netbsd, sunos 等其他各种平台的交叉编译。 我摘录一段之前移植 libuv 写的交叉编译的配置，直观感受下： ```lua for dragonfly/freebsd/netbsd/openbsd platform if is_plat(\"dragonfly\", \"freebsd\", \"netbsd\", \"openbsd\") then add_files(\"src/unix/bsd ifaddrs.c\") add_files(\"src/unix/freebsd.c\") add_files(\"src/unix/kqueue.c\") add_files(\"src/unix/posix hrtime.c\") add_headerfiles(\"(include/uv bsd.h)\") end for sunos platform if is_plat(\"sunos\") then add_files(\"src/unix/no proctitle.c\") add_files(\"src/unix/sunos.c\") add_defines(\"__EXTENSIONS_\", \"_XOPEN_SOURCE 600\") add_headerfiles(\"(include/uv sunos.h)\") end ``` 然后，我们就可以切换这些平台来编译： ```bash $ xmake f p [dragonflyfreebsdnetbsdopenbsdsunos] sdk /home/arm xxx gcc/ $ xmake ``` 另外，内置的 linux 平台也是支持交叉编译的，如果不想配置其他平台名，统一作为 linux 平台来交叉编译，也是可以的。 ```bash $ xmake f p linux sdk /usr/local/arm xxx gcc/ $ xmake ``` 只要设置了 ` sdk ` 等参数，就会启用linux平台的交叉编译模式。 ### 常用工具链配置 完整的工具链列表，请执行下面的命令查看： ```bash $ xmake show l toolchains ``` 上文讲述的是通用的交叉编译工具链配置，如果一些特定的工具链需要额外传入 ` ldflags/ includedirs` 等场景就比较繁琐了, 因此 xmake 也内置了一些常用工具链，可以省去交叉编译工具链复杂的配置过程，只需要执行： ```bash $ xmake f toolchain gnu rm sdk /xxx/ $ xmake ``` 就可以快速切换的指定的交叉编译工具链，如果这个工具链需要追加一些特定的 flags 设置，也会自动设置好，简化配置。 其中，gnu rm 就是内置的 GNU Arm Embedded Toolchain。 比如，我们也可以快速从 gcc 工具链整体切换到 clang 或者 llvm 工具链，不再需要 `xmake f cc clang cxx clang ld clang++` 等挨个配置了。 ```bash $ xmake f toolchain clang $ xmake ``` 或者 ```bash $ xmake f toolchain llvm sdk /xxx/llvm $ xmake ``` 具体 xmake 持哪些工具链，可以通过下面的命令查看： ```bash $ xmake show l toolchains xcode Xcode IDE vs VisualStudio IDE yasm The Yasm Modular Assembler clang A C language family frontend for LLVM go Go Programming Language Compiler dlang D Programming Language Compiler sdcc Small Device C Compiler cuda CUDA Toolkit ndk Android NDK rust Rust Programming Language Compiler llvm A collection of modular and reusable compiler and toolchain technologies cross Common cross compilation toolchain nasm NASM Assembler gcc GNU Compiler Collection mingw Minimalist GNU for Windows gnu rm GNU Arm Embedded Toolchain envs Environment variables toolchain fasm Flat Assembler ``` #### 自定义工具链 另外，我们也可以在 xmake.lua 中自定义 toolchain，然后通过 `xmake f toolchain myclang` 指定切换，例如： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") ... end) ``` 关于这块的详情介绍，可以到[自定义工具链](/zh cn/manual/custom_toolchain)章节查看 更多详情见：[#780](https://github.com/xmake io/xmake/issues/780) #### LLVM 工具链 llvm 工具链下载地址：<https://releases.llvm.org/> ```bash $ xmake f p cross toolchain llvm sdk \"C:\\Program Files\\LLVM\" $ xmake ``` #### GNU RM 工具链 工具链地址：<https://developer.arm.com/tools and software/open source software/developer tools/gnu toolchain/gnu rm/downloads#> ```bash $ xmake f p cross toolchain gnu rm sdk /xxx/cc arm none eabi 9 2019 q4 major $ xmake ``` #### TinyC 工具链 ```bash $ xmake f toolchain tinyc $ xmake ``` > Releases 目录下，我们还提供了特殊的 xmake tinyc vX.X.X.win32.exe 安装包，内置 tinyc 工具链，无需依赖 msvc，也可以编译 c 代码，开箱即用无依赖。 #### Emcc 工具链 通常只需要切换到 Wasm 平台，里面内置了 emcc 工具链，还会额外调整目标程序的扩展名为 `*.html` 以及输出 `*.wasm`。 ```bash $ xmake f p wasm $ xmake ``` 不过我们也能够直接切换到 emcc 工具链，但是后缀名不会被修改。 ```bash $ xmake f toolchain emcc $ xmake ``` #### Intel C++ 编译工具链 ```bash $ xmake f toolchain icc $ xmake ``` #### Intel Fortran 编译工具链 ```bash $ xmake f toolchain ifort $ xmake ``` ### 通用交叉编译配置 参数名 描述 [ sdk](# sdk) 设置交叉工具链的sdk根目录 [ bin](# bin) 设置工具链bin目录 [ cross](# cross) 设置交叉工具链工具前缀 [ as](# as) 设置`asm`汇编器 [ cc](# cc) 设置`c`编译器 [ cxx](# cxx) 设置`c++`编译器 [ mm](# mm) 设置`objc`编译器 [ mxx](# mxx) 设置`objc++`编译器 [ sc](# sc) 设置`swift`编译器 [ gc](# gc) 设置`golang`编译器 [ dc](# dc) 设置`dlang`编译器 [ rc](# rc) 设置`rust`编译器 [ cu](# cu) 设置`cuda`编译器 [ ld](# ld) 设置`c/c++/objc/asm`链接器 [ sh](# sh) 设置`c/c++/objc/asm`共享库链接器 [ ar](# ar) 设置`c/c++/objc/asm`静态库归档器 [ scld](# scld) 设置`swift`链接器 [ scsh](# scsh) 设置`swift`共享库链接器 [ gcld](# gcld) 设置`golang`链接器 [ gcar](# gcar) 设置`golang`静态库归档器 [ dcld](# dcld) 设置`dlang`链接器 [ dcsh](# dcsh) 设置`dlang`共享库链接器 [ dcar](# dcar) 设置`dlang`静态库归档器 [ rcld](# rcld) 设置`rust`链接器 [ rcsh](# rcsh) 设置`rust`共享库链接器 [ rcar](# rcar) 设置`rust`静态库归档器 [ cu ccbin](# cu ccbin) 设置`cuda` host编译器 [ culd](# culd) 设置`cuda`链接器 [ asflags](# asflags) 设置`asm`汇编编译选项 [ cflags](# cflags) 设置`c`编译选项 [ cxflags](# cxflags) 设置`c/c++`编译选项 [ cxxflags](# cxxflags) 设置`c++`编译选项 [ mflags](# mflags) 设置`objc`编译选项 [ mxflags](# mxflags) 设置`objc/c++`编译选项 [ mxxflags](# mxxflags) 设置`objc++`编译选项 [ scflags](# scflags) 设置`swift`编译选项 [ gcflags](# gcflags) 设置`golang`编译选项 [ dcflags](# dcflags) 设置`dlang`编译选项 [ rcflags](# rcflags) 设置`rust`编译选项 [ cuflags](# cuflags) 设置`cuda`编译选项 [ ldflags](# ldflags) 设置链接选项 [ shflags](# shflags) 设置共享库链接选项 [ arflags](# arflags) 设置静态库归档选项 > 如果你想要了解更多参数选项，请运行: `xmake f help`。 #### sdk * 设置交叉工具链的sdk根目录 大部分情况下，都不需要配置很复杂的 toolchains 前缀，例如：`arm linux ` 什么的 只要这个工具链的 sdk 目录满足如下结构（大部分的交叉工具链都是这个结构）： ``` /home/toolchains_sdkdir bin arm linux gcc arm linux ld ... lib libxxx.a include xxx.h ``` 那么，使用 xmake 进行交叉编译的时候，只需要进行如下配置和编译： ```bash $ xmake f p linux sdk /home/toolchains_sdkdir $ xmake ``` 这个时候，xmake 会去自动探测，gcc 等编译器的前缀名：`arm linux `，并且编译的时候，也会自动加上**链接库**和**头文件**的搜索选项，例如： ``` I/home/toolchains_sdkdir/include L/home/toolchains_sdkdir/lib ``` 这些都是xmake自动处理的，不需要手动配置他们。。 #### bin * 设置工具链bin目录 对于不规则工具链目录结构，靠单纯地[ sdk]( sdk)选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的 bin 目录位置。 例如：一些特殊的交叉工具链的，编译器 bin 目录，并不在 `/home/toolchains_sdkdir/bin` 这个位置，而是独立到了 `/usr/opt/bin`。 ```bash $ xmake f p linux sdk /home/toolchains_sdkdir bin /usr/opt/bin $ xmake ``` #### cross * 设置交叉工具链工具前缀 像 `aarch64 linux android ` 这种，通常如果你配置了[ sdk](# sdk)或者[ bin](# bin)的情况下，xmake 会去自动检测的，不需要自己手动设置。 但是对于一些极特殊的工具链，一个目录下同时有多个 cross 前缀的工具 bin 混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个 bin。 例如，toolchains 的 bin 目录下同时存在两个不同的编译器： ``` /opt/bin armv7 linux gcc aarch64 linux gcc ``` 我们现在想要选用 armv7 的版本，则配置如下： ```bash $ xmake f p linux sdk /usr/toolsdk bin /opt/bin cross armv7 linux ``` #### as * 设置 `asm` 汇编器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk as armv7 linux as ``` 如果存在 `AS` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f as gcc@/home/xxx/asmips.exe` 设置ccmips.exe编译器作为类 gcc 的使用方式来编译。 > 也就是说，在指定编译器为 `asmips.exe` 的同时，告诉 xmake，它跟 gcc 用法和参数选项基本相同。 #### cc * 设置c编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk cc armv7 linux clang ``` 如果存在 `CC` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f cc gcc@/home/xxx/ccmips.exe` 设置 ccmips.exe 编译器作为类 gcc 的使用方式来编译。 > 也就是说，在指定编译器为 `ccmips.exe` 的同时，告诉 xmake，它跟 gcc 用法和参数选项基本相同。 #### cxx * 设置 `c++` 编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk cxx armv7 linux clang++ ``` 如果存在 `CXX` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f cxx clang++@/home/xxx/c++mips.exe` 设置 c++mips.exe 编译器作为类 clang++ 的使用方式来编译。 > 也就是说，在指定编译器为 `c++mips.exe` 的同时，告诉 xmake，它跟 clang++ 用法和参数选项基本相同。 #### ld * 设置 `c/c++/objc/asm` 链接器 如果还要继续细分选择链接器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk ld armv7 linux clang++ ``` 如果存在 `LD` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么链接器工具检测就会失败。 > 这个时候我们可以通过：`xmake f ld g++@/home/xxx/c++mips.exe` 设置 c++mips.exe 链接器作为类 g++ 的使用方式来编译。 > 也就是说，在指定链接器为 `c++mips.exe` 的同时，告诉 xmake，它跟 g++ 用法和参数选项基本相同。 #### sh * 设置 `c/c++/objc/asm` 共享库链接器 ```bash $ xmake f p linux sdk /user/toolsdk sh armv7 linux clang++ ``` 如果存在 `SH` 环境变量的话，会优先使用当前环境变量中指定的值。 #### ar * 设置 `c/c++/objc/asm` 静态库归档器 ```bash $ xmake f p linux sdk /user/toolsdk ar armv7 linux ar ``` 如果存在`AR`环境变量的话，会优先使用当前环境变量中指定的值。 ## 全局配置 我们也可以将一些常用配置保存到全局配置中，来简化频繁地输入： 例如: ```bash $ xmake g ndk ~/files/android ndk r10e/ ``` 现在，我们重新配置和编译 `android` 程序： ```bash $ xmake f p android $ xmake ``` 以后，就不需要每次重复配置 ` ndk 参数了。 > 每个命令都有其简写，例如: `xmake g` 或者 `xmake global`。 ## 清除配置 有时候，配置出了问题编译不过，或者需要重新检测各种依赖库和接口，可以加上 ` c` 参数，清除缓存的配置，强制重新检测和配置： ```bash $ xmake f c $ xmake ``` 或者： ```bash $ xmake f p iphoneos c $ xmake ``` ## 导入导出配置 我们还可以导入导出已经配置好的配置集，方便配置的快速迁移。 ### 导出配置 ```bash $ xmake f export /tmp/config.txt $ xmake f m debug xxx y export /tmp/config.txt ``` ### 导入配置 ```bash $ xmake f import /tmp/config.txt $ xmake f m debug xxx y import /tmp/config.txt ``` ### 导出配置（带菜单） ```bash $ xmake f menu export /tmp/config.txt $ xmake f menu m debug xxx y export /tmp/config.txt ``` ### 导入配置（带菜单） ```bash $ xmake f menu import /tmp/config.txt $ xmake f menu m debug xxx y import /tmp/config.txt ```"},"/get_started/zh/tutorial/environment-variables.html":{"title":"","content":" class: heading_no_counter # 环境变量 我们可以执行下面的命令，获取所有 xmake 用到的环境变量，以及当前被设置的值。 ```bash $ xmake show l envs XMAKE_RAMDIR Set the ramdisk directory. <empty> XMAKE_GLOBALDIR Set the global config directory of xmake. /Users/ruki/.xmake XMAKE_ROOT Allow xmake to run under root. <empty> XMAKE_COLORTERM Set the color terminal environment. <empty> XMAKE_PKG_INSTALLDIR Set the install directory of packages. <empty> XMAKE_TMPDIR Set the temporary directory. /var/folders/vn/ppcrrcm911v8b4510klg9xw80000gn/T/.xmake501/211104 XMAKE_PKG_CACHEDIR Set the cache directory of packages. <empty> XMAKE_PROGRAM_DIR Set the program scripts directory of xmake. /Users/ruki/.local/share/xmake XMAKE_PROFILE Start profiler, e.g. perf, trace. <empty> XMAKE_RCFILES Set the runtime configuration files. XMAKE_CONFIGDIR Set the local config directory of project. /Users/ruki/projects/personal/xmake docs/.xmake/macosx/x86_64 XMAKE_LOGFILE Set the log output file path. <empty> ``` ## XMAKE_RAMDIR 设置 ramdisk 目录路径 ramdisk 目录是内存文件系统的目录位置，通常 `os.tmpdir()` 接口会用到，xmake 内部使用的临时文件，如果用户设置 ramdisk 路径，则会优先存储在这个上面，提升整体编译速度。 ## XMAKE_TMPDIR 设置用户的临时目录 默认 xmake 会使用 `/tmp/.xmake`，当然用户可以通过这个变量去修改默认路径。 ## XMAKE_CONFIGDIR 设置本地工程配置目录 每个项目的本地编译配置，默认会存储在当前项目根目录的 `.xmake` 路径下，然后根据不同的平台，架构区分，例如： ```bash .xmake/macosx/x86_64 ``` 我们如果不想存储在项目根目录，也可以自己设置到其他路径，比如 build 目录下等等。 ## XMAKE_GLOBALDIR 设置全局配置文件根目录 也就是 `xmake g/global` 全局配置的存储目录，还有安装包，缓存等其他全局文件，默认都会存储在这个目录下。 默认路径为：`~/.xmake`。 ## XMAKE_ROOT 允许用户在 root 模式下运行 通常 xmake 是默认禁止在 root 下运行，这非常不安全。但是如果用户非要在 root 下运行，也可以设置这个变量，强制开启。 ```bash export XMAKE_ROOT y ``` ## XMAKE_COLORTERM 设置 Terminal 的色彩输出 目前可以设置这几个值： 值 描述 nocolor 禁用彩色输出 color8 8 色输出支持 color256 256 色输出支持 truecolor 真彩色输出支持 通常，用户不需要设置它们，xmake 会自动探测用户终端支持的色彩范围，如果用户不想输出色彩，可以设置 nocolor 来全局禁用。 或者用 `xmake g theme plain` 也可以全局禁用。 ## XMAKE_PKG_INSTALLDIR 设置依赖包的安装根目录 xmake 的远程包安装的全局目录默认是 `~/.xmake/packages`，但是用户也可以设置这个变量，去单独修改它。 我们也可以使用 `xmake g pkg_installdir /xxx` 去设置它，效果是一样的。 ## XMAKE_PKG_CACHEDIR 设置依赖包的缓存目录 默认路径在 `~/.xmake/cache` 目录，存储包安装过程中的各种缓存文件，比较占存储空间，用户也可以单独设置它。 当然，xmake 在每个月都会自动清理上个月的所有缓存文件。 ## XMAKE_PROGRAM_DIR 设置 xmake 的脚本目录 xmake 的所有 lua 脚本随安装程序一起安装，默认都在安装目录下，但是如果想要切到自己下载的脚本目录下，方便本地修改调试，可以设置此变量。 如果要查看当前 xmake 在使用的脚本目录，可以执行： ```bash $ xmake l os.programdir /Users/ruki/.local/share/xmake ``` ## XMAKE_PROFILE 开启性能分析 这仅仅对 xmake 的开发者开放，用于分析 xmake 运行过程中的耗时情况，追踪调用过程。 ### 分析函数调用耗时 ```bash $ XMAKE_PROFILE perf:call xmake [ 25%]: cache compiling.release src/main.cpp [ 50%]: linking.release test [100%]: build ok! 0.238, 97.93%, 1, runloop : @programdir/core/base/scheduler.lua: 805 0.180, 74.04%, 25, _resume : [C]: 1 0.015, 6.34%, 50, _co_groups_resume : @programdir/core/base/scheduler.lua: 299 0.011, 4.37%, 48, wait : @programdir/core/base/poller.lua: 111 0.004, 1.70%, 62, status : @programdir/core/base/scheduler.lua: 71 0.004, 1.53%, 38, is_dead : @programdir/core/base/scheduler.lua: 76 0.003, 1.44%, 50, next : @programdir/core/base/timer.lua: 74 0.003, 1.33%, 48, delay : @programdir/core/base/timer.lua: 60 0.002, 1.02%, 24, is_suspended : @programdir/core/base/scheduler.lua: 86 ``` ### 分析进程耗时 可以用于分析每个文件的编译耗时，以及一些运行瓶颈。 ```bash $ XMAKE_PROFILE perf:process xmake r [ 7%]: compiling.release src/header.h [ 23%]: compiling.release src/test.cpp [ 30%]: compiling.release src/test8.cpp [ 38%]: compiling.release src/test4.cpp [ 46%]: compiling.release src/test5.cpp [ 53%]: compiling.release src/test7.cpp [ 61%]: compiling.release src/test6.cpp [ 69%]: compiling.release src/test2.cpp [ 76%]: compiling.release src/main.cpp [ 84%]: compiling.release test3.cpp [ 84%]: compiling.release src/test.c [ 92%]: linking.release main [100%]: build ok, spent 2.754s 1411.000, 22.19%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_37317EEDB62F4F3088AF6A2E2A649460 fdiagnostics color always x c++ header o build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch src/header.h 508.000, 7.99%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_1ABAE1FAD68D45008DC76A3A00697820 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/main.cpp.o src/main.cpp 473.000, 7.44%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_1C0BE5280C6F4E208F919577A48AAA40 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/test3.cpp.o test3.cpp 451.000, 7.09%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_877D3D9B6BBA4D308BFB5E4EBD751340 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test6.cpp.o src/test6.cpp 404.000, 6.35%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C9968E2873B648208A8C3F2BA7573640 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test7.cpp.o src/test7.cpp 402.000, 6.32%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_7F6DFA37FF494D208EADF9737484EC40 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test2.cpp.o src/test2.cpp 383.000, 6.02%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_63C9E23AE7E047308F762C7C02A56B50 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test4.cpp.o src/test4.cpp 374.000, 5.88%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C3A0EF96A7C14D00879BFAEFD26E9D20 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test8.cpp.o src/test8.cpp 368.000, 5.79%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_BADB46AF75CB4610857EF5083BD54D30 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test.cpp.o src/test.cpp 363.000, 5.71%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_0247BDB87DD14500816471184D4E8140 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test5.cpp.o src/test5.cpp 156.000, 2.45%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fPIC Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F0FF8220B33B46208D39A98937D55E50 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 133.000, 2.09%, 3, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang version 107.000, 1.68%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang O3 Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C8A96266E0034C20898C147FC52F3A40 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 105.000, 1.65%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fdiagnostics color always Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_48A2FA7BE7AB44008B60558E412A9D30 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 105.000, 1.65%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ fPIC target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F510FB15C9A647108111A7010EFED240 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 91.000, 1.43%, 3, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ version 74.000, 1.16%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden O3 DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_BF6B4B6DACB843008E822CEFDC711230 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test.c.o src/test.c 73.000, 1.15%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ o build/macosx/x86_64/release/main build/.objs/main/macosx/x86_64/release/src/test.cpp.o build/.objs/main/macosx/x86_64/release/src/test8.cpp.o build/.objs/main/macosx/x86_64/release/src/test4.cpp.o build/.objs/main/macosx/x86_64/release/src/test5.cpp.o build/.objs/main/macosx/x86_64/release/src/test7.cpp.o build/.objs/main/macosx/x86_64/release/src/test6.cpp.o build/.objs/main/macosx/x86_64/release/src/test2.cpp.o build/.objs/main/macosx/x86_64/release/src/main.cpp.o build/.objs/main/macosx/x86_64/release/test3.cpp.o build/.objs/main/macosx/x86_64/release/src/test.c.o target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz Wl, x Wl, dead_strip 70.000, 1.10%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fPIC Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_6D0B6327841A47208939EEF194F38B50 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 68.000, 1.07%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang O3 Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_8AB279F8450D4D108E92951CC9C1C650 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 65.000, 1.02%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fdiagnostics color always Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_D25F0DB04D6D430084C098F1E1F76C00 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp ``` ### 追踪 xmake 的运行过程 ```bash $ XMAKE_PROFILE trace xmake func : @programdir/core/base/scheduler.lua: 457 is_suspended : @programdir/core/base/scheduler.lua: 86 status : @programdir/core/base/scheduler.lua: 71 thread : @programdir/core/base/scheduler.lua: 66 thread : @programdir/core/base/scheduler.lua: 66 length : @programdir/core/base/heap.lua: 120 ``` ### 分析运行卡死问题 可以用于获取 xmake 运行卡死时的栈。启用此特性后，通过 Ctrl+C 中断后就能获取栈。 ```bash $ XMAKE_PROFILE stuck xmake l test.lua <Ctrl+C> stack traceback: [C]: in function 'base/io.file_read' @programdir/core/base/io.lua:177: in method '_read' @programdir/core/sandbox/modules/io.lua:90: in function <@programdir/core/sandbox/module s/io.lua:89> (...tail calls...) /Users/ruki/share/test.lua:2: in function </Users/ruki/share/test.lua:1> (...tail calls...) @programdir/plugins/lua/main.lua:123: in function <@programdir/plugins/lua/main.lua:79> (...tail calls...) [C]: in function 'xpcall' @programdir/core/base/utils.lua:280: in function 'sandbox/modules/utils.trycall' (...tail calls...) @programdir/core/base/task.lua:519: in function 'base/task.run' @programdir/core/main.lua:278: in upvalue 'cotask' @programdir/core/base/scheduler.lua:371: in function <@programdir/core/base/scheduler.lu a:368> ``` ## XMAKE_RCFILES 设置全局配置文件 我们可以设置一些 xmakerc.lua 全局配置文件，在用户编译项目的时候，全局引入它们，比如全局引入一些用户自定义的帮助脚本，工具链什么的。 ```bash $ export XMAKE_RCFILES xmakerc.lua $ xmake ``` 如果不设置，默认路径为：`~/.xmake/xmakerc.lua`。 ## XMAKE_LOGFILE 设置日志文件路径 默认 xmake 会回显输出到终端，我们在可以通过设置这个路径，开启日志自动存储到指定文件，但它不会影响终端的正常回显输出。 ## XMAKE_MAIN_REPO 设置官方包主仓库地址 xmake 默认内置了三个主仓库地址，它们是完全相同的，xmake 会根据当前网络状态选择最优的地址来使用。 ``` https://github.com/xmake io/xmake repo.git https://gitlab.com/tboox/xmake repo.git https://gitee.com/tboox/xmake repo.git ``` 但如果 xmake 选择错误，可能会导致仓库下载失败，而通过这个环境变量，我们可以自己设置固定使用指定的仓库地址，不再进行自动选择。 ```bash $ export XMAKE_MAIN_REPO https://github.com/xmake io/xmake repo.git ``` ## XMAKE_BINARY_REPO 设置官方包预编译仓库地址 类似 `XMAKE_MAIN_REPO`，唯一的区别是，这个用于切换预编译仓库的地址。 ```bash $ export XMAKE_BINARY_REPO https://github.com/xmake mirror/build artifacts.git ``` ## XMAKE_THEME 设置主题 通常我们可以通过 `xmake g theme plain` 来设置颜色主题，但是它是全局的，如果想单独对当前终端会话设置，我们就可以使用这个环境变量来设置。 ```bash $ export XMAKE_THEME plain ``` ## XMAKE_STATS 开启或禁用用户量统计 由于目前 xmake 还在发展初期，我们需要知道大概的用户量增长情况，以便于提供我们持续更新 xmake 的动力。 因此 xmake 默认每天的第一次项目构建，会在后台进程自动 git clone 一个空仓库：<https://github.com/xmake io/xmake stats> 然后借用 github 自身提供的 Traffic 统计图表来获取大概的用户量。 对于每个项目，每天只会统计一次，并且不会泄露任何用户隐私，因为仅仅只是多了一次额外的 git clone 操作，另外我们 clone 的是一个空仓库，不会耗费用户多少流量。 当然，并不是每个用户都希望这么做，用户完全有权利去禁用这个行为，我们只需要设置： ```bash export XMAKE_STATS n ``` 就可以完全禁用它，另外我们也会在 ci 上自动禁用这个行为。 什么时候移除它？ 这个行为并不会永久存在，等到 xmake 有了足够多的用户量，或者有了其他更好的统计方式，我们会考虑移除相关统计代码。 当然，如果有非常多的用户反馈不愿意接受它，我们也会考虑移除它。 关于这个的相关 issues 见：[#1795](https://github.com/xmake io/xmake/issues/1795)"},"/get_started/zh/features/autogen.html":{"title":"","content":" class: heading_no_counter # 自动扫描源码生成工程 对于一份工程源码，可以不用编写 makefile，也不用编写各种 make 相关的工程描述文件（例如：xmake.lua，makefile.am, cmakelist.txt 等） xmake 就可以直接编译他们，这是如何做到的呢，简单来说下实现原理： 1. 首先扫描当前目录下，xmake 可以支持的所有源代码文件 2. 分析代码，检测哪些代码拥有 main 入口函数 3. 所有没有 main 入口的代码编译成静态库 4. 带有 main 入口的代码，编译成可执行程序，同时链接其他静态库程序 这种代码扫描和智能编译，非常简单，目前 xmake 还不支持多级目录扫描，只对单级目录的代码进行扫描编译。 ## 使用场景 1. 临时快速编译和运行一些零散的测试代码 2. 尝试对其他开源库做移植编译 3. 快速基于现有代码创建新 xmake 工程 ## 如何使用 直接在带有源码的目录（没有 xmake.lua）下执行 xmake，然后根据提示操作： ```bash $ xmake note: xmake.lua not found, try generating it (pass y or confirm y/n/d to skip confirm)? please input: n (y/n) y ``` 另外, 当存在其他构建系统标识性文件的时候 (比如 CMakeLists.txt), 不会触发自动生成 xmake.lua 的流程, 而是首先触发 [自动探测构建系统并编译](# 自动探测构建系统并编译), 如果要强制触发自动扫描生成 xmake.lua 的流程, 可运行: ```bash $ xmake f y ``` ## 开源代码的移植和编译 虽然这种方式，并不是非常智能，限制也不少，但是对于想临时写些代码进行编译运行，或者临时想交叉编译一些简单的开源库代码 这种方式已经足够使用了，下面看下一个实际的例子： 我下载了一份 zlib 1.2.10 的源码，想要编译它，只需要进入 zlib 的源码目录执行： ```bash $ cd zlib 1.2.10 $ xmake note: xmake.lua not found, try generating it (pass y or confirm y/n/d to skip confirm)? please input: n (y/n) y ``` 就行了，输入 y 确认后，输出结果如下： ``` target(zlib 1.2): static [+]: ./adler32.c [+]: ./compress.c [+]: ./crc32.c [+]: ./deflate.c [+]: ./gzclose.c [+]: ./gzlib.c [+]: ./gzread.c [+]: ./gzwrite.c [+]: ./infback.c [+]: ./inffast.c [+]: ./inflate.c [+]: ./inftrees.c [+]: ./trees.c [+]: ./uncompr.c [+]: ./zutil.c xmake.lua generated, scan ok!👌 checking for the architecture ... x86_64 checking for the Xcode SDK version for macosx ... 10.12 checking for the target minimal version ... 10.12 checking for the c compiler (cc) ... xcrun sdk macosx clang checking for the c++ compiler (cxx) ... xcrun sdk macosx clang checking for the objc compiler (mm) ... xcrun sdk macosx clang checking for the objc++ compiler (mxx) ... xcrun sdk macosx clang++ checking for the swift compiler (sc) ... xcrun sdk macosx swiftc checking for the assember (as) ... xcrun sdk macosx clang checking for the linker (ld) ... xcrun sdk macosx clang++ checking for the static library archiver (ar) ... xcrun sdk macosx ar checking for the static library extractor (ex) ... xcrun sdk macosx ar checking for the shared library linker (sh) ... xcrun sdk macosx clang++ checking for the debugger (dd) ... xcrun sdk macosx lldb checking for the golang compiler (go) ... go configure { ex \"xcrun sdk macosx ar\" , sh \"xcrun sdk macosx clang++\" , host \"macosx\" , ar \"xcrun sdk macosx ar\" , buildir \"build\" , as \"xcrun sdk macosx clang\" , plat \"macosx\" , xcode_dir \"/Applications/Xcode.app\" , arch \"x86_64\" , mxx \"xcrun sdk macosx clang++\" , go \"go\" , target_minver \"10.12\" , ccache \"ccache\" , mode \"release\" , clean true , cxx \"xcrun sdk macosx clang\" , cc \"xcrun sdk macosx clang\" , dd \"xcrun sdk macosx lldb\" , kind \"static\" , ld \"xcrun sdk macosx clang++\" , xcode_sdkver \"10.12\" , sc \"xcrun sdk macosx swiftc\" , mm \"xcrun sdk macosx clang\" } configure ok! clean ok! [00%]: cache compiling.release ./adler32.c [06%]: cache compiling.release ./compress.c [13%]: cache compiling.release ./crc32.c [20%]: cache compiling.release ./deflate.c [26%]: cache compiling.release ./gzclose.c [33%]: cache compiling.release ./gzlib.c [40%]: cache compiling.release ./gzread.c [46%]: cache compiling.release ./gzwrite.c [53%]: cache compiling.release ./infback.c [60%]: cache compiling.release ./inffast.c [66%]: cache compiling.release ./inflate.c [73%]: cache compiling.release ./inftrees.c [80%]: cache compiling.release ./trees.c [86%]: cache compiling.release ./uncompr.c [93%]: cache compiling.release ./zutil.c [100%]: archiving.release libzlib 1.2.a build ok!👌 ``` 通过输出结果，可以看到，xmake 会去检测扫描当前目录下的所有. c 代码，发现没有 main 入口，应该是静态库程序，因此执行 xmake 后，就直接编译成静态库 libzlib 1.2.a 了 连 xmake.lua 都没有编写，其实 xmake 在扫描完成后，会去自动在当前目录下生成一份 xmake.lua，下次编译就不需要重新扫描检测了。 自动生成的 xmake.lua 内容如下： ```lua define target target(\"zlib 1.2\"， function() set kind set_kind(\"static\") add files add_files(\"./adler32.c\") add_files(\"./compress.c\") add_files(\"./crc32.c\") add_files(\"./deflate.c\") add_files(\"./gzclose.c\") add_files(\"./gzlib.c\") add_files(\"./gzread.c\") add_files(\"./gzwrite.c\") add_files(\"./infback.c\") add_files(\"./inffast.c\") add_files(\"./inflate.c\") add_files(\"./inftrees.c\") add_files(\"./trees.c\") add_files(\"./uncompr.c\") add_files(\"./zutil.c\") end) ``` 也许你会说，像这种开源库，直接 `configure; make` 不就好了吗，他们自己也有提供 makefile 来直接编译的，的确是这样，我这里只是举个例子而已。 当然，很多开源库在交叉编译的时候，通过自带的 `configure`，处理起来还是很繁琐的，用 xmake 进行交叉编译会更方便些。。 ## 即时地代码编写和编译运行 xmake 的这个扫描代码编译特性，主要的目的：还是为了让我们在临时想写些测试代码的时候，不用考虑太多东西，直接上手敲代码，然后快速执行 `xmake run` 来调试验证结果。 例如： 我想写了个简单的 main.c 的测试程序，打印 `hello world!`，如果要写 makefile 或者直接通过 gcc 命令来，就很繁琐了，你需要： ```bash gcc ./main.c o demo ./demo ``` 最快速的方式，也需要执行两行命令，而如果用 xmake，只需要执行： ```bash xmake run ``` 就行了，它会自动检测到代码后，自动生成对应的 xmake.lua，自动编译，自动运行，然后输出： ```bash hello world! ``` 如果你有十几个代码文件，用手敲 gcc 的方式，或者写 makefile 的方式，这个差距就更明显了，用 xmake 还是只需要一行命令： ```bash xmake run ``` ## 多语言支持 这种代码检测和即时编译，是支持多语言的，不仅支持 c/c++，还支持 objc/swift。 例如我下载了一份 fmdb 的 ios 开源框架代码： ``` . ├── FMDB.h ├── FMDatabase.h ├── FMDatabase.m ├── FMDatabaseAdditions.h ├── FMDatabaseAdditions.m ├── FMDatabasePool.h ├── FMDatabasePool.m ├── FMDatabaseQueue.h ├── FMDatabaseQueue.m ├── FMResultSet.h └── FMResultSet.m ``` 想要把它编译成 ios 的静态库，但是又不想写 xmake.lua，或者 makefile，那么只需要使用 xmake 的这个新特性，直接执行： ```bash $ xmake f p iphoneos; xmake ``` 就行了，输出结果如下： ``` xmake.lua not found, scanning files .. target(FMDB): static [+]: ./FMDatabase.m [+]: ./FMDatabaseAdditions.m [+]: ./FMDatabasePool.m [+]: ./FMDatabaseQueue.m [+]: ./FMResultSet.m xmake.lua generated, scan ok!👌 checking for the architecture ... armv7 checking for the Xcode SDK version for iphoneos ... 10.1 checking for the target minimal version ... 10.1 checking for the c compiler (cc) ... xcrun sdk iphoneos clang checking for the c++ compiler (cxx) ... xcrun sdk iphoneos clang checking for the objc compiler (mm) ... xcrun sdk iphoneos clang checking for the objc++ compiler (mxx) ... xcrun sdk iphoneos clang++ checking for the assember (as) ... gas preprocessor.pl xcrun sdk iphoneos clang checking for the linker (ld) ... xcrun sdk iphoneos clang++ checking for the static library archiver (ar) ... xcrun sdk iphoneos ar checking for the static library extractor (ex) ... xcrun sdk iphoneos ar checking for the shared library linker (sh) ... xcrun sdk iphoneos clang++ checking for the swift compiler (sc) ... xcrun sdk iphoneos swiftc configure { ex \"xcrun sdk iphoneos ar\" , ccache \"ccache\" , host \"macosx\" , ar \"xcrun sdk iphoneos ar\" , buildir \"build\" , as \"/usr/local/share/xmake/tools/utils/gas preprocessor.pl xcrun sdk iphoneos clang\" , arch \"armv7\" , mxx \"xcrun sdk iphoneos clang++\" , cxx \"xcrun sdk iphoneos clang\" , target_minver \"10.1\" , xcode_dir \"/Applications/Xcode.app\" , clean true , sh \"xcrun sdk iphoneos clang++\" , cc \"xcrun sdk iphoneos clang\" , ld \"xcrun sdk iphoneos clang++\" , mode \"release\" , kind \"static\" , plat \"iphoneos\" , xcode_sdkver \"10.1\" , sc \"xcrun sdk iphoneos swiftc\" , mm \"xcrun sdk iphoneos clang\" } configure ok! clean ok! [00%]: cache compiling.release ./FMDatabase.m [20%]: cache compiling.release ./FMDatabaseAdditions.m [40%]: cache compiling.release ./FMDatabasePool.m [60%]: cache compiling.release ./FMDatabaseQueue.m [80%]: cache compiling.release ./FMResultSet.m [100%]: archiving.release libFMDB.a build ok!👌 ``` ## 同时编译多个可执行文件 输出结果的开头部分，就是对代码的分析结果，虽然目前只支持单级目录结构的代码扫描，但是还是可以同时支持检测和编译多个可执行文件的 我们以 libjpeg 的开源库为例： 我们进入 jpeg 6b 目录后，执行： ```bash $ xmake ``` 输出如下： ``` xmake.lua not found, scanning files .. target(jpeg 6b): static [+]: ./cdjpeg.c [+]: ./example.c [+]: ./jcapimin.c [+]: ./jcapistd.c [+]: ./jccoefct.c [+]: ./jccolor.c [+]: ./jcdctmgr.c [+]: ./jchuff.c [+]: ./jcinit.c [+]: ./jcmainct.c [+]: ./jcmarker.c [+]: ./jcmaster.c [+]: ./jcomapi.c [+]: ./jcparam.c [+]: ./jcphuff.c [+]: ./jcprepct.c [+]: ./jcsample.c [+]: ./jctrans.c [+]: ./jdapimin.c [+]: ./jdapistd.c [+]: ./jdatadst.c [+]: ./jdatasrc.c [+]: ./jdcoefct.c [+]: ./jdcolor.c [+]: ./jddctmgr.c [+]: ./jdhuff.c [+]: ./jdinput.c [+]: ./jdmainct.c [+]: ./jdmarker.c [+]: ./jdmaster.c [+]: ./jdmerge.c [+]: ./jdphuff.c [+]: ./jdpostct.c [+]: ./jdsample.c [+]: ./jdtrans.c [+]: ./jerror.c [+]: ./jfdctflt.c [+]: ./jfdctfst.c [+]: ./jfdctint.c [+]: ./jidctflt.c [+]: ./jidctfst.c [+]: ./jidctint.c [+]: ./jidctred.c [+]: ./jmemansi.c [+]: ./jmemmgr.c [+]: ./jmemname.c [+]: ./jmemnobs.c [+]: ./jquant1.c [+]: ./jquant2.c [+]: ./jutils.c [+]: ./rdbmp.c [+]: ./rdcolmap.c [+]: ./rdgif.c [+]: ./rdppm.c [+]: ./rdrle.c [+]: ./rdswitch.c [+]: ./rdtarga.c [+]: ./transupp.c [+]: ./wrbmp.c [+]: ./wrgif.c [+]: ./wrppm.c [+]: ./wrrle.c [+]: ./wrtarga.c target(ansi2knr): binary [+]: ./ansi2knr.c target(cjpeg): binary [+]: ./cjpeg.c target(ckconfig): binary [+]: ./ckconfig.c target(djpeg): binary [+]: ./djpeg.c target(jpegtran): binary [+]: ./jpegtran.c target(rdjpgcom): binary [+]: ./rdjpgcom.c target(wrjpgcom): binary [+]: ./wrjpgcom.c xmake.lua generated, scan ok!👌 checking for the architecture ... x86_64 checking for the Xcode SDK version for macosx ... 10.12 checking for the target minimal version ... 10.12 checking for the c compiler (cc) ... xcrun sdk macosx clang checking for the c++ compiler (cxx) ... xcrun sdk macosx clang checking for the objc compiler (mm) ... xcrun sdk macosx clang checking for the objc++ compiler (mxx) ... xcrun sdk macosx clang++ checking for the swift compiler (sc) ... xcrun sdk macosx swiftc checking for the assember (as) ... xcrun sdk macosx clang checking for the linker (ld) ... xcrun sdk macosx clang++ checking for the static library archiver (ar) ... xcrun sdk macosx ar checking for the static library extractor (ex) ... xcrun sdk macosx ar checking for the shared library linker (sh) ... xcrun sdk macosx clang++ checking for the debugger (dd) ... xcrun sdk macosx lldb checking for the golang compiler (go) ... go configure { ex \"xcrun sdk macosx ar\" , sh \"xcrun sdk macosx clang++\" , host \"macosx\" , ar \"xcrun sdk macosx ar\" , buildir \"build\" , as \"xcrun sdk macosx clang\" , plat \"macosx\" , xcode_dir \"/Applications/Xcode.app\" , arch \"x86_64\" , mxx \"xcrun sdk macosx clang++\" , go \"go\" , target_minver \"10.12\" , ccache \"ccache\" , mode \"release\" , clean true , cxx \"xcrun sdk macosx clang\" , cc \"xcrun sdk macosx clang\" , dd \"xcrun sdk macosx lldb\" , kind \"static\" , ld \"xcrun sdk macosx clang++\" , xcode_sdkver \"10.12\" , sc \"xcrun sdk macosx swiftc\" , mm \"xcrun sdk macosx clang\" } configure ok! clean ok! [00%]: cache compiling.release ./cdjpeg.c [00%]: cache compiling.release ./example.c [00%]: cache compiling.release ./jcapimin.c [00%]: cache compiling.release ./jcapistd.c [00%]: cache compiling.release ./jccoefct.c [00%]: cache compiling.release ./jccolor.c [01%]: cache compiling.release ./jcdctmgr.c [01%]: cache compiling.release ./jchuff.c [01%]: cache compiling.release ./jcinit.c [01%]: cache compiling.release ./jcmainct.c [01%]: cache compiling.release ./jcmarker.c [02%]: cache compiling.release ./jcmaster.c [02%]: cache compiling.release ./jcomapi.c [02%]: cache compiling.release ./jcparam.c [02%]: cache compiling.release ./jcphuff.c [02%]: cache compiling.release ./jcprepct.c [03%]: cache compiling.release ./jcsample.c [03%]: cache compiling.release ./jctrans.c [03%]: cache compiling.release ./jdapimin.c [03%]: cache compiling.release ./jdapistd.c [03%]: cache compiling.release ./jdatadst.c [04%]: cache compiling.release ./jdatasrc.c [04%]: cache compiling.release ./jdcoefct.c [04%]: cache compiling.release ./jdcolor.c [04%]: cache compiling.release ./jddctmgr.c [04%]: cache compiling.release ./jdhuff.c [05%]: cache compiling.release ./jdinput.c [05%]: cache compiling.release ./jdmainct.c [05%]: cache compiling.release ./jdmarker.c [05%]: cache compiling.release ./jdmaster.c [05%]: cache compiling.release ./jdmerge.c [06%]: cache compiling.release ./jdphuff.c [06%]: cache compiling.release ./jdpostct.c [06%]: cache compiling.release ./jdsample.c [06%]: cache compiling.release ./jdtrans.c [06%]: cache compiling.release ./jerror.c [07%]: cache compiling.release ./jfdctflt.c [07%]: cache compiling.release ./jfdctfst.c [07%]: cache compiling.release ./jfdctint.c [07%]: cache compiling.release ./jidctflt.c [07%]: cache compiling.release ./jidctfst.c [08%]: cache compiling.release ./jidctint.c [08%]: cache compiling.release ./jidctred.c [08%]: cache compiling.release ./jmemansi.c [08%]: cache compiling.release ./jmemmgr.c [08%]: cache compiling.release ./jmemname.c [09%]: cache compiling.release ./jmemnobs.c [09%]: cache compiling.release ./jquant1.c [09%]: cache compiling.release ./jquant2.c [09%]: cache compiling.release ./jutils.c [09%]: cache compiling.release ./rdbmp.c [10%]: cache compiling.release ./rdcolmap.c [10%]: cache compiling.release ./rdgif.c [10%]: cache compiling.release ./rdppm.c [10%]: cache compiling.release ./rdrle.c [10%]: cache compiling.release ./rdswitch.c [11%]: cache compiling.release ./rdtarga.c [11%]: cache compiling.release ./transupp.c [11%]: cache compiling.release ./wrbmp.c [11%]: cache compiling.release ./wrgif.c [11%]: cache compiling.release ./wrppm.c [12%]: cache compiling.release ./wrrle.c [12%]: cache compiling.release ./wrtarga.c [12%]: archiving.release libjpeg 6b.a [12%]: cache compiling.release ./wrjpgcom.c [25%]: linking.release wrjpgcom [25%]: cache compiling.release ./ansi2knr.c [37%]: linking.release ansi2knr [37%]: cache compiling.release ./jpegtran.c [50%]: linking.release jpegtran [50%]: cache compiling.release ./djpeg.c [62%]: linking.release djpeg [62%]: cache compiling.release ./ckconfig.c [75%]: linking.release ckconfig [75%]: cache compiling.release ./rdjpgcom.c [87%]: linking.release rdjpgcom [87%]: cache compiling.release ./cjpeg.c [100%]: linking.release cjpeg build ok!👌 ``` 可以看到，处理静态库，xmake 还分析出了很多可执行的测试程序，剩下的代码统一编译成一个 libjpeg.a 的静态库，供哪些测试程序链接使用。。 ``` target(ansi2knr): binary [+]: ./ansi2knr.c target(cjpeg): binary [+]: ./cjpeg.c target(ckconfig): binary [+]: ./ckconfig.c target(djpeg): binary [+]: ./djpeg.c target(jpegtran): binary [+]: ./jpegtran.c target(rdjpgcom): binary [+]: ./rdjpgcom.c target(wrjpgcom): binary [+]: ./wrjpgcom.c ``` ## 遇到的一些问题和限制 当前 xmake 的这种自动分析检测还不是非常智能，对于： 1. 需要特殊的编译选项 2. 需要依赖其他目录的头文件搜索 3. 需要分条件编译不同源文件 4. 同目录需要生成多个静态库 5. 需要多级目录支持的源码库 以上这些情况，xmake 暂时还没发自动化的智能处理，其中限制 1，2 还是可以解决的，通过半手动的方式，例如： ```bash $ xmake f cxflags \"\" ldflags \"\" includedirs \"\" linkdirs \"\"; xmake ``` 在自动检测编译的时候，手动配置这个源码工程需要的特殊编译选项，就可以直接通过编译了 而限制 3，暂时只能通过删源代码来解决了，就像刚才编译 jpeg 的代码，其实它的目录下面同时存在了： ``` jmemdos.c jmemmac.c jmemansi.c ``` 其中两个是没法编译过的，需要删掉后才行。"},"/get_started/zh/features/unity-build.html":{"title":"","content":" class: heading_no_counter # Unity 编译加速 我们知道，C++ 代码编译速度通常很慢，因为每个代码文件都需要解析引入的头文件。 而通过 Unity Build，我们通过将多个 cpp 文件组合成一个来加速项目的编译，其主要好处是减少了解析和编译包含在多个源文件中的头文件内容的重复工作，头文件的内容通常占预处理后源文件中的大部分代码。 Unity 构建还通过减少编译链创建和处理的目标文件的数量来减轻由于拥有大量小源文件而导致的开销，并允许跨形成统一构建任务的文件进行过程间分析和优化（类似于效果链接时优化）。 它可以极大提升 C/C++ 代码的编译速度，通常会有 30% 的速度提升，不过根据项目的复杂程度不同，其带来的效益还是要根据自身项目情况而定。 相关 issues 见 [#1019](https://github.com/xmake io/xmake/issues/1019)。 ## 如何启用？ 我们提供了两个内置规则，分别处理对 C 和 C++ 代码的 Unity Build。 ```lua add_rules(\"c.unity_build\") add_rules(\"c++.unity_build\") ``` ## Batch 模式 默认情况下，只要设置上述规则，就会启用 Batch 模式的 Unity Build，也就是 xmake 自动根据项目代码文件，自动组织合并。 ```lua target(\"test\", function() set_kind(\"binary\") add_includedirs(\"src\") add_rules(\"c++.unity_build\", {batchsize 2}) add_files(\"src/*.c\", \"src/*.cpp\") end) ``` 我们可以额外通过设置 `{batchsize 2}` 参数到规则，来指定每个合并 Batch 的大小数量，这里也就是每两个 C++ 文件自动合并编译。 编译效果大概如下： ```console $ xmake r [ 11%]: cache compiling.release build/.gens/test/unity_build/unity_642A245F.cpp [ 11%]: cache compiling.release build/.gens/test/unity_build/unity_bar.cpp [ 11%]: cache compiling.release build/.gens/test/unity_build/unity_73161A20.cpp [ 11%]: cache compiling.release build/.gens/test/unity_build/unity_F905F036.cpp [ 11%]: cache compiling.release build/.gens/test/unity_build/unity_foo.cpp [ 11%]: cache compiling.release build/.gens/test/unity_build/main.c [ 77%]: linking.release test [100%]: build ok ``` 由于我们仅仅启用了 C++ 的 Unity Build，所以 C 代码还是正常挨个编译。另外在 Unity Build 模式下，我们还是可以做到尽可能的并行编译加速，互不冲突。 如果没有设置 `batchsize` 参数，那么默认会把所有文件合并到一个文件中进行编译。 ## Group 模式 如果上面的 Batch 模式自动合并效果不理想，我们也可以使用自定义分组，来手动配置哪些文件合并到一起参与编译，这使得用户更加地灵活可控。 ```lua target(\"test\", function() set_kind(\"binary\") add_rules(\"c++.unity_build\", {batchsize 0}) disable batch mode add_files(\"src/*.c\", \"src/*.cpp\") add_files(\"src/foo/*.c\", {unity_group \"foo\"}) add_files(\"src/bar/*.c\", {unity_group \"bar\"}) end) ``` 我们使用 `{unity_group \"foo\"}` 来指定每个分组的名字，以及包含了哪些文件，每个分组的文件都会单独被合并到一个代码文件中去。 另外，`batchsize 0` 也强行禁用了 Batch 模式，也就是说，没有设置 unity_group 分组的代码文件，我们还是会单独编译它们，也不会自动开启自动合并。 ## Batch 和 Group 混合模式 我们只要把上面的 `batchsize 0` 改成非 0 值，就可以让分组模式下，剩余的代码文件继续开启 Batch 模式自动合并编译。 ```lua target(\"test\", function() set_kind(\"binary\") add_includedirs(\"src\") add_rules(\"c++.unity_build\", {batchsize 2}) add_files(\"src/*.c\", \"src/*.cpp\") add_files(\"src/foo/*.c\", {unity_group \"foo\"}) add_files(\"src/bar/*.c\", {unity_group \"bar\"}) end) ``` ## 忽略指定文件 如果是 Batch 模式下，由于是自动合并操作，所以默认会对所有文件执行合并，但如果有些代码文件我们不想让它参与合并，那么我们也可以通过 `{unity_ignored true}` 去忽略它们。 ```lua target(\"test\", function() set_kind(\"binary\") add_includedirs(\"src\") add_rules(\"c++.unity_build\", {batchsize 2}) add_files(\"src/*.c\", \"src/*.cpp\") add_files(\"src/test/*.c\", {unity_ignored true}) ignore these files end) ``` ## Unique ID 尽管 Unity Build 带来的收益不错，但是我们还是会遇到一些意外的情况，比如我们的两个代码文件里面，全局命名空间下，都存在相同名字的全局变量和函数。 那么，合并编译就会带来编译冲突问题，编译器通常会报全局变量重定义错误。 为了解决这个问题，我们需要用户代码上做一些修改，然后配合构建工具来解决。 比如，我们的 foo.cpp 和 bar.cpp 都有全局变量 i。 foo.cpp ```c namespace { int i 42; } int foo() { return i; } ``` bar.cpp ```c namespace { int i 42; } int bar() { return i; } ``` 那么，我们合并编译就会冲突，我们可以引入一个 Unique ID 来隔离全局的匿名空间。 foo.cpp ```c namespace MY_UNITY_ID { int i 42; } int foo() { return MY_UNITY_ID::i; } ``` bar.cpp ```c namespace MY_UNITY_ID { int i 42; } int bar() { return MY_UNITY_ID::i; } ``` 接下来，我们还需要保证代码合并后， `MY_UNITY_ID` 在 foo 和 bar 中的定义完全不同，可以按文件名算一个唯一 ID 值出来，互不冲突，也就是实现下面的合并效果： ```c #define MY_UNITY_ID <hash(foo.cpp)> #include \"foo.c\" #undef MY_UNITY_ID #define MY_UNITY_ID <hash(bar.cpp)> #include \"bar.c\" #undef MY_UNITY_ID ``` 这看上去似乎很麻烦，但是用户不需要关心这些，xmake 会在合并时候自动处理它们，用户只需要指定这个 Unique ID 的名字就行了，例如下面这样： ```lua target(\"test\", function() set_kind(\"binary\") add_includedirs(\"src\") add_rules(\"c++.unity_build\", {batchsize 2, uniqueid \"MY_UNITY_ID\"}) add_files(\"src/*.c\", \"src/*.cpp\") end) ``` 处理全局变量，还有全局的重名宏定义，函数什么的，都可以采用这种方式来避免冲突。"},"/get_started/zh/features/distcc-build.html":{"title":"","content":" class: heading_no_counter # 分布式编译 xmake 提供了内置的分布式编译服务，通常它可以跟 本地编译缓存，远程编译缓存 相互配合，实现最优的编译的加速。 另外，它是完全跨平台支持，我们不仅支持 gcc/clang，也能够很好地支持 Windows 和 msvc。 对于交叉编译，只要交叉工具链支持，我们不要求服务器的系统环境，即使混用 linux, macOS 和 Windows 的服务器资源，也可以很好的实现分布式编译。 ## 开启服务 我们可以指定 ` distcc` 参数来开启分布式编译服务，当然如果不指定这个参数，xmake 会默认开启所有服务端配置的服务。 这里我们假设有 2 台机器作为分布式的编译服务器集群,ip 地址分别是 192.168.22.168,192.168.22.169,两台服务器分别执行下面的脚本 ```console $ xmake service distcc <distcc_build_server>: listening 0.0.0.0:9093 .. ``` 我们也可以开启服务的同时，回显详细日志信息。 ```console $ xmake service distcc vD <distcc_build_server>: listening 0.0.0.0:9093 .. ``` ## 以 Daemon 模式开启服务 ```console $ xmake service distcc start $ xmake service distcc restart $ xmake service distcc stop ``` ## 配置服务端 我们首先，运行 `xmake service` 命令，它会自动生成一个默认的 `server.conf` 配置文件，存储到 `~/.xmake/service/server.conf`。 ```bash $ xmake service generating the config file to /Users/ruki/.xmake/service/server.conf .. an token(590234653af52e91b9e438ed860f1a2b) is generated, we can use this token to connect service. generating the config file to /Users/ruki/.xmake/service/client.conf .. <distcc_build_server>: listening 0.0.0.0:9693 .. ``` 然后，我们编辑它，修复每台服务器的监听端口（可选）。 ```bash $ cat ~/.xmake/service/server.conf { distcc_build { listen \"0.0.0.0:9693\", workdir \"/Users/ruki/.xmake/service/server/distcc_build\" }, known_hosts { }, logfile \"/Users/ruki/.xmake/service/server/logs.txt\", tokens { \"590234653af52e91b9e438ed860f1a2b\" } } ``` ## 配置客户端 客户端配置文件在 `~/.xmake/service/client.conf`，我们可以在里面配置客户端需要连接的服务器地址。 我们可以在 hosts 列表里面配置多个服务器地址，以及对应的 token。 > 分布式编译，推荐使用 token 认证模式，因为密码模式，每台服务器连接时候都要输入一次密码，很繁琐。 ```console $cat ~/.xmake/service/client.conf { distcc_build { hosts { { connect \"192.168.22.168:9693\", token \"590234653af52e91b9e438ed860f1a2b\" }, { connect \"192.168.22.169:9693\", token \"590234653af52e91b9e438ed860f1a2b\" } } } } ``` ### 配置超时 默认情况下，客户端连接，收发数据都是无限等待不超时的，但是如果访问服务端的网络不稳定，那么有可能会导致访问卡死，这个时候可以配置超时来解决。 如果发生超时异常，就会自动退化到本地编译，不会永远卡死。 我们可以配置，`send_timeout`, `recv_timeout` 和 `connect_timeout` 三种超时，如果在根节点设置，那么所有客户端服务都会生效。 ```console $ cat ~/.xmake/service/client.conf { send_timeout 5000, recv_timeout 5000, connect_timeout 5000 } ``` 我们也可以仅仅针对当前分布式构建服务配置超时，其他服务还是默认超时。 ```console $ cat ~/.xmake/service/client.conf { distcc_build { send_timeout 5000, recv_timeout 5000, connect_timeout 5000, } } ``` > 服务端配置同样支持超时配置。 ## 用户认证和授权 关于用户认证和授权，可以参考 [远程编译/用户认证和授权](/#/zh cn/guide/other_features?id %e7%94%a8%e6%88%b7%e8%ae%a4%e8%af%81%e5%92%8c%e6%8e%88%e6%9d%83) 里面的详细说明，用法是完全一致的。 ## 连接服务器 配置完认证和服务器地址后，就可以输入下面的命令，将当前工程连接到配置的服务器上了。 我们需要在连接时候，输入 ` distcc`，指定仅仅连接分布式服务。 ```bash $ cd projectdir $ xmake service connect distcc <client>: connect 127.0.0.1:9693 .. <client>: 127.0.0.1:9693 connected! ``` 我们也可以同时连接多个服务，比如分布式编译和远程编译缓存服务。 ```hash $ xmake service connect distcc ccache ``` > 如果不带任何参数，默认连接的是远程编译服务。 ## 分布式编译项目 连接上服务器后，我们就可以像正常本地编译那样，进行分布式编译了，例如： ```bash $ xmake ... [ 93%]: cache compiling.release src/demo/network/unix_echo_client.c > local job [ 93%]: cache compiling.release src/demo/network/ipv6.c [ 93%]: cache compiling.release src/demo/network/ping.c [ 93%]: distcc compiling.release src/demo/network/unix_echo_server.c. > distcc job [ 93%]: distcc compiling.release src/demo/network/http.c [ 93%]: distcc compiling.release src/demo/network/unixaddr.c [ 93%]: distcc compiling.release src/demo/network/ipv4.c [ 94%]: distcc compiling.release src/demo/network/ipaddr.c [ 94%]: distcc compiling.release src/demo/math/fixed.c [ 94%]: distcc compiling.release src/demo/libm/float.c [ 95%]: cache compiling.release src/demo/libm/double.c [ 95%]: cache compiling.release src/demo/other/test.cpp [ 98%]: archiving.release libtbox.a [ 99%]: linking.release demo [100%]: build ok! ``` 其中，带有 distcc 字样的是远程编译任务，其他的都是本地编译任务，默认 xmake 还开启了本地编译缓存，对分布式编译结果进行缓存，避免频繁请求服务器。 另外，我们也可以开启远程编译缓存，跟其他人共享编译缓存，进一步加速多人协同开发的编译。 ## 断开连接 ```bash $ xmake service disconnect distcc ``` ## 指定并行编译任务数 我们先简单介绍下，目前根据主机 cpu core 数量默认计算的并行任务数： ```lua local default_njob math.ceil(ncpu * 3 / 2) ``` 因此，如果不开启分布式编译，默认的最大并行编译任务数就是这个 default_njob。 如果开启分布式编译后，默认的并行编译任务数就是： ```lua local maxjobs default_njob + server_count * server_default_njob ``` ### 修改本地并行任务数 我们只需要通过 ` jN` 就能指定本地并行任务数，但是它不会影响服务端的并行任务数。 ```bash $ xmake jN ``` ### 修改服务端并行任务数 如果要修改服务端的并行任务数，需要修改客户端的配置文件。 ```bash $cat ~/.xmake/service/client.conf { distcc_build { hosts { { connect \"127.0.0.1:9693\", token \"590234653af52e91b9e438ed860f1a2b\", njob 8 < modify here }, { connect \"192.168.01:9693\", token \"590234653af52e91b9e438ed860f1a2b\", njob 4 } } } } ``` 可以对每个服务器主机，添加 `njob N` 参数配置，指定这台服务器可以提供的并行任务数。 ## 分布式编译 Android 项目 xmake 提供的分布式编译服务是完全跨平台的，并且支持 Windows, Linux, macOS, Android, iOS 甚至交叉编译。 如果要进行 Android 项目编译，只需要在服务端配置中，增加 `toolchains` 工具链配置，提供 NDK 的跟路径即可。 ```bash $ cat ~/.xmake/service/server.conf { distcc_build { listen \"0.0.0.0:9693\", toolchains { ndk { ndk \"~/files/android ndk r21e\" < here } }, workdir \"/Users/ruki/.xmake/service/server/distcc_build\" }, known_hosts { }, logfile \"/Users/ruki/.xmake/service/server/logs.txt\", tokens { \"590234653af52e91b9e438ed860f1a2b\" } } ``` 然后，我们就可以像正常本地编译那样，分布式编译 Android 项目，甚至可以配置多台 Windows, macOS, Linux 等不同的服务器主机，做为分布式编译服务的资源，来编译它。 只需要下载对应平台的 NDK 就行了。 ```bash $ xmake f p android ndk ~/files/xxxx $ xmake ``` ## 分布式编译 iOS 项目 编译 iOS 项目更加简单，因为 Xmake 通常能自动检测到 Xcode，所以只需要像正常本地一样，切一下平台到 ios 即可。 ```bash $ xmake f p iphoneos $ xmake ``` ## 分布式交叉编译配置 如果要分布式交叉编译，我们需要在服务端配置工具链 sdk 路径，例如： ```bash $ cat ~/.xmake/service/server.conf { distcc_build { listen \"0.0.0.0:9693\", toolchains { cross { sdkdir \"~/files/arm linux xxx\" < here } }, workdir \"/Users/ruki/.xmake/service/server/distcc_build\" }, known_hosts { }, logfile \"/Users/ruki/.xmake/service/server/logs.txt\", tokens { \"590234653af52e91b9e438ed860f1a2b\" } } ``` 其中，toolchains 下，每一项对应一个工具链，这里配置为 `cross {}` 交叉工具链，对应 `toolchain(\"cross\")`。 工具链里面我们可以配置 `sdkdir`, `bindir`, `cross` 等等，对应 `toolchain(\"cross\")` 里面的 `set_sdkdir`, `set_bindir` 和 `set_cross` 等接口配置。 如果交叉工具链比较规范，我们通常只需要配置 `sdkdir`，xmake 就能自动检测到。 而客户端编译也只需要指定 sdk 目录。 ```bash $ xmake f p cross sdk /xxx/arm linux xxx $ xmake ``` ## 清理服务器缓存 每个项目在服务端的编译，都会产生一些缓存文件，他们都是按工程粒度分别存储的，我们可以通过下面的命令，对当前工程清理每个服务器对应的缓存。 ```bash $ xmake service clean distcc ``` ## 一些内部优化 1. 缓存服务器端编译结果，避免重复编译 2. 本地缓存，远程缓存优化，避免不必要的服务端通信 3. 服务器负载均衡调度，合理分配服务器资源 4. 预处理后小文件直接本地编译，通常会更快 5. 大文件实时压缩传输，基于 lz4 快速压缩 6. 内部状态维护，相比 distcc 等独立工具，避免了频繁的独立进程加载耗时，也避免了与守护进程额外的通信"},"/get_started/zh/features/remote-build.html":{"title":"","content":" class: heading_no_counter # 远程编译 ## 前言 xmake 提供了远程编译支持，我们可以通过它可以远程服务器上编译代码，远程运行和调试。 服务器可以部署在 Linux/MacOS/Windows 上，实现跨平台编译，例如：在 Linux 上编译运行 Windows 程序，在 Windows 上编译运行 macOS/Linux 程序。 相比 ssh 远程登入编译，它更加的稳定，使用更加流畅，不会因为网络不稳定导致 ssh 终端输入卡顿，也可以实现本地快速编辑代码文件。 甚至我们可以在 vs/sublime/vscode/idea 等编辑器和IDE 中无缝实现远程编译，而不需要依赖 IDE 本身对远程编译的支持力度。 ## 开启服务 ```console $ xmake service <remote_build_server>: listening 0.0.0.0:9091 .. ``` 我们也可以开启服务的同时，回显详细日志信息。 ```console $ xmake service vD <remote_build_server>: listening 0.0.0.0:9091 .. ``` ## 以 Daemon 模式开启服务 ```console $ xmake service start $ xmake service restart $ xmake service stop ``` ## 配置服务端 我们首先，运行 `xmake service` 命令，它会自动生成一个默认的 `server.conf` 配置文件，存储到 `~/.xmake/service/server.conf`。 然后，我们编辑它，修复服务器的监听端口（可选）。 ```bash $ cat ~/.xmake/service/server.conf { known_hosts { }, logfile \"/Users/ruki/.xmake/service/server/logs.txt\", remote_build { listen \"0.0.0.0:9691\", workdir \"/Users/ruki/.xmake/service/server/remote_build\" }, tokens { \"e438d816c95958667747c318f1532c0f\" } } ``` ## 配置客户端 客户端配置文件在 `~/.xmake/service/client.conf`，我们可以在里面配置客户端需要连接的服务器地址。 ```console $ cat ~/.xmake/service/client.conf { remote_build { connect \"127.0.0.1:9691\", token \"e438d816c95958667747c318f1532c0f\" } } ``` ## 用户认证和授权 在实际连接之前，我们简单介绍下 xmake 提供的服务目前提供的几种认证机制。 1. Token 认证 2. 密码认证 3. 可信主机验证 ### Token 认证 这也是我们默认推荐的方式，更加安全，配置和连接也更加方便，每次连接也不用输入密码。 我们在执行 `xmake service` 命令时候，默认就会生成一个服务端和客户端的配置文件，并且自动生成一个默认的 token，因此本地直连是不需要任何配置的。 #### 服务端认证配置 服务端可以配置多个 token 用于对不同用户主机进行授权连接，当然也可以共用一个 token。 ```bash $ cat ~/.xmake/service/server.conf { known_hosts { }, logfile \"/Users/ruki/.xmake/service/server/logs.txt\", remote_build { listen \"0.0.0.0:9691\", workdir \"/Users/ruki/.xmake/service/server/remote_build\" }, tokens { \"e438d816c95958667747c318f1532c0f\" } } ``` #### 客户端认证配置 客户端只需要添加服务器上的 token 到对应的客户端配置中即可。 ```bash $ cat ~/.xmake/service/client.conf { remote_build { connect \"127.0.0.1:9691\", token \"e438d816c95958667747c318f1532c0f\" } } ``` #### 手动生成新 token 我们也可以执行下面的命令，手动生成一个新的 token，自己添加到服务器配置中。 ```bash $ xmake service gen token New token a7b9fc2d3bfca1472aabc38bb5f5d612 is generated! ``` ### 密码认证 我们也提供密码认证的授权模式，相比 token 认证，它需要用户每次连接的时候，输入密码，验证通过后，才能连接上。 #### 服务端认证配置 密码认证，我们不需要手动配置 token，只需要执行下面的命令，添加用户就行了，添加过程中，会提示用户输入密码。 ```bash $ xmake service add user ruki Please input user ruki password: 123456 Add user ruki ok! ``` 然后，xmake 就会通过用户名，密码生成一个新的 token 添加到服务器配置的 token 列表中去。 ```bash $ cat ~/.xmake/service/server.conf { known_hosts { }, logfile \"/Users/ruki/.xmake/service/server/logs.txt\", remote_build { listen \"0.0.0.0:9691\", workdir \"/Users/ruki/.xmake/service/server/remote_build\" }, tokens { \"e438d816c95958667747c318f1532c0f\", \"7889e25402413e93fd37395a636bf942\" } } ``` 当然，我们也可以删除指定的用户和密码。 ```bash $xmake service rm user ruki Please input user ruki password: 123456 Remove user ruki ok! ``` #### 客户端认证配置 对于客户端，我们不再需要设置服务器的 token 了，只需要在连接配置中，追加需要连接的用户名即可开启密码认证，格式：`user@address:port` ```bash $ cat ~/.xmake/service/client.conf { remote_build { connect \"root@127.0.0.1:9691\" } } ``` !> 如果去掉用户名，也没配置 token，那就是匿名模式，如果服务器也没配置 token，就是完全禁用认证，直接连接。 ### 可信主机验证 另外，为了更进一步提高安全性，我们还提供了服务端可信主机验证，如果在服务器配置的 known_hosts 列表中，配置了可以连接的客户端主机 ip 地址， 那么只有这些主机可以成功连接上这台服务器，其他主机对它的连接都会被提示为不可信而拒绝连接，即使 token 和密码认证都没问题也不行。 ```bash $ cat ~/.xmake/service/server.conf { logfile \"/Users/ruki/.xmake/service/logs.txt\", server { tokens { \"4b928c7563a0cba10ff4c3f5ca0c8e24\" }, known_hosts { \"127.0.0.1\", \"xx.xx.xx.xx\"} } } ``` ## 连接远程的服务器 接下来，我们只需要进入需要远程编译的工程根目录，执行 `xmake service connect` 命令，进行连接。 如果是 token 认证模式，那么不需要的额外的密码输入，直接连接。 ```console $ xmake create test $ cd test $ xmake service connect <remote_build_client>: connect 192.168.56.110:9091 .. <remote_build_client>: connected! <remote_build_client>: sync files in 192.168.56.110:9091 .. Scanning files .. Comparing 3 files .. [+]: src/main.cpp [+]: .gitignore [+]: xmake.lua 3 files has been changed! Archiving files .. Uploading files with 1372 bytes .. <remote_build_client>: sync files ok! ``` 如果是密码认证，那么会提示用户输入密码，才能继续连接。 ```bash $ xmake service connect Please input user root password: 000000 <remote_build_client>: connect 127.0.0.1:9691 .. <remote_build_client>: connected! <remote_build_client>: sync files in 127.0.0.1:9691 .. Scanning files .. Comparing 3 files .. [+]: xmake.lua [+]: .gitignore [+]: src/main.cpp 3 files has been changed! Archiving files .. Uploading files with 1591 bytes .. <remote_build_client>: sync files ok! ``` 如果密码不对，就会提示错误。 ```bash $ xmake service connect Please input user root password: 123 <remote_build_client>: connect 127.0.0.1:9691 .. <remote_build_client>: connect 127.0.0.1:9691 failed, user and password are incorrect! ``` ## 远程构建工程 连接成功后，我们就可以像正常本地编译一样，进行远程编译。 ```console $ xmake <remote_build_client>: run xmake in 192.168.56.110:9091 .. checking for platform ... macosx checking for architecture ... x86_64 checking for Xcode directory ... /Applications/Xcode.app checking for Codesign Identity of Xcode ... Apple Development: waruqi@gmail.com (T3NA4MRVPU) checking for SDK version of Xcode for macosx (x86_64) ... 11.3 checking for Minimal target version of Xcode for macosx (x86_64) ... 11.4 [ 25%]: cache compiling.release src/main.cpp [ 50%]: linking.release test [100%]: build ok! <remote_build_client>: run command ok! ``` ## 远程运行目标程序 我们也可以像本地运行调试那样，远程运行调试编译的目标程序。 ```console $ xmake run <remote_build_client>: run xmake run in 192.168.56.110:9091 .. hello world! <remote_build_client>: run command ok! ``` ## 远程重建工程 ```console $ xmake rv <remote_build_client>: run xmake rv in 192.168.56.110:9091 .. [ 25%]: cache compiling.release src/main.cpp /usr/local/bin/ccache /usr/bin/xcrun sdk macosx clang c Qunused arguments arch x86_64 mmacosx version min 11.4 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.3.sdk fvisibility hidden fvisibility inlines hidden O3 DNDEBUG o build/.objs/test/macosx/x86_64/release/src/main.cpp.o src/main.cpp [ 50%]: linking.release test \"/usr/bin/xcrun sdk macosx clang++\" o build/macosx/x86_64/release/test build/.objs/test/macosx/x86_64/release/src/main.cpp.o arch x86_64 mmacosx version min 11.4 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.3.sdk stdlib libc++ Wl, x lz [100%]: build ok! <remote_build_client>: run command ok! ``` ## 远程配置编译参数 ```console $ xmake f xxx yy ``` ## 手动同步工程文件 连接的时候，会自动同步一次代码，后期代码改动，可以执行此命令来手动同步改动的文件。 ```console $ xmake service sync <remote_build_client>: sync files in 192.168.56.110:9091 .. Scanning files .. Comparing 3 files .. [+]: src/main.cpp [+]: .gitignore [+]: xmake.lua 3 files has been changed! Archiving files .. Uploading files with 1372 bytes .. <remote_build_client>: sync files ok! ``` ## 拉取远程文件 v2.7.1 版本我们新增了一个参数用于拉取远程指定的文件，通常我们可以用来完成构建后目标文件的拉取，将编译后的库文件下载到本地。 例如： ```bash xmake service pull 'build/**' outputdir ``` 我们可以指定远程路径 `build/**` ，将所有匹配的文件全部拉取到本地 outputdir 目录下。 ## 断开远程连接 针对当前工程，断开连接，这仅仅影响当前工程，其他项目还是可以同时连接和编译。 ```console $ xmake service disconnect <remote_build_client>: disconnect 192.168.56.110:9091 .. <remote_build_client>: disconnected! ``` ## 查看服务器日志 ```console $ xmake service logs ``` ## 清理远程服务缓存和构建文件 我们也可以手动清理远程的任何缓存和构建生成的文件。 ```console $ cd projectdir $ xmake service clean ```"},"/get_started/zh/features/try-build.html":{"title":"","content":" class: heading_no_counter # 尝试使用其他构建系统 xmake 直接对接了其他第三方构建系统，即使其他项目中没有使用 xmake.lua 来维护，xmake 也可以直接调用其他构建工具来完成编译。 那用户直接调用使用第三方构建工具来编译不就行了，为啥还要用 xmake 去调用呢？主要有以下好处： 1. 完全的行为一致，简化编译流程，不管用了哪个其他构建系统，都只需要执行 xmake 这个命令就可以编译，用户不再需要去研究其他工具的不同的编译流程 2. 完全对接 `xmake config` 的配置环境，复用 xmake 的平台探测和 sdk 环境检测，简化平台配置 3. 对接交叉编译环境，即使是用 autotools 维护的项目，也能通过 xmake 快速实现交叉编译 目前已支持的构建系统： * autotools（已完全对接 xmake 的交叉编译环境） * xcodebuild * cmake（已完全对接 xmake 的交叉编译环境） * make * msbuild * scons * meson * bazel * ndkbuild * ninja ## 自动探测构建系统并编译 例如，对于一个使用 cmake 维护的项目，直接在项目根目录执行 xmake，就会自动触发探测机制，检测到 CMakeLists.txt，然后提示用户是否需要使用 cmake 来继续完成编译。 ```bash $ xmake note: CMakeLists.txt found, try building it (pass y or confirm y/n/d to skip confirm)? please input: y (y/n) Symbol prefix: Configuring done Generating done Build files have been written to: /Users/ruki/Downloads/libpng 1.6.35/build [7%] Built target png fix itxt [21%] Built target genfiles [81%] Built target png [83%] Built target png_static ... output to /Users/ruki/Downloads/libpng 1.6.35/build/artifacts build ok! ``` ## 无缝对接 xmake 命令 目前支持 `xmake clean`, `xmake rebuild` 和 `xmake config` 等常用命令与第三方系统的无缝对接。 我们可以直接清理 cmake 维护项目的编译输出文件 ```bash $ xmake clean $ xmake clean all ``` 如果带上 ` all` 执行清理，会清除 autotools/cmake 生成的所有文件，不仅仅只清理对象文件。 默认 `xmake` 对接的是增量构建行为，不过我们也可以强制快速重建： ```bash $ xmake rebuild ``` ## 手动切换指定构建系统 如果一个项目下有多个构建系统同时在维护，比如 libpng 项目，自带 autotools/cmake/makefile 等构建系统维护，xmake 默认优先探测使用了 autotools，如果想要强制切换其他构建系统，可以执行： ```bash $ xmake f trybuild [autotoolscmakemakemsbuild ..] $ xmake ``` 另外，配置了 ` trybuild ` 参数手动指定了默认的构建系统，后续的 build 过程就不会额外提示用户选择了。 ## 实现快速交叉编译 众所周知，cmake/autotools 维护的项目虽然很多都支持交叉编译，但是交叉编译的配置过程很复杂，不同的工具链处理方式还有很多的差异，中途会踩到很多的坑。 即使跑通了一个工具链的交叉编译，如果切到另外一个工具链环境，可能又要折腾好久，而如果使用 xmake，通常只需要两条简单的命令即可： > 目前 cmake/autotools 都已对接支持了 xmake 的交叉编译。 ### 交叉编译 android 平台 ```bash $ xmake f p android trybuild autotools [ ndk xxx] $ xmake ``` > 其中， ndk 参数配置是可选的，如果用户设置了 ANDROID_NDK_HOME 环境变量，或者 ndk 放置在 `~/Library/Android/sdk/ndk bundle`，xmake 都能自动检测到。 是不是很简单？如果你觉得这没啥，那么可以对比下直接操作 `./configure` 去配置交叉编译，可以看下这篇文档对比下：[将 NDK 与其他编译系统配合使用](https://developer.android.com/ndk/guides/other_build_systems#autoconf) 说白了，你大概得这样，还不一定一次就能搞定： ```bash $ export TOOLCHAIN $NDK/toolchains/llvm/prebuilt/$HOST_TAG $ export AR $TOOLCHAIN/bin/aarch64 linux android ar $ export AS $TOOLCHAIN/bin/aarch64 linux android as $ export CC $TOOLCHAIN/bin/aarch64 linux android21 clang $ export CXX $TOOLCHAIN/bin/aarch64 linux android21 clang++ $ export LD $TOOLCHAIN/bin/aarch64 linux android ld $ export RANLIB $TOOLCHAIN/bin/aarch64 linux android ranlib $ export STRIP $TOOLCHAIN/bin/aarch64 linux android strip $ ./configure host aarch64 linux android $ make ``` 如果是 cmake 呢，交叉编译也不省事，对于 android 平台，得这么配置。 ```bash $ cmake \\ DCMAKE_TOOLCHAIN_FILE $NDK/build/cmake/android.toolchain.cmake \\ DANDROID_ABI $ABI \\ DANDROID_NATIVE_API_LEVEL $MINSDKVERSION \\ $OTHER_ARGS ``` 而对于 ios 平台，没找到简单的配置方式，就找到个第三方的 ios 工具链配置，很复杂：<https://github.com/leetal/ios cmake/blob/master/ios.toolchain.cmake> 而对接了 xmake 后，不管是 cmake 还是 autotools，交叉编译都是非常简单的，而且配置方式也完全一样，精简一致。 ### 交叉编译 iphoneos 平台 ```bash $ xmake f p iphoneos trybuild [cmakeautotools] $ xmake ``` ### 使用其他交叉编译工具链 ```bash $ xmake f p cross trybuild [cmakeautotools] sdk /xxxx $ xmake ``` 关于更多交叉编译的配置细节，请参考文档：[交叉编译](https://xmake.io/#/zh cn/guide/configuration?id %e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91)，除了多了一个 ` trybuild ` 参数，其他交叉编译配置参数都是完全通用的。 ## 传递用户配置参数 我们可以通过 ` tryconfigs ` 来传递用户额外的配置参数到对应的第三方构建系统，比如：autotools 会传递给 `./configure`，cmake 会传递给 `cmake` 命令。 ```bash $ xmake f trybuild autotools tryconfigs \" enable shared no\" $ xmake ``` 比如上述命令，传递 ` enable shared no` 给 `./configure`，来禁用动态库编译。 另外，对于 ` cflags`, ` includedirs` 和 ` ldflags` 等参数，不需要通过 ` tryconfigs`，通过 `xmake config cflags ` 等内置参数就可透传过去。 ## 编译其他构建系统过程示例 ### 通用编译方式 大多数情况下，每个构建系统对接后的编译方式都是一致的，除了 ` trybuild ` 配置参数除外。 ```bash $ xmake f trybuild [autotoolscmakemesonninjabazelmakemsbuildxcodebuild] $ xmake ``` !> 我们还需要确保 trybuild 指定的构建工具已经安装能够正常使用。 ### 构建 Android jni 程序 如果当前项目下存在 `jni/Android.mk`，那么 xmake 可以直接调用 ndk build 来构建 jni 库。 ```bash $ xmake f p android trybuild ndkbuild [ ndk ] $ xmake ``` 如果觉得命令行编译 jni 比较麻烦，xmake 也提供了相关的 gradle 集成插件 [xmake gradle](https://github.com/xmake io/xmake gradle)，可以无缝集成 xmake 进行 jni 库的编译集成，具体详情见：[使用 xmake gradle 插件构建 JNI 程序](https://xmake.io/#/zh cn/plugin/more_plugins?id gradle%e6%8f%92%e4%bb%b6%ef%bc%88jni%ef%bc%89)"},"/get_started/zh/features/build-cache.html":{"title":"","content":" class: heading_no_counter # 编译缓存 ## 本地编译缓存 默认情况下，如果你本机安装了 ccache，xmake 就会使用外置的 ccache。如果本机没有安装 ccache，就会降级到 xmake 内置的 xcache 跨平台本地缓存方案。 相比 ccache 等第三方独立进程，xmake 内部状态维护，更加便于优化，也避免了频繁的独立进程加载耗时，也避免了与守护进程额外的通信。 另外，内置的缓存能够更好的支持跨平台，Windows 上 msvc 也能够很好的支持，而 ccache 仅仅支持 gcc/clang。 当然，我们也可以通过下面的命令禁用缓存。 ```bash $ xmake f ccache n ``` 注：不管是否使用内置本地缓存，配置名都是 ` ccache `，意思是 c/c++ 构建缓存，而不仅仅是指 ccache 工具的名字。 我们如果想继续使用外置的其他缓存工具，我们也是可以通过下面的方式来配置。 ```bash $ xmake f ccache n cxx \"ccache gcc\" cc \"ccache gcc\" $ xmake ``` ## 远程编译缓存 除了本地缓存，我们也提供了远程缓存服务，类似 mozilla 的 sscache，如果只是个人开发，平常不会用到它。 但是，如果是公司内部多人协同开发一个大型项目，仅仅靠分布式编译和本地缓存，是不够的。我们还需要对编译的对象文件缓存到独立的服务器上进行共享。 这样，其他人即使首次编译，也不需要每次都去分布式编译它，直接从远程拉取缓存来加速编译。 另外，Xmake 提供的远程缓存服务，也是全平台支持的，不仅支持 gcc/clang 还支持 msvc。 ### 开启服务 我们可以指定 ` ccache` 参数来开启远程编译缓存服务，当然如果不指定这个参数，xmake 会默认开启所有服务端配置的服务。 ```console $ xmake service ccache <remote_cache_server>: listening 0.0.0.0:9092 .. ``` 我们也可以开启服务的同时，回显详细日志信息。 ```console $ xmake service ccache vD <remote_cache_server>: listening 0.0.0.0:9092 .. ``` ### 以 Daemon 模式开启服务 ```console $ xmake service ccache start $ xmake service ccache restart $ xmake service ccache stop ``` ### 配置服务端 我们首先，运行 `xmake service` 命令，它会自动生成一个默认的 `server.conf` 配置文件，存储到 `~/.xmake/service/server.conf`。 ```bash $ xmake service generating the config file to /Users/ruki/.xmake/service/server.conf .. an token(590234653af52e91b9e438ed860f1a2b) is generated, we can use this token to connect service. generating the config file to /Users/ruki/.xmake/service/client.conf .. <remote_cache_server>: listening 0.0.0.0:9692 .. ``` 然后，我们编辑它，修复服务器的监听端口（可选）。 ```bash $ cat ~/.xmake/service/server.conf { distcc_build { listen \"0.0.0.0:9692\", workdir \"/Users/ruki/.xmake/service/server/remote_cache\" }, known_hosts { }, logfile \"/Users/ruki/.xmake/service/server/logs.txt\", tokens { \"590234653af52e91b9e438ed860f1a2b\" } } ``` ### 配置客户端 客户端配置文件在 `~/.xmake/service/client.conf`，我们可以在里面配置客户端需要连接的服务器地址。 我们可以在 hosts 列表里面配置多个服务器地址，以及对应的 token。 ```console $cat ~/.xmake/service/client.conf { remote_cache { connect \"127.0.0.1:9692, token \"590234653af52e91b9e438ed860f1a2b\" } } } ``` #### 配置超时 默认情况下，客户端连接，收发数据都是无限等待不超时的，但是如果访问服务端的网络不稳定，那么有可能会导致访问卡死，这个时候可以配置超时来解决。 如果发生超时异常，就会自动退化到本地缓存，不会永远卡死。 我们可以配置，`send_timeout`, `recv_timeout` 和 `connect_timeout` 三种超时，如果在根节点设置，那么所有客户端服务都会生效。 ```console $ cat ~/.xmake/service/client.conf { send_timeout 5000, recv_timeout 5000, connect_timeout 5000 } ``` 我们也可以仅仅针对当前远程缓存服务配置超时，其他服务还是默认超时。 ```console $ cat ~/.xmake/service/client.conf { distcc_build { send_timeout 5000, recv_timeout 5000, connect_timeout 5000, } } ``` > 服务端配置同样支持超时配置。 ### 用户认证和授权 关于用户认证和授权，可以参考 [远程编译 / 用户认证和授权](/#/zh cn/guide/other_features?id %e7%94%a8%e6%88%b7%e8%ae%a4%e8%af%81%e5%92%8c%e6%8e%88%e6%9d%83) 里面的详细说明，用法是完全一致的。 ### 连接服务器 配置完认证和服务器地址后，就可以输入下面的命令，将当前工程连接到配置的服务器上了。 我们需要在连接时候，输入 ` ccache`，指定仅仅连接远程编译缓存服务。 ```bash $ cd projectdir $ xmake service connect ccache <client>: connect 127.0.0.1:9692 .. <client>: 127.0.0.1:9692 connected! ``` 我们也可以同时连接多个服务，比如分布式编译和远程编译缓存服务。 ```hash $ xmake service connect distcc ccache ``` > 如果不带任何参数，默认连接的是远程编译服务。 ### 断开连接 ```bash $ xmake service disconnect ccache ``` ### 清理服务器缓存 我们也可以通过下面的命令，清理当前工程对应的远程服务器上的缓存。 ```bash $ xmake service clean ccache ``` 而如果我们执行 `xmake clean all`，在连接了远程服务的状态下，也会去自动清理所有的缓存。 ### 一些内部优化 1. 拉取远程缓存的快照，通过 bloom filter + lz4 回传本地后，用于快速判断缓存是否存在，避免频繁的查询服务端缓存信息 2. 配合本地缓存，可以避免频繁地请求远程服务器，拉取缓存。 3. 内部状态维护，相比 sscache 等独立工具，避免了频繁的独立进程加载耗时，也避免了与守护进程额外的通信"},"/get_started/zh/xrepo/usage.html":{"title":"","content":" class: heading_no_counter # xrepo xrepo 是一个基于 [Xmake](https://github.com/xmake io/xmake) 的跨平台 C/C++ 包管理器。 它基于 xmake 提供的运行时，但却是一个完整独立的包管理程序，相比 vcpkg/homebrew 此类包管理器，xrepo 能够同时提供更多平台和架构的 C/C++ 包。 并且还支持多版本语义选择，另外它还是一个去中心化的分布式仓库，不仅仅提供了官方的 [xmake repo](https://github.com/xmake io/xmake repo) 仓库，还支持用户自建多个私有仓库。 同时，xrepo 也支持从 vcpkg/homebrew/conan 等第三方包管理器中安装包，并提供统一一致的库链接信息，方便与第三方项目的集成对接。 ## 安装 我们只需要安装上 xmake 就可以使用 xrepo 命令。 ## 支持平台 * macOS (i386, x86_64, arm64) * Linux (i386, x86_64, cross toolchains ..) * BSD (i386, x86_64) * Android (x86, x86_64, armeabi, armeabi v7a, arm64 v8a) * iOS (armv7, armv7s, arm64, i386, x86_64) * Cross Toolchains ## 分布式仓库支持 除了可以直接从官方仓库：[xmake repo](https://github.com/xmake io/xmake repo) 检索安装包之外， 我们还可以添加任意多个自建的仓库，甚至可以完全隔离外网，仅仅在公司内部网络维护私有包的安装集成。 只需要通过下面的命令，添加上自己的仓库地址： ```console $ xrepo add repo myrepo https://github.com/mygroup/myrepo ``` ## 与 xmake 的工程无缝集成 ```lua add_requires(\"tbox>1.6.1\", \"libuv master\", \"vcpkg::ffmpeg\", \"brew::pcre2/libpcre2 8\") add_requires(\"conan::openssl/1.1.1g\", {alias \"openssl\", optional true, debug true}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"tbox\", \"libuv\", \"vcpkg::ffmpeg\", \"brew::pcre2/libpcre2 8\", \"openssl\") end) ``` 下面是与 xmake 集成的整体架构和编译流程。 <img src \"https://xmake.io/assets/img/index/package_arch.png\" width \"650px\" /> ## 快速上手 ### 安装包 #### 基本使用 ```bash $ xrepo install zlib tbox ``` #### 安装指定版本包 完整支持 Semantic Versioning (语义版本)。 ```bash $ xrepo install \"zlib 1.2.x\" $ xrepo install \"zlib > 1.2.0\" ``` #### 安装指定平台包 ```bash $ xrepo install p iphoneos a arm64 zlib $ xrepo install p android [ ndk /xxx] zlib $ xrepo install p mingw [ mingw /xxx] zlib $ xrepo install p cross sdk /xxx/arm linux musleabi cross zlib ``` #### 安装调试版本包 ```bash $ xrepo install m debug zlib ``` #### 安装动态库版本包 ```bash $ xrepo install k shared zlib ``` #### 安装指定配置包 ```bash $ xrepo install f \"vs_runtime 'MD'\" zlib $ xrepo install f \"regex true,thread true\" boost ``` #### 安装第三方包管理器的包 ```bash $ xrepo install brew::zlib $ xrepo install vcpkg::zlib $ xrepo install conan::zlib/1.2.11 ``` ### 查找包的库使用信息 ```bash $ xrepo fetch pcre2 { { linkdirs { \"/usr/local/Cellar/pcre2/10.33/lib\" }, links { \"pcre2 8\" }, defines { \"PCRE2_CODE_UNIT_WIDTH 8\" }, includedirs \"/usr/local/Cellar/pcre2/10.33/include\" } } ``` ```bash $ xrepo fetch ldflags openssl L/Users/ruki/.xmake/packages/o/openssl/1.1.1/d639b7d6e3244216b403b39df5101abf/lib lcrypto lssl ``` ```bash $ xrepo fetch cflags openssl I/Users/ruki/.xmake/packages/o/openssl/1.1.1/d639b7d6e3244216b403b39df5101abf/include ``` ```bash $ xrepo fetch p [iphoneosandroid] cflags \"zlib 1.2.x\" I/Users/ruki/.xmake/packages/z/zlib/1.2.11/df72d410e7e14391b1a4375d868a240c/include ``` ```bash $ xrepo fetch cflags ldflags conan::zlib/1.2.11 I/Users/ruki/.conan/data/zlib/1.2.11/_/_/package/f74366f76f700cc6e991285892ad7a23c30e6d47/include L/Users/ruki/.conan/data/zlib/1.2.11/_/_/package/f74366f76f700cc6e991285892ad7a23c30e6d47/lib lz ``` ### 导出安装后的包 xrepo 可以快速导出已经安装后的包，包括对应的库文件，头文件等等。 ```bash $ xrepo export o /tmp/output zlib ``` ### 搜索支持的包 ```bash $ xrepo search zlib \"pcr*\" zlib: > zlib: A Massively Spiffy Yet Delicately Unobtrusive Compression Library (in xmake repo) pcr*: > pcre2: A Perl Compatible Regular Expressions Library (in xmake repo) > pcre: A Perl Compatible Regular Expressions Library (in xmake repo) ``` ### 查看包环境信息 ```bash $ xrepo env show luajit { OLDPWD \"/mnt/tbox\", HOME \"/home/ruki\", PATH \"/home/ruki/.xmake/packages/l/luajit/2.1.0 beta3/fbac76d823b844f0b91abf3df0a3bc61/bin:/tmp:/tmp/arm linux musleabi cross/bin:~/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", TERM \"xterm\", PWD \"/mnt/xmake\", XMAKE_PROGRAM_DIR \"/mnt/xmake/xmake\", HOSTNAME \"e6edd61ff1ab\", LD_LIBRARY_PATH \"/home/ruki/.xmake/packages/l/luajit/2.1.0 beta3/fbac76d823b844f0b91abf3df0a3bc61/lib\", SHLVL \"1\", _ \"/mnt/xmake/scripts/xrepo.sh\" } ``` ### 包虚拟环境 #### 进入虚拟环境 我们可以通过在当前目录下，添加 xmake.lua 文件，定制化一些包配置，然后进入特定的包虚拟环境。 ```lua add_requires(\"zlib 1.2.11\") add_requires(\"python 3.x\", \"luajit\") ``` ```bash $ xrepo env shell > python version > luajit version ``` 我们也可以在 xmake.lua 配置加载对应的工具链环境，比如加载 vs 的编译环境。 ```lua set_toolchains(\"msvc\") ``` #### 管理虚拟环境 我们可以使用下面的命令，把指定的虚拟环境配置全局注册到系统中，方便快速切换。 ```bash $ xrepo env add /tmp/base.lua ``` 这个时候，我们就保存了一个名叫 base 的全局虚拟环境，我们可以通过 list 命令去查看它。 ```bash $ xrepo env list /Users/ruki/.xmake/envs: base envs(1) found! ``` 我们也可以删除它。 ```bash $ xrepo env remove base ``` #### 切换全局虚拟环境 如果我们注册了多个虚拟环境，我们也可以快速切换它们。 ```bash $ xrepo env b base shell > python version ``` 或者直接加载指定虚拟环境运行特定命令 ```bash $ xrepo env b base python version ``` `xrepo env b/ bind` 就是绑定指定的虚拟环境，更多详情见：[#1762](https://github.com/xmake io/xmake/issues/1762) #### 快速切换临时虚拟环境 我们不仅可以通过配置 `myenv.lua` 等环境配置文件，来管理切换环境，也可以直接在命令行临时指定需要绑定的环境包列表，实现快速切换，无需任何配置。 例如，我们想进入一个带有 python 3.0, luajit 和 cmake 的环境，只需要执行： ```bash $ xrepo env b \"python 3.x,luajit,cmake\" shell [python,luajit,cmake] $ python version Python 3.10.6 [python,luajit,cmake] $ cmake version cmake version 3.25.3 ``` xmake 会自动安装相关依赖，然后开启一个新的 shell 环境，新环境终端左边也有 prompt 提示。 如果我们想退出当前环境，仅仅需要执行 ```bash [python,luajit,cmake] $ xrepo env quit $ ``` ### 查看包信息 ```bash $ xrepo info zlib The package info of project: require(zlib): > description: A Massively Spiffy Yet Delicately Unobtrusive Compression Library > version: 1.2.11 > urls: > http://zlib.net/zlib 1.2.11.tar.gz > c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1 > https://downloads.sourceforge.net/project/libpng/zlib/1.2.11/zlib 1.2.11.tar.gz > c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1 > repo: xmake repo https://gitee.com/tboox/xmake repo.git master > cachedir: /Users/ruki/.xmake/cache/packages/2010/z/zlib/1.2.11 > installdir: /Users/ruki/.xmake/packages/z/zlib/1.2.11/d639b7d6e3244216b403b39df5101abf > searchdirs: > searchnames: zlib 1.2.11.tar.gz > fetchinfo: 1.2.11, system > version: 1.2.11 > links: z > linkdirs: /usr/local/Cellar/zlib/1.2.11/lib > includedirs: /usr/local/Cellar/zlib/1.2.11/include > platforms: iphoneos, mingw@windows, macosx, mingw@linux,macosx, android@linux,macosx, windows, linux > requires: > plat: macosx > arch: x86_64 > configs: > debug: false > vs_runtime: MT > shared: false > configs: > configs (builtin): > debug: Enable debug symbols. (default: false) > shared: Enable shared library. (default: false) > cflags: Set the C compiler flags. > cxflags: Set the C/C++ compiler flags. > cxxflags: Set the C++ compiler flags. > asflags: Set the assembler flags. > vs_runtime: Set vs compiler runtime. (default: MT) > values: {\"MT\",\"MD\"} ``` ### 下载包源码 我们可以使用 `xrepo download` 命令，仅仅下载指定包的源码，而不去安装它。 ```bash $ xrepo download zlib $ xrepo download \"zlib 2.x\" ``` 默认的下载目录就是当前的目录下 `packages` 子目录中，我们也可以通过 ` o outputdir` 参数修改下载目录。 ```bash $ xrepo download o /tmp zlib ```"},"/get_started/zh/package/local-3rd-source-package.html":{"title":"","content":" class: heading_no_counter # 继承本地第三方源码库 ## 集成 CMake 代码库 我们能够通过 xmake 的包模式直接集成自己项目中带有 CMakeLists.txt 的代码库，而不是通过远程下载安装。 相关 issues: [#1714](https://github.com/xmake io/xmake/issues/1714) 例如，我们有如下项目结构： ``` ├── foo │   ├── CMakeLists.txt │   └── src │   ├── foo.c │   └── foo.h ├── src │   └── main.c ├── test.lua └── xmake.lua ``` foo 目录下是一个使用 cmake 维护的静态库，而根目录下使用了 xmake 来维护，我们可以在 xmake.lua 中通过定义 `package(\"foo\")` 包来描述如何构建 foo 代码库。 ```lua add_rules(\"mode.debug\", \"mode.release\") package(\"foo\", function() add_deps(\"cmake\") set_sourcedir(path.join(os.scriptdir(), \"foo\")) on_install(function (package) local configs {} table.insert(configs, \" DCMAKE_BUILD_TYPE \" .. (package:debug() and \"Debug\" or \"Release\")) table.insert(configs, \" DBUILD_SHARED_LIBS \" .. (package:config(\"shared\") and \"ON\" or \"OFF\")) import(\"package.tools.cmake\").install(package, configs) end) on_test(function (package) assert(package:has_cfuncs(\"add\", {includes \"foo.h\"})) end) end) add_requires(\"foo\") target(\"demo\") set_kind(\"binary\") add_files(\"src/main.c\") add_packages(\"foo\") ``` 其中，我们通过 `set_sourcedir()` 来设置 foo 包的代码目录位置，然后通过 import 导入 `package.tools.cmake` 辅助模块来调用 cmake 构建代码，xmake 会自动获取生成的 libfoo.a 和对应的头文件。 > 如果仅仅本地源码集成，我们不需要额外设置 `add_urls` 和 `add_versions`。 关于包的配置描述，详情见：[包描述说明](https://xmake.io/#/zh cn/package/remote_package?id %e5%8c%85%e6%8f%8f%e8%bf%b0%e8%af%b4%e6%98%8e) 定义完包后，我们就可以通过 `add_requires(\"foo\")` 和 `add_packages(\"foo\")` 来集成使用它了，就跟集成远程包一样的使用方式。 另外，`on_test` 是可选的，如果想要严格检测包的编译安装是否成功，可以在里面做一些测试。 完整例子见：[Library with CMakeLists](https://github.com/xmake io/xmake/tree/master/tests/projects/c/library_with_cmakelists) ## 集成 Meson 代码库 xmake 支持集成更多其他构建系统维护的第三方源码库，比如 meson，仅仅只需要导入使用 `package.tools.meson` 辅助构建模块调用 meson 来构建它们。 例如，我们从 xmake repo 仓库中挑选一个使用 meson 构建的包作为例子： ```lua package(\"harfbuzz\", function() set_sourcedir(path.join(os.scriptdir(), \"3rd/harfbuzz\")) add_deps(\"meson\") if not is_plat(\"windows\") then add_deps(\"freetype\") end on_load(\"windows\", \"linux\", \"macosx\", function (package) if package:config(\"icu\") then package:add(\"deps\", \"icu4c\") end end) on_install(\"windows\", \"linux\", \"macosx\", function (package) local configs {\" Dtests disabled\", \" Ddocs disabled\", \" Dbenchmark disabled\", \" Dcairo disabled\", \" Dfontconfig disabled\", \" Dglib disabled\", \" Dgobject disabled\"} table.insert(configs, \" Ddefault_library \" .. (package:config(\"shared\") and \"shared\" or \"static\")) if package:is_plat(\"windows\") then table.insert(configs, \" Dfreetype disabled\") end import(\"package.tools.meson\").install(package, configs) end) on_test(function (package) assert(package:has_cfuncs(\"hb_buffer_add_utf8\", {includes \"harfbuzz/hb.h\"})) end) end) ``` ## 集成 autoconf 代码库 我们也可以使用 `package.tools.autoconf` 来本地集成带有 autoconf 维护的第三方代码库。 ```lua package(\"pcre2\", function() set_sourcedir(path.join(os.scriptdir(), \"3rd/pcre2\")) add_configs(\"jit\", {description \"Enable jit.\", default true, type \"boolean\"}) add_configs(\"bitwidth\", {description \"Set the code unit width.\", default \"8\", values {\"8\", \"16\", \"32\"}}) on_load(function (package) local bitwidth package:config(\"bitwidth\") or \"8\" package:add(\"links\", \"pcre2 \" .. bitwidth) package:add(\"defines\", \"PCRE2_CODE_UNIT_WIDTH \" .. bitwidth) if not package:config(\"shared\") then package:add(\"defines\", \"PCRE2_STATIC\") end end) on_install(\"macosx\", \"linux\", \"mingw\", function (package) local configs {} table.insert(configs, \" enable shared \" .. (package:config(\"shared\") and \"yes\" or \"no\")) table.insert(configs, \" enable static \" .. (package:config(\"shared\") and \"no\" or \"yes\")) if package:debug() then table.insert(configs, \" enable debug\") end if package:config(\"pic\") ~ false then table.insert(configs, \" with pic\") end if package:config(\"jit\") then table.insert(configs, \" enable jit\") end local bitwidth package:config(\"bitwidth\") or \"8\" if bitwidth ~ \"8\" then table.insert(configs, \" disable pcre2 8\") table.insert(configs, \" enable pcre2 \" .. bitwidth) end import(\"package.tools.autoconf\").install(package, configs) end) on_test(function (package) assert(package:has_cfuncs(\"pcre2_compile\", {includes \"pcre2.h\"})) end) end) ``` `package.tools.autoconf` 和 `package.tools.cmake` 模块都是可以支持 mingw/cross/iphoneos/android 等交叉编译平台和工具链的，xmake 会自动传递对应的工具链进去，用户不需要做任何其他事情。 ## 集成 Scons 代码库 我们也可以使用 `package.tools.scons` 来本地集成带有 Scons 维护的第三方代码库。 ```lua package(\"godotcpp\", function() set_sourcedir(path.join(os.scriptdir(), \"3rd/godotcpp\")) add_deps(\"scons\") add_includedirs(\"include\", \"include/core\", \"include/gen\") on_install(\"linux\", \"windows\", \"macosx\", \"mingw\", \"cygwin\", \"iphoneos\", \"android\", \"msys\", function (package) local configs {\"generate_bindings yes\"} table.insert(configs, \"bits \" .. ((package:is_arch(\"x64\") or package:is_arch(\"x86_64\")) and \"64\" or \"32\")) if package:is_plat(\"windows\") then io.replace(\"SConstruct\", \"/MD\", \"/\" .. package:config(\"vs_runtime\"), {plain true}) end this fixes an error on ios and osx (https://godotengine.org/qa/65616/problems compiling gdnative c example on osx) if package:is_plat(\"macosx\", \"iphoneos\") then io.replace(\"SConstruct\", \" std c++14\", \" std c++17\", {plain true}) end fix to use correct ranlib, @see https://github.com/godotengine/godot cpp/issues/510 if package:is_plat(\"android\") then io.replace(\"SConstruct\", [[env['AR'] toolchain + \"/bin/\" + arch_info['tool_path'] + \" ar\"]], [[env['AR'] toolchain + \"/bin/\" + arch_info['tool_path'] + \" ar\" env['RANLIB'] toolchain + \"/bin/\" + arch_info['tool_path'] + \" ranlib\"]], {plain true}) end import(\"package.tools.scons\").build(package, configs) os.cp(\"bin/*.\" .. (package:is_plat(\"windows\") and \"lib\" or \"a\"), package:installdir(\"lib\")) os.cp(\"include/core/*.hpp\", package:installdir(\"include/core\")) os.cp(\"include/gen/*.hpp\", package:installdir(\"include/gen\")) os.cp(\"godot headers/android\", package:installdir(\"include\")) os.cp(\"godot headers/arvr\", package:installdir(\"include\")) os.cp(\"godot headers/gdnative\", package:installdir(\"include\")) os.cp(\"godot headers/nativescript\", package:installdir(\"include\")) os.cp(\"godot headers/net\", package:installdir(\"include\")) os.cp(\"godot headers/pluginscript\", package:installdir(\"include\")) os.cp(\"godot headers/videodecoder\", package:installdir(\"include\")) os.cp(\"godot headers/*.h\", package:installdir(\"include\")) end) end) ``` ## 集成 makefile 代码库 ### 使用 Nmake 我们也可以使用 `package.tools.nmake` 来本地集成带有 nmake 维护的第三方代码库。 `nmake.install` 会自动绑定当前用户的 msvc 构建环境，确保用户能够顺利调用到 nmake.exe 以及 msbuild 和 cl.exe 等程序。 ```lua package(\"libxml2\", function() set_sourcedir(path.join(os.scriptdir(), \"3rd/libxml2\")) add_includedirs(\"include/libxml2\") if is_plat(\"windows\") then add_syslinks(\"wsock32\", \"ws2_32\") end on_load(\"windows\", function (package) if not package:config(\"shared\") then package:add(\"defines\", \"LIBXML_STATIC\") end end) on_install(\"windows\", function (package) os.cd(\"win32\") os.vrun(\"cscript configure.js iso8859x yes iconv no compiler msvc cruntime /%s debug %s prefix \\\"%s\\\"\", package:config(\"vs_runtime\"), package:debug() and \"yes\" or \"no\", package:installdir()) import(\"package.tools.nmake\").install(package, {\"/f\", \"Makefile.msvc\"}) os.tryrm(path.join(package:installdir(\"lib\"), \"libxml2_a_dll.lib\")) if package:config(\"shared\") then os.tryrm(path.join(package:installdir(\"lib\"), \"libxml2_a.lib\")) else os.tryrm(path.join(package:installdir(\"lib\"), \"libxml2.lib\")) os.tryrm(path.join(package:installdir(\"bin\"), \"libxml2.dll\")) end end) on_test(function (package) assert(package:has_cfuncs(\"xmlNewNode\", {includes {\"libxml/parser.h\", \"libxml/tree.h\"}})) end) end) ``` ### 使用 GnuMake 我们也可以使用 `package.tools.make` 来本地集成带有 gnumake 维护的第三方代码库。 ```lua package(\"openssl\", function() set_sourcedir(path.join(os.scriptdir(), \"3rd/openssl\")) add_links(\"ssl\", \"crypto\") if is_plat(\"linux\", \"cross\") then add_syslinks(\"dl\") end on_install(\"linux\", \"macosx\", function (package) https://wiki.openssl.org/index.php/Compilation_and_Installation#PREFIX_and_OPENSSLDIR os.vrun(\"./config %s openssldir \\\"%s\\\" prefix \\\"%s\\\"\", package:debug() and \" debug\" or \"\", package:installdir(), package:installdir()) import(\"package.tools.make\").install(package) end) on_test(function (package) assert(package:has_cfuncs(\"SSL_new\", {includes \"openssl/ssl.h\"})) end) end) ``` > 我们也可以直接使用 `os.vrunv(\"make\", {})` 来调用 make/gmake 程序来构建库。 ## 集成 Gn 代码库 我们也可以使用 `package.tools.gn` 来本地集成带有 GN 维护的第三方代码库。 ```lua package(\"skia\", function() set_sourcedir(path.join(os.scriptdir(), \"3rd/openssl\")) add_deps(\"gn\", \"ninja\") add_deps(\"python\", {kind \"binary\"}) on_install(\"linux\", \"macosx\", \"windows\", function (package) import(\"package.tools.gn\").install(package) end) on_test(function (package) TODO end) end) ``` 这里有完整的脚本例子：[Skia with GN](https://github.com/xmake io/xmake repo/blob/master/packages/s/skia/xmake.lua)"},"/get_started/zh/package/script-scope.html":{"title":"","content":" class: heading_no_counter # 脚本域 此页面描述了 [包依赖管理](zh cn/manual/package_dependencies.html) 的 `on_load()`、`on_install()` 或 `on_test()` 等函数的 `package` 接口 ## package:name 获取包的名字。 ## package:get 获取包在描述域的配置值。 任何在描述域的 `set_xxx` 和 `add_xxx` 配置值都可以通过这个接口获取到。 ```lua get the dependencies package:get(\"deps\") get the links package:get(\"links\") get the defined macros package:get(\"defines\") ``` ## package:set 设置包的配置值，（如果你想添加值可以用 [package:add](#packageadd)）。 ```lua set the dependencies package:set(\"deps\", \"python\") set the links package:set(\"links\", \"sdl2\") set the defined macros package:set(\"defines\", \"SDL_MAIN_HANDLED\") ``` ## package:add 按名称添加到包的值。 ```lua add dependencies package:add(\"deps\", \"python\") add links package:add(\"links\", \"sdl2\") add defined macros package:add(\"defines\", \"SDL_MAIN_HANDLED\") ``` ## package:license 获取包的许可证（同 `package:get(\"license\")`）。 ## package:description 获取包的描述（同 `package:get(\"description\")`）。 ## package:plat 获取包的平台。 可以是以下任何一种： windows linux macosx android iphoneos watchos mingw cygwin bsd 如果包是二进制的，则会返回 [`os.host`](zh cn/manual/builtin_modules.md#oshost) 的值。 ## package:arch 获取包的架构（例如 x86、x64、x86_64）。 如果包是二进制的，则返回 [`os.arch`](zh cn/manual/builtin_modules.md#osarch)。 ## package:targetos 获取包的目标操作系统，可以具有与 [package:plat](#packageplat) 相同的值。 ## package:targetarch 获取包的目标架构，可以具有与 [package:arch](#packagearch) 相同的值。 ## package:is_plat 当前平台是否是给定平台之一。 ```lua Is the current platform android? package:is_plat(\"android\") Is the current platform windows, linux or macosx? package:is_plat(\"windows\", \"linux\", \"macosx\") ``` ## package:is_arch 当前架构是否是给定架构之一。 ```lua Is the current architecture x86 package:is_arch(\"x86\") Is the current architecture x64 or x86_64 package:is_arch(\"x64\", \"x86_64\") ``` ## package:is_targetos 当前目标操作系统是否是给定操作系统之一。 ```lua Is the currently targeted OS windows? package:is_targetos(\"windows\") Is the currently targeted OS android or iphoneos? package:is_targetos(\"android\", \"iphoneos\") ``` ## package:is_targetarch 当前目标架构是否是给定架构之一。 ```lua Is the currently targeted architecture x86 package:is_targetarch(\"x86\") Is the currently targeted architecture x64 or x86_64 package:is_targetarch(\"x64\", \"x86_64\") ``` ## package:alias 获取包的别名。 如果用户像这样设置别名： ```lua add_requires(\"libsdl\", {alias \"sdl\"}) ``` 那么这个别名可以通过这个接口获取到： ```lua returns \"sdl\" package:alias() ``` ## package:urls 获取包的 urls 列表。 如果我们设置了如下 URLs： ```lua add_urls(\"https://example.com/library $(version).zip\") or so set_urls(\"https://example.com/library $(version).zip\") ``` 那么我们可以通过下面的接口来获取： ```lua returns the table {\"https://example.com/library $(version).zip\"} package:urls() ``` ## package:dep 通过名称获取包的依赖项。 该名称需要是包的依赖项。 ```lua local python package:dep(\"python\") returns \"python\" python:name() ``` ## package:deps 获取包的所有依赖项。 ```lua prints the names of all dependencies for _,dep in pairs(package:deps()) do print(dep:name()) end ``` ## package:sourcehash 获取 URL 别名的 sha256 校验和。 如果校验和是这样提供的： ```lua add_urls(\"https://example.com/library $(version).zip\", {alias \"example\"}) add_versions(\"example:2.4.1\", \"29f9983cc7196e882c4bc3d23d7492f9c47574c7cf658afafe7d00c185429941\") ``` 您可以像这样获取它： ```lua returns \"29f9983cc7196e882c4bc3d23d7492f9c47574c7cf658afafe7d00c185429941\" package:sourcehash(\"example\") or so package:sourcehash(package:url_alias(package:urls()[1])) ``` ## package:kind 获取包的类型。 可以是以下任何一种： binary toolchain (is also binary) library (default) template [#2138](https://github.com/xmake io/xmake/issues/2138) headeronly ## package:is_binary 包是否为二进制类型。 ## package:is_toolchain 报是否为工具链类型。 ## package:is_library 包是否为库类型。 ## package:is_toplevel 包是否在用户 xmake.lua 里面通过 add_requires 直接引用。 ## package:is_thirdparty 包是否由第三方包管理器提供（例如 brew、conan、vcpkg）。 ## package:is_debug 包是否以调试模式构建（同 `package:config(\"debug\")`）。 ## package:is_supported 当前平台和架构是否支持该包。 ## package:debug 包是否使用调试模式构建（不推荐使用：使用 [`package:is_debug`](#packageis_debug) 代替）。 ## package:is_cross 包是否正在交叉编译。 ## package:cachedir 获取包的缓存目录。 ## package:installdir 获取包的安装目录。 也可用于获取子目录。 如果给定的目录树不存在，它将被创建。 ```lua returns the installation directory package:installdir() returns the subdirectory include inside the installation directory package:installdir(\"include\") returns the subdirectory include/files package:installdir(\"include\", \"files\") ``` ## package:scriptdir 获取包的 xmake.lua 所在目录。 ## package:envs 获取包导出的环境变量。 ## package:getenv 获取给定的环境变量。 ```lua returns a table package:getenv(\"PATH\") ``` ## package:setenv 设置给定的环境变量。 覆盖变量。 ```lua sets PATH to {\"bin\", \"lib\"} package:setenv(\"PATH\", \"bin\", \"lib\") ``` ## package:addenv 将给定的值添加到环境变量。 ```lua adds \"bin\" and \"lib\" to PATH package:addenv(\"PATH\", \"bin\", \"lib\") ``` ## package:versions 获取包的所有版本列表。 ## package:version 获取包的版本。 它会返回一个语义版本对象，便于做版本之间的判断。 ```lua local version package:version() get the major version version:major() get the minor version version:minor() get the patch version version:patch() ``` ## package:version_str 以字符串形式获取包的版本。 ## package:config 获取包的给定配置值。 ```lua if configurations are set like so add_require(\"example\", {configs {enable_x true, value_y 6}}) these values can be retrieved like so returns true package:config(\"enable_x\") returns 6 package:config(\"value_y\") ``` ## package:config_set 设置包的给定配置值。 ```lua package:config_set(\"enable_x\", true) package:config_set(\"value_y\", 6) ``` ## package:configs 获取包的所有配置。 ```lua returns a table with the configuration names as keys and their values as values local configs package:configs() local enable_x configs[\"enable_x\"] local value_y configs[\"value_y\"] ``` ## package:buildhash 获取包的构建哈希。 它确保每个包，不同的配置安装到唯一的路径下，相互之间不冲突。 ## package:patches 获取当前版本的所有补丁 ```lua returns a table with all patches local patches package:patches() each element contains the keys \"url\" and \"sha256\" local url patches[1][\"url\"] local sha256 patches[1][\"sha256\"] ``` ## package:has_cfuncs 检测包是否具有给定的 C 函数。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:has_cfuncs(\"foo\")) you can also add configs assert(package:has_cfuncs(\"bar\", {includes \"foo_bar.h\"})) assert(package:has_cfuncs(\"blob\", {includes \"blob.h\", configs {defines \"USE_BLOB\"}})) you can even set the language assert(package:has_cfuncs(\"bla\", {configs {languages \"c99\"}})) end) ``` ## package:has_cxxfuncs 检测包是否具有给定的 C++ 函数。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:has_cxxfuncs(\"foo\")) you can also add configs assert(package:has_cxxfuncs(\"bar\", {includes \"foo_bar.hpp\"})) assert(package:has_cxxfuncs(\"blob\", {includes \"blob.hpp\", configs {defines \"USE_BLOB\"}})) you can even set the language assert(package:has_cxxfuncs(\"bla\", {configs {languages \"cxx17\"}})) end) ``` ## package:has_ctypes 检测包是否具有给定的 C 类型。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:has_ctypes(\"foo\")) you can also add configs assert(package:has_ctypes(\"bar\", {includes \"foo_bar.h\"})) assert(package:has_ctypes(\"blob\", {includes \"blob.h\", configs {defines \"USE_BLOB\"}})) you can even set the language assert(package:has_ctypes(\"bla\", {configs {languages \"c99\"}})) end) ``` ## package:has_cxxtypes 检测包是否具有给定的 C++ 类型。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:has_cxxtypes(\"foo\")) you can also add configs assert(package:has_cxxtypes(\"bar\", {includes \"foo_bar.hpp\"})) assert(package:has_cxxtypes(\"blob\", {includes \"blob.hpp\", configs {defines \"USE_BLOB\"}})) you can even set the language assert(package:has_cxxtypes(\"bla\", {configs {languages \"cxx17\"}})) end) ``` ## package:has_cincludes 检测包是否具有给定的 C 头文件。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:has_cincludes(\"foo.h\")) end) ``` ## package:has_cxxincludes 检测包是否具有给定的 C++ 头文件。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:has_cincludes(\"foo.hpp\")) end) ``` ## package:check_csnippets 检测是否可以编译和链接给定的 C 代码片段。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:check_csnippets({test [[ #define USE_BLOB #include <blob.h> void test(int argc, char** argv) { foo bar; printf(\"%s\", bar.blob); } ]]}, {configs {languages \"c99\"}, includes \"foo.h\"})) end) ``` ## package:check_cxxsnippets 检测是否可以编译和链接给定的 C++ 代码片段。 这应该在 `on_test` 中使用，如下所示： ```lua on_test(function (package) assert(package:check_cxxsnippets({test [[ #define USE_BLOB #include <blob.hpp> void test(int argc, char** argv) { foo bar(); std::cout << bar.blob; } ]]}, {configs {languages \"cxx11\"}, includes \"foo.hpp\"})) end) ``` ## package:check_fcsnippets 检测是否可以编译和链接给定的 Fortran 代码片段。 用法如上。"},"/get_started/zh/package/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 ## 仓库依赖包定义描述 可先参考官方仓库中现有包描述：[xmake repo](https://github.com/xmake io/xmake repo) 这里给个比较具有代表性的实例供参考： ```lua package(\"libxml2\", function() set_homepage(\"http://xmlsoft.org/\") set_description(\"The XML C parser and toolkit of Gnome.\") set_urls(\"https://github.com/GNOME/libxml2/archive/$(version).zip\", {excludes {\"*/result/*\", \"*/test/*\"}}) add_versions(\"v2.9.8\", \"c87793e45e66a7aa19200f861873f75195065de786a21c1b469bdb7bfc1230fb\") add_versions(\"v2.9.7\", \"31dd4c0e10fa625b47e27fd6a5295d246c883f214da947b9a4a9e13733905ed9\") if is_plat(\"macosx\", \"linux\") then add_deps(\"autoconf\", \"automake\", \"libtool\", \"pkg config\") end on_load(function (package) package:add(\"includedirs\", \"include/libxml2\") package:add(\"links\", \"xml2\") end) if is_plat(\"windows\") and winos.version():gt(\"winxp\") then on_install(\"windows\", function (package) os.cd(\"win32\") os.vrun(\"cscript configure.js iso8859x yes iconv no compiler msvc cruntime /MT debug %s prefix \\\"%s\\\"\", package:debug() and\"yes\"or\"no\", package:installdir()) os.vrun(\"nmake /f Makefile.msvc\") os.vrun(\"nmake /f Makefile.msvc install\") end) end on_install(\"macosx\", \"linux\", function (package) import(\"package.tools.autoconf\").install(package, {\" disable dependency tracking\", \" without python\", \" without lzma\"}) end) end) ``` ## package:set_homepage 设置包所在项目的官方页面地址。 ## package:set_description 设置包的相关描述信息。 一般通过 `xmake require info zlib` 查看相关包信息时候，会看到。 ## package:set_kind 设置包类型。 对于依赖库，则不用设置，如果是可执行包，需要设置为 binary。 ```lua package(\"cmake\", function() set_kind(\"binary\") set_homepage(\"https://cmake.org\") set_description(\"A cross platform family of tool designed to build, test and package software\") end) ``` ## package:set_urls 设置包源地址。 设置包的源码包或者 git 仓库地址，跟 add_urls 不同的是，此接口是覆盖性设置，而 add_urls 是追加设置，其他使用方式类似，这个根据不同需要来选择。 ## package:add_urls 添加包源地址。 添加包的源码包或者 git 仓库地址，此接口一般跟 add_version 配对使用，用于设置每个源码包的版本和对应的 sha256 值或者 git 的 commit 或者 tag 或者 branch。 > 可以通过添加多个 urls 作为镜像源，xmake 会自动检测优先选用最快的 url 进行下载，如果下载失败则会尝试其他 urls。 ```lua add_urls(\"https://github.com/protobuf c/protobuf c/releases/download/v$(version)/protobuf c $(version).tar.gz\") add_versions(\"1.3.1\", \"51472d3a191d6d7b425e32b612e477c06f73fe23e07f6a6a839b11808e9d2267\") ``` urls 里面的 `$(version)` 内置变量，会根据实际安装时候选择的版本适配进去，而版本号都是从 `add_versions` 中指定的版本列表中选择的。 如果对于 urls 里面带有比较复杂的版本串，没有跟 `add_versions` 有直接对应关系，则需要通过下面的方式定制化转换下： ```lua add_urls(\"https://sqlite.org/2018/sqlite autoconf $(version)000.tar.gz\", {version function (version) return version:gsub(\"%.\", \"\") end}) add_versions(\"3.24.0\", \"d9d14e88c6fb6d68de9ca0d1f9797477d82fc3aed613558f87ffbdbbc5ceb74a\") add_versions(\"3.23.0\", \"b7711a1800a071674c2bf76898ae8584fc6c9643cfe933cfc1bc54361e3a6e49\") ``` 当然，我们也只可以添加 git 源码地址： ```lua add_urls(\"https://gitlab.gnome.org/GNOME/libxml2.git\") ``` 如果设置的多个镜像地址对应的源码包 sha256 是不同的，我们可以通过 alias 的方式来分别设置 ```lua add_urls(\"https://ffmpeg.org/releases/ffmpeg $(version).tar.bz2\", {alias \"home\"}) add_urls(\"https://github.com/FFmpeg/FFmpeg/archive/n$(version).zip\", {alias \"github\"}) add_versions(\"home:4.0.2\", \"346c51735f42c37e0712e0b3d2f6476c86ac15863e4445d9e823fe396420d056\") add_versions(\"github:4.0.2\", \"4df1ef0bf73b7148caea1270539ef7bd06607e0ea8aa2fbf1bb34062a097f026\") ``` 我们也可以设置指定的 urls 的 http headers： ```lua add_urls(\"https://github.com/madler/zlib/archive/$(version).tar.gz\", { http_headers {\"TEST1: foo\", \"TEST2: bar\"} }) ``` ## package:add_versions 设置每个源码包的版本。 它也会设置对应的 sha256 值，具体描述见：[add_urls](#packageadd_urls) ## package:add_versionfiles 添加包版本列表。 通常我们可以通过 `add_versions` 接口添加包版本，但是如果版本越来越多，就会导致包配置太过臃肿，这个时候，我们可以使用 `add_versionfiles` 接口将所有的版本列表，存储到单独的文件中去维护。 例如： ```lua package(\"libcurl\", function() add_versionfiles(\"versions.txt\") end) ``` ```bash 8.5.0 ce4b6a6655431147624aaf582632a36fe1ade262d5fab385c60f78942dd8d87b 8.4.0 e5250581a9c032b1b6ed3cf2f9c114c811fc41881069e9892d115cc73f9e88c6 8.0.1 9b6b1e96b748d04b968786b6bdf407aa5c75ab53a3d37c1c8c81cdb736555ccf 7.87.0 5d6e128761b7110946d1276aff6f0f266f2b726f5e619f7e0a057a474155f307 7.31.0 a73b118eececff5de25111f35d1d0aafe1e71afdbb83082a8e44d847267e3e08 ... ``` ## package:add_patches 设置包补丁。 此接口用于针对源码包，在编译安装前，先打对应设置的补丁包，再对其进行编译，并且可支持同时打多个补丁。 ```lua if is_plat(\"macosx\") then add_patches(\"1.15\", \"https://raw.githubusercontent.com/Homebrew/patches/9be2793af/libiconv/patch utf8mac.diff\", \"e8128732f22f63b5c656659786d2cf76f1450008f36bcf541285268c66cabeab\") end ``` 例如，上面的代码，就是针对 macosx 下编译的时候，打上对应的 patch utf8mac.diff 补丁，并且每个补丁后面也是要设置 sha256 值的，确保完整性。 ## package:add_links 设置库链接。 默认情况下，xmake 会去自动检测安装后的库，设置链接关系，但是有时候并不是很准，如果要自己手动调整链接顺序，以及链接名，则可以通过这个接口来设置。 ```lua add_links(\"mbedtls\", \"mbedx509\", \"mbedcrypto\") ``` ## package:add_syslinks 设置系统库链接。 添加一些系统库链接，有些包集成链接的时候，还需要依赖一些系统库，才能链接通过，这个时候可以在包描述里面都附加上去。 ```lua if is_plat(\"macosx\") then add_frameworks(\"CoreGraphics\", \"CoreFoundation\", \"Foundation\") elseif is_plat(\"windows\") then add_defines(\"CAIRO_WIN32_STATIC_BUILD 1\") add_syslinks(\"gdi32\", \"msimg32\", \"user32\") else add_syslinks(\"pthread\") end ``` ## package:add_linkorders 调整包内部的链接顺序。 具体详情可以看下 target 内部对 `add_linkorders` 的文档说明，[target/add_linkorders](https://xmake.io/#/zh cn/manual/project_target?id targetadd_linkorders)。 ```lua package(\"libpng\", function() add_linkorders(\"png16\", \"png\", \"linkgroup::foo\") add_linkgroups(\"dl\", {name \"foo\", group true}) end) ``` ## package:add_linkgroups 配置包的链接组。 具体详情可以看下 target 内部对 `add_linkgroups` 的文档说明，[target/add_linkgroups](https://xmake.io/#/zh cn/manual/project_target?id targetadd_linkgroups)。 ```lua package(\"libpng\", function() add_linkorders(\"png16\", \"png\", \"linkgroup::foo\") add_linkgroups(\"dl\", {name \"foo\", group true}) end) ``` ## package:add_frameworks 添加依赖的系统 frameworks 链接。 示例见：[add_syslinks](#packageadd_syslinks) ## package:add_linkdirs 添加链接目录。 包的链接库搜索目录也是可以调整的，不过通常都不需要，除非一些库安装完不在 prefix/lib 下面，而在 lib 的子目录下，默认搜索不到的话。 ## package:add_includedirs 添加其他头文件搜索目录。 ## package:add_bindirs 添加可执行文件目录。 默认情况下，如果配置了 `set_kind(\"binary\")` 或者 `set_kind(\"toolchain\")` 作为可执行的包。 那么，它默认会将 bin 目录作为可执行目录，并且自动将它加入到 PATH 环境变量中去。 而如果对应 library 包，想要将里面附带编译的一些可执行工具开放给用户执行，那么需要在包中配置 `package:addenv(\"PATH\", \"bin\")` 中才行。 而通过这个接口去配置 `add_bindirs(\"bin\")` ，那么将会自动将 bin 添加到 PATH，不再需要单独配置 PATH，另外，这也提供了一种可以修改可执行目录的方式。 ## package:add_defines 添加宏定义。 可以对集成的包对外输出一些特定的定义选项。 ## package:add_configs 添加包配置。 我们可以通过此接口添加每个包的对外输出配置参数： ```lua package(\"pcre2\", function() set_homepage(\"https://www.pcre.org/\") set_description(\"A Perl Compatible Regular Expressions Library\") add_configs(\"bitwidth\", {description \"Set the code unit width.\", default \"8\", values {\"8\", \"16\", \"32\"}}) on_load(function (package) local bitwidth package:config(\"bitwidth\") or \"8\" package:add(\"links\", \"pcre2 \" .. bitwidth) package:add(\"defines\", \"PCRE2_CODE_UNIT_WIDTH \" .. bitwidth) end) end) ``` 在工程项目里面，我们也可以查看特定包的可配置参数和值列表： ```bash $ xmake require info pcre2 The package info of project: require(pcre2): > description: A Perl Compatible Regular Expressions Library > version: 10.31 ... > configs: > bitwidth: > description: Set the code unit width. > values: {\"8\",\"16\",\"32\"} > default: 8 ``` 然后在项目里面，启用这些配置，编译集成带有特定配置的包： ```lua add_requires(\"pcre2\", {configs {bitwidth 16}}) ``` ## package:add_extsources 添加扩展的包源。 支持 `add_extsources` 和 `on_fetch` 两个配置接口，可以更好的配置 xmake 在安装 C/C++ 包的过程中，对系统库的查找过程。 至于具体背景，我们可以举个例子，比如我们在 [xmake repo](https://github.com/xmake io/xmake repo) 仓库新增了一个 `package(\"libusb\")` 的包。 那么用户就可以通过下面的方式，直接集成使用它： ```lua add_requires(\"libusb\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"libusb\") end) ``` 如果用户系统上确实没有安装 libusb，那么 xmake 会自动下载 libusb 库源码，自动编译安装集成，没啥问题。 但如果用户通过 `apt install libusb 1.0` 安装了 libusb 库到系统，那么按理 xmake 应该会自动优先查找用户安装到系统环境的 libusb 包，直接使用，避免额外的下载编译安装。 但是问题来了，xmake 内部通过 `find_package(\"libusb\")` 并没有找打它，这是为什么呢？因为通过 apt 安装的 libusb 包名是 `libusb 1.0`, 而不是 libusb。 我们只能通过 `pkg config cflags libusb 1.0` 才能找到它，但是 xmake 内部的默认 find_package 逻辑并不知道 `libusb 1.0` 的存在，所以找不到。 因此为了更好地适配不同系统环境下，系统库的查找，我们可以通过 `add_extsources(\"pkgconfig::libusb 1.0\")` 去让 xmake 改进查找逻辑，例如： ```lua package(\"libusb\", function() add_extsources(\"pkgconfig::libusb 1.0\") on_install(function (package) ... end) end) ``` 另外，我们也可以通过这个方式，改进查找 homebrew/pacman 等其他包管理器安装的包，例如：`add_extsources(\"pacman::libusb 1.0\")`。 ## package:add_deps 添加包依赖接口，通过配置包之间的依赖关系，我们能够在安装包的同时，自动安装它的所有依赖包。 另外，默认情况下，我们只要配置了依赖关系，cmake/autoconf 就能够自动找到所有依赖包的库和头文件。 当然，如果由于一些特殊原因，导致当前包的 cmake 脚本没能够正常找到依赖包，那么我们也可以通过 `{packagedeps \"xxx\"}` 来强行打入依赖包信息。 例如： ```lua package(\"foo\", function() add_deps(\"cmake\", \"bar\") on_install(function (package) local configs {} import(\"package.tools.cmake\").install(package, configs) end) end) ``` foo 包是使用 CMakeLists.txt 维护的，它在安装过程中，依赖 bar 包，因此，xmake 会优先安装 bar，并且让 cmake.install 在调用 cmake 时候，自动找到 bar 安装后的库。 但是，如果 foo 的 CMakeLists.txt 还是无法自动找到 bar，那么我们可以修改成下面的配置，强制将 bar 的 includedirs/links 等信息通过 flags 的方式，传入 foo。 ```lua package(\"foo\", function() add_deps(\"cmake\", \"bar\") on_install(function (package) local configs {} import(\"package.tools.cmake\").install(package, configs, {packages \"bar\"}) end) end) ``` ## package:add_components 用于支持包的组件化配置，详情见：[#2636](https://github.com/xmake io/xmake/issues/2636)。 通过这个接口，我们可以配置当前包实际可以提供的组件列表。 ```lua package(\"sfml\", function() add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") end) ``` 在用户端，我们可以通过下面的方式来使用包的特定组件。 ```lua add_requires(\"sfml\") target(\"test\", function() add_packages(\"sfml\", {components \"graphics\") end) ``` > 注：除了配置可用的组件列表，我们还需要对每个组件进行详细配置，才能正常使用，因此，它通常和 `on_component` 接口配合使用。 一个关于包组件的配置和使用的完整例子见：[components example](https://github.com/xmake io/xmake/blob/master/tests/projects/package/components/xmake.lua) ## package:set_base 继承包配置。 这是 2.6.4 新加的接口，我们可以通过它去继承一个已有的包的全部配置，然后在此基础上重写部分配置。 这通常在用户自己的项目中，修改 xmake repo 官方仓库的内置包比较有用，比如：修复改 urls，修改版本列表，安装逻辑等等。 例如，修改内置 zlib 包的 url，切到自己的 zlib 源码地址。 ```lua package(\"myzlib\", function() set_base(\"zlib\") set_urls(\"https://github.com/madler/zlib.git\") end) add_requires(\"myzlib\", {system false, alias \"zlib\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") end) ``` 我们也可以用来单纯添加一个别名包。 ```lua package(\"onetbb\", function() set_base(\"tbb\") end) ``` 我们可以通过 `add_requires(\"onetbb\")` 集成安装 tbb 包，只是包名不同而已。 ## package:on_load 加载包配置。 这是个可选的接口，如果要更加灵活的动态判断各种平台架构，针对性做设置，可以在这个里面完成，例如： ```lua on_load(function (package) local bitwidth package:config(\"bitwidth\") or \"8\" package:add(\"links\", \"pcre\" .. (bitwidth ~ \"8\" and bitwidth or \"\")) if not package:config(\"shared\") then package:add(\"defines\", \"PCRE_STATIC\") end end) ``` pcre 包需要做一些针对 bitwidth 的判断，才能确定对外输出的链接库名字，还需要针对动态库增加一些 defines 导出，这个时候在 on_load 里面设置，就更加灵活了。 ## package:on_fetch 从系统中查找库。 这是个可选配置，2.5.2 之后，如果不同系统下安装的系统库，仅仅只是包名不同，那么使用 `add_extsources` 改进系统库查找已经足够，简单方便。 但是如果有些安装到系统的包，位置更加复杂，想要找到它们，也许需要一些额外的脚本才能实现，例如：windows 下注册表的访问去查找包等等，这个时候，我们就可以通过 `on_fetch` 完全定制化查找系统库逻辑。 还是以 libusb 为例，我们不用 `add_extsources`，可以使用下面的方式，实现相同的效果，当然，我们可以在里面做更多的事情。 ``` package(\"libusb\") on_fetch(\"linux\", function(package, opt) if opt.system then return find_package(\"pkgconfig::libusb 1.0\") end end) ``` ## package:on_check 检测包是否支持当前平台。 有时候，单纯用 `on_install(\"windows\", \"android\", function () end)` 无法很好的限制包对当前平台的支持力度。 例如，同样都是在 windows 上使用 msvc 编译，但是它仅仅只支持使用 vs2022 工具链。那么我们无法简单的去通过禁用 windows 平台，来限制包的安装。 因为每个用户的编译工具链环境都可能是不同的。这个时候，我们可以通过配置 `on_check` 去做更细致的检测，来判断包是否支持当前的工具链环境。 如果包不被支持，那么它会在包被下载安装前，更早的提示用户，也可以在 xmake repo 的 ci 上，规避掉一些不支持的 ci job 测试。 例如，下面的配置，就可以判断当前的 msvc 是否提供了对应的 vs sdk 版本，如果版本不满足，那么这个包就无法被编译安装，用户会看到更加可读的不支持的错误提示。 ```lua package(\"test\", function() on_check(\"windows\", function (package) import(\"core.tool.toolchain\") import(\"core.base.semver\") local msvc toolchain.load(\"msvc\", {plat package:plat(), arch package:arch()}) if msvc then local vs_sdkver msvc:config(\"vs_sdkver\") assert(vs_sdkver and semver.match(vs_sdkver):gt(\"10.0.19041\"), \"package(cglm): need vs_sdkver > 10.0.19041.0\") end end) end)S ``` 例如，我们也可以用它来判断，当前编译器对 c++20 的支持力度，如果不支持 c++20 才有的 std::input_iterator。那么这个包就没必要继续下载编译安装。 用户会看到 `Require at least C++20.` 的错误，来提示用户取升级自己的编译器。 ```lua package(\"test\", function() on_check(function (package) assert(package:check_cxxsnippets({test [[ #include <cstddef> #include <iterator> struct SimpleInputIterator { using difference_type std::ptrdiff_t; using value_type int; int operator*() const; SimpleInputIterator& operator++(); void operator++(int) { ++*this; } }; static_assert(std::input_iterator<SimpleInputIterator>); ]]}, {configs {languages \"c++20\"}}), \"Require at least C++20.\") end) end) ``` ## package:on_install 安装包。 这个接口主要用于添加安装脚本，前面的字符串参数用于设置支持的平台，像 `on_load`, `on_test` 等其他脚本域也是同样支持的。 完整的过滤语法如下：`platarch1,arch2@hostarch1,arch2` 看上去非常的复杂，其实很简单，其中每个阶段都是可选的，可部分省略，对应：` 编译平台 编译架构 @主机平台 主机架构 ` 如果不设置任何平台过滤条件，那么默认全平台支持，里面的脚本对所有平台生效，例如： ```lua on_install(function (package) TODO end) ``` 如果安装脚本对特定平台生效，那么直接指定对应的编译平台，可以同时指定多个： ```lua on_install(\"linux\", \"macosx\", function (package) TODO end) ``` 如果还要细分到指定架构才能生效，可以这么写： ```lua on_install(\"linuxx86_64\", \"iphoneosarm64\", function (package) TODO end) ``` 如果还要限制执行的主机环境平台和架构，可以在后面追加 `@hostarch`，例如： ```lua on_install(\"mingw@windows\", function (package) TODO end) ``` 意思就是仅对 windows 下编译 mingw 平台生效。 我们也可以不指定比那一平台和架构，仅设置主机平台和架构，这通常用于描述一些跟编译工具相关的依赖包，只能在主机环境运行。 例如，我们编译的包，依赖了 cmake，需要添加 cmake 的包描述，那么里面编译安装环境，只能是主机平台： ```lua on_install(\"@windows\", \"@linux\", \"@macosx\", function (package) TODO end) ``` 其他一些例子： ```lua `@linux` `@linuxx86_64` `@macosx,linux` `android@macosx,linux` `androidarmeabi v7a@macosx,linux` `androidarmeabi v7a@macosx,linuxx86_64` `androidarmeabi v7a@linuxx86_64` ``` 在 2.8.7 中，我们改进了模式匹配支持，新增排除指定平台和架构，例如： ``` !plat!arch@!subhost!subarch ``` ```lua @!linux @!linuxx86_64 @!macosx,!linux !android@macosx,!linux android!armeabi v7a@macosx,!linux androidarmeabi v7a,!iphoneos@macosx,!linuxx86_64 !androidarmeabi v7a@!linux!x86_64 !linux* ``` 同时，还提供了一个内置的 `native` 架构，用于匹配当前平台的本地架构，主要用于指定或者排除交叉编译平台。 ```lua on_install(\"macosxnative\", ...) ``` 上面的配置，如果在 macOS x86_64 的设备上，它仅仅只会匹配 `xmake f a x86_64` 的本地架构编译。 如果是 `xmake f a arm64` 交叉编译，就不会被匹配到。 同理，如果只想匹配交叉编译，可以使用 `macosx!native` 进行取反排除就行了。 2.9.1 版本，我们继续对它做了改进，增加了条件逻辑判断的支持： 例如： ```lua on_install(\"!wasm!arm* and !cross!arm*\", function (package) end) ``` 来表述排除 wasm 和 cross 平台之外的 arm 架构。 并且，它也支持通过 `()` 描述的嵌套逻辑，`a and b or (a and (c or d))`。 我们内置了一些安装常用编译工具脚本，用于针对不同源码依赖的构建工具链，进行方便的构架支持，例如：autoconf, cmake, meson 等， 如果是基于 xmake 的依赖包，那么集成起来就非常简单了，xmake 对其做了非常好的内置集成支持，可以直接对其进行跨平台编译支持，一般情况下只需要： ```lua on_install(function (package) import(\"package.tools.xmake\").install(package) end) ``` 如果要传递一些特有的编译配置参数： ```lua on_install(function (package) import(\"package.tools.xmake\").install(package, {\" xxx y\"}) end) ``` 如果是基于 cmake 的包，集成起来也很简答，通常也只需要设置一些配置参数即可，不过还需要先添加上 cmake 的依赖才行： ```lua add_deps(\"cmake\") on_install(function (package) import(\"package.tools.cmake\").install(package, {\" Dxxx ON\"}) end) ``` 如果是基于 autoconf 的包，集成方式跟 cmake 类似，只是传递的配置参数不同而已，不过通常情况下，unix 系统都内置了 autoconf 系列工具，所以不加相关依赖也没事。 ```lua on_install(function (package) import(\"package.tools.autoconf\").install(package, {\" enable shared no\"}) end) ``` 不过，有些源码包用系统内置的 autoconf 可能不能完全满足，那么可以加上 autoconf 系列依赖，对其进行构建： ```lua add_deps(\"autoconf\", \"automake\", \"libtool\", \"pkg config\") on_install(function (package) import(\"package.tools.autoconf\").install(package, {\" enable shared no\"}) end) ``` 如果是 meson，还需要加上 ninja 的依赖来执行构建才行。 ```lua add_deps(\"meson\", \"ninja\") on_install(function (package) import(\"package.tools.meson\").install(package, {\" Dxxx ON\"}) end) ``` 如果是 makefile： ```lua 参考 z3 package on_install(function(package) import(\"package.tools.make\").install(package) end) ``` ## package:on_test 测试包。 安装后，需要设置对应的测试脚本，执行一些测试，确保安装包的可靠性，如果测试不通过，则会撤销整个安装包。 ```lua on_test(function (package) assert(package:has_cfuncs(\"inflate\", {includes \"zlib.h\"})) end) ``` 上面的脚本调用包内置的 `has_cfuncs` 接口，检测安装后的包是否存在 zlib.h 头文件，以及库和头文件里面是否存在 `inflate` 这个接口函数。 xmake 会去尝试编译链接来做测试，`has_cfuncs` 用于检测 c 函数，而 `has_cxxfuncs` 则可以检测 c++ 库函数。 而 includes 里面可以设置多个头文件，例如：`includes {\"xxx.h\", \"yyy.h\"}` 我们还可以传递一些自己的编译参数进去检测，例如： ```lua on_test(function (package) assert(package:has_cxxfuncs(\"func1\", {includes \"xxx.h\", configs {defines \"c++14\", cxflags \" Dxxx\"}})) end) ``` 我们也可以通过 `check_csnippets` 和 `check_cxxsnippets` 检测一个代码片段： ```lua on_test(function (package) assert(package:check_cxxsnippets({test [[ #include <boost/algorithm/string.hpp> #include <string> #include <vector> #include <assert.h> using namespace boost::algorithm; using namespace std; static void test() { string str(\"a,b\"); vector<string> strVec; split(strVec, str, is_any_of(\",\")); assert(strVec.size() 2); assert(strVec[0] \"a\"); assert(strVec[1] \"b\"); } ]]}, {configs {languages \"c++14\"}})) end) ``` 如果是可执行包，也可以通过尝试运行来检测： ```lua on_test(function (package) os.run(\"xxx help\") end) ``` 如果运行失败，那么测试不会通过。 ## package:on_download 自定义下载包。 自定义包的下载逻辑，这是 2.6.4 新加的接口，通常用不到，使用 Xmake 的内置下载就足够了。 如果用户自建私有仓库，对包的下载有更复杂的鉴权机制，特殊处理逻辑，那么可以重写内部的下载逻辑来实现。 ```lua on_download(function (package, opt) local url opt.url local sourcedir opt.sourcedir download url to the current directory and extract it's source code to sourcedir ... end) ``` opt 参数里面，可以获取到下载包的目的源码目录 `opt.sourcedir`，我们只需要从 `opt.url` 获取到包地址，下载下来就可以了。 然后，根据需要，添加一些自定义的处理逻辑。另外，自己可以添加下载缓存处理等等。 下面是一个自定义下载 tar.gz 文件，并且实现缓存和源文件目录解压的例子，可以参考下： ```lua package(\"zlib\", function() add_urls(\"https://github.com/madler/zlib/archive/$(version).tar.gz\") add_versions(\"v1.2.10\", \"42cd7b2bdaf1c4570e0877e61f2fdc0bce8019492431d054d3d86925e5058dc5\") on_download(function (package, opt) import(\"net.http\") import(\"utils.archive\") local url opt.url local sourcedir opt.sourcedir local packagefile path.filename(url) local sourcehash package:sourcehash(opt.url_alias) local cached true if not os.isfile(packagefile) or sourcehash ~ hash.sha256(packagefile) then cached false attempt to remove package file first os.tryrm(packagefile) http.download(url, packagefile) check hash if sourcehash and sourcehash ~ hash.sha256(packagefile) then raise(\"unmatched checksum, current hash(%s) ! original hash(%s)\", hash.sha256(packagefile):sub(1, 8), sourcehash:sub(1, 8)) end end extract package file local sourcedir_tmp sourcedir .. \".tmp\" os.rm(sourcedir_tmp) if archive.extract(packagefile, sourcedir_tmp) then os.rm(sourcedir) os.mv(sourcedir_tmp, sourcedir) else if it is not archive file, we need only create empty source file and use package:originfile() os.tryrm(sourcedir) os.mkdir(sourcedir) end save original file path package:originfile_set(path.absolute(packagefile)) end) end) ``` 自定义下载需要用户完全自己控制下载逻辑，会比较复杂，除非必要，不推荐这么做。 如果仅仅只是想增加自定义 http headers 去获取下载授权，可以使用 [设置包下载的 http headers](https://xmake.io/#/zh cn/manual/project_target?id %e8%ae%be%e7%bd%ae%e5%8c%85%e4%b8%8b%e8%bd%bd%e7%9a%84 http headers) ## package:on_component 配置包组件。 这是 2.7.3 新加的接口，用于支持包的组件化配置，详情见：[#2636](https://github.com/xmake io/xmake/issues/2636)。 通过这个接口，我们可以配置当前包，指定组件的详细信息，比如组件的链接，依赖等等。 ### 配置组件链接信息 ```lua package(\"sfml\") add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") on_component(\"graphics\", function (package, component) local e package:config(\"shared\") and \"\"or\" s\" component:add(\"links\", \"sfml graphics\" .. e) if package:is_plat(\"windows\", \"mingw\") and not package:config(\"shared\") then component:add(\"links\", \"freetype\") component:add(\"syslinks\", \"opengl32\", \"gdi32\", \"user32\", \"advapi32\") end end) on_component(\"window\", function (package, component) local e package:config(\"shared\") and \"\"or\" s\" component:add(\"links\", \"sfml window\" .. e) if package:is_plat(\"windows\", \"mingw\") and not package:config(\"shared\") then component:add(\"syslinks\", \"opengl32\", \"gdi32\", \"user32\", \"advapi32\") end end) ... ``` 在用户端，我们可以通过下面的方式来使用包的特定组件。 ```lua add_requires(\"sfml\") target(\"test\") add_packages(\"sfml\", {components \"graphics\") ``` > 注：除了配置组件信息，我们还需要配置可用的组件列表，才能正常使用，因此，它通常和 `add_components` 接口配合使用。 一个关于包组件的配置和使用的完整例子见：[components example](https://github.com/xmake io/xmake/blob/master/tests/projects/package/components/xmake.lua) ### 配置组件的编译信息 我们不仅可以配置每个组件的链接信息，还有 includedirs, defines 等等编译信息，我们也可以对每个组件单独配置。 ```lua package(\"sfml\") on_component(\"graphics\", function (package, component) package:add(\"defines\", \"TEST\") end) ``` ### 配置组件依赖 ```lua package(\"sfml\", function() add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") on_component(\"graphics\", function (package, component) component:add(\"deps\", \"window\", \"system\") end) end) ``` 上面的配置，告诉包，我们的 graphics 组件还会额外依赖 `window` 和 `system` 两个组件。 因此，在用户端，我们对 graphics 的组件使用，可以从 ```lua add_packages(\"sfml\", {components {\"graphics\", \"window\", \"system\"}) ``` 简化为： ```lua add_packages(\"sfml\", {components \"graphics\") ``` 因为，只要我们开启了 graphics 组件，它也会自动启用依赖的 window 和 system 组件。 另外，我们也可以通过 `add_components(\"graphics\", {deps {\"window\", \"system\"}})` 来配置组件依赖关系。 ### 从系统库中查找组件 我们知道，在包配置中，配置 `add_extsources` 可以改进包在系统中的查找，比如从 apt/pacman 等系统包管理器中找库。 当然，我们也可以让每个组件也能通过 `extsources` 配置，去优先从系统库中找到它们。 例如，sfml 包，它在 homebrew 中其实也是组件化的，我们完全可以让包从系统库中，找到对应的每个组件，而不需要每次源码安装它们。 ```bash $ ls l /usr/local/opt/sfml/lib/pkgconfig r r r 1 ruki admin 317 10 19 17:52 sfml all.pc r r r 1 ruki admin 534 10 19 17:52 sfml audio.pc r r r 1 ruki admin 609 10 19 17:52 sfml graphics.pc r r r 1 ruki admin 327 10 19 17:52 sfml network.pc r r r 1 ruki admin 302 10 19 17:52 sfml system.pc r r r 1 ruki admin 562 10 19 17:52 sfml window.pc ``` 我们只需要，对每个组件配置它的 extsources： ```lua if is_plat(\"macosx\") then add_extsources(\"brew::sfml/sfml all\") end on_component(\"graphics\", function (package, component) ... component:add(\"extsources\", \"brew::sfml/sfml graphics\") end) ``` ### 默认的全局组件配置 除了通过指定组件名的方式，配置特定组件，如果我们没有指定组件名，默认就是全局配置所有组件。 ```lua package(\"sfml\", function() on_component(function (package, component) configure all components end) end) ``` 当然，我们也可以通过下面的方式，指定配置 graphics 组件，剩下的组件通过默认的全局配置接口进行配置： ```lua package(\"sfml\", function() add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") on_component(\"graphics\", function (package, component) configure graphics end) on_component(function (package, component) component audio, network, window, system end) end) ```"},"/get_started/zh/package/local-package.html":{"title":"","content":" class: heading_no_counter # 使用本地包 ## 默认打包格式 xmake 提供了一种新的本地包打包方案，将会更加无缝的对接 `add_requires` 和 `add_packages`。 我们执行 `xmake package` 命令就能够生成默认的新版打包格式。 ```console $ xmake package package(foo): build/packages/f/foo generated ``` 它将会产生 `build/packages/f/foo/xmake.lua` 文件，内容如下： ```lua package(\"foo\", function() set_description(\"The foo package\") set_license(\"Apache 2.0\") add_deps(\"add\", \"sub\") on_load(function (package) package:set(\"installdir\", path.join(os.scriptdir(), package:plat(), package:arch(), package:mode())) end) on_fetch(function (package) local result {} result.links \"foo\" result.linkdirs package:installdir(\"lib\") result.includedirs package:installdir(\"include\") return result end) end) ``` 其实就是采用 `package()` 来定义描述本地包，就跟远程包一样。 而生成的目录结构如下： ```console $ tree build/packages/f/foo/ build/packages/f/foo/ ├── macosx │   └── x86_64 │   └── release │   ├── include │   │   └── foo.h │   └── lib │   └── libfoo.a └── xmake.lua ``` 我们也能够使用 `add_requires`/`add_repositories` 接口来无缝集成这个包。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_repositories(\"local repo build\") add_requires(\"foo\") target(\"bar\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"foo\") end) ``` 其中，add_repositories 配置指定本地包的仓库根目录，然后就可以通过 `add_requires` 来引用这个包了。 另外，生成的本地包，还有一个特性，就是支持 `target/add_deps`，会自动关联多个包的依赖关系，集成时候，也会自动对接所有依赖链接。 这里有完整的 [测试例子](https://github.com/xmake io/xmake/blob/dev/tests/actions/package/localpkg/test.lua)。 ```bash \"/usr/bin/xcrun sdk macosx clang++\" o build/macosx/x86_64/release/bar build/.objs/bar/macosx/x86_64/release/src/main.cpp.o arch x86_64 mmacosx version min 10.15 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.0.sdk stdlib libc++ L/Users/ruki/projects/personal/xmake/tests/actions/package/localpkg/bar/build/packages/f/foo/macosx/x86_64/release/lib L/Users/ruki/projects/personal/xmake/tests/actions/package/localpkg/bar/build/packages/s/sub/macosx/x86_64/release/lib L/Users/ruki/projects/personal/xmake/tests/actions/package/localpkg/bar/build/packages/a/add/macosx/x86_64/release/lib Wl, x lfoo lsub ladd lz ``` ## 生成远程包 除了本地包格式，`xmake package` 现在也支持生成远程包，便于用户将他们快速提交到远程仓库。 我们只需要在打包时候，修改包格式。 ```console $ xmake package f remote ``` 他也会产生 packages/f/foo/xmake.lua 文件。 ```lua package(\"foo\", function() set_description(\"The foo package\") set_license(\"Apache 2.0\") add_deps(\"add\", \"sub\") add_urls(\"https://github.com/myrepo/foo.git\") add_versions(\"1.0\", \"<shasum256 or gitcommit>\") on_install(function (package) local configs {} if package:config(\"shared\") then configs.kind \"shared\" end import(\"package.tools.xmake\").install(package, configs) end) on_test(function (package) TODO check includes and interfaces assert(package:has_cfuncs(\"foo\", {includes \"foo.h\"}) end) end) ``` 包定义配置相比本地包，多了实际的安装逻辑，以及 urls 和 versions 的设置， 我们也能够通过附加参数，去修改 urls，versions 等配置值，例如： ```console $ xmake package f remote url https://xxxx/xxx.tar.gz shasum xxxxx homepage xxxxx` ``` xmake 也会从 target 的 `set_license` 和 `set_version` 等配置中读取相关配置信息。 ## 从 CMake 中查找包 现在 cmake 已经是事实上的标准，所以 CMake 提供的 find_package 已经可以查找大量的库和模块，我们完全复用 cmake 的这部分生态来扩充 xmake 对包的集成。 我们可以通过 `find_package(\"cmake::xxx\")` 去借助 cmake 来找一些包，xmake 会自动生成一个 cmake 脚本来调用 cmake 的 find_package 去查找一些包，获取里面包信息。 例如： ```console $ xmake l find_package cmake::ZLIB { links { \"z\" }, includedirs { \"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10. 15.sdk/usr/include\" }, linkdirs { \"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10. 15.sdk/usr/lib\" } } $ xmake l find_package cmake::LibXml2 { links { \"xml2\" }, includedirs { \"/Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk/usr/include/libxml2\" }, linkdirs { \"/usr/lib\" } } ``` ### 1. 在项目中集成包 如果我们在 xmake.lua 项目配置中集成查找 cmake 的依赖包，通常不需要直接使用 find_package，我们可以用更加通用、简单的包集成方式。 ```lua add_requires(\"cmake::ZLIB\", {alias \"zlib\", system true}) target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") ``` 我们指定 `system true` 告诉 xmake 强制从系统中调用 cmake 查找包，如果找不到，不再走安装逻辑，因为 cmake 没有提供类似 vcpkg/conan 等包管理器的安装功能，只提供了包查找特性。 ### 2. 指定版本 ```lua add_requires(\"cmake::OpenCV 4.1.1\", {system true}) ``` ### 3. 指定组件 ```lua add_requires(\"cmake::Boost\", {system true, configs {components {\"regex\", \"system\"}}}) ``` ### 4. 预设开关 ```lua add_requires(\"cmake::Boost\", {system true, configs {components {\"regex\", \"system\"}, presets {Boost_USE_STATIC_LIB true}}}) ``` 相当于内部调用 find_package 查找包之前，在 CMakeLists.txt 中预定义一些配置，控制 find_package 的查找策略和状态。 ``` set(Boost_USE_STATIC_LIB ON) will be used in FindBoost.cmake find_package(Boost REQUIRED COMPONENTS regex system) ``` ### 5. 设置环境变量 ```lua add_requires(\"cmake::OpenCV\", {system true, configs {envs {CMAKE_PREFIX_PATH \"xxx\"}}}) ``` ### 6. 指定自定义 FindFoo.cmake 模块脚本目录 mydir/cmake_modules/FindFoo.cmake： ```lua add_requires(\"cmake::Foo\", {system true, configs {moduledirs \"mydir/cmake_modules\"}}) ``` 相关 issues: [#1632](https://github.com/xmake io/xmake/issues/1632) ### 7. 指定链接项 对于 cmake 包，我们新增了 `link_libraries` 配置选项，让用户在查找使用 cmake 包的时候，可以自定义配置包依赖的链接库，甚至对 target 链接的支持。 ```lua add_requires(\"cmake::xxx\", {configs {link_libraries {\"abc::lib1\", \"abc::lib2\"}}}) ``` xmake 在查找 cmake 包的时候，会自动追加下面的配置，改进对 links 库的提取。 ```cmake target_link_libraries(test PRIVATE ABC::lib1 ABC::lib2) ``` ### 8. 指定搜索模式 另外，我们增加的搜索模式配置： ```lua add_requires(\"cmake::xxx\", {configs {search_mode \"config\"}}) add_requires(\"cmake::xxx\", {configs {search_mode \"module\"}}) add_requires(\"cmake::xxx\") both ``` 比如指定 config 搜索模式，告诉 cmake 从 `XXXConfig.cmake` 中查找包。 xmake 在查找 cmake 包的时候，内部会自动追加下面的配置。 ```cmake find_package(ABC CONFIG REQUIRED) ```"},"/get_started/zh/package/remote-package.html":{"title":"","content":" class: heading_no_counter # 使用远程包 ## 前言 远程包在用法上更加的简单，只需要设置对应的依赖包就行了，例如： ```lua add_requires(\"tbox 1.6.*\", \"libpng ~1.16\", \"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"tbox\", \"libpng\", \"zlib\") end) ``` 上面的 `add_requires` 用于描述当前项目需要的依赖包，而 `add_packages` 用于应用依赖包到 test 目标，只有设置这个才会自动追加 links, linkdirs, includedirs 等设置。 然后直接执行编译即可： ```console $ xmake ``` xmake 会去远程拉取相关源码包，然后自动编译安装，最后编译项目，进行依赖包的链接。 关于包依赖管理的更多相关信息和进展见相关 issues：[Remote package management](https://github.com/xmake io/xmake/issues/69) ## 目前支持的特性 * 语义版本支持，例如：\"> 1.1.0 < 1.2\", \"~1.6\", \"1.2.x\", \"1.*\" * 提供官方包仓库、自建私有仓库、项目内置仓库等多仓库管理支持 * 跨平台包编译集成支持（不同平台、不同架构的包可同时安装，快速切换使用） * debug 依赖包支持，实现源码调试 ## 依赖包处理机制 这里我们简单介绍下整个依赖包的处理机制： ![package arch](image/package arch.png) 1. 优先检测当前系统目录、第三方包管理下有没有存在指定的包，如果有匹配的包，那么就不需要下载安装了 （当然也可以设置不使用系统包） 2. 检索匹配对应版本的包，然后下载、编译、安装（注：安装在特定 xmake 目录，不会干扰系统库环境） 3. 编译项目，最后自动链接启用的依赖包 ## 快速上手 新建一个依赖 tbox 库的空工程： ```console $ xmake create t console_tbox test $ cd test ``` 执行编译即可，如果当前没有安装 tbox 库，则会自动下载安装后使用： ```console $ xmake ``` 切换到 iphoneos 平台进行编译，将会重新安装 iphoneos 版本的 tbox 库进行链接使用： ```console $ xmake f p iphoneos $ xmake ``` 切换到 android 平台 arm64 v8a 架构编译： ```console $ xmake f p android [ ndk ~/android ndk r16b] $ xmake ``` ## 语义版本设置 xmake 的依赖包管理是完全支持语义版本选择的，例如：\"~1.6.1\"，对于语义版本的具体描述见：[https://semver.org/](https://semver.org/) 一些语义版本写法： ```lua add_requires(\"tbox 1.6.*\", \"pcre 1.3.x\", \"libpng ^1.18\") add_requires(\"libpng ~1.16\", \"zlib 1.1.2 > 1.2.11 <1.3.0\") ``` 目前 xmake 使用的语义版本解析器是 [uael](https://github.com/uael) 贡献的 [sv](https://github.com/uael/sv) 库，里面也有对版本描述写法的详细说明，可以参考下：[版本描述说明](https://github.com/uael/sv#versions) 当然，如果我们对当前的依赖包的版本没有特殊要求，那么可以直接这么写： ```lua add_requires(\"tbox\", \"libpng\", \"zlib\") ``` 这会使用已知的最新版本包，或者是 master 分支的源码编译的包，如果当前包有 git repo 地址，我们也能指定特定分支版本： ```lua add_requires(\"tbox master\") add_requires(\"tbox dev\") ``` ## 额外的包信息设置 ### 可选包设置 如果指定的依赖包当前平台不支持，或者编译安装失败了，那么 xmake 会编译报错，这对于有些必须要依赖某些包才能工作的项目，这是合理的。 但是如果有些包是可选的依赖，即使没有也可以正常编译使用的话，可以设置为可选包： ```lua add_requires(\"tbox\", {optional true}) ``` ### 禁用系统库 默认的设置，xmake 会去优先检测系统库是否存在（如果没设置版本要求），如果用户完全不想使用系统库以及第三方包管理提供的库，那么可以设置： ```lua add_requires(\"tbox\", {system false}) ``` ### 使用调试版本的包 如果我们想同时源码调试依赖包，那么可以设置为使用 debug 版本的包（当然前提是这个包支持 debug 编译）： ```lua add_requires(\"tbox\", {debug true}) ``` 如果当前包还不支持 debug 编译，可在仓库中提交修改编译规则，对 debug 进行支持，例如： ```lua package(\"openssl\", function() on_install(\"linux\", \"macosx\", function (package) os.vrun(\"./config %s prefix \\\"%s\\\"\", package:debug() and\" debug\"or\"\", package:installdir()) os.vrun(\"make j4\") os.vrun(\"make install\") end) end) ``` ### 传递额外的编译信息到包 某些包在编译时候有各种编译选项，我们也可以传递进来，当然包本身得支持： ```lua add_requires(\"tbox\", {configs {small true}}) ``` 传递 ` small true` 给 tbox 包，使得编译安装的 tbox 包是启用此选项的。 我们可以通过在工程目录中执行：`xmake require info tbox` 来获取指定包所有的可配置参数列表和取值说明。 比如： ```console xmake require info spdlog require(spdlog): > requires: > plat: macosx > arch: x86_64 > configs: > header_only: true > shared: false > vs_runtime: MT > debug: false > fmt_external: true > noexcept: false > configs: > header_only: Use header only (default: true) > fmt_external: Use external fmt library instead of bundled (default: false) > noexcept: Compile with fno exceptions. Call abort() on any spdlog exceptions (default: false) > configs (builtin): > debug: Enable debug symbols. (default: false) > shared: Enable shared library. (default: false) > cflags: Set the C compiler flags. > cxflags: Set the C/C++ compiler flags. > cxxflags: Set the C++ compiler flags. > asflags: Set the assembler flags. > vs_runtime: Set vs compiler runtime. (default: MT) > values: {\"MT\",\"MD\"} ``` 其中，configs 里面就是 spdlog 包自身提供的可配置参数，而下面带有 builtin 的 configs 部分，是所有包都会有的内置配置参数。 最上面 requires 部分，是项目当前配置值。 > `vs_runtime` 是用于 msvc 下 vs runtime 的设置，v2.2.9 版本中，还支持所有 static 依赖包的自动继承，也就是说 spdlog 如果设置了 MD，那么它依赖的 fmt 包也会自动继承设置 MD。 可以看到，我们已经能够很方便的定制化获取需要的包，但是每个包自身也许有很多依赖，如果这些依赖也要各种定制化配置，怎么办？ 可以通过 `add_requireconfs` 去重写内部依赖包的配置参数。 ### 安装任意版本的包 默认情况下，`add_requires(\"zlib>1.2.x\")` 只能选择到 `xmake repo` 仓库中存在的包版本，因为每个版本的包，它们都会有一个 sha256 的校验值，用于包的完整性校验。 因此，未知版本的包不存在校验值，xmake 默认是不让选择使用的，这并不安全。 那如果，我们需要的包版本无法选择使用怎么办呢？有两种方式，一种是提交一个 pr 给 [xmake repo](https://github.com/xmake io/xmake repo)，增加指定包的新版本以及对应的 sha256，例如： ```lua package(\"zlib\", function() add_versions(\"1.2.10\", \"8d7e9f698ce48787b6e1c67e6bff79e487303e66077e25cb9784ac8835978017\") add_versions(\"1.2.11\", \"c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1\") end) ``` 另外，还有一种方式，就是用户传递 `{verify false}` 配置给 `add_requires`，强制忽略包的文件完整性校验，这样就不需要 sha256 值，因此就可以安装任意版本的包。 当然，这也会存在一定的安全性以及包不完整的风险，这就需要用户自己去选择评估了。 ```lua add_requires(\"zlib 1.2.11\", {verify false}) ``` ### 禁用外部头文件搜索路径 默认情况下，通过 `add_requires` 安装的包会采用 ` isystem` 或者 `/external:I` 来引用里面的头文件路径，这通常能够避免一些包头文件引入的不可修改的警告信息， 但是，我们还是可以通过设置 `{external false}` 来禁用外部头文件，切回 ` I` 的使用。 默认启用了 external 外部头文件的编译 flags 如下： ```console isystem /Users/ruki/.xmake/packages/z/zlib/1.2.11/d639b7d6e3244216b403b39df5101abf/include ``` 手动关闭 external 外部头文件的编译 flags 如下： ```lua add_requires(\"zlib 1.x\", {external false}) ``` ```console I /Users/ruki/.xmake/packages/z/zlib/1.2.11/d639b7d6e3244216b403b39df5101abf/include ``` ## 第三方依赖包安装 xmake 支持对对第三方包管理器里面的依赖库安装支持，例如：conan, brew, vcpkg 等 ### 添加 homebrew 的依赖包 ```lua add_requires(\"brew::zlib\", {alias \"zlib\"}) add_requires(\"brew::pcre2/libpcre2 8\", {alias \"pcre2\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"pcre2\", \"zlib\") end) ``` ### 添加 vcpkg 的依赖包 ```lua add_requires(\"vcpkg::zlib\", \"vcpkg::pcre2\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"vcpkg::zlib\", \"vcpkg::pcre2\") end) ``` 我们也可以加个包别名，简化对 `add_packages` 的使用： ```lua add_requires(\"vcpkg::zlib\", {alias \"zlib\"}) add_requires(\"vcpkg::pcre2\", {alias \"pcre2\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\", \"pcre2\") end) ``` 如果 vcpkg 包带有可选特性，我们也可以直接使用 vcpkg 的语法格式 `packagename[feature1,feature2]` 来安装包。 例如： ```lua add_requires(\"vcpkg::boost[core]\") ``` xmake 支持 vcpkg 新的清单模式，通过它，我们就能支持 vcpkg 包的版本选择，例如： ```lua add_requires(\"vcpkg::zlib 1.2.11\") add_requires(\"vcpkg::fmt> 8.0.1\", {configs {baseline \"50fd3d9957195575849a49fa591e645f1d8e7156\"}}) add_requires(\"vcpkg::libpng\", {configs {features {\"apng\"}}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"vcpkg::zlib\", \"vcpkg::fmt\", \"vcpkg::libpng\") end) ``` 还可以额外配置私有仓库，仅清单模式有效。 ```lua local registries { { kind \"git\", repository \"https://github.com/SakuraEngine/vcpkg registry\", baseline \"e0e1e83ec66e3c9b36066f79d133b01eb68049f7\", packages { \"skrgamenetworkingsockets\" } } } add_requires(\"vcpkg::skrgamenetworkingsockets> 1.4.0+1\", {configs {registries registries}}) ``` ### 添加 conan 的依赖包 ```lua add_requires(\"conan::zlib/1.2.11\", {alias \"zlib\", debug true}) add_requires(\"conan::openssl/1.1.1g\", {alias \"openssl\", configs {options \"OpenSSL:shared True\"}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"openssl\", \"zlib\") end) ``` 执行 xmake 进行编译后： ```console ruki:test_package ruki$ xmake checking for the architecture ... x86_64 checking for the Xcode directory ... /Applications/Xcode.app checking for the SDK version of Xcode ... 10.14 note: try installing these packages (pass y to skip confirm)? > conan::zlib/1.2.11 (debug) > conan::openssl/1.1.1g please input: y (y/n) > installing conan::zlib/1.2.11 .. ok > installing conan::openssl/1.1.1g .. ok [0%]: cache compiling.release src/main.c [100%]: linking.release test ``` 自定义 conan/settings 配置： ```lua add_requires(\"conan::poco/1.10.0\", {alias \"poco\", configs {settings {\"compiler gcc\", \"compiler.libcxx libstdc++11\"}}}) ``` 其他一些 conan 相关配置项： ``` { build {description \"use it to choose if you want to build from sources.\", default \"missing\", values {\"all\", \"never\", \"missing\", \"outdated\"}}, remote {description \"Set the conan remote server.\"}, options {description \"Set the options values, e.g. OpenSSL:shared True\"}, imports {description \"Set the imports for conan.\"}, settings {description \"Set the build settings for conan.\"}, build_requires {description \"Set the build requires for conan.\", default \"xmake_generator/0.1.0@bincrafters/testing\"} } ``` ### 添加 conda 的依赖包 ```lua add_requires(\"conda::zlib 1.2.11\", {alias \"zlib\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") end) ``` ### 添加 pacman 的依赖包 我们既支持 archlinux 上的 pacman 包安装和集成，也支持 msys2 上 pacman 的 mingw x86_64/i386 包安装和集成。 ```lua add_requires(\"pacman::zlib\", {alias \"zlib\"}) add_requires(\"pacman::libpng\", {alias \"libpng\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\", \"libpng\") end) ``` archlinux 上只需要： ```console xmake ``` msys2 上安装 mingw 包，需要指定到 mingw 平台： ```console xmake f p mingw a [x86_64i386] xmake ``` ### 添加 clib 的依赖包 clib 是一款基于源码的依赖包管理器，拉取的依赖包是直接下载对应的库源码，集成到项目中编译，而不是二进制库依赖。 其在 xmake 中集成也很方便，唯一需要注意的是，还需要自己添加上对应库的源码到 xmake.lua，例如： ```lua add_requires(\"clib::clibs/bytes@0.0.4\", {alias \"bytes\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"clib/bytes/*.c\") add_files(\"src/*.c\") add_packages(\"bytes\") end) ``` ### 添加 dub/dlang 的依赖包 xmake 也支持 dlang 的 dub 包管理器，集成 dlang 的依赖包来使用。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"dub::log 0.4.3\", {alias \"log\"}) add_requires(\"dub::dateparser\", {alias \"dateparser\"}) add_requires(\"dub::emsi_containers\", {alias \"emsi_containers\"}) add_requires(\"dub::stdx allocator\", {alias \"stdx allocator\"}) add_requires(\"dub::mir core\", {alias \"mir core\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") add_packages(\"log\", \"dateparser\", \"emsi_containers\", \"stdx allocator\", \"mir core\") end) ``` ### 添加 ubuntu/apt 的依赖包 xmake 支持使用 apt 集成依赖包，也会自动查找 ubuntu 系统上已经安装的包。 ```lua add_requires(\"apt::zlib1g dev\", {alias \"zlib\"}) target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") ``` ### 添加 gentoo/portage 的依赖包 v2.5.4 之后版本支持使用 Portage 集成依赖包，也会自动查找 Gentoo 系统上已经安装的包。 ```lua add_requires(\"portage::libhandy\", {alias \"libhandy\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"libhandy\") end) ``` ### 添加 nimble 的依赖包 xmake 支持集成 nimble 包管理器中的包，但是目前仅用于 nim 项目，因为它并没有提供二进制的包，而是直接安装的 nim 代码包。 ```lua add_requires(\"nimble::zip>1.3\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"nimble::zip\") end) ``` ### 添加 cargo 的依赖包 Cargo 依赖包主要给 rust 项目集成使用，例如： ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::base64 0.13.0\") add_requires(\"cargo::flate2 1.0.17\", {configs {features \"zlib\"}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::base64\", \"cargo::flate2\") end) ``` 不过，我们也可以在 C++ 中通过 cxxbridge 的方式，调用 Rust 库接口，来变相复用所有的 Rust 包。 完整例子见：[Call Rust in C++](https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library) ### 添加 NuGet 的依赖包 xmake 也支持从 dotnet/nuget 中，获取 native 库并快速集成。 ```lua add_requires(\"nuget::zlib_static\", {alias \"zlib\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"zlib\") end) ``` ## 使用自建私有包仓库 如果需要的包不在官方仓库 [xmake repo](https://github.com/xmake io/xmake repo) 中，我们可以提交贡献代码到仓库进行支持。 但如果有些包仅用于个人或者私有项目，我们可以建立一个私有仓库 repo，仓库组织结构可参考：[xmake repo](https://github.com/xmake io/xmake repo) 比如，现在我们有一个一个私有仓库 repo：`git@github.com:myrepo/xmake repo.git` 我们可以通过下面的命令进行仓库添加： ```console $ xmake repo add myrepo git@github.com:myrepo/xmake repo.git [branch] ``` > [branch] 是可选的，我们也可以切换到指定 repo 分支 或者我们直接写在 xmake.lua 中： ```lua add_repositories(\"my repo git@github.com:myrepo/xmake repo.git\") ``` 同样，我们也可以切换到指定 repo 分支 ```lua add_repositories(\"my repo git@github.com:myrepo/xmake repo.git dev\") ``` 如果我们只是想添加一两个私有包，这个时候特定去建立一个 git repo 太小题大做了，我们可以直接把包仓库放置项目里面，例如： ``` projectdir myrepo packages t/tbox/xmake.lua z/zlib/xmake.lua src main.c xmake.lua ``` 上面 myrepo 目录就是自己的私有包仓库，内置在自己的项目里面，然后在 xmake.lua 里面添加一下这个仓库位置： ```lua add_repositories(\"my repo myrepo\") ``` 这个可以参考 [benchbox](https://github.com/xmake io/benchbox) 项目，里面就内置了一个私有仓库。 我们甚至可以连仓库也不用建，直接定义包描述到项目 xmake.lua 中，这对依赖一两个包的情况还是很有用的，例如： ```lua package(\"libjpeg\", function() set_urls(\"http://www.ijg.org/files/jpegsrc.$(version).tar.gz\") add_versions(\"v9c\", \"650250979303a649e21f87b5ccd02672af1ea6954b911342ea491f351ceb7122\") on_install(\"windows\", function (package) os.mv(\"jconfig.vc\", \"jconfig.h\") os.vrun(\"nmake f makefile.vc\") os.cp(\"*.h\", package:installdir(\"include\")) os.cp(\"libjpeg.lib\", package:installdir(\"lib\")) end) on_install(\"macosx\", \"linux\", function (package) import(\"package.tools.autoconf\").install(package) end) end) add_requires(\"libjpeg\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"libjpeg\") end) ``` 关于如何编写自定义包描述规则，详情见：[添加包到仓库](# 添加包到仓库) ## 包管理命令使用 包管理命令 `$ xmake require` 可用于手动显示的下载编译安装、卸载、检索、查看包信息。 ### xrepo 命令 `xmake require` 仅用于当前工程，我们也提供了更加方便的独立 `xrepo` 包管理器命令，来全局对包进行安装，卸载和查找管理。 详细文档见：[Xrepo 命令使用入门](https://xrepo.xmake.io/#/zh cn/getting_started) ### 安装指定包 ```console $ xmake require tbox ``` 安装指定版本包： ```console $ xmake require tbox \"~1.6\" ``` 强制重新下载安装，并且显示详细安装信息： ```console $ xmake require f v tbox \"1.5.x\" ``` 传递额外的设置信息： ```console $ xmake require extra \"{debug true,config {small true}}\" tbox ``` 安装 debug 包，并且传递 `small true` 的编译配置信息到包中去。 ### 卸载指定包 ```console $ xmake require uninstall tbox ``` 这会完全卸载删除包文件。 ### 查看包详细信息 ```console $ xmake require info tbox ``` ### 在当前仓库中搜索包 ```console $ xmake require search tbox ``` 这个是支持模糊搜素以及 lua 模式匹配搜索的： ```console $ xmake require search pcr ``` 会同时搜索到 pcre, pcre2 等包。 ### 列举当前已安装的包 ```console $ xmake require list ``` ## 仓库管理命令使用 上文已经简单讲过，添加私有仓库可以用（支持本地路径添加）： ```console $ xmake repo add myrepo git@github.com:myrepo/xmake repo.git ``` xmake 支持添加指定分支的 repo，例如： ```console $ xmake repo add myrepo git@github.com:myrepo/xmake repo.git dev ``` > 我们也可以添加本地仓库路径，即使没有 git 也是可以支持的，用于在本地快速的调试 repo 中的包。 我们也可以移除已安装的某个仓库： ```console $ xmake repo remove myrepo ``` 或者查看所有已添加的仓库： ```console $ xmake repo list ``` 如果远程仓库有更新，可以手动执行仓库更新，来获取更多、最新的包： ```console $ xmake repo u ``` ## 远程包下载优化 如果由于网络不稳定，导致下载包速度很慢或者下载失败，我们可以通过的下面的一些方式来解决。 ### 手动下载 默认 xmake 会调用 curl, wget 等工具来下载，用户也可以手动用自己的下载器下载（也可以使用代理），把下载后的包放到自己的目录下，比如: `/download/packages/zlib v1.0.tar.gz` 然后使用下面的命令，设置包下载的搜索目录： ```console $ xmake g pkg_searchdirs \"/download/packages\" ``` 然后重新执行 xmake 编译时候，xmake 会优先从 `/download/packages` 找寻源码包，然后直接使用，不再自己下载了。 至于找寻的包名是怎样的呢，可以通过下面的命令查看： ```console $ xmake require info zlib > searchdirs: /download/packages > searchnames: zlib 1.2.11.tar.gz ``` 我们可以看到对应的搜索目录以及搜索的包名。 ### 设置代理 如果觉得手动下载还是麻烦，我们也可以让 xmake 直接走代理。 ```console $ xmake g proxy \"socks5://127.0.0.1:1086\" $ xmake g help x PROXY, proxy PROXY Use proxy on given port. [PROTOCOL://]HOST[:PORT] e.g. xmake g proxy 'http://host:port' xmake g proxy 'https://host:port' xmake g proxy 'socks5://host:port' ``` ` proxy` 参数指定代理协议和地址，具体语法可以参考 curl 的，通常可以支持 http, https, socks5 等协议，但实际支持力度依赖 curl, wget 和 git，比如 wget 就不支持 socks5 协议。 我们可以通过下面的参数指定哪些 host 走代理，如果没设置，默认全局走代理。 ```console proxy_hosts PROXY_HOSTS Only enable proxy for the given hosts list, it will enable all if be unset, and we can pass match pattern to list: e.g. xmake g proxy_hosts 'github.com,gitlab.*,*.xmake.io' ``` 如果设置了 hosts 列表，那么之后这个列表里面匹配的 host 才走代理。。 ` proxy_host` 支持多个 hosts 设置，逗号分隔，并且支持基础的模式匹配 *.github.com， 以及其他 lua 模式匹配规则也支持 如果觉得上面的 hosts 模式配置还不够灵活，我们也可以走 pac 的自动代理配置规则： ```console proxy_pac PROXY_PAC Set the auto proxy configuration file. (default: pac.lua) e.g. xmake g proxy_pac pac.lua (in /Users/ruki/.xmake or absolute path) function main(url, host) if host 'github.com' then return true end end ``` > 如果有 proxy_hosts 优先走 hosts 配置，没有的话才走 pac 配置。 pac 的默认路径：~/.xmake/pac.lua，如果 proxy 被设置，并且这个文件存在，就会自动走 pac，如果不存在，也没 hosts，那就全局生效代理。 也可以手动指定 pac 全路径 ```console $ xmake g proxy_pac /xxxx/xxxxx_pac.lua ``` 配置规则描述： ```lua function main(url, host) if host:find(\"bintray.com\") then return true end end ``` 如果返回 true，那么这个 url 和 host 就是走的代理，不返回或者返回 false，就是不走代理。 这块的具体详情见：<https://github.com/xmake io/xmake/issues/854> > 另外，除了依赖包下载，其他涉及网络下载的命令也都支持代理，比如：`xmake update` #### 镜像代理 v2.5.4 之后，pac.lua 配置里面还可以配置镜像代理规则，比如对所有 github.com 域名的访问切到 hub.fastgit.org 域名，实现加速下载包。 ```lua function mirror(url) return url:gsub(\"github.com\", \"hub.fastgit.org\") end ``` ```console $ xrepo install libpng > curl https://hub.fastgit.org/glennrp/libpng/archive/v1.6.37.zip o v1.6.37.zip ``` ## 添加包到仓库 ### 仓库包结构 在制作自己的包之前，我们需要先了解下一个包仓库的结构，不管是官方包仓库，还是自建私有包仓库，结构都是相同的： ``` xmake repo packages t/tbox/xmake.lua z/zlib/xmake.lua ``` 通过上面的结构，可以看到每个包都会有个 xmake.lua 用于描述它的安装规则，并且根据 `z/zlib` 两级子目录分类存储，方便快速检索。 ### 包描述说明 关于包的描述规则，基本上都是在它的 xmake.lua 里面完成的，这跟项目工程里面的 xmake.lua 描述很类似，不同的是描述域仅支持 `package()`， 不过，在项目 xmake.lua 里面，也是可以直接添加 `package()` 来内置包描述的，连包仓库都省了，有时候这样会更加方便。 首先，我们先拿 zlib 的描述规则，来直观感受下，这个规则可以在 [xmake repo/z/zlib/xmake.lua](https://github.com/xmake io/xmake repo/blob/master/packages/z/zlib/xmake.lua) 下找到。 ```lua package(\"zlib\", function() set_homepage(\"http://www.zlib.net\") set_description(\"A Massively Spiffy Yet Delicately Unobtrusive Compression Library\") set_urls(\"http://zlib.net/zlib $(version).tar.gz\", \"https://downloads.sourceforge.net/project/libpng/zlib/$(version)/zlib $(version).tar.gz\") add_versions(\"1.2.10\", \"8d7e9f698ce48787b6e1c67e6bff79e487303e66077e25cb9784ac8835978017\") add_versions(\"1.2.11\", \"c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1\") on_install(\"windows\", function (package) io.gsub(\"win32/Makefile.msc\", \"% MD\", \" \" .. package:config(\"vs_runtime\")) os.vrun(\"nmake f win32\\\\Makefile.msc zlib.lib\") os.cp(\"zlib.lib\", package:installdir(\"lib\")) os.cp(\"*.h\", package:installdir(\"include\")) end) on_install(\"linux\", \"macosx\", function (package) import(\"package.tools.autoconf\").install(package, {\" static\"}) end) on_install(\"iphoneos\", \"android@linux,macosx\", \"mingw@linux,macosx\", function (package) import(\"package.tools.autoconf\").configure(package, {host \"\",\" static\"}) io.gsub(\"Makefile\", \"\\nAR . \\n\", \"\\nAR \" .. (package:build_getenv(\"ar\") or \"\") ..\"\\n\") io.gsub(\"Makefile\", \"\\nARFLAGS . \\n\", \"\\nARFLAGS cr\\n\") io.gsub(\"Makefile\", \"\\nRANLIB . \\n\", \"\\nRANLIB \\n\") os.vrun(\"make install j4\") end) on_test(function (package) assert(package:has_cfuncs(\"inflate\", {includes \"zlib.h\"})) end) end) ``` 这个包规则对 windows, linux, macosx, iphoneos，mingw 等平台都添加了安装规则，基本上已经做到了全平台覆盖，甚至一些交叉编译平台，算是一个比较典型的例子了。 当然，有些包依赖源码实现力度，并不能完全跨平台，那么只需对它支持的平台设置安装规则即可。 更多详细的包配置 API 说明见：[包接口文档](/zh cn/manual/package_dependencies) ### 扩展配置参数 详情见：[add_configs](/zh cn/manual/package_dependencies?id packageadd_configs) ### 内置配置参数 除了可以通过 [add_configs](/zh cn/manual/package_dependencies?id packageadd_configs) 设置一些扩展的配置参数以外，xmake 还提供了一些内置的配置参数，可以使用 #### 启用调试包 ```lua add_requires(\"xxx\", {debug true}) ``` 包描述里面必须有相关处理才能支持： ```lua on_install(function (package) local configs {} if package:debug() then table.insert(configs, \" enable debug\") end import(\"package.tools.autoconf\").install(package) end) ``` #### 设置 msvc 运行时库 ```lua add_requires(\"xxx\", {configs {vs_runtime \"MT\"}}) ``` 通常情况下，通过 `import(\"package.tools.autoconf\").install` 等内置工具脚本安装的包，内部都对 vs_runtime 自动处理过了。 但是如果是一些特殊的源码包，构建规则比较特殊，那么需要自己处理了： ```lua on_install(function (package) io.gsub(\"build/Makefile.win32.common\", \"% MD\", \" \" .. package:config(\"vs_runtime\")) end) ``` ### 添加环境变量 对于一些库，里面也带了可执行的工具，如果需要在集成包的时候，使用上这些工具，那么也可以设置上对应 PATH 环境变量： ```lua package(\"luajit\", function() on_load(function (package) if is_plat(\"windows\") then package:addenv(\"PATH\", \"lib\") end package:addenv(\"PATH\", \"bin\") end) end) ``` 而在项目工程中，只有通过 `add_packages` 集成对应的包后，对应的环境变量才会生效。 ```lua add_requires(\"luajit\") target(\"test\", function() set_kind(\"binary\") add_packages(\"luajit\") after_run(function (package) os.exec(\"luajit version\") end) end) ``` ### 安装二进制包 xmake 也是支持直接引用二进制版本包，直接安装使用，例如： ```lua if is_plat(\"windows\") then set_urls(\"https://www.libsdl.org/release/SDL2 devel $(version) VC.zip\") add_versions(\"2.0.8\", \"68505e1f7c16d8538e116405411205355a029dcf2df738dbbc768b2fe95d20fd\") end on_install(\"windows\", function (package) os.cp(\"include\", package:installdir()) os.cp(\"lib/$(arch)/*.lib\", package:installdir(\"lib\")) os.cp(\"lib/$(arch)/*.dll\", package:installdir(\"lib\")) end) ``` ### 本地测试 如果在本地 xmake repo 仓库中，已经添加和制作好了新的包，可以在本地运行测试下，是否通过，如果测试通过，即可提交 pr 到官方仓库，请求 merge。 我们可以执行下面的脚本进行测试指定包： ```bash cd xmake repo xmake l scripts/test.lua v D zlib ``` 上面的命令，会强制重新下载和安装 zlib 包，测试整个安装流程是否 ok，加上 ` v D` 是为了可以看到完整详细的日志信息和出错信息，方便调试分析。 如果网络环境不好，不想每次测试都去重新下载所有依赖，可以加上 ` shallow` 参数来执行，这个参数告诉脚本，仅仅重新解压本地缓存的 zlib 源码包，重新执行安装命令，但不会下载各种依赖。 ```bash cd xmake repo xmake l scripts/test.lua v D shallow zlib ``` 如果我们想测试其他平台的包规则是否正常，比如: android, iphoneos 等平台，可以通过 ` p/ plat` 或者 ` a/ arch` 来指定。 ```bash cd xmake repo xmake l scripts/test.lua v D shallow p iphoneos a arm64 zlib xmake l scripts/test.lua v D shallow p android ndk /xxxx zlib ``` ## 提交包到官方仓库 目前这个特性刚完成不久，目前官方仓库的包还不是很多，有些包也许还不支持部分平台，不过这并不是太大问题，后期迭代几个版本后，我会不断扩充完善包仓库。 如果你需要的包，当前的官方仓库还没有收录，可以提交 issues 或者自己可以在本地调通后，贡献提交到官方仓库：[xmake repo](https://github.com/xmake io/xmake repo) 详细的贡献说明，见：[CONTRIBUTING.md](https://github.com/xmake io/xmake repo/blob/master/CONTRIBUTING.md) 关于如何制作自己的包，可以看下上文：[添加包到仓库](# 添加包到仓库)。 ## 依赖包的锁定和升级 xmake 支持依赖包的版本锁定，类似 npm 的 package.lock, cargo 的 cargo.lock。 比如，我们引用一些包，默认情况下，如果不指定版本，那么 xmake 每次都会自动拉取最新版本的包来集成使用，例如： ```lua add_requires(\"zlib\") ``` 但如果上游的包仓库更新改动，比如 zlib 新增了一个 1.2.11 版本，或者安装脚本有了变动，都会导致用户的依赖包发生改变。 这容易导致原本编译通过的一些项目，由于依赖包的变动出现一些不稳定因素，有可能编译失败等等。 为了确保用户的项目每次使用的包都是固定的，我们可以通过下面的配置去启用包依赖锁定。 ```lua set_policy(\"package.requires_lock\", true) ``` 这是一个全局设置，必须设置到全局根作用域，如果启用后，xmake 执行完包拉取，就会自动生成一个 `xmake requires.lock` 的配置文件。 它包含了项目依赖的所有包，以及当前包的版本等信息。 ```lua { __meta__ { version \"1.0\" }, [\"macosxx86_64\"] { [\"cmake#31fecfc4\"] { repo { branch \"master\", commit \"4498f11267de5112199152ab030ed139c985ad5a\", url \"https://github.com/xmake io/xmake repo.git\" }, version \"3.21.0\" }, [\"glfw#31fecfc4\"] { repo { branch \"master\", commit \"eda7adee81bac151f87c507030cc0dd8ab299462\", url \"https://github.com/xmake io/xmake repo.git\" }, version \"3.3.4\" }, [\"opengl#31fecfc4\"] { repo { branch \"master\", commit \"94d2eee1f466092e04c5cf1e4ecc8c8883c1d0eb\", url \"https://github.com/xmake io/xmake repo.git\" } } } } ``` 当然，我们也可以执行下面的命令，强制升级包到最新版本。 ```console $ xmake require upgrade upgrading packages .. zlib: 1.2.10 > 1.2.11 1 package is upgraded! ``` ## 分发和使用自定义包规则 我们可以在包管理仓库中，添加自定义构架规则脚本，实现跟随包进行动态下发和安装。 我们需要将自定义规则放到仓库的 `packages/x/xxx/rules` 目录中，它会跟随包一起被安装。 但是，它也存在一些限制： * 在包中规则，我们不能添加 `on_load`, `after_load` 脚本，但是通常我们可以使用 `on_config` 来代替。 ### 添加包规则 我们需要将规则脚本添加到 rules 固定目录下，例如：packages/z/zlib/rules/foo.lua ```lua rule(\"foo\", function() on_config(function (target) print(\"foo: on_config %s\", target:name()) end) end) ``` ### 应用包规则 使用规则的方式跟之前类似，唯一的区别就是，我们需要通过 `@packagename/` 前缀去指定访问哪个包里面的规则。 具体格式：`add_rules(\"@packagename/rulename\")`，例如：`add_rules(\"@zlib/foo\")`。 ```lua add_requires(\"zlib\", {system false}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"zlib\") add_rules(\"@zlib/foo\") end) ``` ### 通过包别名引用规则 如果存在一个包的别名，xmake 将优先考虑包的别名来获得规则。 ```lua add_requires(\"zlib\", {alias \"zlib2\", system false}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"zlib2\") add_rules(\"@zlib2/foo\") end) ``` ### 添加包规则依赖 我们可以使用 `add_deps(\"@bar\")` 来添加相对于当前包目录的其他规则。 然而，我们不能添加来自其他包的规则依赖，它们是完全隔离的，我们只能参考用户项目中由 `add_requires` 导入的其他包的规则。 packages/z/zlib/rules/foo.lua ```lua rule(\"foo\", function() add_deps(\"@bar\") on_config(function (target) print(\"foo: on_config %s\", target:name()) end) end) ``` packages/z/zlib/rules/bar.lua ```lua rule(\"bar\", function() on_config(function (target) print(\"bar: on_config %s\", target:name()) end) end) ``` ## 在 CMake 中使用 Xrepo 的依赖包管理 我们新增了一个独立项目 [xrepo cmake](https://github.com/xmake io/xrepo cmake)。 它是一个基于 Xrepo/Xmake 的 C/C++ 包管理器的 CMake 包装器。 这允许使用 CMake 来构建您的项目，同时使用 Xrepo 来管理依赖包。这个项目的部分灵感来自 [cmake conan](https://github.com/conan io/cmake conan)。 此项目的示例用例： * 想要使用 Xrepo 管理包的现有 CMake 项目。 * 必须使用 CMake，但想使用 Xrepo 管理的新项目包。 ### Apis #### xrepo_package [xrepo.cmake](https://github.com/xmake io/xrepo cmake/blob/main/xrepo.cmake) 提供 `xrepo_package` 函数来管理包。 ```cmake xrepo_package( \"foo 1.2.3\" [CONFIGS feature1 true,feature2 false] [CONFIGS path/to/script.lua] [DEPS] [MODE debugrelease] [ALIAS aliasname] [OUTPUT verbosediagnosisquiet] [DIRECTORY_SCOPE] ) ``` 一些函数参数直接对应于 Xrepo 命令选项。 `xrepo_package` 将软件包安装目录添加到 `CMAKE_PREFIX_PATH`。所以 `find_package` 可以使用。如果 `CMAKE_MINIMUM_REQUIRED_VERSION` > 3.1，cmake `pkgConfig` 也会搜索 对于软件包安装目录下的 pkgconfig 文件。 调用 `xrepo_package(foo)` 后，有 `foo` 包的三种使用方式： 1. 如果包提供 cmake 配置文件，则调用 `find_package(foo)`。 * 有关详细信息，请参阅 CMake [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html) 文档。 2. 如果包没有提供 cmake 配置文件或者找不到模块 * 以下变量可用于使用 pacakge（cmake 后的变量名 查找模块 [标准变量名称](https://cmake.org/cmake/help/latest/manual/cmake developer.7.html#standard variable names)) * `foo_INCLUDE_DIRS` * `foo_LIBRARY_DIRS` * `foo_LIBRARIES` * `foo_DEFINITIONS` * 如果指定了 `DIRECTORY_SCOPE`，则 `xrepo_package` 将运行以下代码 ```cmake include_directories(${foo_INCLUDE_DIRS}) link_directories(${foo_LIBRARY_DIRS}) ``` 3. 使用 `xrepo_target_packages`。请参阅以下部分。 注意 `CONFIGS path/to/script.lua` 用于对包配置进行精细控制。 例如： * 排除系统上的包。 * 覆盖依赖包的默认配置，例如设置 `shared true`。 如果指定了 `DEPS`，所有依赖库都将添加到 `CMAKE_PREFIX_PATH`，以及 include 和 libraries 那四个变量中。 #### xrepo_target_packages 将包 includedirs 和 links/linkdirs 添加到给定的目标。 ```cmake xrepo_target_packages( target [NO_LINK_LIBRARIES] [PRIVATEPUBLICINTERFACE] package1 package2 ... ) ``` ### 使用来自官方存储库的包 Xrepo 官方仓库：[xmake repo](https://github.com/xmake io/xmake repo) 这是一个使用 `gflags` 包版本 2.2.2 的示例 `CMakeLists.txt` 由 Xrepo 管理。 #### 集成 xrepo.cmake ```cmake cmake_minimum_required(VERSION 3.13.0) project(foo) # Download xrepo.cmake if not exists in build directory. if(NOT EXISTS \"${CMAKE_BINARY_DIR}/xrepo.cmake\") message(STATUS \"Downloading xrepo.cmake from https://github.com/xmake io/xrepo cmake/\") # mirror https://cdn.jsdelivr.net/gh/xmake io/xrepo cmake@main/xrepo.cmake file(DOWNLOAD \"https://raw.githubusercontent.com/xmake io/xrepo cmake/main/xrepo.cmake\" \"${CMAKE_BINARY_DIR}/xrepo.cmake\" TLS_VERIFY ON) endif() # Include xrepo.cmake so we can use xrepo_package function. include(${CMAKE_BINARY_DIR}/xrepo.cmake) ``` #### 添加包 ```cmake xrepo_package(\"zlib\") add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) xrepo_target_packages(example bin zlib) ``` #### 添加带有配置的包 ```cmake xrepo_package(\"gflags 2.2.2\" CONFIGS \"shared true,mt true\") add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) xrepo_target_packages(example bin gflags) ``` #### 添加带有 cmake 导入模块的包 ```cmake xrepo_package(\"gflags 2.2.2\" CONFIGS \"shared true,mt true\") # `xrepo_package` 会将 gflags 安装目录添加到 CMAKE_PREFIX_PATH. # `find_package(gflags)` 会从 CMAKE_PREFIX_PATH 包含的目录中找到 gflags 提供的 # config file 文件。 # 参考 https://cmake.org/cmake/help/latest/command/find_package.html#search modes find_package(gflags CONFIG COMPONENTS shared) add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) target_link_libraries(example bin gflags) ``` #### 添加自定义包 ```cmake set(XREPO_XMAKEFILE ${CMAKE_CURRENT_SOURCE_DIR}/packages/xmake.lua) xrepo_package(\"myzlib\") add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) xrepo_target_packages(example bin myzlib) ``` 在 packages/xmake.lua 中定义一个包： ```lua package(\"myzlib\") ... ``` 我们可以自定义一个包，具体定义方式，参考文档：[自定义 Xrepo 包](https://xmake.io/#/zh cn/package/remote_package?id package description)。 ### 使用来自第三个存储库的包 除了从官方维护的存储库安装软件包之外，Xrepo 还可以安装来自第三方包管理器的包，例如 vcpkg/conan/conda/pacman/homebrew/apt/dub/cargo。 关于命令行的使用，我们可以参考文档：[Xrepo 命令用法](https://xrepo.xmake.io/#/getting_started?id install packages from third party package manager) 我们也可以直接在 cmake 中使用它来安装来自第三方仓库的包，只需将仓库名称添加为命名空间即可。例如：`vcpkg::zlib`, `conan::pcre2` #### Conan ```cmake xrepo_package(\"conan::gflags/2.2.2\") ``` #### Conda ```cmake xrepo_package(\"conda::gflags 2.2.2\") ``` #### Vcpkg ```cmake xrepo_package(\"vcpkg::gflags\") ``` #### Homebrew ```cmake xrepo_package(\"brew::gflags\") ```"},"/get_started/zh/package/system-package.html":{"title":"","content":" class: heading_no_counter # 使用系统包 ## 查找使用系统包 xmake 对远程包和系统包的使用进行了统一，全部使用 `add_requires(\"zlib\")` 接口来描述集成，而默认的配置方式，它会优先从系统上查找库，如果没有，会自动下载安装集成。 而如果我们仅仅想查找使用系统库，不想远程下载，可以这么配置： ```lua add_requires(\"zlib\", {system true}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") end) ``` 通过 `{system true}` 就可以强制禁用远程下载，这时候，他就等价于 xmake/CMake 的 `find_package`，但是更加简单易用，并且和远程包使用方式完全一致。 默认情况下，如果找不到系统库，就是提示失败，如果这个包是可选的，那么可以额外配置 `{optional true}` 选项。 ```lua add_requires(\"zlib\", {system true, optional true}) ``` ## 查找包快速测试 我们可以使用下面的命令，快速检测系统上指定的包信息： ```console $ xmake l find_package x264 { links { \"x264\" }, linkdirs { \"/usr/local/Cellar/x264/r2699/lib\" }, version \"0.148.2699 a5e06b9\", includedirs { \"/usr/local/Cellar/x264/r2699/include\" } } ``` 我们也可以追加第三方包管理器前缀来测试： ```console xmake l find_package conan::OpenSSL/1.0.2g ``` > 需要注意的是，find_package 命令如果在带有 xmake.lua 的工程目录下执行，是会有缓存的，如果查找失败，下次查找也会使用缓存的结果，如果要每次强制重新检测，请切换到非工程目录下执行上面的命令。"},"/get_started/zh/option/script-scope.html":{"title":"","content":" class: heading_no_counter # 脚本域 ## option:value 获取选项的值。 ## option:name 获取选项的名字。 ## option:get 获取选项在描述域的配置值。 任何在描述域的 `set_xxx` 和 `add_xxx` 配置值都可以通过这个接口获取到。 ```lua get the links option:get(\"links\") get the defined macros option:get(\"defines\") ``` ## option:set 设置选项的配置值，（如果你想添加值可以用 [option:add](#optionadd)）。 ```lua set the links option:set(\"links\", \"sdl2\") set the defined macros option:set(\"defines\", \"SDL_MAIN_HANDLED\") set configvar option:set(\"configvar\", option:name(), option:value(), {quote false}) ``` ## option:add 按名称添加到选项的值 ```lua add links option:add(\"links\", \"sdl2\") add defined macros option:add(\"defines\", \"SDL_MAIN_HANDLED\") ```"},"/get_started/zh/option/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 定义和设置选项开关，每个 `option` 对应一个选项，可用于自定义编译配置选项、开关设置。 > 除了 `target` 以外的所有域接口，例如 `option`，`task` 等的接口，默认不能放置在外面的全局作用域中的（除非部分跟 target 共用的接口除外）。 > 如果要设置值影响所有 `option`，`task` 等选项，可以通过匿名全局域来设置。 > 不过我们不推荐这么使用，后续是会废弃掉 `option_end` 接口以保持 xmake.lua 脚本的易读性。 例如： ```lua 进入 option 的匿名全局域，里面的设置会同时影响 test 和 test2 选项 option() add_defines(\"DEBUG\") option(\"test\") ... 尽量保持缩进，因为这个之后的所有设置，都是针对 test 选项的 option(\"test2\") ... ``` > `option` 域是可以重复进入来实现分离设置的，如果要显示离开当前选项的作用域设置，可以手动调用 [option_end](#option_end) 接口。 ## option 定义和设置选项开关，可用于自定义编译配置选项、开关设置。 例如，定义一个是否启用 test 的选项： ```lua option(\"test\", function() set_default(false) set_showmenu(true) add_defines(\"TEST\") end) ``` 然后关联到指定的 target 中去： ```lua target(\"demo\", function() add_options(\"test\") end) ``` 这样，一个选项就算定义好了，如果这个选项被启用，那么编译这个 target 的时候，就会自动加上 ` DTEST` 的宏定义。 ```lua # 手动启用这个选项 $ xmake f test y $ xmake ``` ## option_end 这是一个可选 api，显示离开选项作用域，用法和 [target_end](/zh cn/manual/project_target?id target_end) 类似。 ## option:add_deps 通过设置依赖，可以调整选项的检测顺序，一般用于 [on_check](#optionon_check) 等检测脚本的调用时机。 ```lua option(\"small\", function() set_default(true) on_check(function (option) ... end) end) option(\"test\", function() add_deps(\"small\") set_default(true) after_check(function (option) if option:dep(\"small\"):enabled() then option:enable(false) end end) end) ``` 当依赖的 small 选项检测完成后，通过判断 small 选项的状态，来控制 test 的选项状态。 > 由于 on_check 只有在没有设置 default 值的情况下才会被执行，因此如果设置了 default 值，那么可以在 after_check 阶段处理自定义逻辑。 ## option:before_check 选项检测之前执行此脚本： ```lua option(\"zlib\", function() before_check(function (option) end) end) ``` ## option:on_check 自定义选项检测脚本，此脚本会覆盖内置的选项检测逻辑。 ```lua option(\"test\", function() add_deps(\"small\") on_check(function (option) option:enable(true) end) end) ``` > 仅仅在 `set_default` 没有被设置的情况下，才会执行 `on_check` 进行自定义的选项检测脚本。 ## option:after_check 在选项检测完成后，执行此脚本做一些后期处理，也可以在此时重新禁用选项： ```lua option(\"test\", function() add_deps(\"small\") add_links(\"pthread\") after_check(function (option) option:enable(false) end) end) ``` ## option:set_values 设置选项值列表，仅用于 `xmake f menu` 的图形菜单配置时，提供选项值列表供用户快速选择使用，例如： ```lua option(\"test\", function() set_default(\"b\") set_showmenu(true) set_values(\"a\", \"b\", \"c\") end) ``` 效果图如下： ![option set values](image/option_set_values.png) ## option:set_default 在没有通过 `xmake f option [yn}` 等命令修改选项值的时候，这个选项本身也是有个默认值的，可以通过这个接口来设置： ```lua option(\"test\", function() 默认禁用这个选项 set_default(false) end) ``` 选项的值不仅支持 boolean 类型，也可以是字符串类型，例如： ```lua option(\"test\", function() set_default(\"value\") end) ``` 值类型 描述 配置 boolean 一般用作参数开关，值范围：`true/false` `xmake f optionname [y/n/yes/no/true/false]` string 可以是任意字符串，一般用于模式判断 `xmake f optionname value` 如果是 `boolean` 值的选项，可以通过 [has_config](/zh cn/manual/conditions?id has_config) 来进行判断，选项是否被启用。 如果是 `string` 类型的选项，可以在内建变量中直接使用，例如： ```lua 定义一个路径配置选项，默认使用临时目录 option(\"rootdir\", function() set_default(\"$(tmpdir)\") set_showmenu(true) end) target(\"test\", function() 添加指定选项目录中的源文件 add_files(\"$(rootdir)/*.c\") end) ``` 其中，`$(rootdir)` 就是自定义的选项内建变量，通过手动配置，可以动态修改它的值： ```bash $ xmake f rootdir ~/projectdir/src $ xmake ``` 给这个 `rootdir` 选项指定一个其他的源码目录路径，然后编译。 选项的检测行为： default 值 检测行为 没有设置 优先手动配置修改，默认禁用，否则会启用自动检测，也会执行 on_check，可根据手动传入的值类型，自动切换 boolean 和 string 类型 false 开关选项，不自动检测，默认禁用，可手动配置修改 true 开关选项，不自动检测，默认启用，可手动配置修改 string 类型 无开关状态，不自动检测，可手动配置修改，一般用于配置变量传递 ## option:set_showmenu 用于设置是否启用菜单显示。 如果设置为 `true`，那么在 `xmake f help` 里面就会出现这个选项，也就能通过 `xmake f optionname xxx` 进行配置，否则只能在 `xmake.lua` 内部使用，无法手动配置修改。 ```lua option(\"test\", function() set_showmenu(true) end) ``` 设置为启用菜单后，执行 `xmake f help` 可以看到，帮助菜单里面多了一项： ``` Options: ... test TEST ``` > 此选项默认改为启用，通常都不需要额外配置它。考虑后面删除这个 api。 ## option:set_category 这个是个可选配置，仅用于在帮助菜单中，进行分类显示选项，同一类别的选项，会在同一个分组里面显示，这样菜单看起来更加的美观。 例如： ```lua option(\"test1\", function() set_showmenu(true) set_category(\"test\") end) option(\"test2\", function() set_showmenu(true) set_category(\"test\") end) option(\"demo1\", function() set_showmenu(true) set_category(\"demo\") end) option(\"demo2\", function() set_showmenu(true) set_category(\"demo\") end) ``` 这里四个选项分别归类于两个分组：`test` 和 `demo`，那么显示的布局类似这样： ```bash Options: ... test1 TEST1 test2 TEST2 demo1 DEMO1 demo2 DEMO2 ``` 这个接口，仅仅是为了调整显示布局，更加美观而已，没其他用途。 还可以通过 category 设置分级路径名 `set_category(\"root/submenu/submenu2\")`，来配置 `xmake f menu` 的图形菜单界面，例如： ```lua 'boolean' option option(\"test1\", function() set_default(true) set_showmenu(true) set_category(\"root menu/test1\") end) 'choice' option with values: \"a\", \"b\", \"c\" option(\"test2\", function() set_default(\"a\") set_values(\"a\", \"b\", \"c\") set_showmenu(true) set_category(\"root menu/test2\") end) 'string' option option(\"test3\", function() set_default(\"xx\") set_showmenu(true) set_category(\"root menu/test3/test3\") end) 'number' option option(\"test4\", function() set_default(6) set_showmenu(true) set_category(\"root menu/test4\") end) ``` 上述配置最后显示的菜单界面路径结构： root menu test1 test2 test3 test3 test4 效果图如下： ![opiton set category](image/option_set_category.gif) ## option:set_description 设置选项菜单显示时，右边的描述信息，用于帮助用户更加清楚的知道这个选项的用途，例如： ```lua option(\"test\", function() set_default(false) set_showmenu(true) set_description(\"Enable or disable test\") end) ``` 生成的菜单内容如下： ``` Options: ... test TEST Enable or disable test (default: false) ``` 这个接口也支持多行显示，输出更加详细的描述信息，例如： ```lua option(\"mode\", function() set_default(\"debug\") set_showmenu(true) set_description(\"Set build mode\", \" debug\", \" release\", \" profile\") end) ``` 生成的菜单内容如下： ``` Options: ... mode MODE Set build mode (default: debug) debug release profile ``` 看到这个菜单，用户就能清楚地知道，定义的这个 `mode` 选项的具体用处，以及如何使用了： ```bash $ xmake f mode release ``` ## option:add_links 添加链接库检测。 如果指定的链接库检测通过，此选项将被启用，并且对应关联的 target 会自动加上此链接，例如： ```lua option(\"pthread\", function() add_links(\"pthread\") add_linkdirs(\"/usr/local/lib\") end) target(\"test\", function() add_options(\"pthread\") end) ``` 如果检测通过，`test` 目标编译的时候就会自动加上：` L/usr/local/lib lpthread` 编译选项 ## option:add_linkdirs 添加链接库检测时候需要的搜索目录。 这个是可选的，一般系统库不需要加这个，也能检测通过，如果确实没找到，可以自己追加搜索目录，提高检测通过率。具体使用见：[add_links](#optionadd_links) ## option:add_rpathdirs 添加程序运行时动态库的加载搜索目录。 在选项通过检测后，会自动添加到对应的 target 上去，具体使用见：[target.add_rpathdirs](/zh cn/manual/project_target?id targetadd_rpathdirs)。 ## option:add_cincludes 添加 c 头文件检测。 如果 c 头文件检测通过，此选项将被启用，例如： ```lua option(\"pthread\", function() add_cincludes(\"pthread.h\") add_defines(\"ENABLE_PTHREAD\") end) target(\"test\", function() add_options(\"pthread\") end) ``` 此选项检测是否存在 `pthread.h` 的头文件，如果检测通过那么 `test` 目标程序将会加上 `ENABLE_PTHREAD` 的宏定义。 如果想要更加灵活的检测，可以通过 [lib.detect.has_cincludes](#detect has_cincludes) 在[option.on_check](#optionon_check)中去实现。 ## option:add_cxxincludes 添加 c++ 头文件检测。 与 [add_cincludes](#optionadd_cincludes) 类似，只是检测的头文件类型是 c++ 头文件。 ## option:add_ctypes 添加 c 类型检测。 如果 c 类型检测通过，此选项将被启用，例如： ```lua option(\"wchar\", function() add_ctypes(\"wchar_t\") add_defines(\"HAVE_WCHAR\") end) target(\"test\", function() add_options(\"wchar\") end) ``` 此选项检测是否存在 `wchar_t` 的类型，如果检测通过那么 `test` 目标程序将会加上 `HAVE_WCHAR` 的宏定义。 如果想要更加灵活的检测，可以通过 [lib.detect.has_ctypes](#detect has_ctypes) 在[option.on_check](#optionon_check)中去实现。 ## option:add_cxxtypes 添加 c++ 类型检测。 与 [add_ctypes](#optionadd_ctypes) 类似，只是检测的类型是 c++ 类型。 ## option:add_csnippets 添加 c 代码片段检测。 如果现有的 [add_ctypes](#optionadd_ctypes), [add_cfuncs](#optionadd_cfuncs) 等不能满足当前的检测需求， 可以用这个接口实现更加定制化检测一些编译器特性检测，具体见: [add_cxxsnippets](#optionadd_cxxsnippets)。 ## option:add_cxxsnippets 添加 c++ 代码片段检测。 可以用这个接口实现更加定制化检测一些编译器特性检测，尤其是 c++ 的各种特性的检测支持，例如： ```lua option(\"constexpr\", function() add_cxxsnippets(\"constexpr\", \"constexpr int f(int x) { int sum 0; for (int i 0; i< x; ++i) sum + i; return sum; } constexpr int x f(5); static_assert(x 15);\") end) ``` 第一个参数设置代码片段的名字作为标示，检测输出信息时候会有显示。 上述代码，实现对 c++ 的 constexpr 特性的检测，如果检测通过，则启用 constexpr 选项，当然这里只是个例子。 对于编译器特性的检测，有更加方便高效的检测模块，提供更强大的检测支持，具体见：[compiler.has_features](#compiler has_features) 和 [detect.check_cxsnippets](#detect check_cxsnippets) 如果想要更加灵活的检测，可以通过 [lib.detect.check_cxsnippets](#detect check_cxsnippets) 在[option.on_check](#optionon_check)中去实现。 另外我们还可以通过 `{tryrun true}` 和 `{output true}` 两个选项用于尝试运行检测和捕获输出。 设置 tryrun 可以尝试运行来检测： ```lua option(\"test\", function() add_cxxsnippets(\"HAS_INT_4\", \"return (sizeof(int) 4)? 0 : 1;\", {tryrun true}) end) ``` 设置 output 也会尝试去检测，并且额外捕获运行的输出内容。 ```lua option(\"test\", function() add_cxxsnippets(\"INT_SIZE\", 'printf(\"%d\", sizeof(int)); return 0;', {output true, number true}) end) ``` > 设置为捕获输出，当前 option 不能再设置其他 snippets。 我们也可以通过 `is_config` 获取绑定到 option 的输出。 ```lua if is_config(\"test\", \"8\") tben xxx end ``` ## option:add_cfuncs 添加 c 库函数检测。 ```lua option(\"setjmp\", function() add_cincludes(\"setjmp.h\") add_cfuncs(\"sigsetjmp\", \"setjmp\") add_defines(\"HAVE_SETJMP\") end) target(\"test\", function() add_options(\"setjmp\") end) ``` 此选项检测是否存在 `setjmp` 的一些接口，如果检测通过那么 `test` 目标程序将会加上 `HAVE_SETJMP` 的宏定义。 里面的函数片段支持下面几种语法格式： ```lua 单纯检测函数地址是否存在，内部会尝试去它的地址来判断 sigsetjmp 如果有些函数是宏定义 wrap 的，可以通过这种方式绕通过检测 sigsetjmp((void*)0, 0) 也可以指定一个完整函数语句，例如：funcname{codebody} sigsetjmp{sigsetjmp((void*)0, 0);} sigsetjmp{int a 0; sigsetjmp((void*)a, a);} ``` 注意，检测的函数通常需要附带 `add_cincludes` 确保函数能够被正常 include 进来，否则检测会失败。 ## option:add_cxxfuncs 添加 c++ 库函数检测。 用法跟 [option:add_cfuncs](#optionadd_cxxfuncs) 一致。"},"/get_started/zh/task/builtin-plugins.html":{"title":"","content":" class: heading_no_counter # 内置插件 ## 生成 IDE 工程文件 ### 简介 xmake 跟 `cmake`, `premake` 等其他一些构建工具的区别在于： > `xmake` 默认是直接构建运行的，生成第三方的 IDE 的工程文件仅仅作为 “插件” 来提供。 这样做的一个好处是：插件更加容易扩展，维护也更加独立和方便。 ### 生成 Makefile ```console $ xmake project k makefile ``` ### 生成 CMakelists.txt ```console $ xmake project k cmakelists ``` ### 生成 build.ninja ```console $ xmake project k ninja ``` ### 生成 compiler_flags ```console $ xmake project k compiler_flags ``` ### 生成 compile_commands 导出每个源文件的编译信息，生成基于 clang 的编译数据库文件，json 格式，可用于跟 ide，编辑器，静态分析工具进行交互。 ```console $ xmake project k compile_commands ``` 输出的内容格式如下： ``` [ { \"directory\": \"/home/user/llvm/build\", \"command\": \"/usr/bin/clang++ Irelative DSOMEDEF \\\"With spaces, quotes and \\\\ es.\\\" c o file.o file.cc\", \"file\": \"file.cc\" }, ... ] ``` 对于 `compile_commands` 的详细说明见：[JSONCompilationDatabase](#https://clang.llvm.org/docs/JSONCompilationDatabase.html) ### 生成 Xcode 工程文件 目前，我们还没有时间去自己实现 xcode 工程的生成，但不代表不支持，因为 xmake 支持生成 cmakelists.txt 文件，而 cmake 是支持 xcode 工程文件生成的，在官方还没有实现之前， 我们也可以通过 cmake 变相支持它，xmake 会自动内部调用 cmake 中转下生成结果，对用户而言使用上没啥区别，只需要确保 cmake 已经安装即可： ```console $ xmake project k xcode ``` ## 运行自定义 lua 脚本 这个跟宏脚本类似，只是省去了导入导出操作，直接指定 lua 脚本来加载运行，这对于想要快速测试一些接口模块，验证自己的某些思路，都是一个不错的方式。 ### 运行指定的脚本文件 我们先写个简单的 lua 脚本： ```lua function main() print(\"hello xmake!\") end ``` 然后直接运行它就行了： ```console $ xmake lua /tmp/test.lua ``` > 当然，你也可以像宏脚本那样，使用 `import` 接口导入扩展模块，实现复杂的功能。 ### 运行内置的脚本命令 你可以运行 `xmake lua l` 来列举所有内置的脚本名，例如： ```console $ xmake lua l scripts: cat cp echo versioninfo ... ``` 并且运行它们： ```console $ xmake lua cat ~/file.txt $ xmake lua echo \"hello xmake\" $ xmake lua cp /tmp/file /tmp/file2 $ xmake lua versioninfo ``` ### 运行交互命令 (REPL) 有时候在交互模式下，运行命令更加的方便测试和验证一些模块和 api，也更加的灵活，不需要再去额外写一个脚本文件来加载。 我们先看下，如何进入交互模式： ```console # 不带任何参数执行，就可以进入 $ xmake lua > # 进行表达式计算 > 1 + 2 3 # 赋值和打印变量值 > a 1 > a 1 # 多行输入和执行 > for _, v in pairs({1, 2, 3}) do >> print(v) >> end 1 2 3 ``` 我们也能够通过 `import` 来导入扩展模块： ```console > task import(\"core.project.task\") > task.run(\"hello\") hello xmake! ``` 如果要中途取消多行输入，只需要输入字符：`q` 就行了 ```console > for _, v in ipairs({1, 2}) do >> print(v) >> q < 取消多行输入，清空先前的输入数据 > 1 + 2 3 ``` ## 显示指定信息和列表 ### 显示 xmake 自身和当前项目的基础信息 ```bash $ xmake show The information of xmake: version: 2.3.3+202006011009 host: macosx/x86_64 programdir: /Users/ruki/.local/share/xmake programfile: /Users/ruki/.local/bin/xmake globaldir: /Users/ruki/.xmake tmpdir: /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/200603 workingdir: /Users/ruki/projects/personal/tbox packagedir: /Users/ruki/.xmake/packages packagedir(cache): /Users/ruki/.xmake/cache/packages/2006 The information of project: tbox version: 1.6.5 plat: macosx arch: x86_64 mode: release buildir: build configdir: /Users/ruki/projects/personal/tbox/.xmake/macosx/x86_64 projectdir: /Users/ruki/projects/personal/tbox projectfile: /Users/ruki/projects/personal/tbox/xmake.lua ``` ### 显示工具链列表 ```bash $ xmake show l toolchains xcode Xcode IDE vs VisualStudio IDE yasm The Yasm Modular Assembler clang A C language family frontend for LLVM go Go Programming Language Compiler dlang D Programming Language Compiler sdcc Small Device C Compiler cuda CUDA Toolkit ndk Android NDK rust Rust Programming Language Compiler llvm A collection of modular and reusable compiler and toolchain technologies cross Common cross compilation toolchain nasm NASM Assembler gcc GNU Compiler Collection mingw Minimalist GNU for Windows gnu rm GNU Arm Embedded Toolchain envs Environment variables toolchain fasm Flat Assembler ``` ### 显示指定 target 配置信息 我们可以用它来快速追溯定位一些特定配置的位置。 ```bash $ xmake show t tbox The information of target(tbox): at: /Users/ruki/projects/personal/tbox/src/tbox/xmake.lua kind: static targetfile: build/macosx/x86_64/release/libtbox.a rules: > mode.release > ./xmake.lua:26 > mode.debug > ./xmake.lua:26 > mode.profile > ./xmake.lua:26 > mode.coverage > ./xmake.lua:26 > utils.install.cmake_importfiles > ./src/tbox/xmake.lua:15 > utils.install.pkgconfig_importfiles > ./src/tbox/xmake.lua:16 options: > info > ./src/tbox/xmake.lua:50 > float > ./src/tbox/xmake.lua:50 > wchar > ./src/tbox/xmake.lua:50 > exception > ./src/tbox/xmake.lua:50 > force utf8 > ./src/tbox/xmake.lua:50 > deprecated > ./src/tbox/xmake.lua:50 > xml > ./src/tbox/xmake.lua:53 > zip > ./src/tbox/xmake.lua:53 > hash > ./src/tbox/xmake.lua:53 > regex > ./src/tbox/xmake.lua:53 > coroutine > ./src/tbox/xmake.lua:53 > object > ./src/tbox/xmake.lua:53 > charset > ./src/tbox/xmake.lua:53 > database > ./src/tbox/xmake.lua:53 packages: > mbedtls > ./src/tbox/xmake.lua:43 > polarssl > ./src/tbox/xmake.lua:43 > openssl > ./src/tbox/xmake.lua:43 > pcre2 > ./src/tbox/xmake.lua:43 > pcre > ./src/tbox/xmake.lua:43 > zlib > ./src/tbox/xmake.lua:43 > mysql > ./src/tbox/xmake.lua:43 > sqlite3 > ./src/tbox/xmake.lua:43 links: > pthread > option(__keyword_thread_local) > @programdir/includes/check_csnippets.lua:100 syslinks: > pthread > ./xmake.lua:71 > dl > ./xmake.lua:71 > m > ./xmake.lua:71 > c > ./xmake.lua:71 defines: > __tb_small__ > ./xmake.lua:42 > __tb_prefix__ \"tbox\" > ./src/tbox/xmake.lua:19 > _GNU_SOURCE 1 > option(__systemv_semget) > @programdir/includes/check_cfuncs.lua:104 cxflags: > Wno error deprecated declarations > ./xmake.lua:22 > fno strict aliasing > ./xmake.lua:22 > Wno error expansion to defined > ./xmake.lua:22 > fno stack protector > ./xmake.lua:51 frameworks: > CoreFoundation > ./src/tbox/xmake.lua:38 > CoreServices > ./src/tbox/xmake.lua:38 mxflags: > Wno error deprecated declarations > ./xmake.lua:23 > fno strict aliasing > ./xmake.lua:23 > Wno error expansion to defined > ./xmake.lua:23 includedirs: > src > ./src/tbox/xmake.lua:26 > build/macosx/x86_64/release > ./src/tbox/xmake.lua:27 headerfiles: > src/(tbox/**.h)**/impl/**.h > ./src/tbox/xmake.lua:30 > src/(tbox/prefix/**/prefix.S) > ./src/tbox/xmake.lua:31 > src/(tbox/math/impl/*.h) > ./src/tbox/xmake.lua:32 > src/(tbox/utils/impl/*.h) > ./src/tbox/xmake.lua:33 > build/macosx/x86_64/release/tbox.config.h > ./src/tbox/xmake.lua:34 files: > src/tbox/*.c > ./src/tbox/xmake.lua:56 > src/tbox/hash/bkdr.c > ./src/tbox/xmake.lua:57 > src/tbox/hash/fnv32.c > ./src/tbox/xmake.lua:57 > src/tbox/hash/adler32.c > ./src/tbox/xmake.lua:57 > src/tbox/math/**.c > ./src/tbox/xmake.lua:58 > src/tbox/libc/**.cstring/impl/**.c > ./src/tbox/xmake.lua:59 > src/tbox/utils/*.coption.c > ./src/tbox/xmake.lua:60 > src/tbox/prefix/**.c > ./src/tbox/xmake.lua:61 > src/tbox/memory/**.c > ./src/tbox/xmake.lua:62 > src/tbox/string/**.c > ./src/tbox/xmake.lua:63 > src/tbox/stream/**.c**/charset.c**/zip.c > ./src/tbox/xmake.lua:64 > src/tbox/network/**.cimpl/ssl/*.c > ./src/tbox/xmake.lua:65 > src/tbox/algorithm/**.c > ./src/tbox/xmake.lua:66 > src/tbox/container/**.celement/obj.c > ./src/tbox/xmake.lua:67 > src/tbox/libm/impl/libm.c > ./src/tbox/xmake.lua:68 > src/tbox/libm/idivi8.c > ./src/tbox/xmake.lua:73 > src/tbox/libm/ilog2i.c > ./src/tbox/xmake.lua:70 > src/tbox/libm/isqrti.c > ./src/tbox/xmake.lua:71 > src/tbox/libm/isqrti64.c > ./src/tbox/xmake.lua:72 > src/tbox/platform/*.ccontext.cexception.c > ./src/tbox/xmake.lua:74 > src/tbox/platform/impl/*.ccharset.cpoller_fwatcher.c > ./src/tbox/xmake.lua:74 > src/tbox/libm/*.c > ./src/tbox/xmake.lua:77 compiler (cc): /usr/bin/xcrun sdk macosx clang > Qunused arguments target x86_64 apple macos12.6 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX13.0.sdk linker (ar): /usr/bin/xcrun sdk macosx ar > cr compflags (cc): > Qunused arguments target x86_64 apple macos12.6 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX13.0.sdk Wall Werror Oz std c99 Isrc Ibuild/macosx/x86_64/release D__tb_small__ D__tb_prefix__ \\\"tbox\\\" D_GNU_SOURCE 1 framework CoreFoundation framework CoreServices Wno error deprecated declarations fno strict aliasing Wno error expansion to defined fno stack protector linkflags (ar): > cr ``` ### 显示内置编译模式列表 ```bash $ xmake show l buildmodes ``` ### 显示内置编译规则列表 ```bash $ xmake show l rules ``` ### 显示其他信息 还在完善中，详情见：<https://github.com/xmake io/xmake/issues/798> 或者运行： ```bash $ xmake show help ``` ## 监视文件更新 `xmake watch` 插件命令可以自动监视项目文件更新，然后触发自动构建，或者运行一些自定义命令。 这通常用于个人开发时候，实现快速的实时增量编译，而不需要每次手动执行编译命令，提高开发效率。 ### 项目更新后自动构建 默认行为就是监视整个项目根目录，任何文件改动都会触发项目的增量编译。 ```bash $ xmake watch watching /private/tmp/test/src/** .. watching /private/tmp/test/* .. /private/tmp/test/src/main.cpp modified [25%]: cache compiling.release src/main.cpp [50%]: linking.release test [100%]: build ok! ``` ### 监视指定目录 我们也可以监视指定的代码目录，缩小监视范围，提升监视性能。 ```bash $ xmake watch d src $ xmake watch d \"src;tests/*\" ``` 上面的命令，会去递归监视所有子目录，如果想要紧紧监视当前目录下的文件，不进行递归监视，可以使用下面的命令。 ```bash $ xmake watch p src $ xmake watch p \"src;tests/*\" ``` ### 监视并运行指定命令 如果想在自动构建后，还想自动运行构建的程序，我们可以使用自定义的命令集。 ```bash $ xmake watch c \"xmake; xmake run\" ``` 上面的命令列表是作为字符串传递，这对于复杂命令参数，需要转义比较繁琐不够灵活，那么我们可以使用下面的方式进行任意命令的设置。 ```bash $ xmake watch echo hello xmake! $ xmake watch xmake run help ``` ### 监视并运行目标程序 尽管我们可以通过自定义命令来实现目标程序的自动运行，但是我们也提供了更加方便的参数来实现这个行为。 ```bash $ xmake watch r $ xmake watch run [100%]: build ok! hello world! ``` ### 监视并运行 lua 脚本 我们还可以监视文件更新后，运行指定的 lua 脚本，实现更加灵活复杂的命令定制。 ```bash $ xmake watch s /tmp/test.lua ``` 我们还可以再脚本中获取所有更新的文件路径列表和事件。 ```lua function main(events) TODO handle events end ``` ## 分析诊断工程配置和代码 ### 检测工程配置 #### 默认检测所有 API ```lua set_lanuages(\"c91\") typo ``` ```console $ xmake check ./xmake.lua:15: warning: unknown language value 'c91', it may be 'c90' 0 notes, 1 warnings, 0 errors ``` 默认也可以指定检测特定组： ```console $ xmake check api $ xmake check api.target ``` #### 显示详细输出 这会额外提供 note 级别的检测信息。 ```console $ xmake check v ./xmake.lua:15: warning: unknown language value 'cxx91', it may be 'cxx98' ./src/tbox/xmake.lua:43: note: unknown package value 'mbedtls' ./src/tbox/xmake.lua:43: note: unknown package value 'polarssl' ./src/tbox/xmake.lua:43: note: unknown package value 'openssl' ./src/tbox/xmake.lua:43: note: unknown package value 'pcre2' ./src/tbox/xmake.lua:43: note: unknown package value 'pcre' ./src/tbox/xmake.lua:43: note: unknown package value 'zlib' ./src/tbox/xmake.lua:43: note: unknown package value 'mysql' ./src/tbox/xmake.lua:43: note: unknown package value 'sqlite3' 8 notes, 1 warnings, 0 errors ``` #### 检测指定的 API ```console $ xmake check api.target.languages ./xmake.lua:15: warning: unknown language value 'cxx91', it may be 'cxx98' 0 notes, 1 warnings, 0 errors ``` #### 检测编译 flags ```console $ xmake check ./xmake.lua:10: warning: clang: unknown c compiler flag ' Ox' 0 notes, 1 warnings, 0 errors ``` #### 检测 includedirs 除了 includedirs，还有 linkdirs 等路径都会去检测。 ```console $ xmake check ./xmake.lua:11: warning: includedir 'xxx' not found 0 notes, 1 warnings, 0 errors ``` ### 检测工程代码（clang tidy） #### 显示 clang tidy 检测列表 ```console $ xmake check clang.tidy list Enabled checks: clang analyzer apiModeling.StdCLibraryFunctions clang analyzer apiModeling.TrustNonnull clang analyzer apiModeling.google.GTest clang analyzer apiModeling.llvm.CastValue clang analyzer apiModeling.llvm.ReturnValue ... ``` #### 检测所有 targets 中的源码 ```console $ xmake check clang.tidy 1 error generated. Error while processing /private/tmp/test2/src/main.cpp. /tmp/test2/src/main.cpp:1:10: error: 'iostr' file not found [clang diagnostic error] #include <iostr> ^~~~~~~ Found compiler error(s). error: execv(/usr/local/opt/llvm/bin/clang tidy p compile_commands.json /private/tmp/test2/src /main.cpp) failed(1) ``` #### 指定检测类型 我们可以在 ` check ` 中指定需要检测的类型，具体用法可以参考 `clang tidy` 的 ` check ` 参数，完全一致的。 ```console $ xmake check clang.tidy checks \"*\" 6 warnings and 1 error generated. Error while processing /private/tmp/test2/src/main.cpp. /tmp/test2/src/main.cpp:1:10: error: 'iostr' file not found [clang diagnostic error] #include <iostr> ^~~~~~~ /tmp/test2/src/main.cpp:3:1: warning: do not use namespace using directives; use using declarat ions instead [google build using namespace] using namespace std; ^ /tmp/test2/src/main.cpp:3:17: warning: declaration must be declared within the '__llvm_libc' na mespace [llvmlibc implementation in namespace] using namespace std; ^ /tmp/test2/src/main.cpp:5:5: warning: declaration must be declared within the '__llvm_libc' nam espace [llvmlibc implementation in namespace] int main(int argc, char **argv) { ^ /tmp/test2/src/main.cpp:5:5: warning: use a trailing return type for this function [modernize u se trailing return type] int main(int argc, char **argv) { ~~~ ^ auto > int /tmp/test2/src/main.cpp:5:14: warning: parameter 'argc' is unused [misc unused parameters] int main(int argc, char **argv) { ^~~~ /*argc*/ /tmp/test2/src/main.cpp:5:27: warning: parameter 'argv' is unused [misc unused parameters] int main(int argc, char **argv) { ^~~~ /*argv*/ Found compiler error(s). error: execv(/usr/local/opt/llvm/bin/clang tidy checks * p compile_commands.json /private/tm p/test2/src/main.cpp) failed(1) ``` #### 检测指定 target 的代码 ```console $ xmake check clang.tidy [targetname] ``` #### 检测给定的源文件列表 ```console $ xmake check clang.tidy f src/main.c $ xmake check clang.tidy f 'src/*.c:src/**.cpp' ``` #### 设置 .clang tidy 配置文件 ```console $ xmake check clang.tidy configfile /tmp/.clang tidy ``` #### 创建 .clang tidy 配置文件 ```console $ xmake check clang.tidy checks \"*\" create $ cat .clang tidy Checks: 'clang diagnostic *,clang analyzer *,*' WarningsAsErrors: '' HeaderFilterRegex: '' AnalyzeTemporaryDtors: false FormatStyle: none User: ruki CheckOptions: key: readability suspicious call argument.PrefixSimilarAbove value: '30' key: cppcoreguidelines no malloc.Reallocations value: '::realloc' ``` #### 自动修复错误代码 我们可以使用下面的命令参数，自动修复 clang tidy 检测出来的问题代码。 ``` console $ xmake check clang.tidy fix $ xmake check clang.tidy fix_errors $ xmake check clang.tidy fix_notes ``` ## 生成安装包 (XPack) ### 简介 这个插件可以帮助用户快速生成不同平台的安装包，源码包，它会生成下面一些安装包格式： Windows NSIS 二进制安装包 Windows WIX 二进制安装包 runself (shell) 自编译安装包 zip/tar.gz 二进制包 zip/tar.gz 源码包 RPM 二进制安装包 SRPM 源码安装包 DEB 二进制安装包 下面是一个完整例子，我们可以先简单看下： ```lua set_version(\"1.0.0\") add_rules(\"mode.debug\", \"mode.release\") includes(\"@builtin/xpack\") target(\"test\") set_kind(\"binary\") add_files(\"src/*.cpp\") xpack(\"test\") set_formats(\"nsis\", \"zip\", \"targz\", \"runself\") set_title(\"hello\") set_author(\"ruki\") set_description(\"A test installer.\") set_homepage(\"https://xmake.io\") set_licensefile(\"LICENSE.md\") add_targets(\"test\") add_installfiles(\"src/(assets/*.png)\", {prefixdir \"images\"}) add_sourcefiles(\"(src/**)\") set_iconfile(\"src/assets/xmake.ico\") after_installcmd(function (package, batchcmds) batchcmds:mkdir(package:installdir(\"resources\")) batchcmds:cp(\"src/assets/*.txt\", package:installdir(\"resources\"), {rootdir \"src\"}) batchcmds:mkdir(package:installdir(\"stub\")) end) after_uninstallcmd(function (package, batchcmds) batchcmds:rmdir(package:installdir(\"resources\")) batchcmds:rmdir(package:installdir(\"stub\")) end) ``` 我们通过 `includes(\"@builtin/xpack\")` 引入 xpack 的所有配置接口，包括 xpack 配置域，以及它的所有域接口。 然后我们执行： ```bash $ xmake pack ``` 即可生成所有安装包。 ### 生成 NSIS 安装包 只要配置了 `set_formats(\"nsis\")` 格式，然后执行 `xmake pack` 命令，就能生成 NSIS 格式的安装包。 另外，xmake 还会自动安装生成 NSIS 包所需的工具，实现真正的一键打包。 ```bash $ xmake pack note: install or modify (m) these packages (pass y to skip confirm)? in xmake repo: > nsis 3.09 please input: y (y/n/m) > install nsis 3.09 .. ok [25%]: compiling.release src\\main.cpp [37%]: compiling.release src\\main.cpp [50%]: linking.release foo.dll [62%]: linking.release test.exe packing build\\xpack\\test\\test windows x64 v1.0.0.exe pack ok ``` `test windows x64 v1.0.0.exe` 就是我们生成的安装包，双击运行它，就能安装我们的二进制文件到指定目录。 ![](/assets/img/manual/nsis_1.png) ![](/assets/img/manual/nsis_2.png) ![](/assets/img/manual/nsis_3.png) #### 增加组件安装 我们还可以给 NSIS 增加组件安装命令，只有当用户选择指定组件的时候，它的安装命令才会被执行。 ```lua xpack(\"test\") add_components(\"LongPath\") xpack_component(\"LongPath\") set_default(false) set_title(\"Enable Long Path\") set_description(\"Increases the maximum path length limit, up to 32,767 characters (before 256).\") on_installcmd(function (component, batchcmds) batchcmds:rawcmd(\"nsis\", [[ ${If} $NoAdmin \"false\" ; Enable long path WriteRegDWORD ${HKLM} \"SYSTEM\\CurrentControlSet\\Control\\FileSystem\" \"LongPathsEnabled\" 1 ${EndIf}]]) end) ``` 这个例子中，我们在里面添加了一个 NSIS 特有的自定义命令，去实现对长路径的支持。 ![](/assets/img/manual/nsis_4.png) ### 生成自安装包 我们也可以生成基于 shell 脚本的自编译安装包。我们需要配置 runself 打包格式，然后通过 `add_sourcefiles` 添加需要参与编译安装的源文件。 接着，我们需要自定义 on_installcmd 安装脚本，里面去配置如果编译源码包，我们可以简单的调用一个内置的编译安装脚本文件，也可以直接配置 `make install` 等编译安装命令。 例如： ```lua xpack(\"test\") set_formats(\"runself\") add_sourcefiles(\"(src/**)\") on_installcmd(function (package, batchcmds) batchcmds:runv(\"make\", {\"install\"}) end) ``` 然后，我们执行 `xmake pack` 命令，就可以生成一个自安装的 xxx.gz.run 包，默认采用 gzip 压缩。 ```bash $ xmake pack packing build/xpack/test/test macosx src v1.0.0.gz.run pack ok ``` 我们可以使用 sh 去加载运行它来安装我们的程序。 ```bash $ sh ./build/xpack/test/test macosx src v1.0.0.gz.run ``` 我们也可以看一个比较完整的例子： ```lua xpack(\"xmakesrc\") set_formats(\"runself\") set_basename(\"xmake v$(version)\") set_prefixdir(\"xmake $(version)\") before_package(function (package) import(\"devel.git\") local rootdir path.join(os.tmpfile(package:basename()) .. \".dir\", \"repo\") if not os.isdir(rootdir) then os.tryrm(rootdir) os.cp(path.directory(os.projectdir()), rootdir) git.clean({repodir rootdir, force true, all true}) git.reset({repodir rootdir, hard true}) if os.isfile(path.join(rootdir, \".gitmodules\")) then git.submodule.clean({repodir rootdir, force true, all true}) git.submodule.reset({repodir rootdir, hard true}) end end local extraconf {rootdir rootdir} package:add(\"sourcefiles\", path.join(rootdir, \"core/**src/pdcurses/**src/luajit/**src/tbox/tbox/src/demo/**\"), extraconf) package:add(\"sourcefiles\", path.join(rootdir, \"xmake/**\"), extraconf) package:add(\"sourcefiles\", path.join(rootdir, \"*.md\"), extraconf) package:add(\"sourcefiles\", path.join(rootdir, \"configure\"), extraconf) package:add(\"sourcefiles\", path.join(rootdir, \"scripts/*.sh\"), extraconf) package:add(\"sourcefiles\", path.join(rootdir, \"scripts/man/**\"), extraconf) package:add(\"sourcefiles\", path.join(rootdir, \"scripts/debian/**\"), extraconf) package:add(\"sourcefiles\", path.join(rootdir, \"scripts/msys/**\"), extraconf) end) on_installcmd(function (package, batchcmds) batchcmds:runv(\"./scripts/get.sh\", {\"__local__\"}) end) ``` 它是 xmake 自身源码的安装包配置脚本，更完整的配置可以参考：[xpack.lua](https://github.com/xmake io/xmake/blob/master/core/xpack.lua) 这里，它通过调用源码包内置的 `./scripts/get.sh` 安装脚本去执行编译安装。 ### 生成源码归档包 另外，我们也可以配置 `srczip` 和 `srctargz` 格式，来生成源码压缩包，它不是完整的安装包，也没有安装命令，仅仅用于源码包分发。 ```lua xpack(\"test\") set_formats(\"srczip\", \"srctargz\") add_sourcefiles(\"(src/**)\") ``` ```bash $ xmake pack packing build/xpack/test/test macosx src v1.0.0.zip .. packing build/xpack/test/test macosx src v1.0.0.tar.gz .. pack ok ``` ### 生成二进制归档包 我们也可以配置 `zip` 和 `targz` 来生成二进制的压缩包，它会先自动编译所有绑定的 target 目标程序，将所有需要的二进制程序，库文件打包到 zip/tar.gz 格式。 这通常用于制作绿色版的安装包，内部不太任何自动安装脚本，用户需要自己设置 PATH 等环境变量。 ```lua xpack(\"test\") set_formats(\"zip\", \"targz\") add_installfiles(\"(src/**)\") ``` ```bash $ xmake pack packing build/xpack/test/test macosx v1.0.0.zip .. packing build/xpack/test/test macosx v1.0.0.tar.gz .. pack ok ``` !> 需要注意的是，打二进制文件到包里，使用的是 `add_installfiles` 而不是 `add_sourcefiles`。 我们也可以通过 `add_targets` 去绑定需要安装的 target 目标程序和库。更多详情见下面关于 `add_targets` 的接口描述。 ### 生成 SRPM 源码安装包 它可以生成 `.src.rpm` 格式的源码安装包。 我们可以通过配置 add_targets 关联需要构建的目标，在生成的 srpm 包中，它会自动调用 `xmake build` 和 `xmake install` 去构建和安装包。 ```lua xpack(\"test\") set_homepage(\"https://xmake.io\") set_license(\"Apache 2.0\") set_description(\"A cross platform build utility based on Lua.\") set_formats(\"srpm\") add_sourcefiles(\"(src/**)\") add_sourcefiles(\"./xmake.lua\") add_targets(\"demo\") ``` 它会生成类似下面的 spec 文件，然后自动调用 rpmbuild 去生成 `.src.rpm` 包。 ``` Name: test Version: 1.0.0 Release: 1%{?dist} Summary: hello License: Apache 2.0 URL: https://xmake.io Source0: test linux src v1.0.0.tar.gz BuildRequires: xmake BuildRequires: gcc BuildRequires: gcc c++ %description A test installer. %prep %autosetup n test 1.0.0 p1 %build xmake build y test %install xmake install o %{buildroot}/%{_exec_prefix} test cd %{buildroot} find . type f sed 's!^\\./!/!' > %{_builddir}/_installedfiles.txt %check %files f %{_builddir}/_installedfiles.txt %changelog * Fri Dec 22 2023 ruki 1.0.0 1 Update to 1.0.0 ``` 我们也可以通过 `on_buildcmd` 和 `on_installcmd` 自定义构建和安装脚本。 ```lua xpack(\"test\") set_homepage(\"https://xmake.io\") set_license(\"Apache 2.0\") set_description(\"A cross platform build utility based on Lua.\") set_formats(\"srpm\") add_sourcefiles(\"(src/**)\") add_sourcefiles(\"./configure\") on_buildcmd(function (package, batchcmds) batchcmds:runv(\"./configure\") batchcmds:runv(\"make\") end) on_installcmd(function (package, batchcmds) batchcmds:runv(\"make\", {\"install\", \"PREFIX %{buildroot}\"}) end) ``` ### 生成 RPM 二进制安装包 RPM 包将会直接生成编译好的二进制安装包。xmake 会自动调用 `rpmbuild rebuild` 命令去构建 SRPM 包生成它。 而在 XPack 中，我们仅仅只需要配置 `set_formats(\"rpm\")` 即可支持 rpm 包生成，其他配置与 srpm 包完全一致。 ```lua xpack(\"test\") set_formats(\"rpm\") TODO ``` ### 打包命令参数 #### 指定打包格式 如果我们在配置文件中已经使用 `set_formats` 配置了多个打包格式，那么默认情况下，`xmake pack` 会自动生成所有这些格式的包。 当然，我们也可以通过 `xmake pack formats nsis,targz` 来选择性指定当前需要打哪些格式的包。 #### 修改打包文件名 我们可以在配置文件中，通过 `set_basename()` 来修改包名，也可以通过命令行去修改它。 ```bash $ xmake pack basename \"foo\" packing build/xpack/test/foo.zip .. pack ok ``` #### 指定输出目录 默认的输出目录是在 build 目录下，但我们也可以修改输出的路径。 ```bash $ xmake pack o /tmp/output ``` #### 禁用自动构建 如果是打 NSIS 等二进制包，`xmake pack` 会先自动编译所有被绑定的 target 目标文件，然后再去执行打包逻辑。 但是如果我们已经编译过了，不想每次都去编译它，而是直接去打包，可以通过下面的参数禁用自动构建。 ```bash $ xmake pack autobuild n ``` ### 接口描述 更多 XPack 打包接口描述见：[XPack 打包接口文档](https://xmake.io/#/zh cn/manual/xpack)。 ## 宏记录和回放 ### 简介 我们可以通过这个插件，快速记录和回放我们平常频繁使用到的一些 xmake 操作，来简化我们日常的开发工作。 它提供了一些功能： 手动记录和回放多条执行过的 xmake 命令 支持快速的匿名宏创建和回放 支持命名宏的长久记录和重用 支持宏脚本的批量导入和导出 支持宏脚本的删除、显示等管理功能 支持自定义高级宏脚本，以及参数配置 ### 记录操作 ```console # 开始记录宏 $ xmake macro begin # 执行一些 xmake 命令 $ xmake f p android ndk /xxx/ndk a arm64 v8a $ xmake p $ xmake f p mingw sdk /mingwsdk $ xmake p $ xmake f p linux sdk /toolsdk toolchains /xxxx/bin $ xmake p $ xmake f p iphoneos a armv7 $ xmake p $ xmake f p iphoneos a arm64 $ xmake p $ xmake f p iphoneos a armv7s $ xmake p $ xmake f p iphoneos a i386 $ xmake p $ xmake f p iphoneos a x86_64 $ xmake p # 结束宏记录，这里不设置宏名字，所以记录的是一个匿名宏 xmake macro end ``` ### 回放 ```console # 回放一个匿名宏 $ xmake macro . ``` ### 命名宏 匿名宏的好处就是快速记录，快速回放，如果需要长久保存，就需要给宏取个名字。 ```console $ xmake macro begin $ ... $ xmake macro end macroname $ xmake macro macroname ``` ### 导入导出宏 导入指定的宏脚本或者宏目录： ```console $ xmake macro import /xxx/macro.lua macroname $ xmake macro import /xxx/macrodir ``` 导出指定的宏到脚本或者目录： ```console $ xmake macro export /xxx/macro.lua macroname $ xmake macro export /xxx/macrodir ``` ### 列举显示宏 列举所有 `xmake` 内置的宏脚本： ```console $ xmake macro list ``` 显示指定的宏脚本内容： ```console $ xmake macro show macroname ``` ### 自定义宏脚本 我们也可以自己编写个宏脚本 `macro.lua` 然后导入到 xmake 中去。 ```lua function main() os.exec(\"xmake f p android ndk /xxx/ndk a arm64 v8a\") os.exec(\"xmake p\") os.exec(\"xmake f p mingw sdk /mingwsdk\") os.exec(\"xmake p\") os.exec(\"xmake f p linux sdk /toolsdk toolchains /xxxx/bin\") os.exec(\"xmake p\") os.exec(\"xmake f p iphoneos a armv7\") os.exec(\"xmake p\") os.exec(\"xmake f p iphoneos a arm64\") os.exec(\"xmake p\") os.exec(\"xmake f p iphoneos a armv7s\") os.exec(\"xmake p\") os.exec(\"xmake f p iphoneos a i386\") os.exec(\"xmake p\") os.exec(\"xmake f p iphoneos a x86_64\") os.exec(\"xmake p\") end ``` 导入到 xmake，并且定义宏名字： ```console $ xmake macro import /xxx/macro.lua [macroname] ``` 回放这个宏脚本： ```console $ xmake macro [.macroname] ``` ### 内置的宏脚本 XMake 提供了一些内置的宏脚本，来简化我们的日常开发工作。 例如，我们可以使用 `package` 宏来对 `iphoneos` 平台的所有架构，一次性批量构建和打包： ```console $ xmake macro package p iphoneos ``` ### 高级的宏脚本编写 以上面提到的 `package` 宏为例，我们看下其具体代码，里面通过 `import` 导入一些扩展模块，实现了复杂的脚本操作。 ```lua imports import(\"core.base.option\") import(\"core.project.config\") import(\"core.project.project\") import(\"core.platform.platform\") the options local options { {'p', \"plat\", \"kv\", os.host(), \"Set the platform.\" } , {'f', \"config\", \"kv\", nil, \"Pass the config arguments to \\\"xmake config\\\"..\"} , {'o', \"outputdir\", \"kv\", nil, \"Set the output directory of the package.\"} } package all .e.g xmake m package xmake m package f \" m debug\" xmake m package p linux xmake m package p iphoneos f \" m debug xxx ...\" o /tmp/xxx xmake m package f \\\" mode debug\\\" function main(argv) parse arguments local args option.parse(argv, options, \"Package all architectures for the given the platform.\" , \"\" , \"Usage: xmake macro package [options]\") package all archs local plat args.plat for _, arch in ipairs(platform.archs(plat)) do config it os.exec(\"xmake f p %s a %s %s c %s\", plat, arch, args.config or \"\", (option.get(\"verbose\") and\" v\"or\"\")) package it if args.outputdir then os.exec(\"xmake p o %s %s\", args.outputdir, (option.get(\"verbose\") and \" v\" or \"\")) else os.exec(\"xmake p %s\", (option.get(\"verbose\") and \" v\" or \"\")) end end package universal for iphoneos, watchos ... if plat \"iphoneos\" or plat \"watchos\" then load configure config.load() load project project.load() enter the project directory os.cd(project.directory()) the outputdir directory local outputdir args.outputdir or config.get(\"buildir\") package all targets for _, target in pairs(project.targets()) do get all modes local modedirs os.match(format(\"%s/%s.pkg/lib/*\", outputdir, target:name()), true) for _, modedir in ipairs(modedirs) do get mode local mode path.basename(modedir) make lipo arguments local lipoargs nil for _, arch in ipairs(platform.archs(plat)) do local archfile format(\"%s/%s.pkg/lib/%s/%s/%s/%s\", outputdir, target:name(), mode, plat, arch, path.filename(target:targetfile())) if os.isfile(archfile) then lipoargs format(\"%s arch %s %s\", lipoargs or \"\", arch, archfile) end end if lipoargs then make full lipo arguments lipoargs format(\" create %s output %s/%s.pkg/lib/%s/%s/universal/%s\", lipoargs, outputdir, target:name(), mode, plat, path.filename(target:targetfile())) make universal directory os.mkdir(format(\"%s/%s.pkg/lib/%s/%s/universal\", outputdir, target:name(), mode, plat)) package all archs os.execv(\"xmake\", {\"l\", \"lipo\", lipoargs}) end end end end end ``` !> 如果你想要获取更多宏参数选项信息，请运行： `xmake macro help` ## 生成 doxygen 文档 请先确保本机已安装 `doxygen` 工具，然后在工程目录下运行： ```console $ xmake doxygen ```"},"/get_started/zh/task/plugin-development.html":{"title":"","content":" class: heading_no_counter # 开发插件 ## 简介 xmake 完全支持插件模式，我们可以很方便的扩展实现自己的插件，并且 xmake 也提供了一些内建的使用插件。 我们可以执行下 `xmake h` 看下当前支持的插件： ``` Plugins: l, lua Run the lua script. m, macro Run the given macro. doxygen Generate the doxygen document. hello Hello xmake! project Create the project file. ``` * lua: 运行 lua 脚本的插件 * macro: 这个很实用，宏脚本插件，可以手动录制多条 xmake 命令并且回放，也可以通过脚本实现一些复杂的宏脚本，这个我们后续会更加详细的介绍 * doxygen：一键生成 doxygen 文档的插件 * hello: 插件 demo，仅仅显示一句话：'hello xmake!' * project： 生成工程文件的插件，目前已经支持 make, cmake, ninja, xcode (需要 cmake) 和 vs 的工程文件以及 compile_commands.json 和 compile_flags.txt 文件的生成 ## 快速开始 接下来我们介绍下本文的重点，一个简单的 hello xmake 插件的开发，代码如下： ```lua 定义一个名叫 hello 的插件任务 task(\"hello\", function() 设置类型为插件 set_category(\"plugin\") 插件运行的入口 on_run(function () 显示 hello xmake! print(\"hello xmake!\") end) 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述 set_menu { usage usage \"xmake hello [options]\" description , description \"Hello xmake!\" options , options {} } end) ``` 这个插件的文件结构如下： ``` plugins hello xmake.lua ... plugins 目录下无需 xmake.lua ``` 现在一个最简单的插件写完了，那怎么让它被 xmake 检测到呢，有三种方式： 1. 把 hello 这个文件夹放置在 xmake 的插件安装目录 `xmake/plugins`，这个里面都是些内建的插件 2. 把 hello 文件夹放置在 `~/.xmake/plugins` 用户全局目录，这样对当前 xmake 全局生效 3. 把 hello 文件夹放置在当前工程的 `./plugins` 目录下，通过在工程描述文件 xmake.lua 中调用 `add_plugindirs(\"plugins\")` 添加当前的工程的插件搜索目录，这样只对当前工程生效 ## 运行插件 接下来，我们尝试运行下这个插件： ```console xmake hello ``` 显示结果： ``` hello xmake! ``` 最后我们还可以在 target 自定义的脚本中运行这个插件： ```lua target(\"demo\", function() 构建之后运行插件 after_build(function (target) 导入 task 模块 import(\"core.project.task\") 运行插件任务 task.run(\"hello\") end) end) ```"},"/get_started/zh/task/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 xmake 可以实现自定义任务或者插件，其两者的核心就是 `task` 任务，其两者实际上是一样的，xmake 的插件都是用 `task` 实现的。 本质上都是任务，只是 [set_category](#taskset_category) 分类不同而已。 接口 描述 [task](#task) 定义插件或者任务 [set_menu](#taskset_menu) 设置任务菜单 [set_category](#taskset_category) 设置任务类别 [on_run](#taskon_run) 设置任务运行脚本 ## task 定义插件或者任务。 `task` 域用于描述一个自定义的任务实现，与 [target](#target) 和[option](#option)同级。 例如，这里定义一个最简单的任务： ```lua task(\"hello\", function() 设置运行脚本 on_run(function () print(\"hello xmake!\") end) end) ``` 这个任务只需要打印 `hello xmake!`，那如何来运行呢？ 由于这里没有使用 [set_menu](#taskset_menu) 设置菜单，因此这个任务只能在 `xmake.lua` 的自定义脚本或者其他任务内部调用，例如： ```lua target(\"test\", function() after_build(function (target) 导入 task 模块 import(\"core.project.task\") 运行 hello 任务 task.run(\"hello\") end) end) ``` 在构建完 `test` 目标后运行 `hello` 任务。 ## task:set_menu 设置任务菜单。 通过设置一个菜单，这个任务就可以开放给用户自己通过命令行手动调用，菜单的设置如下： ```lua task(\"echo\", function() 设置运行脚本 on_run(function () 导入参数选项模块 import(\"core.base.option\") 初始化颜色模式 local modes \"\" for _, mode in ipairs({\"bright\", \"dim\", \"blink\", \"reverse\"}) do if option.get(mode) then modes modes .. \" \" .. mode end end 获取参数内容并且显示信息 cprint(\"${%s%s}%s\", option.get(\"color\"), modes, table.concat(option.get(\"contents\") or {}, \" \")) end) 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述 set_menu { 设置菜单用法 usage \"xmake echo [options]\" 设置菜单描述 , description \"Echo the given info!\" 设置菜单选项，如果没有选项，可以设置为 {} , options { 设置 k 模式作为 key only 型 bool 参数 {'b', \"bright\", \"k\", nil, \"Enable bright.\"} , {'d', \"dim\", \"k\", nil, \"Enable dim.\"} , {' ', \"blink\", \"k\", nil, \"Enable blink.\"} , {'r', \"reverse\", \"k\", nil, \"Reverse color.\"} 菜单显示时，空白一行 , {} 设置 kv 作为 key value 型参数，并且设置默认值：black , {'c', \"color\", \"kv\", \"black\", \"Set the output color.\" , \" red\" , \" blue\" , \" yellow\" , \" green\" , \" magenta\" , \" cyan\" , \" white\" } 设置 `vs` 作为 values 多值型参数，还有 `v` 单值类型 一般放置在最后，用于获取可变参数列表 , {} , {nil, \"contents\", \"vs\", nil, \"The info contents.\"} } } end) ``` 定义完这个任务后，执行 `xmake help`，就会多出一个任务项来： ``` Tasks: ... echo Echo the given info! ``` 如果通过 [set_category](#taskset_category) 设置分类为 `plugin`，那么这个任务就是一个插件了： ``` Plugins: ... echo Echo the given info! ``` 想要手动运行这个任务，可以执行： ```bash $ xmake echo hello xmake! ``` 就行了，如果要看这个任务定义的菜单，只需要执行：`xmake echo [ h help]`，显示结果如下： ```bash Usage: $xmake echo [options] Echo the given info! Options: v, verbose Print lots of verbose information. backtrace Print backtrace information for debugging. profile Print performance data for debugging. version Print the version number and exit. h, help Print this help message and exit. F FILE, file FILE Read a given xmake.lua file. P PROJECT, project PROJECT Change to the given project directory. Search priority: 1. The Given Command Argument 2. The Envirnoment Variable: XMAKE_PROJECT_DIR 3. The Current Directory b, bright Enable bright. d, dim Enable dim. , blink Enable blink. r, reverse Reverse color. c COLOR, color COLOR Set the output color. (default: black) red blue yellow green magenta cyan white contents ... The info contents. ``` > 其中菜单最开头的部分选项，是 xmake 内置的常用选项，基本上每个任务都会用到，不需要自己额外定义，简化菜单定义。 下面，我们来实际运行下这个任务，例如我要显示红色的 `hello xmake!`，只需要： ```bash $ xmake echo c red hello xmake! ``` 也可以使用选项全名，并且加上高亮： ```bash $ xmake echo color red bright hello xmake! ``` 最后面的可变参数列表，在 `run` 脚本中通过 `option.get(\"contents\")` 获取，返回的是一个 `table` 类型的数组。 ## task:set_category 设置任务类别。 仅仅用于菜单的分组显示，当然插件默认会用 `plugin`，内置任务默认会用：`action`，但也仅仅只是个约定。 > 你可以使用任何自己定义的名字，相同名字会分组归类到一起显示，如果设置为 `plugin`，就会显示到 xmake 的 Plugins 分组中去。 例如： ```lua Plugins: l, lua Run the lua script. m, macro Run the given macro. doxygen Generate the doxygen document. project Generate the project file. hello Hello xmake! app2ipa Generate .ipa file from the given .app echo Echo the given info! ``` 如果没有调用这个接口设置分类，默认使用 `Tasks` 分组显示，代表普通任务。 ## task:on_run 设置任务运行脚本。 可以有两种设置方式，最简单的就是设置内嵌函数： ```lua task(\"hello\", function() on_run(function () print(\"hello xmake!\") end) end) ``` 这种对于小任务很方便，也很简洁，但是对于大型任务就不太适用了，例如插件等，需要复杂的脚本支持。 这个时候就需要独立的模块文件来设置运行脚本，例如： ```lua task(\"hello\", function() on_run(\"main\") end) ``` 这里的 `main` 设置为脚本运行主入口模块，文件名为 `main.lua`，放在定义 `task` 的 `xmake.lua` 的同目录下，当然你可以起其他文件名。 目录结构如下： ``` projectdir xmake.lua main.lua ``` `main.lua` 里面内容如下： ```lua function main(...) print(\"hello xmake!\") end ``` 就是一个简单的带 `main` 主函数的脚本文件，你可以通过 [import](/zh cn/manual/builtin_modules?id import) 导入各种扩展模块，实现复杂功能，例如： ```lua 导入参数选项模块 import(\"core.base.option\") 入口函数 function main(...) 获取参数内容 print(\"color: %s\", option.get(\"color\")) end ``` 你也可以在当前目录下，创建多个自定义的模块文件，通过 [import](/zh cn/manual/builtin_modules?id import) 导入后使用，例如： ``` projectdir xmake.lua main.lua module.lua ``` `module.lua` 的内容如下： ```lua 定义一个导出接口 function hello() print(\"hello xmake!\") end ``` > 私有接口，通过 `_hello` 带下滑线前缀命名，这样导入的模块就不会包含此接口，只在模块自身内部使用。 然后在 `main.lua` 进行调用： ```lua import(\"module\") function main(...) module.hello() end ``` 更多模块介绍见：[内置模块](/zh cn/manual/builtin_modules) 和 [扩展模块](/zh cn/manual/extension_modules) 其中，`main(...)` 中参数，是通过 `task.run` 指定的，例如： ```lua task.run(\"hello\", {color \"red\"}, arg1, arg2, arg3) ``` 里面的 `arg1, arg2` 这些就是传入 `hello` 任务 `main(...)` 入口的参数列表，而 `{color \"red\"}` 用来指定任务菜单中的参数选项。 更加详细的 `task.run` 描述，见：[task.run](#task run)。"},"/get_started/zh/target/script-scope.html":{"title":"","content":" class: heading_no_counter # 脚本域 此页面描述了 [工程目标](zh cn/manual/project_target.html) 的 `on_load()`、`before_build()` 或 `after_install()` 等函数的 `target` 接口。 ## target:name 获取目标的名字。 ## target:get 获取目标在描述域的配置值。 任何在描述域的 `set_xxx` 和 `add_xxx` 配置值都可以通过这个接口获取到。 ```lua get the links target:get(\"links\") get the defined macros target:get(\"defines\") ``` ## target:set 设置目标的配置值，（如果你想添加值可以用 [target:add](#targetadd)）。 ```lua set the links target:set(\"links\", \"sdl2\") set the defined macros target:set(\"defines\", \"SDL_MAIN_HANDLED\") ``` ## target:add 按名称添加到目标的值。 ```lua add links target:add(\"links\", \"sdl2\") add defined macros target:add(\"defines\", \"SDL_MAIN_HANDLED\") ``` ## target:kind 获取目标程序类型。 对应 `set_kind` 描述域接口设置。目标类型主要有：binary, static, shared, phony, object, headeronly。 ## target:is_plat 当前平台是否是给定平台之一。 尽管，我们也可以用 `is_plat` 全局接口直接判断平台，但是 xmake 支持使用 `set_plat` 针对特定 target 单独设置编译平台。 这个时候，使用全局接口，就不适用了，所以通常我们推荐使用 target 提供的接口，来直接对当前 target 判断编译平台，更加可靠。 ```lua Is the current platform android? target:is_plat(\"android\") Is the current platform windows, linux or macosx? target:is_plat(\"windows\", \"linux\", \"macosx\") ``` ## target:is_arch 当前架构是否是给定架构之一。 尽管，我们也可以用 `is_arch` 全局接口直接判断架构，但是 xmake 支持使用 `set_arch` 针对特定 target 单独设置编译架构。 这个时候，使用全局接口，就不适用了，所以通常我们推荐使用 target 提供的接口，来直接对当前 target 判断编译架构，更加可靠。 ```lua Is the current architecture x86 target:is_arch(\"x86\") Is the current architecture x64 or x86_64 target:is_arch(\"x64\", \"x86_64\") ``` ## target:targetfile 获取目标文件路径。 主要用于获取 static, shared, binary 目标程序文件的输出路径。 ```lua os.cp(target:targetfile(), \"/tmp/\") ``` ## target:targetdir 获取目标文件的输出目录。 也就是 target:targetfile() 对应的存储目录。 ## target:basename 获取目标文件的 base 名。 也就是 libfoo.a，foo.dll, foo.exe 中的 `foo`。 ## target:filename 获取目标文件名。 目标文件的完整文件名，等价于 `path.filename(target:targetfile())`。 ## target:installdir 获取目标文件的安装目录。 通常用于 `xmake install/uninstall` 的 after_install 等脚本中获取对应的安装目录路径，可以用于用户自定义安装脚本。 ## target:autogendir 获取自动生成目录。 这个通常用于一些自定义规则脚本中，存放一些特定于 target 的自动生成文件，路径通常在 `build/.gens/target` 下面。 比如，我们在处理 lex/yacc 自动生成一些源码文件，就可以存放在这个目录下，方便之后去处理它。 ## target:objectfile 获取对象文件路径。 通常用于自定义脚本中，获取源文件对应的目标文件路径，例如： ```lua local objectfile target:objectfile(sourcefile) ``` ## target:sourcebatches 获取所有源文件。 它可以获取到 `add_files` 添加的所有源文件，并且根据不同源文件类型，分别存储。 大概结构如下： ```lua { \"c++.build\" { objectfiles { \"build/.objs/test/macosx/x86_64/release/src/main.cpp.o\" }, rulename \"c++.build\", sourcekind \"cxx\", sourcefiles { \"src/main.cpp\" }, dependfiles { \"build/.deps/test/macosx/x86_64/release/src/main.cpp.o.d\" } }, \"asm.build\" { objectfiles { \"build/.objs/test/macosx/x86_64/release/src/test.S.o\" }, rulename \"asm.build\", sourcekind \"as\", sourcefiles { \"src/test.S\" }, dependfiles { \"build/.deps/test/macosx/x86_64/release/src/test.S.o.d\" } } } ``` 我们可以通过遍历去获取处理每种类型的源文件。 ```lua for _, sourcebatch in pairs(target:sourcebatches()) do local sourcekind sourcebatch.sourcekind if sourcekind \"cc\" or sourcekind \"cxx\" or sourcekind \"as\" then for _, sourcefile in ipairs(sourcebatch.sourcefiles) do TODO end end end ``` 其中 sourcekind 是每种源文件的类型，cc 是 c 文件类型，cxx 是 c++ 源文件，as 是 asm 源文件。 sourcebatch 对应每种类型的源文件 batch，对应一批同类型源文件。 sourcebatch.sourcefiles 是源文件列表，sourcebatch.objectfiles 是对象文件列表，sourcebatch.rulename 是对应的规则名。 ## target:objectfiles 获取所有对象文件列表。 尽管 `target:sourcebatches()` 也可以获取所有对象文件，但是它们是根据源文件类型分类过的，且不直接参与最终链接。 如果我们想动态修改最终链接的对象文件列表，可以修改 `target:objectfiles()`，它是一个数组列表。 ## target:headerfiles 获取所有的头文件列表。 可以获取到 `add_headerfiles()` 接口设置的所有头文件列表。 ```lua for _, headerfile in ipairs(target:headerfiles()) do TODO end ``` ## target:scriptdir 获取目标定义所在的 xmake.lua 目录。 这通常在自定义规则中使用的比较多，想获取当前 target 实际被定义在哪个 xmake.lua 所在目录下，方便引用一些资源文件，可以用这个接口。 ## target:has_cfuncs 检测目标编译配置能否获取给定的 C 函数。 这应该在 `on_config` 中使用，比如可以用它来判断当前目标能否获取到 zlib 依赖包的一些函数接口，然后自动定义 `HAVE_INFLATE`： ```lua add_requires(\"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") on_config(function (target) if target:has_cfuncs(\"inflate\", {includes \"zlib.h\"}) then target:add(\"defines\", \"HAVE_INFLATE\") end end) end) ``` 尽管 option 也提供了类似的检测功能，但 option 的检测使用的是全局的平台工具链，它无法附带上 target 相关的一些编译配置，也无法根据 target 设置不同编译工具链来适配检测，并且无法检测包里面的一些接口。 如果我们仅仅是想粗粒度的检测函数接口，并且 target 没有额外设置不同的工具链，那么 option 提供的检测功能已经足够使用了。 如果想要更细粒度控制检测，可以使用 target 实例接口提供的检测特性。 ## target:has_cxxfuncs 检测目标编译配置能否获取给定的 C++ 函数。 用法跟 [target:has_cfuncs](#targethas_cfuncs) 类似，只是这里主要用于检测 C++ 的函数。 不过，在检测函数的同时，我们还可以额外配置 std languages，来辅助检测。 ```lua target:has_cxxfuncs(\"foo\", {includes \"foo.h\", configs {languages \"cxx17\"}}) ``` ## target:has_ctypes 检测目标编译配置能否获取给定的 C 类型。 这应该在 `on_config` 中使用，如下所示： ```lua add_requires(\"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") on_config(function (target) if target:has_ctypes(\"z_stream\", {includes \"zlib.h\"}) then target:add(\"defines\", \"HAVE_ZSTEAM_T\") end end) end) ``` ## target:has_cxxtypes 检测目标编译配置能否获取给定的 C++ 类型。 用法跟 [target:has_ctypes](#targethas_ctypes) 类似，只是这里主要用于检测 C++ 的类型。 ## target:has_cflags 检测目标编译配置能否获取给定的 C 编译 flags。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") on_config(function (target) if target:has_cxxflags(\" fPIC\") then target:add(\"defines\", \"HAS_PIC\") end end) end) ``` ## target:has_cxxflags 检测目标编译配置能否获取给定的 C++ 编译 flags。 用法跟 [target:has_cflags](#targethas_cflags) 类似，只是这里主要用于检测 C++ 的编译 flags。 ## target:has_cincludes 检测目标编译配置能否获取给定的 C 头文件。 这应该在 `on_config` 中使用，比如可以用它来判断当前目标能否获取到 zlib 依赖包的 zlib.h 头文件，然后自动定义 `HAVE_INFLATE`： ```lua add_requires(\"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") on_config(function (target) if target:has_cincludes(\"zlib.h\") then target:add(\"defines\", \"HAVE_ZLIB_H\") end end) end) ``` ## target:has_cxxincludes 检测目标编译配置能否获取给定的 C++ 头文件。 用法跟 [target:has_cincludes](#targethas_cincludes) 类似，只是这里主要用于检测 C++ 的头文件。 ## target:check_csnippets 检测是否可以编译和链接给定的 C 代码片段。 用法跟 [target:check_cxxsnippets](#targetcheck_cxxsnippets) 类似，只是这里主要用于检测 C 的代码片段。 ## target:check_cxxsnippets 检测是否可以编译和链接给定的 C++ 代码片段。 这应该在 `on_config` 中使用，如下所示： ```lua add_requires(\"libtins\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"libtins\") on_config(function (target) local has_snippet target:check_cxxsnippets({test [[ #include <string> using namespace Tins; void test() { std::string name NetworkInterface::default_interface().name(); printf(\"%s\\n\", name.c_str()); } ]]}, {configs {languages \"c++11\"}, includes {\"tins/tins.h\"}}) if has_snippet then target:add(\"defines\", \"HAS_XXX\") end end) end) ``` 默认仅仅检测编译链接是否通过，如果想要尝试运行时检测，可以再设置 `tryrun true`。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") on_config(function (target) local has_int_4 target:check_cxxsnippets({test [[ return (sizeof(int) 4)? 0 : 1; ]]}, {configs {languages \"c++11\"}, tryrun true}) if has_int_4 then target:add(\"defines\", \"HAS_INT4\") end end) end) ``` 我们也可以继续通过设置 `output true` 来捕获检测的运行输出，并且加上自定义的 `main` 入口，实现完整的测试代码，而不仅仅是代码片段。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") on_config(function (target) local int_size target:check_cxxsnippets({test [[ #include <stdio.h> int main(int argc, char** argv) { printf(\"%d\", sizeof(int)); return 0; return 0; } ]]}, {configs {languages \"c++11\"}, tryrun true, output true}) end) end) ``` ## target:check_sizeof 检测类型大小。 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") on_config(function (target) print(\"sizeof(long) %s\", target:check_sizeof(\"long\")) print(\"sizeof(string) %s\", target:check_sizeof(\"std::string\", {includes \"string\"})) if target:check_size(\"long\") 8 then target:add(\"defines\", \"LONG64\") end end) end) ``` ```bash $ xmake sizeof(long) 8 sizeof(string) 24 ``` ## target:has_features 检测是否指定的 C/C++ 编译特性。 它相比使用 `check_cxxsnippets` 来检测，会更加快一些，因为它仅仅执行一次预处理就能检测所有的编译器特性，而不是每次都去调用编译器尝试编译。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") on_config(function (target) if target:has_features(\"c_static_assert\") then target:add(\"defines\", \"HAS_STATIC_ASSERT\") end if target:has_features(\"cxx_constexpr\") then target:add(\"defines\", \"HAS_CXX_CONSTEXPR\") end end) end) ```"},"/get_started/zh/target/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 定义和设置子工程模块，每个 `target` 对应一个子工程，最后会生成一个目标程序，有可能是可执行程序，也有可能是库模块。 > target 的接口，都是可以放置在 target 外面的全局作用域中的，如果在全局中设置，那么会影响所有子工程 target。 例如： ```lua 会同时影响 test 和 test2 目标 add_defines(\"DEBUG\") target(\"test\", function() add_files(\"*.c\") end) target(\"test2\", function() add_files(\"*.c\") end) ``` > `target` 域是可以重复进入来实现分离设置的。 ## 定义工程目标 定义一个新的控制台工程目标，工程名为 `test`，最后生成的目标名也是 `test`。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 可以重复调用这个 api，进入 target 域修改设置 ```lua 定义目标 demo，并进入 demo 设置模式 target(\"demo\", function() set_kind(\"binary\") add_files(\"src/demo.c\") end) 定义和设置其他目标 target(\"other\", function() ... end) 重新进入 demo 目标域，添加 test.c 文件 target(\"demo\", function() add_files(\"src/test.c\") end) ``` > 所有根域的设置，会全局影响所有 target 目标，但是不会影响 option 的定义。 ```lua 在根域对所有 target 添加 DDEBUG 的宏定义，影响所有 target（demo 和 test 都会加上此宏定义） add_defines(\"DEBUG\") target(\"demo\", function() set_kind(\"binary\") add_files(\"src/demo.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/test.c\") end) ``` ## target:set_kind ### 设置目标编译类型 设置目标类型，目前支持的类型有： 值 描述 phony 假的目标程序 binary 二进制程序 static 静态库程序 shared 动态库程序 object 仅仅编译对象集合 headeronly 仅仅头文件集合 #### binary 可执行文件类型 ```lua target(\"demo\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` > 如果没有设置 set_kind 接口，默认就是 binary 类型。 所以我们简化为： ```lua target(\"demo\", function() add_files(\"src/*.c\") end) ``` 甚至: ```lua target(\"demo\", {files \"src/*.c\"}) ``` #### static 静态库目标类型 ```lua target(\"demo\", function() set_kind(\"static\") add_files(\"src/*.c\") end) ``` #### shared 动态库目标类型 ```lua target(\"demo\", function() set_kind(\"shared\") add_files(\"src/*.c\") end) ``` #### object 纯对象文件列表类型 通常用于两个目标程序间，部分对象文件共享，仅仅编译一次。也可以用于分离对象文件列表，配置不同的编译参数。 #### phony 空目标类型 它是一个特殊的目标程序类型，它不生成任何实际的程序文件，仅仅用于组合其他目标程序的依赖关系。 ```lua target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) target(\"demo\", function() set_kind(\"phony\") add_deps(\"test1\", \"test2\") end) ``` 比如上述配置，我们就可以在执行 `xmake build demo` 编译的时候，同时编译相关的两个依赖程序：test1 和 test2。 #### headeronly 纯头文件目标类型 xmake 新增了 `headeronly` 目标类型，这个类型的目标程序，我们不会实际编译它们，因为它没有源文件需要被编译。 但是它包含了头文件列表，这通常用于 headeronly 库项目的安装，IDE 工程的文件列表生成，以及安装阶段的 cmake/pkgconfig 导入文件的生成。 例如： ```lua add_rules(\"mode.release\", \"mode.debug\") target(\"foo\", function() set_kind(\"headeronly\") add_headerfiles(\"src/foo.h\") add_rules(\"utils.install.cmake_importfiles\") add_rules(\"utils.install.pkgconfig_importfiles\") end) ``` 更多详情见：[#1747](https://github.com/xmake io/xmake/issues/1747) ## target:set_strip ### 设置是否 strip 信息 设置当前目标的 strip 模式，目前支持以下模式： 值 描述 debug 链接的时候，strip 掉调试符号 all 链接的时候，strip 掉所有符号，包括调试符号 这个 api 一般在 release 模式下使用，可以生成更小的二进制程序： ```lua target(\"xxxx\", function() set_strip(\"all\") end) ``` > 这个 api 不一定非得在 target 之后使用，如果没有 target 指定，那么将会设置到全局模式。 ## target:set_enabled ### 设置是否启用或禁用目标 如果设置 `set_enabled(false)`，则会直接禁用对应的 target，包括 target 的加载和信息获取，而 [set_default](#target%3Aset_default) 仅仅只是设置默认不去编译，但是 target 还是能获取到相关信息的，默认也会被加载。 ## target:set_default ### 设置是否为默认构建安装目标 这个接口用于设置给定工程目标是否作为默认构建，如果没有调用此接口进行设置，那么这个目标就是默认被构建的，例如： ```lua target(\"test1\", function() set_default(false) end) target(\"test2\", function() set_default(true) end) target(\"test3\", function() ... end) ``` 上述代码的三个目标，在执行 `xmake`, `xmake install`, `xmake package`, `xmake run` 等命令的时候，如果不指定目标名，那么： 目标名 行为 test1 不会被默认构建、安装、打包和运行 test2 默认构建、安装、打包和运行 test3 默认构建、安装、打包和运行 通过上面的例子，可以看到默认目标可以设置多个，运行的时候也会依次运行。 > 需要注意的是，`xmake uninstall` 和 `xmake clean` 命令不受此接口设置影响，因为用户大部分情况下都是喜欢清除和卸载所有。 如果不想使用默认的目标，那么可以手动指定需要构建安装的目标： ```bash $ xmake build targetname $ xmake install targetname ``` 如果要强制构建安装所有目标，可以传入 `[ a all]` 参数： ```bash $ xmake build [ a all] $ xmake install [ a all] ``` ## target:set_options ### 设置关联选项 添加选项依赖，如果通过 [option](#option) 接口自定义了一些选项，那么只有在指定 `target` 目标域下，添加此选项，才能进行关联生效。 ```lua 定义一个 hello 选项 option(\"hello\", function() set_default(false) set_showmenu(true) add_defines(\"HELLO_ENABLE\") end) target(\"test\", function() 如果 hello 选项被启用了，这个时候就会将 DHELLO_ENABLE 宏应用到 test 目标上去 set_options(\"hello\") end) ``` > 只有调用 `set_options` 进行关联生效后，[option](#option) 中定义的一些设置才会影响到此 `target` 目标，例如：宏定义、链接库、编译选项等等。 ## target:set_symbols ### 设置符号信息 设置目标的符号模式，如果当前没有定义 target，那么将会设置到全局状态中，影响所有后续的目标。 目前主要支持以下几个级别： 值 描述 gcc/clang msvc debug 添加调试符号 g /Zi /Pdxxx.pdb debug, edit 仅 msvc 生效，配合 debug 级别使用 忽略 /ZI /Pdxxx.pdb debug, embed 仅 msvc 生效，配合 debug 级别使用 忽略 /Z7 hidden 设置符号不可见 fvisibility hidden 忽略 这两个值也可以同时被设置，例如： ```lua 添加调试符号, 设置符号不可见 set_symbols(\"debug\", \"hidden\") ``` 如果没有调用这个 api，默认是禁用调试符号的。 > 通过跟 `set_strip(\"all\")` 配合同时设置，可以自动生成独立的调试符号，例如对于 ios 程序，就是 `.dSYM` 文件，对于 android 等其他程序，就是 `.sym` 符号文件。 如果 target 同时设置了下面两个设置，就会启用符号文件生成： ```lua target(\"test\", function() set_symbols(\"debug\") set_strip(\"all\") end) ``` 对于内置的 release 模式，默认不启用符号生成，仅仅只是 strip targetfile，如果要启用，只需要再额外开启 debug 符号就行，因为 mode.release 内部默认已经启用了 strip 了。 ```lua add_rules(\"mode.release\") target(\"test\", function() set_symbols(\"debug\") end) ``` ios 程序会生成 `.dSYM` 文件，然后同时 Strip 自身符号： ```console [62%]: linking.release libtest.dylib [62%]: generating.release test.dSYM ``` android 程序会生成 `.sym` 文件（其实就是带符号的 so/binary 程序），然后同时 Strip 自身符号： ```console [62%]: linking.release libtest.so [62%]: generating.release test.sym ``` ## target:set_basename ### 设置目标文件名 默认情况下，生成的目标文件名基于 `target(\"name\")` 中配置的值，例如： ```lua 目标文件名为：libxxx.a target(\"xxx\", function() set_kind(\"static\") end) 目标文件名为：libxxx2.so target(\"xxx2\", function() set_kind(\"shared\") end) ``` 默认的命名方式，基本上可以满足大部分情况下的需求，但是如果有时候想要更加定制化目标文件名。 例如，按编译模式和架构区分目标名，这个时候可以使用这个接口，来设置： ```lua target(\"xxx\", function() set_kind(\"static\") set_basename(\"xxx_$(mode)_$(arch)\") end) ``` 如果这个时候，编译配置为：`xmake f m debug a armv7`，那么生成的文件名为：`libxxx_debug_armv7.a` 如果还想进一步定制目标文件的目录名，可参考：[set_targetdir](#target%3Aset_targetdir)。 或者通过编写自定义脚本，实现更高级的逻辑，具体见：[after_build](#target%3Aafter_build) 和 [os.mv](/zh cn/manual/builtin_modules?id osmv)。 ## target:set_filename ### 设置目标文件全名 它跟 [set_basename](#target%3Aset_basename) 的区别在于，[set_basename](#target%3Aset_basename)设置名字不带后缀跟前缀，例如：`libtest.a`，basename 如果改成 test2 后就变成了 `libtest2.a`。 而 filename 的修改，是修改整个目标文件名，包括前后缀，例如可以直接把 `libtest.a` 改成 `test.dll`，这个对于 [set_basename](#target%3Aset_basename) 是做不到的。 ## target:set_prefixname ### 设置目标文件的前置名 修改设置目标文件的前置名，例如将默认的：`libtest.so` 改成 `test.so` ```lua target(\"test\", function() set_prefixname(\"\") end) ``` ## target:set_suffixname ### 设置目标文件的后置名 修改设置目标文件的后置名，例如将默认的：`libtest.so` 改成 `libtest d.so` ```lua target(\"test\", function() set_suffixname(\" d\") end) ``` ## target:set_extension ### 设置目标文件的扩展名 修改设置目标文件的扩展名，例如将默认的：`libtest.so` 改成 `test.dll` ```lua target(\"test\", function() set_prefixname(\"\") set_extension(\".dll\") end) ``` ## target:set_warnings ### 设置警告级别 设置当前目标的编译的警告级别，一般支持一下几个级别： 值 描述 gcc/clang msvc none 禁用所有警告 w W0 less 启用较少的警告 W1 W1 more 启用较多的警告 W3 W3 extra 启用额外警告 Wextra pedantic 启用非语言标准的使用警告 Wpedantic all 启用所有警告 Wall W3 allextra 启用所有警告 + 额外的警告 Wall Wextra W4 everything 启用全部支持的警告 Wall Wextra Weffc++ / Weverything Wall error 将所有警告作为编译错误 Werror WX 这个 api 的参数是可以混合添加的，例如： ```lua 启用所有警告，并且作为编译错误处理 set_warnings(\"all\", \"error\") ``` 如果当前没有目标，调用这个 api 将会设置到全局模式。。 ## target:set_optimize ### 设置优化级别 设置目标的编译优化等级，如果当前没有设置目标，那么将会设置到全局状态中，影响所有后续的目标。 目前主要支持一下几个级别： 值 描述 gcc/clang msvc none 禁用优化 O0 Od fast 快速优化 O1 default faster 更快的优化 O2 O2 fastest 最快运行速度的优化 O3 Ox fp:fast smallest 最小化代码优化 Os O1 GL aggressive 过度优化 Ofast Ox fp:fast 例如： ```lua 最快运行速度的优化 set_optimize(\"fastest\") ``` ## target:set_languages ### 设置代码语言标准 设置目标代码编译的语言标准，如果当前没有目标存在，将会设置到全局模式中。 支持的语言标准目前主要有以下几个： 值 描述 ansi c 语言标准: ansi c89 c 语言标准: c89 gnu89 c 语言标准: gnu89 c99 c 语言标准: c99 gnu99 c 语言标准: gnu99 c11 c 语言标准: c11 c17 c 语言标准: c17 clatest c 语言标准: clatest 值 描述 cxx98 c++ 语言标准:`c++98` gnuxx98 c++ 语言标准:`gnu++98` cxx11 c++ 语言标准:`c++11` gnuxx11 c++ 语言标准:`gnu++11` cxx14 c++ 语言标准:`c++14` gnuxx14 c++ 语言标准:`gnu++14` cxx1z c++ 语言标准:`c++1z` gnuxx1z c++ 语言标准:`gnu++1z` cxx17 c++ 语言标准:`c++17` gnuxx17 c++ 语言标准:`gnu++17` cxx20 c++ 语言标准:`c++20` gnuxx20 c++ 语言标准:`gnu++20` cxxlatest c++ 语言标准:`c++latest` gnuxxlatest c++ 语言标准:`gnu++latest` c 标准和 c++ 标准可同时进行设置，例如： ```lua 设置 c 代码标准：c99， c++ 代码标准：c++11 set_languages(\"c99\", \"cxx11\") ``` 并不是设置了指定的标准，编译器就一定会按这个标准来编译，毕竟每个编译器支持的力度不一样，但是 xmake 会尽最大可能的去适配当前编译工具的支持标准。 ## target:set_fpmodels ### 设置 float point 编译模式 此接口用于设置浮点的编译模式，对数学计算相关优化的编译抽象设置，提供：fast, strict, except, precise 等几种常用的级别，有些可同时设置，有些是有冲突的，最后设置的生效。 关于这些级别的说明，可以参考下微软的文档：[Specify floating point behavior](https://docs.microsoft.com/en us/cpp/build/reference/fp specify floating point behavior?view vs 2019) 当然，对应 gcc/icc 等其他编译器，xmake 会映射到不同的编译 flags。 ```lua set_fpmodels(\"fast\") set_fpmodels(\"strict\") set_fpmodels(\"fast\", \"except\") set_fpmodels(\"precise\") default ``` 关于这块详情见：[https://github.com/xmake io/xmake/issues/981](https://github.com/xmake io/xmake/issues/981) ## target:set_targetdir ### 设置生成目标文件目录 设置目标程序文件的输出目录，一般情况下，不需要设置，默认会输出在 build 目录下 而 build 的目录可以在工程配置的时候，手动修改： ```bash xmake f o /tmp/build ``` 修改成 `/tmp/build` 后，目标文件默认输出到 `/tmp/build` 下面。 而如果用这个接口去设置，就不需要每次敲命令修改了，例如： ```lua target(\"test\", function() set_targetdir(\"/tmp/build\") end) ``` > 如果显示设置了 `set_targetdir`， 那么优先选择 `set_targetdir` 指定的目录为目标文件的输出目录。 ## target:set_objectdir ### 设置对象文件生成目录 设置目标 target 的对象文件 (`*.o/obj`) 的输出目录，例如: ```lua target(\"test\", function() set_objectdir(\"$(buildir)/.objs\") end) ``` ## target:set_dependir ### 设置依赖文件生成目录 设置目标 target 的编译依赖文件 (`.deps`) 的输出目录，例如: ```lua target(\"test\", function() set_dependir(\"$(buildir)/.deps\") end) ``` ## target:add_imports ### 为自定义脚本预先导入扩展模块 通常，我们在 [on_build](#targeton_build) 等自定义脚本内部，可以通过 `import(\"core.base.task\")` 的方式导入扩展模块， 但是对于自定义脚本比较多的情况下，每个自定义脚本都重复导入一遍，非常的繁琐，那么可以通过这个接口，实现预先导入，例如： ```lua target(\"test\", function() on_load(function (target) import(\"core.base.task\") import(\"core.project.project\") task.run(\"xxxx\") end) on_build(function (target) import(\"core.base.task\") import(\"core.project.project\") task.run(\"xxxx\") end) on_install(function (target) import(\"core.base.task\") import(\"core.project.project\") task.run(\"xxxx\") end) end) ``` 通过此接口可以简化为： ```lua target(\"test\", function() add_imports(\"core.base.task\", \"core.project.project\") on_load(function (target) task.run(\"xxxx\") end) on_build(function (target) task.run(\"xxxx\") end) on_install(function (target) task.run(\"xxxx\") end) end) ``` ## target:add_rules ### 添加规则到目标 我们可以通过预先设置规则支持的文件后缀，来扩展其他文件的构建支持： ```lua 定义一个 markdown 文件的构建规则 rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build(function (target, sourcefile) os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. \".html\")) end) end) target(\"test\", function() set_kind(\"binary\") 使 test 目标支持 markdown 文件的构建规则 add_rules(\"markdown\") 添加 markdown 文件的构建 add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` 我们可以在 add_rules 时传参： ```lua rule(\"my_rule\", function() on_load(function (target) local my_arg target:extraconf(\"rules\", \"my_rule\", \"my_arg\") \"my arg\" end) end) target(\"test\", function() add_rules(\"my_rule\", { my_arg \"my arg\"}) end) ``` 我们也可以指定应用局部文件到规则，具体使用见：[add_files](#targetadd_files)。 ## target:on_load ### 自定义目标加载脚本 在 target 初始化加载的时候，将会执行此脚本，在里面可以做一些动态的目标配置，实现更灵活的目标描述定义，例如： ```lua target(\"test\", function() on_load(function (target) target:add(\"defines\", \"DEBUG\", \"TEST \\\"hello\\\"\") target:add(\"linkdirs\", \"/usr/lib\", \"/usr/local/lib\") target:add({includedirs \"/usr/include\", \"links\" \"pthread\"}) end) end) ``` 可以在 `on_load` 里面，通过 `target:set`, `target:add` 来动态添加各种 target 属性。 ## target:on_config ### 自定义配置脚本 在 `xmake config` 执行完成后，Build 之前会执行此脚本，通常用于编译前的配置工作。它与 on_load 不同的是，on_load 只要 target 被加载就会执行，执行时机更早。 如果一些配置，无法在 on_load 中过早配置，那么都可以在 on_config 中去配置它。 另外，它的执行时机比 before_build 还要早，大概的执行流程如下： ``` on_load > after_load > on_config > before_build > on_build > after_build ``` ## target:on_link ### 自定义链接脚本 用于定制化处理 target 的链接过程。 ```lua target(\"test\", function() on_link(function (target) print(\"link it\") end) end) ``` ## target:on_build ### 自定义编译脚本 覆盖 target 目标默认的构建行为，实现自定义的编译过程，一般情况下，并不需要这么做，除非确实需要做一些 xmake 默认没有提供的编译操作。 你可以通过下面的方式覆盖它，来自定义编译操作： ```lua target(\"test\", function() 设置自定义编译脚本 on_build(function (target) print(\"build it\") end) end) ``` 所有 target 的自定义脚本都可以针对不同平台和架构，分别处理，例如： ```lua target(\"test\", function() on_build(\"iphoneosarm*\", function (target) print(\"build for iphoneos and arm\") end) end) ``` 其中如果第一个参数为字符串，那么就是指定这个脚本需要在哪个 `平台 架构` 下，才会被执行，并且支持模式匹配，例如 `arm*` 匹配所有 arm 架构。 当然也可以只设置平台，不设置架构，这样就是匹配指定平台下，执行脚本： ```lua target(\"test\", function() on_build(\"windows\", function (target) print(\"build for windows\") end) end) ``` > 一旦对这个 target 目标设置了自己的 build 过程，那么 xmake 默认的构建过程将不再被执行。 ## target:on_build_file ### 自定义编译脚本, 实现单文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，替换每个源文件编译过程： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_build_file(function (target, sourcefile, opt) end) end) ``` 如果不想重写内置的编译脚本，仅仅只是在编译前后添加一些自己的处理，其实用：[target.before_build_file](#targetbefore_build_file)和 [target.after_build_file](#targetafter_build_file) 会更加方便，不需要调用 `opt.origin`。 ## target:on_build_files ### 自定义编译脚本, 实现多文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，替换一批同类型源文件编译过程： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_build_files(function (target, sourcebatch, opt) end) end) ``` 设置此接口后，对应源文件列表中文件，就不会出现在自定义的 [target.on_build_file](#targeton_build_file) 了，因为这个是包含关系。 其中 sourcebatch 描述了这批同类型源文件： `sourcebatch.sourcekind`: 获取这批源文件的类型，比如：cc, as, .. `sourcebatch.sourcefiles()`: 获取源文件列表 `sourcebatch.objectfiles()`: 获取对象文件列表 `sourcebatch.dependfiles()`: 获取对应依赖文件列表，存有源文件中编译依赖信息，例如：xxx.d ## target:on_clean ### 自定义清理脚本 覆盖 target 目标的 `xmake [cclean}` 的清理操作，实现自定义清理过程。 ```lua target(\"test\", function() 设置自定义清理脚本 on_clean(function (target) 仅删掉目标文件 os.rm(target:targetfile()) end) end) ``` 一些 target 接口描述如下： target 接口 描述 target:name() 获取目标名 target:targetfile() 获取目标文件路径 target:get(\"kind\") 获取目标的构建类型 target:get(\"defines\") 获取目标的宏定义 target:get(\"xxx\") 其他通过 `set_/add_` 接口设置的 target 信息，都可以通过此接口来获取 target:add(\"links\", \"pthread\") 添加目标设置 target:set(\"links\", \"pthread\", \"z\") 覆写目标设置 target:deps() 获取目标的所有依赖目标 target:dep(\"depname\") 获取指定的依赖目标 target:sourcebatches() 获取目标的所有源文件列表 ## target:on_package ### 自定义打包脚本 覆盖 target 目标的 `xmake [ppackage}` 的打包操作，实现自定义打包过程，如果你想对指定 target 打包成自己想要的格式，可以通过这个接口自定义它。 这个接口还是挺实用的，例如，编译完 jni 后，将生成的 so，打包进 apk 包中。 ```lua 定义一个 android app 的测试 demo target(\"demo\", function() 生成动态库：libdemo.so set_kind(\"shared\") 设置对象的输出目录，可选 set_objectdir(\"$(buildir)/.objs\") 每次编译完的 libdemo.so 的生成目录，设置为 app/libs/armeabi set_targetdir(\"libs/armeabi\") 添加 jni 的代码文件 add_files(\"jni/*.c\") 设置自定义打包脚本，在使用 xmake 编译完 libdemo.so 后，执行 xmake p 进行打包 会自动使用 ant 将 app 编译成 apk 文件 on_package(function (target) 使用 ant 编译 app 成 apk 文件，输出信息重定向到日志文件 os.run(\"ant debug\") end) end) ``` ## target:on_install ### 自定义安装脚本 覆盖 target 目标的 `xmake [iinstall}` 的安装操作，实现自定义安装过程。 例如，将生成的 apk 包，进行安装。 ```lua target(\"test\", function() 设置自定义安装脚本，自动安装 apk 文件 on_install(function (target) 使用 adb 安装打包生成的 apk 文件 os.run(\"adb install r ./bin/Demo debug.apk\") end) end) ``` ## target:on_uninstall ### 自定义卸载脚本 覆盖 target 目标的 `xmake [uuninstall}` 的卸载操作，实现自定义卸载过程。 ```lua target(\"test\", function() on_uninstall(function (target) ... end) end) ``` ## target:on_run ### 自定义运行脚本 覆盖 target 目标的 `xmake [rrun}` 的运行操作，实现自定义运行过程。 例如，运行安装好的 apk 程序： ```lua target(\"test\", function() 设置自定义运行脚本，自动运行安装好的 app 程序，并且自动获取设备输出信息 on_run(function (target) os.run(\"adb shell am start n com.demo/com.demo.DemoTest\") os.run(\"adb logcat\") end) end) ``` ## target:before_link ### 在链接之前执行一些自定义脚本 用于在链接之前增加一些自定义的操作。 ```lua target(\"test\", function() before_link(function (target) print(\"\") end) end) ``` ## target:before_build ### 在构建之前执行一些自定义脚本 并不会覆盖默认的构建操作，只是在构建之前增加一些自定义的操作。 ```lua target(\"test\", function() before_build(function (target) print(\"\") end) end) ``` ## target:before_build_file ### 自定义编译前的脚本, 实现单文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在每个源文件编译过程之前执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") before_build_file(function (target, sourcefile, opt) end) end) ``` ## target:before_build_files ### 自定义编译前的脚本, 实现多文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在一批同类型源文件编译过程之前执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") before_build_files(function (target, sourcebatch, opt) end) end) ``` ## target:before_clean ### 在清理之前执行一些自定义脚本 并不会覆盖默认的清理操作，只是在清理之前增加一些自定义的操作。 ```lua target(\"test\", function() before_clean(function (target) print(\"\") end) end) ``` ## target:before_package #### 在打包之前执行一些自定义脚本 并不会覆盖默认的打包操作，只是在打包之前增加一些自定义的操作。 ```lua target(\"test\", function() before_package(function (target) print(\"\") end) end) ``` ## target:before_install ### 在安装之前执行一些自定义脚本 并不会覆盖默认的安装操作，只是在安装之前增加一些自定义的操作。 ```lua target(\"test\", function() before_install(function (target) print(\"\") end) end) ``` ## target:before_uninstall ### 在卸载之前执行一些自定义脚本 并不会覆盖默认的卸载操作，只是在卸载之前增加一些自定义的操作。 ```lua target(\"test\", function() before_uninstall(function (target) print(\"\") end) end) ``` ## target:before_run ### 在运行之前执行一些自定义脚本 并不会覆盖默认的运行操作，只是在运行之前增加一些自定义的操作。 ```lua target(\"test\", function() before_run(function (target) print(\"\") end) end) ``` ## target:after_link ### 在链接之后执行一些自定义脚本 用于在链接之后增加一些自定义的操作。 ```lua target(\"test\", function() after_link(function (target) print(\"\") end) end) ``` ## target:after_build ### 在构建之后执行一些自定义脚本 并不会覆盖默认的构建操作，只是在构建之后增加一些自定义的操作。 例如，对于 ios 的越狱开发，构建完程序后，需要用 `ldid` 进行签名操作 ```lua target(\"test\", function() after_build(function (target) os.run(\"ldid S %s\", target:targetfile()) end) end) ``` ## target:after_build_file ### 自定义编译前的脚本, 实现单文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在每个源文件编译过程之后执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") after_build_file(function (target, sourcefile, opt) end) end) ``` ## target:after_build_files ### 自定义编译前的脚本, 实现多文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在一批同类型源文件编译过程之后执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") after_build_files(function (target, sourcebatch, opt) end) end) ``` ## target:after_clean ### 在清理之后执行一些自定义脚本 并不会覆盖默认的清理操作，只是在清理之后增加一些自定义的操作。 一般可用于清理编译某 target 自动生成的一些额外的临时文件，这些文件 xmake 默认的清理规则可能没有清理到，例如： ```lua target(\"test\", function() after_clean(function (target) os.rm(\"$(buildir)/otherfiles\") end) end) ``` ## target:after_package ### 在打包之后执行一些自定义脚本 并不会覆盖默认的打包操作，只是在打包之后增加一些自定义的操作。 ```lua target(\"test\", function() after_package(function (target) print(\"\") end) end) ``` ## target:after_install ### 在安装之后执行一些自定义脚本 并不会覆盖默认的安装操作，只是在安装之后增加一些自定义的操作。 ```lua target(\"test\", function() after_install(function (target) print(\"\") end) end) ``` ## target:after_uninstall ### 在卸载之后执行一些自定义脚本 并不会覆盖默认的卸载操作，只是在卸载之后增加一些自定义的操作。 ```lua target(\"test\", function() after_uninstall(function (target) print(\"\") end) end) ``` ## target:after_run ### 在运行之后执行一些自定义脚本 并不会覆盖默认的运行操作，只是在运行之后增加一些自定义的操作。 ```lua target(\"test\", function() after_run(function (target) print(\"\") end) end) ``` ## target:set_pcheader ### 设置 C 预编译头文件 xmake 支持通过预编译头文件去加速 c 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pcheader(\"header.h\") end) ``` ## target:set_pcxxheader ### 设置 C++ 预编译头文件 xmake 支持通过预编译头文件去加速 c++ 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pcxxheader(\"header.h\") end) ``` ## target:set_pmheader ### 设置 ObjC 预编译头文件 xmake 支持通过预编译头文件去加速 ObjC 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pmheader(\"header.h\") end) ``` ## target:set_pmxxheader ### 设置 ObjC++ 预编译头文件 xmake 支持通过预编译头文件去加速 ObjC++ 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pmxxheader(\"header.h\") end) ``` ## target:add_deps ### 添加子工程目标依赖 添加当前目标的依赖目标，编译的时候，会去优先编译依赖的目标，然后再编译当前目标。。。 ```lua target(\"test1\", function() set_kind(\"static\") set_files(\"*.c\") end) target(\"test2\", function() set_kind(\"static\") set_files(\"*.c\") end) target(\"demo\", function() add_deps(\"test1\", \"test2\") end) ``` 上面的例子，在编译目标 demo 的时候，需要先编译 test1, test2 目标，因为 demo 会去用到他们 > target 会自动继承依赖目标中的配置和属性，不需要额外调用 `add_links`, `add_linkdirs` 和 `add_rpathdirs` 等接口去关联依赖目标了。 并且继承关系是支持级联的，例如： ```lua target(\"library1\", function() set_kind(\"static\") add_files(\"*.c\") add_includedirs(\"inc\") 默认私有头文件目录不会被继承 add_includedirs(\"inc1\", {public true}) 此处的头文件相关目录也会被继承 end) target(\"library2\", function() set_kind(\"static\") add_deps(\"library1\") add_files(\"*.c\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"library2\") end) ``` 如果我们不想继承依赖 target 的任何配置，如何操作呢？ ```lua add_deps(\"dep1\", \"dep2\", {inherit false}) ``` 通过显式设置 inherit 配置，来告诉 xmake，这两个依赖的配置是否需要被继承，如果不设置，默认就是启用继承的。 通过 `add_includedirs(\"inc1\", {public true})`, 设置 public 为 true, 将 includedirs 的设置公开给其他依赖的子 target 继承。 目前对于 target 的编译链接 flags 相关接口设置，都是支持继承属性的，可以人为控制是否需要导出给其他 target 来依赖继承，目前支持的属性有： 属性 描述 private 默认设置，作为当前 target 的私有配置，不会被依赖的其他 target 所继承 public 公有配置，当前 target，依赖的子 target 都会被设置 interface 接口设置，仅被依赖的子 target 所继承设置，当前 target 不参与 对于这块的详细说明，可以看下：[https://github.com/xmake io/xmake/issues/368](https://github.com/xmake io/xmake/issues/368) ## target:add_links ### 添加链接库名 为当前目标添加链接库，一般这个要与 [add_linkdirs](#targetadd_linkdirs) 配对使用。 ```lua target(\"demo\", function() 添加对 libtest.a 的链接，相当于 ltest add_links(\"test\") 添加链接搜索目录 add_linkdirs(\"$(buildir)/lib\") end) ``` add_links 还支持添加库的完整路径，例如：`add_links(\"/tmp/libfoo.a\")`，显式的指定库文件。 ## target:add_syslinks ### 添加系统链接库名 这个接口使用上跟 [add_links](#targetadd_links) 类似，唯一的区别就是，通过这个接口添加的链接库顺序在所有 `add_links` 之后。 因此主要用于添加系统库依赖，因为系统库的链接顺序是非常靠后的，例如： ```lua add_syslinks(\"pthread\", \"m\", \"dl\") target(\"demo\", function() add_links(\"a\", \"b\") add_linkdirs(\"$(buildir)/lib\") end) ``` 上面的配置，即使 `add_syslinks` 被优先提前设置了，但最后的链接顺序依然是：` la lb lpthread lm ldl` ## target:add_linkorders ### 调整链接顺序 用于调整 target 内部的链接顺序。 由于 xmake 提供了 `add_links`, `add_deps`, `add_packages`, `add_options` 接口，可以配置目标、依赖，包和选项中的链接。 但是它们之间的链接顺序，在之前可控性比较弱，只能按固定顺序生成，这对于一些复杂的项目，就有点显得力不从心了。 更多详情和背景见：[#1452](https://github.com/xmake io/xmake/issues/1452) #### 排序链接 为了更加灵活的调整 target 内部的各种链接顺序，我们新增了 `add_linkorders` 接口，用于配置目标、依赖、包、选项、链接组引入的各种链接顺序。 例如： ```lua add_links(\"a\", \"b\", \"c\", \"d\", \"e\") e > b > a add_linkorders(\"e\", \"b\", \"a\") e > d add_linkorders(\"e\", \"d\") ``` add_links 是配置的初始链接顺序，然后我们通过 add_linkorders 配置了两个局部链接依赖 `e > b > a` 和 `e > d` 后。 xmake 内部就会根据这些配置，生成 DAG 图，通过拓扑排序的方式，生成最终的链接顺序，提供给链接器。 当然，如果存在循环依赖，产生了环，它也会提供警告信息。 #### 排序链接和链接组 另外，对于循环依赖，我们也可以通过 `add_linkgroups` 配置链接组的方式也解决。 并且 `add_linkorders` 也能够对链接组进行排序。 ```lua add_links(\"a\", \"b\", \"c\", \"d\", \"e\") add_linkgroups(\"c\", \"d\", {name \"foo\", group true}) add_linkorders(\"e\", \"linkgroup::foo\") ``` 如果要排序链接组，我们需要对每个链接组取个名，`{name \"foo\"}` ，然后就能在 `add_linkorders` 里面通过 `linkgroup::foo` 去引用配置了。 2.9.6 版本新增 as_needed 配置项，可以用于禁用 as_needed。（默认不配置，就是开启状态。） ```lua add_linkgroups(\"c\", \"d\", {as_needed false}) ``` 对应的 flags 如下。 ```bash Wl, no as needed c d Wl, as needed ``` #### 排序链接和 frameworks 我们也可以排序链接和 macOS/iPhoneOS 的 frameworks。 ```lua add_links(\"a\", \"b\", \"c\", \"d\", \"e\") add_frameworks(\"Foundation\", \"CoreFoundation\") add_linkorders(\"e\", \"framework::CoreFoundation\") ``` #### 完整例子 相关的完整例子，我们可以看下： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"libpng\") target(\"bar\", function() set_kind(\"shared\") add_files(\"src/foo.cpp\") add_linkgroups(\"m\", \"pthread\", {whole true}) end) target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.cpp\") add_packages(\"libpng\", {public true}) end) target(\"demo\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.cpp\") if is_plat(\"linux\", \"macosx\") then add_syslinks(\"pthread\", \"m\", \"dl\") end if is_plat(\"macosx\") then add_frameworks(\"Foundation\", \"CoreFoundation\") end add_linkorders(\"framework::Foundation\", \"png16\", \"foo\") add_linkorders(\"dl\", \"linkgroup::syslib\") add_linkgroups(\"m\", \"pthread\", {name \"syslib\", group true}) end) ``` 完整工程在：[linkorders example](https://github.com/xmake io/xmake/blob/master/tests/projects/c%2B%2B/linkorders/xmake.lua) ## target:add_linkgroups ### 添加链接组 这个链接组的特性，目前主要用于 linux 平台的编译，仅支持 gcc/clang 编译器。 需要注意的是 gcc/clang 里面的链接组概念主要特指：` Wl, start group` 而 xmake 对齐进行了封装，做了进一步抽象，并且不仅仅用于处理 ` Wl, start group`，还可以处理 ` Wl, whole archive` 和 ` Wl, Bstatic`。 下面我们会一一对其进行讲解。 更多详情见：[#1452](https://github.com/xmake io/xmake/issues/1452) #### start group 支持 ` Wl, start group` 和 ` Wl, end group` 是用于处理复杂库依赖关系的链接器选项，确保链接器可以解决符号依赖并成功连接多个库。 在 xmake 中，我们可以通过下面的方式实现： ```lua add_linkgroups(\"a\", \"b\", {group true}) ``` 它会对应生成 ` Wl, start group la lb Wl, end group` 链接选项。 如果 a 和 b 库之间有符号的循环依赖，也不会报链接错误，能够正常链接成功。 对于不支持的平台和编译，会退化成 ` la lb` #### whole archive 支持 ` whole archive` 是一个链接器选项，通常用于处理静态库。 它的作用是告诉链接器将指定的静态库中的所有目标文件都包含到最终可执行文件中，而不仅仅是满足当前符号依赖的目标文件。 这可以用于确保某些库的所有代码都被链接，即使它们在当前的符号依赖关系中没有直接引用。 更多信息，可以参考 gcc/clang 的文档。 在 xmake 中，我们可以通过下面的方式实现： ```lua add_linkgroups(\"a\", \"b\", {whole true}) ``` 它会对应生成 ` Wl, whole archive la lb Wl, no whole archive` 链接选项。 对于不支持的平台和编译，会退化成 ` la lb` 另外，我们可以同时配置 group/whole： ```lua add_linkgroups(\"a\", \"b\", {whole true, group true}) ``` #### Bstatic 支持 ` Bstatic` 也是用于编译器（如 gcc）的选项，用于指示编译器在链接时只使用静态库而不使用共享库。 更多信息，可以参考 gcc/clang 的文档。 在 xmake 中，我们可以通过下面的方式实现： ```lua add_linkgroups(\"a\", \"b\", {static true}) ``` 它会对应生成 ` Wl, Bstatic la lb Wl, Bdynamic` 链接选项。 ## target:add_files ### 添加源代码文件 用于添加目标工程的源文件，甚至库文件，目前支持的一些文件类型： 支持的源文件类型 描述 .c/.cpp/.cc/.cxx c++ 文件 .s/.S/.asm 汇编文件 .m/.mm objc 文件 .swift swift 文件 .go golang 文件 .o/.obj 对象文件 .a/.lib 静态库文件，会自动合并库到目标程序 .rc msvc 的资源文件 .manifest windows manifest 文件 .def windows dll 导出文件 .ld/.lds linker scripts 文件，通常用于 gcc/clang .map/.ver version script 文件，通常用于 gcc/clang 其中通配符 `*` 表示匹配当前目录下文件，而 `**` 则匹配多级目录下的文件。 例如： ```lua add_files(\"src/test_*.c\") add_files(\"src/xxx/**.cpp\") add_files(\"src/asm/*.S\", \"src/objc/**/hello.m\") ``` `add_files` 的使用其实是相当灵活方便的，其匹配模式借鉴了 premake 的风格，但是又对其进行了改善和增强。 使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。 例如： ```lua 递归添加 src 下的所有 c 文件，但是不包括 src/impl / 下的所有 c 文件 add_files(\"src/**.cimpl/*.c\") 添加 src 下的所有 cpp 文件，但是不包括 src/test.cpp、src/hello.cpp 以及 src 下所有带 xx_前缀的 cpp 文件 add_files(\"src/*.cpptest.cpphello.cppxx_*.cpp\") ``` 其中分隔符 `` 之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用 `` 分割就行了。。 添加文件的时候支持过滤一些文件的一个好处就是，可以为后续根据不同开关逻辑添加文件提供基础。 <p class \"tip\"> 为了使得描述上更加的精简，`` 之后的过滤描述都是基于起一个模式：`src/*.cpp` 中 `*` 之前的目录为基础的。 所以上面的例子后面过滤的都是在 src 下的文件，这个是要注意的。 </p> xmake 对 `add_files` 进行了改进，支持基于 files 更细粒度的编译选项控制，例如： ```lua target(\"test\", function() add_defines(\"TEST1\") add_files(\"src/*.c\") add_files(\"test/*.c\", \"test2/test2.c\", {defines \"TEST2\", languages \"c99\", includedirs \".\", cflags \" O0\"}) end) ``` 可以在 `add_files` 的最后一个参数，传入一个配置 table，去控制指定 files 的编译选项，里面的配置参数跟 target 的一致，并且这些文件还会继承 target 的通用配置 ` DTEST1`。 xmake 支持添加未知的代码文件，通过设置 rule 自定义规则，实现这些文件的自定义构建，例如： ```lua target(\"test\", function() ... add_files(\"src/test/*.md\", {rule \"markdown\"}) end) ``` 关于自定义构建规则的使用说明，详细见：[构建规则](#构建规则)。 可以通过 force 参数来强制禁用 cxflags,cflags 等编译选项的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置： ```lua add_files(\"src/*.c\", {force {cxflags \" DTEST\", mflags \" framework xxx\"}}) ``` ## target:remove_files ### 从前面的源代码文件列表中删除指定文件 通过此接口，可以从前面 [add_files](targetadd_files) 接口添加的文件列表中，删除指定的文件，例如： ```lua target(\"test\", function() add_files(\"src/*.c\") remove_files(\"src/test.c\") end) ``` 上面的例子，可以从 `src` 目录下添加除 `test.c` 以外的所有文件，当然这个也可以通过 `add_files(\"src/*.ctest.c\")` 来达到相同的目的，但是这种方式更加灵活。 例如，我们可以条件判断来控制删除哪些文件，并且此接口也支持 [add_files](targetadd_files) 的匹配模式，过滤模式，进行批量移除。 ```lua target(\"test\", function() add_files(\"src/**.c\") remove_files(\"src/test*.c\") remove_files(\"src/subdir/*.cxxx.c\") if is_plat(\"iphoneos\") then add_files(\"xxx.m\") end end) ``` 通过上面的例子，我们可以看出 `add_files` 和 `remove_files` 是根据调用顺序，进行顺序添加和删除的，并且通过 `remove_files(\"src/subdir/*.cxxx.c\")` 删除一批文件， 并且排除 `src/subdir/xxx.c`（就是说，不删除这个文件）。 注： 这个接口 v2.6.3 版本才提供，之前的版本是 del_files，已经废弃。 如果向下要兼容以前的版本，可以通过下面的配置解决。 ```lua remove_files remove_files or del_files ``` ## target:remove_headerfiles ### 从前面的头文件列表中删除指定文件 主要用于从 `add_headerfiles` 设置的头文件列表中删除文件，用法与 `remove_files` 类似。 ## target:add_linkdirs ### 添加链接库搜索目录 设置链接库的搜索目录，这个接口的使用方式如下： ```lua target(\"test\", function() add_linkdirs(\"$(buildir)/lib\") end) ``` 此接口相当于 gcc 的 ` Lxxx` 链接选项。 一般他是与 [add_links](#targetadd_links) 配合使用的，当然也可以直接通过 [add_ldflags](#targetadd_ldflags) 或者 [add_shflags](#targetadd_shflags) 接口来添加，也是可以的。 <p class \"tip\"> 如果不想在工程中写死，可以通过：`xmake f linkdirs xxx` 或者 `xmake f ldflags \" L/xxx\"` 的方式来设置，当然这种手动设置的目录搜索优先级更高。 </p> ## target:add_rpathdirs ### 添加程序运行时动态库的加载搜索目录 通过 [add_linkdirs](#targetadd_linkdirs) 设置动态库的链接搜索目录后，程序被正常链接，但是在 linux 平台想要正常运行编译后的程序，会报加载动态库失败。 因为没找到动态库的加载目录，想要正常运行依赖动态库的程序，需要设置 `LD_LIBRARY_PATH` 环境变量，指定需要加载的动态库目录。 但是这种方式是全局的，影响太广，更好的方式是通过 ` rpath xxx` 的链接器选项，在链接程序的时候设置好需要加载的动态库搜索路径，而 xmake 对其进行了封装，通过 `add_rpathdirs` 更好的处理跨平台问题。 具体使用如下： ```lua target(\"test\", function() set_kind(\"binary\") add_linkdirs(\"$(buildir)/lib\") add_rpathdirs(\"$(buildir)/lib\") end) ``` 只需要在链接的时候，在设置下 rpath 目录就好了，虽然也可以通过 `add_ldflags(\" Wl, rpath xxx\")` 达到相同的目的，但是这个接口更加通用。 内部会对不同平台进行处理，像在 macOS 下，是不需要 ` rpath` 设置的，也是可以正常加载运行程序，因此针对这个平台，xmake 内部会直接忽略器设置，避免链接报错。 而在为 dlang 程序进行动态库链接时，xmake 会自动处理成 ` L rpath xxx` 来传入 dlang 的链接器，这样就避免了直接使用 `add_ldflags` 需要自己判断和处理不同平台和编译器问题。 xmake 对这个接口进行了改进，支持：`@loader_path`, `@executable_path` 和 `$ORIGIN` 的内置变量，来指定程序的加载目录，它们的效果基本上是一样的，主要是为了同时兼容 macho, elf。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_linkdirs(\"$(buildir)/lib\") add_rpathdirs(\"@loader_path/lib\") end) ``` 指定 test 程序加载当前执行目录下 `lib/*.[sodylib]` 的动态库文件，这将有助于提升程序的可移植性，不用写死绝对路径和相对路径，导致程序和目录切换引起程序加载动态库失败。 > 需要注意的是，在 macos 下，要想 add_rpathdirs 设置生效，需要对 dylib 做一些预处理，添加 `@rpath/xxx` 路径设置： > `$install_name_tool add_rpath @rpath/libxxx.dylib xxx/libxxx.dylib` > 我们也可以通过 `otool L libxxx.dylib` 查看是否存在带 @rpath 的路径 另外，对于 gcc， `add_rpathdirs` 默认设置的是 runpath，如果想要显式的配置上 ` Wl, enable new dtags`, ` Wl, disable new dtags` 去配置 rpath 还是 runpath 我们可以通过额外的参数指定，`add_rpathdirs(\"xxx\", {runpath true})` 相关背景细节见：[#5109](https://github.com/xmake io/xmake/issues/5109) xmake 新增了 `add_rpathdirs(\"xxx\", {install_only true})` ，可以单独配置安装后的 rpath 路径。 ## target:add_includedirs ### 添加头文件搜索目录 设置头文件的搜索目录，这个接口的使用方式如下： ```lua target(\"test\", function() add_includedirs(\"$(buildir)/include\") end) ``` 当然也可以直接通过 [add_cxflags](#targetadd_cxflags) 或者 [add_mxflags](#targetadd_mxflags) 等接口来设置，也是可以的。 可通过额外的 `{publicinterface true}` 属性设置，将 includedirs 导出给依赖的子 target，例如： ```lua target(\"test\", function() set_kind(\"static\") add_includedirs(\"src/include\") 仅对当前 target 生效 add_includedirs(\"$(buildir)/include\", {public true})，当前 target 和子 target 都会被设置 end) target(\"demo\", function() set_kind(\"binary\") add_deps(\"test\") end) ``` 更多关于这块的说明，见：[add_deps](#targetadd_deps) > 如果不想在工程中写死，可以通过：`xmake f includedirs xxx` 或者 `xmake f cxflags \" I/xxx\"` 的方式来设置，当然这种手动设置的目录搜索优先级更高。 > 头文件默认不支持模式匹配，也不推荐这么做， 容易引入一些不需要的子目录，导致各种头文件引用冲突干扰，出了问题更难查。 > 如果用户非要这么做，可以通过 `add_includedirs(os.dirs(path.join(os.scriptdir(), \"xxx/**\")))` 来实现。 ## target:add_sysincludedirs ### 添加系统头文件搜索目录 `add_includedirs` 通常用于添加工程头文件搜索目录，而一些系统库头文件的引入，有可能会触发一些内部的警告信息，但是这些警告对于用户来讲也许是无法避免，也修复不了的。 那么，每次显示这些警告反而会干扰用户，因此，gcc/clang 提供了 ` isystem` 专门用来设置系统头文件搜索路径，通过此接口设置的头文件，会压制一些警告信息来避免干扰用户。 msvc 也通提供了 `/external:I` 编译选项来设置它，但是需要高版本 msvc 才支持。 因此，xmake 提供了 `add_sysincludedirs` 来抽象适配设置系统库头文件搜索路径，如果当前编译器不支持，会自动切换回 ` I` 编译选项。 ```lua target(\"test\", function() add_sysincludedirs(\"/usr/include\") end) ``` 生成的编译选项如下： ```console isystem /usr/include ``` 如果是 msvc 编译器，则会是： ```console /experimental:external /external:W0 /external:I /usr/include ``` > 另外，使用 `add_requires()` 引入的依赖包，默认也会使用 ` isystem` 作为外部系统头文件。 ## target:add_defines ### 添加宏定义 ```lua add_defines(\"DEBUG\", \"TEST 0\", \"TEST2 \\\"hello\\\"\") ``` 相当于设置了编译选项： ``` DDEBUG DTEST 0 DTEST2 \\\"hello\\\" ``` ## target:add_undefines ### 取消宏定义 ```lua add_undefines(\"DEBUG\") ``` 相当于设置了编译选项：` UDEBUG` 在代码中相当于：`#undef DEBUG` ## target:add_cflags ### 添加 c 编译选项 仅对 c 代码添加编译选项 ```lua add_cflags(\" g\", \" O2\", \" DDEBUG\") ``` > 所有选项值都基于 gcc 的定义为标准，如果其他编译器不兼容（例如：vc），xmake 会自动内部将其转换成对应编译器支持的选项值。 > 用户无需操心其兼容性，如果其他编译器没有对应的匹配值，那么 xmake 会自动忽略器设置。 可以通过 force 参数来强制禁用 flags 的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置： ```lua add_cflags(\" g\", \" O2\", {force true}) ``` ## target:add_cxflags ### 添加 c/c++ 编译选项 同时对 c/c++ 代码添加编译选项，用法跟 add_cflags 一致。 ## target:add_cxxflags ### 添加 c++ 编译选项 仅对 c++ 代码添加编译选项，用法跟 add_cflags 一致。 #### 添加特定编译器 flags 我们改进了所有 flags 添加接口，可以仅仅对特定编译器指定 flags，例如： ```lua add_cxxflags(\"clang:: stdlib libc++\") add_cxxflags(\"gcc:: stdlib libc++\") add_cxxflags(\"cl::/GR \") add_cxxflags(\"clang_cl::/GR \") ``` 或者： ```lua add_cxxflags(\" stdlib libc++\", {tools \"clang\"}) add_cxxflags(\" stdlib libc++\", {tools \"gcc\"}) add_cxxflags(\"/GR \", {tools {\"clang_cl\", \"cl\"}}) ``` > 不仅仅是编译 flags，对 add_ldflags 等链接 flags，也是同样生效的。 ## target:add_mflags ### 添加 objc 编译选项 仅对 objc 代码添加编译选项 ```lua add_mflags(\" g\", \" O2\", \" DDEBUG\") ``` 可以通过 force 参数来强制禁用 flags 的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置： ```lua add_mflags(\" g\", \" O2\", {force true}) ``` ## target:add_mxflags ### 添加 objc/objc++ 编译选项 同时对 objc/objc++ 代码添加编译选项 ```lua add_mxflags(\" framework CoreFoundation\") ``` ## target:add_mxxflags ### 添加 objc++ 编译选项 仅对 objc++ 代码添加编译选项 ```lua add_mxxflags(\" framework CoreFoundation\") ``` ## target:add_scflags ### 添加 swift 编译选项 对 swift 代码添加编译选项 ```lua add_scflags(\"xxx\") ``` ## target:add_asflags ### 添加汇编编译选项 对汇编代码添加编译选项 ```lua add_asflags(\"xxx\") ``` ## target:add_gcflags ### 添加 go 编译选项 对 golang 代码添加编译选项 ```lua add_gcflags(\"xxx\") ``` ## target:add_dcflags ### 添加 dlang 编译选项 对 dlang 代码添加编译选项 ```lua add_dcflags(\"xxx\") ``` ## target:add_rcflags ### 添加 rust 编译选项 对 rust 代码添加编译选项 ```lua add_rcflags(\"xxx\") ``` ## target:add_fcflags ### 添加 fortran 编译选项 对 fortran 代码添加编译选项 ```lua add_fcflags(\"xxx\") ``` ## target:add_zcflags ### 添加 zig 编译选项 对 zig 代码添加编译选项 ```lua add_zcflags(\"xxx\") ``` ## target:add_cuflags ### 添加 cuda 编译选项 对 cuda 代码添加编译选项 ```lua add_cuflags(\" gencode arch compute_30,code sm_30\") ``` ## target:add_culdflags ### 添加 cuda 设备链接选项 cuda 默认构建会使用 device link，这个阶段如果要设置一些链接 flags，则可以通过这个接口来设置。 而最终的程序链接，会使用 ldflags，不会调用 nvcc，直接通过 gcc/clang 等 c/c++ 链接器来链接。 关于 device link 的说明，可以参考：[https://devblogs.nvidia.com/separate compilation linking cuda device code/](https://devblogs.nvidia.com/separate compilation linking cuda device code/) ```lua add_culdflags(\" gencode arch compute_30,code sm_30\") ``` ## target:add_cugencodes ### 添加 cuda 设备的 gencode 设置 `add_cugencodes()` 接口其实就是对 `add_cuflags(\" gencode arch compute_xx,code compute_xx\")` 编译 flags 设置的简化封装，其内部参数值对应的实际 flags 映射关系如下： ```lua compute_xx > ` gencode arch compute_xx,code compute_xx` sm_xx > ` gencode arch compute_xx,code sm_xx` sm_xx,sm_yy > ` gencode arch compute_xx,code [sm_xx,sm_yy]` compute_xx,sm_yy > ` gencode arch compute_xx,code sm_yy` compute_xx,sm_yy,sm_zz > ` gencode arch compute_xx,code [sm_yy,sm_zz]` native > match the fastest cuda device on current host, eg. for a Tesla P100, ` gencode arch compute_60,code sm_60` will be added, if no available device is found, no ` gencode` flags will be added ``` 例如： ```lua add_cugencodes(\"sm_30\") ``` 就等价为 ```lua add_cuflags(\" gencode arch compute_30,code sm_30\") add_culdflags(\" gencode arch compute_30,code sm_30\") ``` 是不是上面的更加精简些，这其实就是个用于简化设置的辅助接口。 而如果我们设置了 native 值，那么 xmake 会自动探测当前主机的 cuda 设备，然后快速匹配到它对应的 gencode 设置，自动追加到整个构建过程中。 例如，如果我们主机目前的 GPU 是 Tesla P100，并且能够被 xmake 自动检测到，那么下面的设置： ```lua add_cugencodes(\"native\") ``` 等价于： ```lua add_cugencodes(\"sm_60\") ``` ## target:add_ldflags ### 添加链接选项 添加静态链接选项 ```lua add_ldflags(\" L/xxx\", \" lxxx\") ``` 在添加链接选项时，默认无法支持参数内有空格，使用 expand false： ```lua add_ldflags(\" L/my lib\") ERROR: Invalid arguments add_ldflags({\" L/my lib\"}, {expand false}) OK ``` ## target:add_arflags ### 添加静态库归档选项 影响对静态库的生成 ```lua add_arflags(\"xxx\") ``` ## target:add_shflags ### 添加动态库链接选项 影响对动态库的生成 ```lua add_shflags(\"xxx\") ``` ## target:add_options ### 添加关联选项 这个接口跟 [set_options](#targetset_options) 类似，唯一的区别就是，此处是追加选项，而 [set_options](#targetset_options) 每次设置会覆盖先前的设置。 ## target:add_packages ### 添加包依赖 在 target 作用域中，添加集成包依赖，例如： ```lua target(\"test\", function() add_packages(\"zlib\", \"polarssl\", \"pcre\", \"mysql\") end) ``` 这样，在编译 test 目标时，如果这个包存在的，将会自动追加包里面的宏定义、头文件搜索路径、链接库目录，也会自动链接包中所有库。 用户不再需要自己单独调用 [add_links](#targetadd_links)，[add_includedirs](#targetadd_includedirs), [add_ldflags](#targetadd_ldflags) 等接口，来配置依赖库链接了。 对于如何设置包搜索目录，可参考：[add_packagedirs](/zh cn/manual/global_interfaces?id add_packagedirs) 接口 此接口也同时支持远程依赖包管理中 [add_requires](/zh cn/manual/global_interfaces?id add_requires) 定义的包。 ```lua add_requires(\"zlib\", \"polarssl\") target(\"test\", function() add_packages(\"zlib\", \"polarssl\") end) ``` 还支持覆写内置的 links，控制实际链接的库： ```lua 默认会有 ncurses, panel, form 等 links add_requires(\"ncurses\") target(\"test\", function() 显示指定，只使用 ncurses 一个链接库 add_packages(\"ncurses\", {links \"ncurses\"}) end) ``` 或者干脆禁用 links，只使用头文件： ```lua add_requires(\"lua\") target(\"test\", function() add_packages(\"lua\", {links {}}) end) ``` ## target:add_languages ### 添加语言标准 与 [set_languages](#targetset_languages) 类似，唯一区别是这个接口不会覆盖掉之前的设置，而是追加设置。 ## target:add_vectorexts ### 添加向量扩展指令 添加扩展指令优化选项，目前支持以下几种扩展指令集： ```lua add_vectorexts(\"mmx\") add_vectorexts(\"neon\") add_vectorexts(\"avx\", \"avx2\", \"avx512\") add_vectorexts(\"sse\", \"sse2\", \"sse3\", \"ssse3\", \"sse4.2\") ``` > 如果当前设置的指令集编译器不支持，xmake 会自动忽略掉，所以不需要用户手动去判断维护，只需要将你需要的指令集全部设置上就行了。 xmake 新增了一个 `all` 配置项，可以用于尽可能的开启所有扩展指令优化。 ```lua add_vectorexts(\"all\") ``` ## target:add_frameworks ### 添加链接框架 目前主要用于 `ios` 和 `macosx` 平台的 `objc` 和 `swift` 程序，例如： ```lua target(\"test\", function() add_frameworks(\"Foundation\", \"CoreFoundation\") end) ``` 当然也可以使用 [add_mxflags](#targetadd_mxflags) 和[add_ldflags](#targetadd_ldflags)来设置，不过比较繁琐，不建议这样设置。 ```lua target(\"test\", function() add_mxflags(\" framework Foundation\", \" framework CoreFoundation\") add_ldflags(\" framework Foundation\", \" framework CoreFoundation\") end) ``` 如果不是这两个平台，这些设置将会被忽略。 ## target:add_frameworkdirs ### 添加链接框架搜索目录 对于一些第三方 framework，那么仅仅通过 [add_frameworks](#targetadd_frameworks) 是没法找到的，还需要通过这个接口来添加搜索目录。 ```lua target(\"test\", function() add_frameworks(\"MyFramework\") add_frameworkdirs(\"/tmp/frameworkdir\", \"/tmp/frameworkdir2\") end) ``` ## target:set_toolset ### 设置工具集 针对特定 target 单独设置切换某个编译器，链接器，不过我们更推荐使用 [set_toolchains](#targetset_toolchains) 对某个 target 进行整体工具链的切换。 与 set_toolchains 相比，此接口只切换工具链某个特定的编译器或者链接器。 对于 `add_files(\"*.c\")` 添加的源码文件，默认都是会调用系统最匹配的编译工具去编译，或者通过 `xmake f cc clang` 命令手动去修改，不过这些都是全局影响所有 target 目标的。 如果有些特殊需求，需要对当前工程下某个特定的 target 目标单独指定不同的编译器、链接器或者特定版本的编译器，这个时候此接口就可以排上用途了，例如： ```lua target(\"test1\", function() add_files(\"*.c\") end) target(\"test2\", function() add_files(\"*.c\") set_toolset(\"cc\", \"$(projectdir)/tools/bin/clang 5.0\") end) ``` 上述描述仅对 test2 目标的编译器进行特殊设置，使用特定的 clang 5.0 编译器来编译 test2，而 test1 还是使用默认设置。 <p class \"tip\"> 每次设置都会覆盖当前 target 目标下之前的那次设置，不同 target 之间不会被覆盖，互相独立，如果在根域设置，会影响所有子 target。 </p> 前一个参数是 key，用于指定工具类型，目前支持的有（编译器、链接器、归档器）： 工具类型 描述 cc c 编译器 cxx c++ 编译器 mm objc 编译器 mxx objc++ 编译器 gc go 编译器 as 汇编器 sc swift 编译器 rc rust 编译器 dc dlang 编译器 fc fortran 编译器 sc swift 编译器 rust rust 编译器 strip strip 程序 ld c/c++/asm/objc 等通用可执行程序链接器 sh c/c++/asm/objc 等通用动态库链接器 ar c/c++/asm/objc 等通用静态库归档器 dcld dlang 可执行链接器, rcld/gcld 等类似 dcsh dlang 动态库链接器, rcsh/gcsh 等类似 对于一些编译器文件名不规则，导致 xmake 无法正常识别处理为已知的编译器名的情况下，我们也可以加一个工具名提示，例如： ```lua set_toolset(\"cc\", \"gcc@$(projectdir)/tools/bin/mipscc.exe\") ``` 上述描述设置 mipscc.exe 作为 c 编译器，并且提示 xmake 作为 gcc 的传参处理方式进行编译。 ## target:set_toolchains ### 设置工具链 这对某个特定的 target 单独切换设置不同的工具链，和 set_toolset 不同的是，此接口是对完整工具链的整体切换，比如 cc/ld/sh 等一系列工具集。 这也是推荐做法，因为像 gcc/clang 等大部分编译工具链，编译器和链接器都是配套使用的，要切就得整体切，单独零散的切换设置会很繁琐。 比如我们切换 test 目标到 clang+yasm 两个工具链： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"clang\", \"yasm\") end) ``` 只需要指定工具链名字即可，具体 xmake 支持哪些工具链，可以通过下面的命令查看： ```bash $ xmake show l toolchains xcode Xcode IDE vs VisualStudio IDE yasm The Yasm Modular Assembler clang A C language family frontend for LLVM go Go Programming Language Compiler dlang D Programming Language Compiler sdcc Small Device C Compiler cuda CUDA Toolkit ndk Android NDK rust Rust Programming Language Compiler llvm A collection of modular and reusable compiler and toolchain technologies cross Common cross compilation toolchain nasm NASM Assembler gcc GNU Compiler Collection mingw Minimalist GNU for Windows gnu rm GNU Arm Embedded Toolchain envs Environment variables toolchain fasm Flat Assembler ``` 当然，我们也可以通过命令行全局切换到其他工具链： ```bash $ xmake f toolchain clang $ xmake ``` 另外，我们也可以在 xmake.lua 中自定义 toolchain，然后通过 `set_toolchains` 指定进去，例如： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") ... end) ``` 关于这块的详情介绍，可以到 [自定义工具链](/zh cn/manual/custom_toolchain) 章节查看 更多详情见：[#780](https://github.com/xmake io/xmake/issues/780) 支持对 toolchains 平台和架构的单独设置和切换，比如： ```lua target(\"test\", function() set_toolchains(\"xcode\", {plat os.host(), arch os.arch()}) end) ``` 如果当前是在交叉编译模式，那么这个 test 还是会强制切到 xcode 的本地编译工具链和对应的 pc 平台上去，这对于想要同时支持部分 target 使用主机工具链，部分 target 使用交叉编译工具链时候，非常有用。 但是，这还不是特别方便，尤其是跨平台编译时候，不同平台的 pc 工具链都是不同的，有 msvc, xcode, clang 等，还需要判断平台来指定。 因此，我们可以直接使用 [set_plat](#targetset_plat) 和[set_arch](#targetset_arch)接口，直接设置特定 target 到主机平台，就可以内部自动选择 host 工具链了，例如： ```lua target(\"test\", function() set_plat(os.host()) set_arch(os.arch()) end) ``` 这块的应用场景和 example 可以看下：[https://github.com/xmake io/xmake repo/blob/dev/packages/l/luajit/port/xmake.lua](https://github.com/xmake io/xmake repo/blob/dev/packages/l/luajit/port/xmake.lua) luajit 里面就需要同时编译 host 平台的 minilua/buildvm 来生成 jit 相关代码，然后开始针对性编译 luajit 自身到不同的交叉工具链。 关于这块详情，可以参考：[https://github.com/xmake io/xmake/pull/857](https://github.com/xmake io/xmake/pull/857) xmake 对 set_toolchains 做了进一步的改进，更好地对特定 target 支持独立工具链切换，比如不同 target 支持切换到不同的 vs 版本，例如： ```lua target(\"test\", function() set_toolchains(\"msvc\", {vs \"2015\"}) end) ``` 默认 xmake 会使用全局 vs 工具链，比如当前检测到 vs2019，但是用户同时还安装了 vs2015，那么可以通过上面的配置将 test 目标切换到 vs2015 来编译。 甚至还可以配合 `set_arch` 来指定特定的架构到 x86，而不是默认的 x64。 ```lua target(\"test\", function() set_arch(\"x86\") set_toolchains(\"msvc\", {vs \"2015\"}) end) ``` 上面的效果跟 `set_toolchains(\"msvc\", {vs \"2015\", arch \"x86\"})` 类似，不过 `set_arch` 是针对 target 粒度的，而 `set_toolchains` 里面的 arch 设置仅仅针对特定工具链粒度。 通常，我们更推荐使用 `set_arch` 来对整个 target 实现架构切换。 ## target:set_plat ### 设置指定目标的编译平台 通常配合 [set_arch](#targetset_arch) 使用，将指定 target 的编译平台切换到指定平台，xmake 会自动根据切换的平台，选择合适的工具链。 一般用于需要同时编译 host 平台目标、交叉编译目标的场景，更多详情见：[set_toolchains](#targetset_toolchains) 例如： ```console $ xmake f p android ndk /xxx ``` 即使正在使用 android ndk 编译 android 平台目标，但是其依赖的 host 目标，还是会切换到主机平台，使用 xcode, msvc 等 host 工具链来编译。 ```lua target(\"host\", function() set_kind(\"binary\") set_plat(os.host()) set_arch(os.arch()) add_files(\"src/host/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"host\") add_files(\"src/test/*.c\") end) ``` ## target:set_arch ### 设置指定目标的编译架构 详情见：[set_plat](#targetset_plat) ## target:set_values ### 设置一些扩展配置值 给 target 设置一些扩展的配置值，这些配置没有像 `set_ldflags` 这种内置的 api 可用，通过第一个参数传入一个配置名，来扩展配置。 一般用于传入配置参数给自定义 rule 中的脚本使用，例如： ```lua rule(\"markdown\", function() on_build_file(function (target, sourcefile, opt) compile .markdown with flags local flags target:values(\"markdown.flags\") if flags then .. end end) end) target(\"test\", function() add_files(\"src/*.md\", {rule \"markdown\"}) set_values(\"markdown.flags\", \"xxx\", \"xxx\") end) ``` 上述代码例子中，可以看出，在 target 应用 markdown 规则的时候，通过 set_values 去设置一些 flags 值，提供给 markdown 规则去处理。 在规则脚本中可以通过 `target:values(\"markdown.flags\")` 获取到 target 中设置的扩展 flags 值。 > 具体扩展配置名，根据不同的 rule，会有所不同，目前有哪些，可以参考相关规则的描述：[内建规则](/zh cn/manual/custom_rule?id 内建规则) 下面是一些 xmake 目前支持的一些内置的扩展配置项列表。 扩展配置名 配置描述 fortran.moduledir 设置 fortran 模块的输出目录 ndk.arm_mode 设置 ndk 的 arm 编译模式（arm/thumb） objc.build.arc 设置启用或禁用 objc 的 arc objc++.build.arc 设置启用或禁用 objc++ 的 arc xcode.bundle_identifier 设置 xcode 工具链的 Bundle Identifier xcode.mobile_provision 设置 xcode 工具链的证书信息 xcode.codesign_identity 设置 xcode 工具链的代码签名标识 wasm.preloadfiles 设置 wasm 打包的预加载文件（preload file） wdk.env.winver 设置 wdk 的 win 支持版本 wdk.umdf.sdkver 设置 wdk 的 umdf sdk 版本 wdk.kmdf.sdkver 设置 wdk 的 kmdf sdk 版本 wdk.sign.mode 设置 wdk 的代码签名模式 wdk.sign.store 设置 wdk 的代码签名 store wdk.sign.certfile 设置 wdk 的代码签名证书文件 wdk.sign.thumbprint 设置 wdk 的代码签名指纹 ## target:add_values ### 添加一些扩展配置值 用法跟 [target:set_values](#targetset_values) 类似，区别就是这个接口是追加设置，而不会每次覆盖设置。 ## target:set_rundir ### 设置运行目录 此接口用于设置默认运行 target 程序的当前运行目录，如果不设置，默认情况下，target 是在可执行文件所在目录加载运行。 如果用户想要修改加载目录，一种是通过 `on_run()` 的方式自定义运行逻辑，里面去做切换，但仅仅为了切个目录就这么做，太过繁琐。 因此可以通过这个接口快速的对默认执行的目录环境做设置切换。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_rundir(\"$(projectdir)/xxx\") end) ``` ## target:set_runargs ### 设置运行参数列表 2.6.9 新增接口，可用于设置 `xmake run` 的默认运行参数，通过它，我们可以避免每次命令行输入运行参数，`xmake run x arg1 val` ```lua set_runargs(\" x\", \" arg1 val\") ``` ## target:add_runenvs ### 添加运行环境变量 此接口用于添加设置默认运行 target 程序的环境变量，跟 [set_runenv](#targetset_runenv) 不同的是，此接口是对已有系统 env 中的值进行追加，并不会覆盖。 所以，对于 PATH 这种，通过此接口追加值是非常方便的，而且此接口支持多值设置，所以通常就是用来设置带有 path sep 的多值 env。。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_runenvs(\"PATH\", \"/tmp/bin\", \"xxx/bin\") add_runenvs(\"LD_LIBRARY_PATH\", \"/tmp/lib\", \"xxx/lib\") end) ``` ## target:set_runenv ### 设置运行环境变量 此接口跟 [add_runenvs](#targetadd_runenvs) 不同的是，`set_runenv` 是对某个环境变量的覆盖设置，会覆盖原有系统环境的 env 值，并且此接口是单数设置，不能传递多参。 所以，如果要覆盖设置 PATH 这中多路径的 env，需要自己去拼接： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_runenv(\"PATH\", path.joinenv(\"/tmp/bin\", \"xxx/bin\")) set_runenv(\"NAME\", \"value\") end) ``` ## target:set_installdir ### 设置安装目录 2.2.5 版本新增接口，用于针对每个 target 设置不同的默认安装目录，一般用于 `xmake install/uninstall` 命令。 默认情况下执行 `xmake install` 会安装到系统 `/usr/local` 目录，我们除了可以通过 `xmake install o /usr/local` 指定其他安装目录外， 还可以在 xmake.lua 中针对 target 设置不同的安装目录来替代默认目录。 除了上述两种方式，我们也可以通过 `INSTALLDIR` 和 `DESTDIR` 环境变量设置默认的安装目录。 ## target:set_prefixdir ### 设置安装前置子目录 尽管通过 `set_installdir` 和 `xmake install o [installdir]` 设置了安装根目录，但是如果我们还想进一步调整 bin, lib 和 include 的子路径。 那么，我们可以使用这个接口，默认情况下，安装目录会按照这个结构： ```bash installdir bin lib include ``` 如果我们配置： ```lua set_prefix(\"prefixdir\") ``` 就是增加一个总的子目录： ```bash installdir prefixdir bin lib include ``` 我们还可以单独配置 bin, lib 和 include 子目录，例如： ```lua set_prefix(\"prefixdir\", {bindir \"mybin\", libdir \"mylib\", includedir \"myinc\"}) ``` ```bash installdir prefixdir mybin mylib myinc ``` 如果，我们不配置 prefixdir，仅仅修改 bin 子目录，可以将 prefixdir 配置成 `/`。 ```lua set_prefix(\"/\", {bindir \"mybin\", libdir \"mylib\", includedir \"myinc\"}) ``` ```bash installdir mybin mylib myinc ``` ## target:add_installfiles ### 添加安装文件 2.2.5 版本新增接口，用于针对每个 target 设置对应需要安装的文件，一般用于 `xmake install/uninstall` 命令。 比如我们可以指定安装各种类型的文件到安装目录： ```lua target(\"test\", function() add_installfiles(\"src/*.h\") add_installfiles(\"doc/*.md\") end) ``` 默认在 linux 等系统上，我们会安装到 `/usr/local/*.h, /usr/local/*.md`，不过我们也可以指定安装到特定子目录： ```lua target(\"test\", function() add_installfiles(\"src/*.h\", {prefixdir \"include\"}) add_installfiles(\"doc/*.md\", {prefixdir \"share/doc\"}) end) ``` 上面的设置，我们会安装到 `/usr/local/include/*.h, /usr/local/share/doc/*.md` 注：默认安装不会保留目录结构，会完全展开，当然我们也可以通过 `()` 去提取源文件中的子目录结构来安装，例如： ```lua target(\"test\", function() add_installfiles(\"src/(tbox/*.h)\", {prefixdir \"include\"}) add_installfiles(\"doc/(tbox/*.md)\", {prefixdir \"share/doc\"}) end) ``` 我们把 `src/tbox/*.h` 中的文件，提取 `tbox/*.h` 子目录结构后，在进行安装：`/usr/local/include/tbox/*.h, /usr/local/share/doc/tbox/*.md` 当然，用户也可以通过 [set_installdir](#targetset_installdir) 接口，来配合使用。 关于此接口的详细说明，见：[https://github.com/xmake io/xmake/issues/318](https://github.com/xmake io/xmake/issues/318) ## target:add_headerfiles ### 添加安装头文件 2.2.5 版本新增接口，用于针对每个 target 设置对应需要安装的头文件，一般用于 `xmake install/uninstall` 命令。 此接口使用方式跟 [add_installfiles](#targetadd_installfiles) 接口几乎完全一样，都可以用来添加安装文件，不过此接口仅用于安装头文件。 因此，使用上比 `add_installfiles` 简化了不少，默认不设置 prefixdir，也会自动将头文件安装到对应的 `include` 子目录中。 并且此接口对于 `xmake project k vs201x` 等插件生成的 IDE 文件，也会添加对应的头文件进去。 我注：默认安装不会保留目录结构，会完全展开，当然们也可以通过 `()` 去提取源文件中的子目录结构来安装，例如： ```lua target(\"test\", function() add_headerfiles(\"src/(tbox/*.h)\", {prefixdir \"include\"}) end) ``` v2.7.1 之后，我们可以通过 `{install false}` 参数，禁用默认的头文件安装行为，仅仅对设置的头文件用于 project generator 的文件列表展示和编辑，例如 vs project。 ```lua add_headerfiles(\"src/foo.h\") add_headerfiles(\"src/test.h\", {install false}) ``` 上面两个头文件，在 vs 工程中都会展示出来，但是仅仅 foo.h 会被发布安装到系统。 ## target:set_configdir ### 设置模板配置文件的输出目录 2.2.5 版本新增接口，主要用于 [add_configfiles](#targetadd_configfiles) 接口设置的模板配置文件的输出目录。 ## target:set_configvar ### 设置模板配置变量 2.2.5 版本新增接口，用于在编译前，添加一些需要预处理的模板配置变量，一般用于 [add_configfiles](#targetadd_configfiles) 接口。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") set_configvar(\"HAS_FOO\", 1) set_configvar(\"HAS_BAR\", \"bar\") set_configvar(\"HAS_ZOO\", \"zoo\", {quote false}) add_configfiles(\"config.h.in\") end) ``` config.h.in ```c ${define HAS_FOO} ${define HAS_BAR} ${define HAS_ZOO} ``` 生成的 config.h 内容如下： ```c #define HAS_FOO 1 #define HAS_BAR \"bar\" #define HAS_ZOO zoo ``` set_configvar 可以设置 number，string 和 boolean 类型值，如果是 string 值，默认生成的宏定义带有引号，如果要去掉引号，可以设置 `{quote false}`。 相关 issues 见：[#1694](https://github.com/xmake io/xmake/issues/1694) 对于，宏定义里面有路径，需要转义处理路径分隔符的，我们也可以配置开启路径字符转义。 ```lua set_configvar(\"TEST\", \"C:\\\\hello\", {escape true}) ``` 它会自动转义成 `#define TEST \"C:\\\\hello\"` ，如果没开启转义，则会变成：`#define TEST \"C:\\hello\"` 相关 issues 见：[#1872](https://github.com/xmake io/xmake/issues/1872) ## target:add_configfiles ### 添加模板配置文件 用于在编译前，添加一些需要预处理的配置文件。 先来一个简单的例子： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_configdir(\"$(buildir)/config\") add_configfiles(\"src/config.h.in\") end) ``` 上面的设置，会在编译前，自动的将 `config.h.in` 这个头文件配置模板，经过预处理后，生成输出到指定的 `build/config/config.h`。 如果 `set_configdir` 不设置，那么默认输出到 `build` 目录下。 其中 `.in` 后缀会被自动识别处理掉，如果想要输出存储为其他文件名，可以通过： ```lua add_configfiles(\"src/config.h\", {filename \"myconfig.h\"}) ``` 的方式，来重命名输出，同样，这个接口跟 [add_installfiles](#targetadd_configfiles) 类似，也是支持 prefixdir 和子目录提取设置： ```lua add_configfiles(\"src/*.h.in\", {prefixdir \"subdir\"}) add_configfiles(\"src/(tbox/config.h)\") ``` #### 变量替换 这个接口的一个最重要的特性就是，可以在预处理的时候，对里面的一些模板变量进行预处理替换，例如： config.h.in ``` #define VAR1 \"${VAR1}\" #define VAR2 \"${VAR2}\" #define HELLO \"${HELLO}\" ``` ```lua set_configvar(\"VAR1\", \"1\") target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") set_configvar(\"VAR2\", 2) add_configfiles(\"config.h.in\", {variables {hello \"xmake\"}}) add_configfiles(\"*.man\", {onlycopy true}) end) ``` 通过 [set_configvar](#targetset_configvar) 接口设置模板变量，裹着通过 `{variables {xxx \"\"}}` 中设置的变量进行替换处理。 预处理后的文件 `config.h` 内容为： ``` #define VAR1 \"1\" #define VAR2 \"2\" #define HELLO \"xmake\" ``` 而 `{onlycopy true}` 设置，会强制将 `*.man` 作为普通文件处理，仅在预处理阶段 copy 文件，不进行变量替换。 默认的模板变量匹配模式为 `${var}`，当然我们也可以设置其他的匹配模式，例如，改为 `@var@` 匹配规则： ```lua target(\"test\", function() add_configfiles(\"config.h.in\", {pattern \"@(. )@\"}) end) ``` #### 内置变量 我们也有提供了一些内置的变量，即使不通过此接口设置，也是可以进行默认变量替换的： ``` ${VERSION} > 1.6.3 ${VERSION_MAJOR} > 1 ${VERSION_MINOR} > 6 ${VERSION_ALTER} > 3 ${VERSION_BUILD} > set_version(\"1.6.3\", {build \"%Y%m%d%H%M\"}) > 201902031421 ${PLAT} and ${plat} > MACOS and macosx ${ARCH} and ${arch} > ARM and arm ${MODE} and ${mode} > DEBUG/RELEASE and debug/release ${DEBUG} and ${debug} > 1 or 0 ${OS} and ${os} > IOS or ios ``` 例如： config.h.in ```c #define CONFIG_VERSION \"${VERSION}\" #define CONFIG_VERSION_MAJOR ${VERSION_MAJOR} #define CONFIG_VERSION_MINOR ${VERSION_MINOR} #define CONFIG_VERSION_ALTER ${VERSION_ALTER} #define CONFIG_VERSION_BUILD ${VERSION_BUILD} ``` config.h ```c #define CONFIG_VERSION \"1.6.3\" #define CONFIG_VERSION_MAJOR 1 #define CONFIG_VERSION_MINOR 6 #define CONFIG_VERSION_ALTER 3 #define CONFIG_VERSION_BUILD 201902031401 ``` v2.5.3 后新增 git 相关内置变量： ```c #define GIT_COMMIT \"${GIT_COMMIT}\" #define GIT_COMMIT_LONG \"${GIT_COMMIT_LONG}\" #define GIT_COMMIT_DATE \"${GIT_COMMIT_DATE}\" #define GIT_BRANCH \"${GIT_BRANCH}\" #define GIT_TAG \"${GIT_TAG}\" #define GIT_TAG_LONG \"${GIT_TAG_LONG}\" #define GIT_CUSTOM \"${GIT_TAG} ${GIT_COMMIT}\" ``` ```c #define GIT_COMMIT \"8c42b2c2\" #define GIT_COMMIT_LONG \"8c42b2c251793861eb85ffdf7e7c2307b129c7ae\" #define GIT_COMMIT_DATE \"20210121225744\" #define GIT_BRANCH \"dev\" #define GIT_TAG \"v1.6.6\" #define GIT_TAG_LONG \"v1.6.6 0 g8c42b2c2\" #define GIT_CUSTOM \"v1.6.6 8c42b2c2\" ``` #### 宏定义 我们还可以对 `#define` 定义进行一些变量状态控制处理： config.h.in ```c ${define FOO_ENABLE} ``` ```lua set_configvar(\"FOO_ENABLE\", 1) or pass true set_configvar(\"FOO_STRING\", \"foo\") ``` 通过上面的变量设置后，`${define xxx}` 就会替换成： ```c #define FOO_ENABLE 1 #define FOO_STRING \"foo\" ``` 或者（设置为 0 禁用的时候） ```c /* #undef FOO_ENABLE */ /* #undef FOO_STRING */ ``` 这种方式，对于一些自动检测生成 config.h 非常有用，比如配合 option 来做自动检测： ```lua option(\"foo\") set_default(true) set_description(\"Enable Foo\") set_configvar(\"FOO_ENABLE\", 1) 或者传递 true，启用 FOO_ENABLE 变量 set_configvar(\"FOO_STRING\", \"foo\") target(\"test\") add_configfiles(\"config.h.in\") 如果启用 foo 选项 > 添加 FOO_ENABLE 和 FOO_STRING 定义 add_options(\"foo\") ``` config.h.in ```c ${define FOO_ENABLE} ${define FOO_STRING} ``` config.h ```c #define FOO_ENABLE 1 #define FOO_STRING \"foo\" ``` 关于 option 选项检测，以及 config.h 的自动生成，有一些辅助函数，可以看下：[https://github.com/xmake io/xmake/issues/342](https://github.com/xmake io/xmake/issues/342) 除了 `#define`，如果想要对其他非 `#define xxx` 也做状态切换处理，可以使用 `${default xxx 0}` 模式，设置默认值，例如： ``` HAVE_SSE2 equ ${default VAR_HAVE_SSE2 0} ``` 通过 `set_configvar(\"HAVE_SSE2\", 1)` 启用变量后，变为 `HAVE_SSE2 equ 1`，如果没有设置变量，则使用默认值：`HAVE_SSE2 equ 0` 关于这个的详细说明，见：[https://github.com/xmake io/xmake/issues/320](https://github.com/xmake io/xmake/issues/320) #### 定义导出宏 v2.9.8 新增的特性，可以生成动态库的导出宏定义，通常用于 windows 下 dll 库的符号导出和导入。 在 config.h.in 中定义： ```c ${define_export MYLIB} ``` 就会生成 ```c #ifdef MYLIB_STATIC # define MYLIB_EXPORT #else # if defined(_WIN32) # define MYLIB_EXPORT __declspec(dllexport) # elif defined(__GNUC__) && ((__GNUC__ > 4) (__GNUC__ 3 && __GNUC_MINOR__ > 3)) # define MYLIB_EXPORT __attribute__((visibility(\"default\"))) # else # define MYLIB_EXPORT # endif #endif ``` 我们在定义动态库导出符号时，可以通过这个宏来控制导入导出。 ```c MYLIB_EXPORT void foo(); ``` 它跟 CMake 的 [GenerateExportHeader](https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html) 的功能类似。 不过，它不会额外生成一个独立的导出头文件，而是直接在 config.h 中去生成它。 更多详情见：[#6088](https://github.com/xmake io/xmake/issues/6088) #### 自定义预处理器 如果 xmake 内置的生成规则不满足需求，也可以自定义处理器去重写生成规则，例如重写 `${define_export XXX}`： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") add_configfiles(\"config.h.in\", { preprocessor function (preprocessor_name, name, value, opt) if preprocessor_name \"define_export\" then value ([[#ifdef %s_STATIC # define %s_EXPORT #else # if defined(_WIN32) # define %s_EXPORT __declspec(dllexport) # elif defined(__GNUC__) && ((__GNUC__ > 4) (__GNUC__ 3 && __GNUC_MINOR__ > 3)) # define %s_EXPORT __attribute__((visibility(\"default\"))) # else # define %s_EXPORT # endif #endif ]]):format(name, name, name, name, name) return value end end}) end) ``` 我们也可以重写对 `${define XXX}` 和 `${default XXX}` 的生成，甚至自定义扩展其他预处理配置。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") set_configvar(\"FOO\", \"foo\") add_configfiles(\"config.h.in\", { preprocessor function (preprocessor_name, name, value, opt) local argv opt.argv if preprocessor_name \"define_custom\" then return string.format(\"#define CUSTOM_%s %s\", name, value) end end}) end) ``` 然后我们在 config.h.in 中配置： ```c ${define_custom FOO arg1 arg2} ``` 其中，`define_custom` 是自定义的预处理器名，FOO 是变量名，可以从 `set_configvar` 中获取变量值。 而 arg1, arg2 是可选的预处理参数列表，根据实际的需求来判断是否需要使用，如果想要使用参数，可以通过 `opt.argv` 来获取，它是一个参数列表 table。 在运行 `xmake config` 后，就会在 config.h 中自动生成如下配置： ```c #define CUSTOM_FOO foo ``` ## target:set_policy ### 设置构建行为策略 xmake 有很多的默认行为，比如：自动检测和映射 flags、跨 target 并行构建等，虽然提供了一定的智能化处理，但重口难调，不一定满足所有的用户的使用习惯和需求。 因此，从 v2.3.4 开始，xmake 提供默认构建策略的修改设置，开放给用户一定程度上的可配置性。 使用方式如下： ```lua set_policy(\"check.auto_ignore_flags\", false) ``` 只需要在项目根域设置这个配置，就可以禁用 flags 的自动检测和忽略机制，另外 `set_policy` 也可以针对某个特定的 target 局部生效。 ```lua target(\"test\", function() set_policy(\"check.auto_ignore_flags\", false) end) ``` 完整的 policies 支持列表和使用说明，见：[构建策略](/zh cn/guide/build_policies) ### target:set_runtimes ### 设置编译目标依赖的运行时库 用于抽象化设置编译目标依赖的运行时库，目前仅仅支持对 msvc 运行时库的抽象，但后续也许会扩展对其他编译器运行时库的映射。 目前支持的一些配置值说明如下： 值 描述 MT msvc 运行时库：多线程静态库 MTd msvc 运行时库：多线程静态库（调试） MD msvc 运行时库：多线程动态库 MDd msvc 运行时库：多线程动态库（调试） c++_static clang 的 c++ 运行时库，静态库 c++_shared clang 的 c++ 运行时库，动态库 stdc++_static gcc 的 c++ 运行时库，静态库 stdc++_shared gcc 的 c++ 运行时库，动态库 gnustl_static android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 gnustl_shared android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 stlport_static android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 stlport_static android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 关于 vs 运行时，可以参考：[msvc 运行时说明](https://docs.microsoft.com/en us/cpp/build/reference/md mt ld use run time library?view msvc 160) 而这个接口传入 MT/MTd 参数配置，xmake 会自动配置上 `/MT /nodefaultlib:msvcrt.lib` 参数。 我们可以针对不同的 target 设置不同的运行时。 另外，如果我们将 `set_runtimes` 设置在全局根域，那么所有的 `add_requires(\"xx\")` 包定义也会全局同步切换到对应的 vs runtime 配置 ```lua set_runtimes(\"MD\") add_requires(\"libcurl\", \"fmt\") target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") ``` 当然，我们也可以通过 `add_requires(\"xx\", {configs {vs_runtime \"MD\"}})` 对特定包修改 vs 运行时库。 我们也可以通过 `xmake f vs_runtime 'MD'` 通过参数配置来全局切换它。 与此 api 相关的 issue：[#1071](https://github.com/xmake io/xmake/issues/1071#issuecomment 750817681) ## target:set_group ### 设置目标分组 #### 编译指定一批目标程序 我们可以使用 `set_group()` 将给定的目标标记为 `test/benchmark/...` 并使用 `set_default(false)` 禁用来默认构建它。 然后，通过 `xmake g xxx` 命令就能指定构建一批目标程序了。 比如，我们可以使用此功能来构建所有测试。 ```lua target(\"test1\", function() set_kind(\"binary\") set_default(false) set_group(\"test\") add_files(\"src/*.cpp\") end) target(\"test2\", function() set_kind(\"binary\") set_default(false) set_group(\"test\") add_files(\"src/*.cpp\") end) ``` 编译指定的 group： ```console $ xmake g test $ xmake group test ``` #### 运行指定一批目标程序 我们也可以通过设置分组，来指定运行所有带有 `test` 分组的测试程序。 ```console $ xmake run g test $ xmake run group test ``` 另外，我们还可以支持分组的模式匹配： ``` $ xmake build g test_* $ xmake run g test/foo_* $ xmake build g bench* $ xmake run g bench* ``` 更多信息见：[#1913](https://github.com/xmake io/xmake/issues/1913) ## target:set_exceptions ### 启用或者禁用异常 我们可以通过这个配置，配置启用和禁用 C++/Objc 的异常。 通常，如果我们通过 `add_cxxflags` 接口去配置它们，需要根据不同的平台，编译器分别处理它们，非常繁琐。 例如： ```lua on_config(function (target) if (target:has_tool(\"cxx\", \"cl\")) then target:add(\"cxflags\", \"/EHsc\", {force true}) target:add(\"defines\", \"_HAS_EXCEPTIONS 1\", {force true}) elseif(target:has_tool(\"cxx\", \"clang\") or target:has_tool(\"cxx\", \"clang cl\")) then target:add(\"cxflags\", \" fexceptions\", {force true}) target:add(\"cxflags\", \" fcxx exceptions\", {force true}) end end) ``` 而通过这个接口，我们就可以抽象化成编译器无关的方式去配置它们。 开启 C++ 异常: ```lua set_exceptions(\"cxx\") ``` 禁用 C++ 异常: ```lua set_exceptions(\"no cxx\") ``` 我们也可以同时配置开启 objc 异常。 ```lua set_exceptions(\"cxx\", \"objc\") ``` 或者禁用它们。 ```lua set_exceptions(\"no cxx\", \"no objc\") ``` xmake 会在内部自动根据不同的编译器，去适配对应的 flags。 ## target:set_encodings ### 设置编码 我们可以用这个接口设置源文件、目标执行文件的编码。 目前支持的编码：utf 8, gb2312 (msvc) 默认情况下，我们仅仅指定编码，是会同时对源文件，目标文件生效。 ```lua for all source/target encodings set_encodings(\"utf 8\") msvc: /utf 8 ``` 它等价于： ```lua set_encodings(\"source:utf 8\", \"target:utf 8\") ``` 并且，目前仅仅支持设置成 utf 8 编码，将来会不断扩展。 如果，我们仅仅想单独设置源文件编码，或者目标文件编码，也是可以的。 #### 设置源文件编码 通常指的是编译的代码源文件的编码，我们可以这么设置。 ```lua gcc/clang: finput charset UTF 8, msvc: source charset utf 8 set_encodings(\"source:utf 8\") ``` #### 设置目标文件编码 它通常指的是目标可执行文件的运行输出编码。 ```lua gcc/clang: fexec charset UTF 8, msvc: target charset utf 8 set_encodings(\"target:utf 8\") ``` ## target:add_forceincludes ### 强制添加 includes 用于在配置文件中直接强制添加 `includes` 头文件。 ```lua add_forceincludes(\"config.h\") ``` 它的效果类似于 `#include <config.h>`，但是不需要在源码中显式添加它了。 另外，它的搜索路径也是需要通过 `add_includedirs` 来控制，而不是直接配置文件路径。 ```lua add_forceincludes(\"config.h\") add_includedirs(\"src\") ``` 默认 add_forceincludes 匹配 c/c++/objc。如果仅仅只想匹配 c++ 可以这么配置： ```lua add_forceincludes(\"config.h\", {sourcekinds \"cxx\"}) ``` 如果想同时匹配多个源文件类型，也是可以的： ```lua add_forceincludes(\"config.h\", {sourcekinds {\"cxx\", \"mxx\"}}) ``` ## target:add_tests ### 添加测试用例 我们只需要在需要测试的 target 上通过 add_tests 配置一些测试用例，就可以自动执行测试。 即使当前 target 被设置成了 `set_default(false)`，在执行测试的时候，xmake 也还是会先自动编译它们，然后自动运行所有的测试。 我们可以先看个整体的例子，大概知道下它是怎么样子的。 ```lua add_rules(\"mode.debug\", \"mode.release\") for _, file in ipairs(os.files(\"src/test_*.cpp\")) do local name path.basename(file) target(name, function() set_kind(\"binary\") set_default(false) add_files(\"src/\" .. name .. \".cpp\") add_tests(\"default\") add_tests(\"args\", {runargs {\"foo\", \"bar\"}}) add_tests(\"pass_output\", {trim_output true, runargs \"foo\", pass_outputs \"hello foo\"}) add_tests(\"fail_output\", {fail_outputs {\"hello2 .*\", \"hello xmake\"}}) end) end ``` 这个例子，自动扫描源码目录下的 `test_*.cpp` 源文件，然后每个文件自动创建一个测试目标，它被设置成了 `set_default(false)`，也就是正常情况下，默认不会编译它们。 但是，如果执行 `xmake test` 进行测试，它们就会被自动编译，然后测试运行，运行效果如下： ```bash $ xmake test running tests ... [2%]: test_1/args .................................... passed 7.000s [5%]: test_1/default .................................... passed 5.000s [8%]: test_1/fail_output .................................... passed 5.000s [11%]: test_1/pass_output .................................... passed 6.000s [13%]: test_2/args .................................... passed 7.000s [16%]: test_2/default .................................... passed 6.000s [19%]: test_2/fail_output .................................... passed 6.000s [22%]: test_2/pass_output .................................... passed 6.000s [25%]: test_3/args .................................... passed 7.000s [27%]: test_3/default .................................... passed 7.000s [30%]: test_3/fail_output .................................... passed 6.000s [33%]: test_3/pass_output .................................... passed 6.000s [36%]: test_4/args .................................... passed 6.000s [38%]: test_4/default .................................... passed 6.000s [41%]: test_4/fail_output .................................... passed 5.000s [44%]: test_4/pass_output .................................... passed 6.000s [47%]: test_5/args .................................... passed 5.000s [50%]: test_5/default .................................... passed 6.000s [52%]: test_5/fail_output .................................... failed 6.000s [55%]: test_5/pass_output .................................... failed 5.000s [58%]: test_6/args .................................... passed 7.000s [61%]: test_6/default .................................... passed 6.000s [63%]: test_6/fail_output .................................... passed 6.000s [66%]: test_6/pass_output .................................... passed 6.000s [69%]: test_7/args .................................... failed 6.000s [72%]: test_7/default .................................... failed 7.000s [75%]: test_7/fail_output .................................... failed 6.000s [77%]: test_7/pass_output .................................... failed 5.000s [80%]: test_8/args .................................... passed 7.000s [83%]: test_8/default .................................... passed 6.000s [86%]: test_8/fail_output .................................... passed 6.000s [88%]: test_8/pass_output .................................... failed 5.000s [91%]: test_9/args .................................... passed 6.000s [94%]: test_9/default .................................... passed 6.000s [97%]: test_9/fail_output .................................... passed 6.000s [100%]: test_9/pass_output .................................... passed 6.000s 80% tests passed, 7 tests failed out of 36, spent 0.242s ``` #### 运行指定测试目标 我们也可以指定运行指定 target 的某个测试： ```bash $ xmake test targetname/testname ``` 或者按模式匹配的方式，运行一个 target 的所有测试，或者一批测试： ```bash $ xmake test targetname/* $ xmake test targetname/foo* ``` 也可以运行所有 target 的同名测试： ```bash $ xmake test */testname ``` #### 并行化运行测试 其实，默认就是并行化运行的，但是我们可以通过 ` jN` 调整运行的并行度。 ```bash $ xmake test jN ``` #### 分组运行测试 ```bash $ xmake test g \"foo\" $ xmake test g \"foo*\" ``` #### 添加测试到目标（无参数） 如果没有配置任何参数，仅仅配置了测试名到 `add_tests`，那么仅仅测试这个目标程序的是否会运行失败，根据退出代码来判断是否通过测试。 ``` target(\"test\", function() add_tests(\"testname\") end) ``` #### 配置运行参数 我们也可以通过 `{runargs {\"arg1\", \"arg2\"}}` 的方式，给 `add_tests` 配置指定测试需要运行的参数。 另外，一个 target 可以同时配置多个测试用例，每个测试用例可独立运行，互不冲突。 ```lua target(\"test\", function() add_tests(\"testname\", {runargs \"arg1\"}) add_tests(\"testname\", {runargs {\"arg1\", \"arg2\"}}) end) ``` 如果我们没有配置 runargs 到 `add_tests`，那么我们也会尝试从被绑定的 target 中，获取 `set_runargs` 设置的运行参数。 ```lua target(\"test\", function() add_tests(\"testname\") set_runargs(\"arg1\", \"arg2\") end) ``` #### 配置运行目录 我们也可以通过 rundir 设置测试运行的当前工作目录，例如： ```lua target(\"test\", function() add_tests(\"testname\", {rundir os.projectdir()}) end) ``` 如果我们没有配置 rundir 到 `add_tests`，那么我们也会尝试从被绑定的 target 中，获取 `set_rundir` 设置的运行目录。 ```lua target(\"test\", function() add_tests(\"testname\") set_rundir(\"$(projectdir)\") end) ``` #### 配置运行环境 我们也可以通过 runenvs 设置一些运行时候的环境变量，例如： ```lua target(\"test\", function() add_tests(\"testname\", {runenvs {LD_LIBRARY_PATH \"/lib\"}}) end) ``` 如果我们没有配置 runenvs 到 `add_tests`，那么我们也会尝试从被绑定的 target 中，获取 `add_runenvs` 设置的运行环境。 ```lua target(\"test\", function() add_tests(\"testname\") add_runenvs(\"LD_LIBRARY_PATH\", \"/lib\") end) ``` #### 匹配输出结果 默认情况下，`xmake test` 会根据测试运行的退出代码是否为 0，来判断是否测试通过。 当然，我们也可以通过配置测试运行的输出结果是否满足我们的指定的匹配模式，来判断是否测试通过。 主要通过这两个参数控制： 参数 说明 pass_outputs 如果输出匹配，则测试通过 fail_outputs 如果输出匹配，则测试失败 传入 `pass_outputs` 和 `fail_outputs` 的是一个 lua 匹配模式的列表，但模式稍微做了一些简化，比如对 `*` 的处理。 如果要匹配成功，则测试通过，可以这么配置： ```lua target(\"test\", function() add_tests(\"testname1\", {pass_outputs \"hello\"}) add_tests(\"testname2\", {pass_outputs \"hello *\"}) add_tests(\"testname3\", {pass_outputs {\"hello\", \"hello *\"}}) end) ``` 如果要匹配成功，则测试失败，可以这么配置： ```lua target(\"test\", function() add_tests(\"testname1\", {fail_outputs \"hello\"}) add_tests(\"testname2\", {fail_outputs \"hello *\"}) add_tests(\"testname3\", {fail_outputs {\"hello\", \"hello *\"}}) end) ``` 我们也可以同时配置它们： ```lua target(\"test\", function() add_tests(\"testname\", {pass_outputs \"foo\", fail_outputs \"hello\"}) end) ``` 由于一些测试输出的结果，尾部会有一些换行什么的空白字符，干扰匹配模式，我们可以再配置 `trim_output true`，先截断空白字符后，再做匹配。 ```lua target(\"test\", function() add_tests(\"testname\", {trim_output true, pass_outputs \"foo\", fail_outputs \"hello\"}) end) ``` 我们还可以配置 `{plain true}` 是禁用 lua 模式匹配，仅仅做最基础的平坦文本匹配。 ```lua target(\"test\", function() add_tests(\"testname\", {plain true, pass_outputs \"foo\", fail_outputs \"hello\"}) end) ``` #### 配置测试组 我们也可以通过 `group \"foo\"` 来配置一个测试组，进行分组测试： ```lua target(\"test\", function() add_tests(\"testname1\", {group \"foo\"}) add_tests(\"testname2\", {group \"foo\"}) add_tests(\"testname3\", {group \"bar\"}) add_tests(\"testname4\", {group \"bae\"}) end) ``` 其中 testname1/testname2 是一个组 foo，另外两个是在另外一个组。 然后，我们就可以使用 `xmake test g groupname` 来进行分组测试了。 ```bash $ xmake test g \"foo\" $ xmake test g \"foo*\" ``` > 运行分组，也是支持模式匹配的。 另外，如果没有设置 `group` 参数给 `add_tests`，我们也可以默认获取绑定到 target 的组名。 ```lua target(\"test\", function() add_tests(\"testname\") set_group(\"foo\") end) ``` #### 自定义测试脚本 我们还新增了 `before_test`, `on_test` 和 `after_test` 配置脚本，用户可以在 rule 和 target 域，自定义配置它们实现定制化的测试执行。 ```lua target(\"test\", function()) on_test(function (target, opt) print(opt.name, opt.runenvs, opt.runargs, opt.pass_outputs) do test ... passed return true failied return false, errors end) end) ``` 其中，opt 里面可以获取到所有传入 `add_tests` 的参数，我们在 on_test 里面自定义测试逻辑，然后返回 true 就是测试通过，返回 false 就是测试失败，然后继续返回测试失败的错误信息。 #### 自动化构建 由于测试目标在正常开发构建阶段，通常是不需要被构建的，因此我们会设置 `set_default(false)`。 ```lua target(\"test\", function() add_tests(\"testname\") set_default(false) end) ``` 但是运行 `xmake test` 进行测试时候，这些测试对应的 target 还是会被自动构建，确保能够被运行。 ```bash $ xmake test [25%]: cache compiling.release src/main.cpp [50%]: linking.release test running tests ... [100%]: test/testname .................................... passed 6.000s 100% tests passed, 0 tests failed out of 1, spent 0.006s ``` #### 首次测试失败就终止 默认情况下，`xmake test` 会等到所有测试都运行完，不管里面有多少是没通过的。 而有时候，我们想在第一个测试没通过，就直接中断测试，那么我们可以通过下面的配置启用： ```lua set_policy(\"test.stop_on_first_failure\", true) ``` #### 测试失败返回 0 默认情况下，只要有一个测试没通过，等到 `xmake test` 运行完成，它都会返回非 0 退出代码，这对于一些 CI 环境非常有用，可以中断 CI 的其他脚本继续运行。 然后触发信号告诉 CI，我们需要生成测试报告和告警了。 然后，如果我们想要压制这种行为，可以强制将 `xmake test` 的退出代码总是设置成 0。 ```lua set_policy(\"test.return_zero_on_failure\", true) ``` #### 仅仅测试编译 有时候，我们仅仅想要测试代码是否通过编译，或者没有通过编译，不需要运行它们，那么可以通过配置 `build_should_pass` 和 `build_should_fail` 来实现。 ```lua target(\"test_10\", function() set_kind(\"binary\") set_default(false) add_files(\"src/compile.cpp\") add_tests(\"compile_fail\", {build_should_fail true}) end) target(\"test_11\", function() set_kind(\"binary\") set_default(false) add_files(\"src/compile.cpp\") add_tests(\"compile_pass\", {build_should_pass true}) end) ``` 这通常用于一些测试代码中带有 `static_assert` 的场景，例如： ```c++ template <typename T> bool foo(T val) { if constexpr (std::is_same_v<T, int>) { printf(\"int!\\n\"); } else if constexpr (std::is_same_v<T, float>) { printf(\"float!\\n\"); } else { static_assert(false, \"unsupported type\"); } } int main(int, char**) { foo(\"BAD\"); return 0; } ``` #### 配置额外的代码编译 我们还可以在配置测试用例的时候，对每个测试配置额外需要编译的代码，以及一些宏定义，实现内联测试。 xmake 会为每个测试单独编译一个独立的可执行程序去运行它，但这并不会影响到 target 在生产环境的编译结果。 ```lua target(\"test_13\", function() set_kind(\"binary\") set_default(false) add_files(\"src/test_1.cpp\") add_tests(\"stub_1\", {files \"tests/stub_1.cpp\", defines \"STUB_1\"}) end) target(\"test_14\", function() set_kind(\"binary\") set_default(false) add_files(\"src/test_2.cpp\") add_tests(\"stub_2\", {files \"tests/stub_2.cpp\", defines \"STUB_2\"}) end) target(\"test_15\", function() set_kind(\"binary\") set_default(false) add_files(\"src/test_1.cpp\") add_tests(\"stub_n\", {files \"tests/stub_n*.cpp\", defines \"STUB_N\"}) end) ``` 以 doctest 为例，我们可以在不修改任何 main.cpp 的情况下，外置单元测试： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"doctest\") target(\"doctest\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") for _, testfile in ipairs(os.files(\"tests/*.cpp\")) do add_tests(path.basename(testfile), { files testfile, remove_files \"src/main.cpp\", languages \"c++11\", packages \"doctest\", defines \"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\"}) end end) ``` 定义 `DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN` 会引入额外的 main 入口函数，因此我们需要配置 remove_files 去移除已有的 main.cpp 文件。 运行效果如下： ```bash $ xmake test running tests ... [50%]: doctest/test_1 .................................... failed 0.009s [100%]: doctest/test_2 .................................... passed 0.009s 50% tests passed, 1 tests failed out of 2, spent 0.019s ruki 2:doctest ruki$ xmake test v running tests ... [50%]: doctest/test_1 .................................... failed 0.026s [doctest] doctest version is \"2.4.11\" [doctest] run with \" help\" for options tests/test_1.cpp:7: TEST CASE: testing the factorial function tests/test_1.cpp:8: ERROR: CHECK(factorial(1) 10 ) is NOT correct! values: CHECK(1 10) [doctest] test cases: 1 0 passed 1 failed 0 skipped [doctest] assertions: 4 3 passed 1 failed [doctest] Status: FAILURE! run failed, exit code: 1 [100%]: doctest/test_2 .................................... passed 0.010s 50% tests passed, 1 tests failed out of 2, spent 0.038s ``` #### 测试动态库 通常，`add_tests` 仅用于对可执行程序进行运行测试，运行动态库需要有一个额外的 main 主入口，因此我们需要额外配置一个可执行程序去加载它，例如： ```lua target(\"doctest_shared\", function() set_kind(\"shared\") add_files(\"src/foo.cpp\") for _, testfile in ipairs(os.files(\"tests/*.cpp\")) do add_tests(path.basename(testfile), { kind \"binary\", files testfile, languages \"c++11\", packages \"doctest\", defines \"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\"}) end end) ``` 通过 `kind \"binary\"` 可以将每个单元测试改为 binary 可执行程序，并通过 `DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN` 引入 main 入口函数。 这样就能实现动态库目标中外置可运行的单元测试。 #### 配置运行超时 如果一些测试程序长时间运行不退出，就会卡住，我们可以通过配置超时时间，强制退出，并返回失败。 ```lua target(\"test_timeout\", function() set_kind(\"binary\") set_default(false) add_files(\"src/run_timeout.cpp\") add_tests(\"run_timeout\", {run_timeout 1000}) end) ``` ```bash $ xmake test [100%]: test_timeout/run_timeout .................................... failed 1.006s run failed, exit code: 1, exit error: wait process timeout ```"},"/get_started/zh/module/extension-modules.html":{"title":"","content":" class: heading_no_counter # 扩展模块 所有扩展模块的使用，都需要通过 [import](/zh cn/manual/builtin_modules?id import) 接口，进行导入后才能使用。 ## core.base.option 一般用于获取 xmake 命令参数选项的值，常用于插件开发。 ### option.get 获取参数选项值 在插件开发中用于获取参数选项值，例如： ```lua 导入选项模块 import(\"core.base.option\") 插件入口函数 function main(...) print(option.get(\"info\")) end ``` 上面的代码获取 hello 插件，执行：`xmake hello info xxxx` 命令时候传入的 ` info ` 选项的值，并显示：`xxxx` 对于非 main 入口的 task 任务或插件，可以这么使用： ```lua task(\"hello\", function() on_run(function () import(\"core.base.option\") print(option.get(\"info\")) end) end) ``` ## core.base.global 用于获取 xmake 全局的配置信息，也就是 `xmake gglobal xxx val` 传入的参数选项值。 ### global.get 获取指定配置值。 类似 [config.get](#configget)，唯一的区别就是这个是从全局配置中获取。 ### global.load 加载配置。 类似 [global.get](#globalget)，唯一的区别就是这个是从全局配置中加载。 ### global.directory 获取全局配置信息目录。 默认为 `~/.config` 目录。 ### global.dump 打印输出所有全局配置信息。 输出结果如下： ```lua { clean true , ccache \"ccache\" , xcode_dir \"/Applications/Xcode.app\" } ``` ## core.base.task 用于任务操作，一般用于在自定义脚本中、插件任务中，调用运行其他 task 任务。 ### task.run 运行指定任务。 用于在自定义脚本、插件任务中运行 [task](#task) 定义的任务或插件，例如： ```lua task(\"hello\", function() on_run(function () print(\"hello xmake!\") end) end) target(\"demo\", function() on_clean(function(target) 导入 task 模块 import(\"core.base.task\") 运行这个 hello task task.run(\"hello\") end) end) ``` 我们还可以在运行任务时，增加参数传递，例如： ```lua task(\"hello\", function() on_run(function (arg1, arg2) print(\"hello xmake: %s %s!\", arg1, arg2) end) end) target(\"demo\", function() on_clean(function(target) 导入 task import(\"core.base.task\") {} 这个是给第一种选项传参使用，这里置空，这里在最后面传入了两个参数：arg1, arg2 task.run(\"hello\", {}, \"arg1\", \"arg2\") end) end) ``` 对于 `task.run` 的第二个参数，用于传递命令行菜单中的选项，而不是直接传入 `function (arg, ...)` 函数入口中，例如： ```lua 导入 task import(\"core.base.task\") 插件入口 function main(...) 运行内置的 xmake 配置任务，相当于：xmake fconfig plat iphoneos arch armv7 task.run(\"config\", {plat \"iphoneos\", arch \"armv7\"}) end ``` ## core.base.json xmake 提供了内置的 json 模块，基于 lua_cjson 实现，我们可以用它实现快速的在 json 和 lua table 直接相互操作。 我们可以通过 `import(\"core.base.json\")` 直接导入使用。 这里也有一些例子：[Jsom Examples](https://github.com/xmake io/xmake/blob/master/tests/modules/json/test.lua) ### json.decode 直接从字符串解码 json 获取 lua table. ```lua import(\"core.base.json\") local luatable json.decode('[1,\"2\", {\"a\":1,\"b\":true}]') print(luatable) ``` ``` { 1.0, \"2\", { b true, a 1.0 } } ``` > 如果里面有 null，可以用 `json.null` 来判断 ### json.encode 我们也可以直接对一个 lua table 进行编码。 ```lua local jsonstr json.encode({1, \"2\", {a 1}}) ``` 需要注意的是，如果需要编码 null，需要使用 `json.null`，例如 ```lua local jsonstr json.encode({json.null, 1, \"2\", false, true}) ``` ### json.loadfile 直接加载 json 文件，并解析成 lua table。 ```lua local luatable json.loadfile(\"/tmp/xxx.json\") ``` ### json.savefile 保存 lua table 到指定 json 文件。 ```lua json.savefile(\"/tmp/xxx.json\", {1, {a 1}}) ``` ## core.tool.linker 链接器相关操作，常用于插件开发。 ### linker.link 执行链接。 针对 target，链接指定对象文件列表，生成对应的目标文件，例如： ```lua linker.link(\"binary\", \"cc\", {\"a.o\", \"b.o\", \"c.o\"}, target:targetfile(), {target target}) ``` 其中 [target](#target)，为工程目标，这里传入，主要用于获取 target 特定的链接选项，具体如果获取工程目标对象，见：[core.project.project](#core project project) 当然也可以不指定 target，例如： ```lua linker.link(\"binary\", \"cc\", {\"a.o\", \"b.o\", \"c.o\"}, \"/tmp/targetfile\") ``` 第一个参数指定链接类型，目前支持：binary, static, shared 第二个参数告诉链接器，应该作为那种源文件对象进行链接，这些对象源文件使用什么编译器编译的，例如： 第二个参数值 描述 cc c 编译器 cxx c++ 编译器 mm objc 编译器 mxx objc++ 编译器 gc go 编译器 as 汇编器 sc swift 编译器 rc rust 编译器 dc dlang 编译器 指定不同的编译器类型，链接器会适配最合适的链接器来处理链接，并且如果几种支持混合编译的语言，那么可以同时传入多个编译器类型，指定链接器选择支持这些混合编译语言的链接器进行链接处理： ```lua linker.link(\"binary\", {\"cc\", \"mxx\", \"sc\"}, {\"a.o\", \"b.o\", \"c.o\"}, \"/tmp/targetfile\") ``` 上述代码告诉链接器，a, b, c 三个对象文件有可能分别是 c, objc++, swift 代码编译出来的，链接器会从当前系统和工具链中选择最合适的链接器去处理这个链接过程。 ### linker.linkcmd 获取链接命令行字符串。 直接获取 [linker.link](#linkerlink) 中执行的命令行字符串，相当于： ```lua local cmdstr linker.linkcmd(\"static\", \"cxx\", {\"a.o\", \"b.o\", \"c.o\"}, target:targetfile(), {target target}) ``` 注：后面 `{target target}` 扩展参数部分是可选的，如果传递了 target 对象，那么生成的链接命令，会加上这个 target 配置对应的链接选项。 并且还可以自己传递各种配置，例如： ```lua local cmdstr linker.linkcmd(\"static\", \"cxx\", {\"a.o\", \"b.o\", \"c.o\"}, target:targetfile(), {configs {linkdirs \"/usr/lib\"}}) ``` ### linker.linkargv 获取链接命令行参数列表。 跟 [linker.linkcmd](#linkerlinkchtml) 稍微有点区别的是，此接口返回的是参数列表，table 表示，更加方便操作： ```lua local program, argv linker.linkargv(\"static\", \"cxx\", {\"a.o\", \"b.o\", \"c.o\"}, target:targetfile(), {target target}) ``` 其中返回的第一个值是主程序名，后面是参数列表，而 `os.args(table.join(program, argv))` 等价于 `linker.linkcmd`。 我们也可以通过传入返回值给 [os.runv](#os runv) 来直接运行它：`os.runv(linker.linkargv(..))` ### linker.linkflags 获取链接选项。 获取 [linker.linkcmd](#linkerlinkchtml) 中的链接选项字符串部分，不带 shellname 和对象文件列表，并且是按数组返回，例如： ```lua local flags linker.linkflags(\"shared\", \"cc\", {target target}) for _, flag in ipairs(flags) do print(flag) end ``` 返回的是 flags 的列表数组。 ### linker.has_flags 判断指定链接选项是否支持。 虽然通过 [lib.detect.has_flags](detect has_flags) 也能判断，但是那个接口更加底层，需要指定链接器名称 而此接口只需要指定 target 的目标类型，源文件类型，它会自动切换选择当前支持的链接器。 ```lua if linker.has_flags(target:targetkind(), target:sourcekinds(), \" L/usr/lib lpthread\") then ok end ``` ## core.tool.compiler 编译器相关操作，常用于插件开发。 ### compiler.compile 执行编译。 针对 target，链接指定对象文件列表，生成对应的目标文件，例如： ```lua compiler.compile(\"xxx.c\", \"xxx.o\", \"xxx.h.d\", {target target}) ``` 其中 [target](#target)，为工程目标，这里传入主要用于获取 taeget 的特定编译选项，具体如果获取工程目标对象，见：[core.project.project](#core project project) 而 `xxx.h.d` 文件用于存储为此源文件的头文件依赖文件列表，最后这两个参数都是可选的，编译的时候可以不传他们： ```lua compiler.compile(\"xxx.c\", \"xxx.o\") ``` 来单纯编译一个源文件。 ### compiler.compcmd 获取编译命令行。 直接获取 [compiler.compile](#compilercompile) 中执行的命令行字符串，相当于： ```lua local cmdstr compiler.compcmd(\"xxx.c\", \"xxx.o\", {target target}) ``` 注：后面 `{target target}` 扩展参数部分是可选的，如果传递了 target 对象，那么生成的编译命令，会加上这个 target 配置对应的链接选项。 并且还可以自己传递各种配置，例如： ```lua local cmdstr compiler.compcmd(\"xxx.c\", \"xxx.o\", {configs {includedirs \"/usr/include\", defines \"DEBUG\"}}) ``` 通过 target，我们可以导出指定目标的所有源文件编译命令： ```lua import(\"core.project.project\") for _, target in pairs(project.targets()) do for sourcekind, sourcebatch in pairs(target:sourcebatches()) do for index, objectfile in ipairs(sourcebatch.objectfiles) do local cmdstr compiler.compcmd(sourcebatch.sourcefiles[index], objectfile, {target target}) end end end ``` ### compiler.compargv 获取编译命令行列表。 跟 [compiler.compcmd](#compilercompchtml) 稍微有点区别的是，此接口返回的是参数列表，table 表示，更加方便操作： ```lua local program, argv compiler.compargv(\"xxx.c\", \"xxx.o\") ``` ### compiler.compflags 获取编译选项。 获取 [compiler.compcmd](#compilercompchtml) 中的编译选项字符串部分，不带 shellname 和文件列表，例如： ```lua local flags compiler.compflags(sourcefile, {target target}) for _, flag in ipairs(flags) do print(flag) end ``` 返回的是 flags 的列表数组。 ### compiler.has_flags 判断指定编译选项是否支持 虽然通过 [lib.detect.has_flags](detect has_flags) 也能判断，但是那个接口更加底层，需要指定编译器名称。 而此接口只需要指定语言类型，它会自动切换选择当前支持的编译器。 ```lua 判断 c 语言编译器是否支持选项: g if compiler.has_flags(\"c\", \" g\") then ok end 判断 c++ 语言编译器是否支持选项: g if compiler.has_flags(\"cxx\", \" g\") then ok end ``` ### compiler.features 获取所有编译器特性 虽然通过 [lib.detect.features](detect features) 也能获取，但是那个接口更加底层，需要指定编译器名称。 而此接口只需要指定语言类型，它会自动切换选择当前支持的编译器，然后获取当前的编译器特性列表。 ```lua 获取当前 c 语言编译器的所有特性 local features compiler.features(\"c\") 获取当前 c++ 语言编译器的所有特性，启用 c++11 标准，否则获取不到新标准的特性 local features compiler.features(\"cxx\", {configs {cxxflags \" std c++11\"}}) 获取当前 c++ 语言编译器的所有特性，传递工程 target 的所有配置信息 local features compiler.features(\"cxx\", {target target, configs {defines \"..\", includedirs \"..\"}}) ``` 所有 c 编译器特性列表： 特性名 c_static_assert c_restrict c_variadic_macros c_function_prototypes 所有 c++ 编译器特性列表： 特性名 cxx_variable_templates cxx_relaxed_constexpr cxx_aggregate_default_initializers cxx_contextual_conversions cxx_attribute_deprecated cxx_decltype_auto cxx_digit_separators cxx_generic_lambdas cxx_lambda_init_captures cxx_binary_literals cxx_return_type_deduction cxx_decltype_incomplete_return_types cxx_reference_qualified_functions cxx_alignof cxx_attributes cxx_inheriting_constructors cxx_thread_local cxx_alias_templates cxx_delegating_constructors cxx_extended_friend_declarations cxx_final cxx_nonstatic_member_init cxx_override cxx_user_literals cxx_constexpr cxx_defaulted_move_initializers cxx_enum_forward_declarations cxx_noexcept cxx_nullptr cxx_range_for cxx_unrestricted_unions cxx_explicit_conversions cxx_lambdas cxx_local_type_template_args cxx_raw_string_literals cxx_auto_type cxx_defaulted_functions cxx_deleted_functions cxx_generalized_initializers cxx_inline_namespaces cxx_sizeof_member cxx_strong_enums cxx_trailing_return_types cxx_unicode_literals cxx_uniform_initialization cxx_variadic_templates cxx_decltype cxx_default_function_template_args cxx_long_long_type cxx_right_angle_brackets cxx_rvalue_references cxx_static_assert cxx_extern_templates cxx_func_identifier cxx_variadic_macros cxx_template_template_parameters ### compiler.has_features 判断指定的编译器特性是否支持。 虽然通过 [lib.detect.has_features](detect has features) 也能获取，但是那个接口更加底层，需要指定编译器名称。 而此接口只需要指定需要检测的特姓名称列表，就能自动切换选择当前支持的编译器，然后判断指定特性在当前的编译器中是否支持。 ```lua if compiler.has_features(\"c_static_assert\") then ok end if compiler.has_features({\"c_static_assert\", \"cxx_constexpr\"}, {languages \"cxx11\"}) then ok end if compiler.has_features(\"cxx_constexpr\", {target target, defines \"..\", includedirs \"..\"}) then ok end ``` 具体特性名有哪些，可以参考：[compiler.features](#compilerfeatures)。 ## core.project.config 用于获取工程编译时候的配置信息，也就是 `xmake fconfig xxx val` 传入的参数选项值。 ### config.get 获取指定配置值。 用于获取 `xmake fconfig xxx val` 的配置值，例如： ```lua target(\"test\") on_run(function (target) 导入配置模块 import(\"core.project.config\") 获取配置值 print(config.get(\"xxx\")) end) ``` ### config.load 加载配置。 一般用于插件开发中，插件任务中不像工程的自定义脚本，环境需要自己初始化加载，默认工程配置是没有被加载的，如果要用 [config.get](#configget) 接口获取工程配置，那么需要先： ```lua 导入配置模块 import(\"core.project.config\") function main(...) 先加载工程配置 config.load() 获取配置值 print(config.get(\"xxx\")) end ``` ### config.arch 获取当前工程的架构配置。 也就是获取 `xmake fconfig arch armv7` 的平台配置，相当于 `config.get(\"arch\")`。 ### config.plat 获取当前工程的平台配置。 也就是获取 `xmake fconfig plat iphoneos` 的平台配置，相当于 `config.get(\"plat\")`。 ### config.mode 获取当前工程的编译模式配置。 也就是获取 `xmake fconfig mode debug` 的平台配置，相当于 `config.get(\"mode\")`。 ### config.buildir 获取当前工程的输出目录配置。 也就是获取 `xmake fconfig o /tmp/output` 的平台配置，相当于 `config.get(\"buildir\")`。 ### config.directory 获取当前工程的配置信息目录。 获取工程配置的存储目录，默认为：`projectdir/.config` ### config.dump 打印输出当前工程的所有配置信息。 输出结果例如： ```lua { sh \"xcrun sdk macosx clang++\" , xcode_dir \"/Applications/Xcode.app\" , ar \"xcrun sdk macosx ar\" , small true , object false , arch \"x86_64\" , xcode_sdkver \"10.12\" , ex \"xcrun sdk macosx ar\" , cc \"xcrun sdk macosx clang\" , rc \"rustc\" , plat \"macosx\" , micro false , host \"macosx\" , as \"xcrun sdk macosx clang\" , dc \"dmd\" , gc \"go\" , openssl false , ccache \"ccache\" , cxx \"xcrun sdk macosx clang\" , sc \"xcrun sdk macosx swiftc\" , mm \"xcrun sdk macosx clang\" , buildir \"build\" , mxx \"xcrun sdk macosx clang++\" , ld \"xcrun sdk macosx clang++\" , mode \"release\" , kind \"static\" } ``` ## core.project.project 用于获取当前工程的一些描述信息，也就是在 `xmake.lua` 工程描述文件中定义的配置信息，例如：[target](#target)、[option](#option) 等。 ### project.load 加载工程描述配置。 仅在插件中使用，因为这个时候还没有加载工程配置信息，在工程目标的自定义脚本中，不需要执行此操作，就可以直接访问工程配置。 ```lua 导入工程模块 import(\"core.project.project\") 插件入口 function main(...) 加载工程描述配置 project.load() 访问工程描述，例如获取指定工程目标 local target project.target(\"test\") end ``` ### project.directory 获取工程目录 获取当前工程目录，也就是 `xmake P xxx` 中指定的目录，否则为默认当前 `xmake` 命令执行目录。 > 建议使用 [os.projectdir](#os projectdir) 来获取。 ### project.target 获取指定工程目标对象。 获取和访问指定工程目标配置，例如： ```lua local target project.target(\"test\") if target then 获取目标名 print(target:name()) 获取目标目录, 2.1.9 版本之后才有 print(target:targetdir()) 获取目标文件名 print(target:targetfile()) 获取目标类型，也就是：binary, static, shared print(target:targetkind()) 获取目标名 print(target:name()) 获取目标源文件 local sourcefiles target:sourcefiles() 获取目标安装头文件列表 local srcheaders, dstheaders target:headerfiles() 获取目标依赖 print(target:get(\"deps\")) end ``` ### project.targets 获取工程目标对象列表。 返回当前工程的所有编译目标，例如： ```lua for targetname, target in pairs(project.targets()) print(target:targetfile()) end ``` ### project.option 获取指定选项对象。 获取和访问工程中指定的选项对象，例如： ```lua local option project.option(\"test\") if option:enabled() then option:enable(false) end ``` ### project.options 获取工程所有选项对象。 返回当前工程的所有编译目标，例如： ```lua for optionname, option in pairs(project.options()) print(option:enabled()) end ``` ### project.name 获取当前工程名。 也就是获取 [set_project](#set_project) 的工程名配置。 ```lua print(project.name()) ``` ### project.version 获取当前工程版本号。 也就是获取 [set_version](#set_version) 的工程版本配置。 ```lua print(project.version()) ``` ## core.language.language 用于获取编译语言相关信息，一般用于代码文件的操作。 ### language.extensions 获取所有语言的代码后缀名列表。 获取结果如下： ```lua { [\".c\"] cc , [\".cc\"] cxx , [\".cpp\"] cxx , [\".m\"] mm , [\".mm\"] mxx , [\".swift\"] sc , [\".go\"] gc } ``` ### language.targetkinds 获取所有语言的目标类型列表。 获取结果如下： ```lua { binary {\"ld\", \"gcld\", \"dcld\"} , static {\"ar\", \"gcar\", \"dcar\"} , shared {\"sh\", \"dcsh\"} } ``` ### language.sourcekinds 获取所有语言的源文件类型列表。 获取结果如下： ```lua { cc \".c\" , cxx {\".cc\", \".cpp\", \".cxx\"} , mm \".m\" , mxx \".mm\" , sc \".swift\" , gc \".go\" , rc \".rs\" , dc \".d\" , as {\".s\", \".S\", \".asm\"} } ``` ### language.sourceflags 加载所有语言的源文件编译选项名列表。 获取结果如下： ```lua { cc {\"cflags\", \"cxflags\"} , cxx {\"cxxflags\", \"cxflags\"} , ... } ``` ### language.load 加载指定语言。 从语言名称加载具体语言对象，例如： ```lua local lang language.load(\"c++\") if lang then print(lang:name()) end ``` ### language.load_sk 从源文件类型加载指定语言。 从源文件类型：`cc, cxx, mm, mxx, sc, gc, as ..` 加载具体语言对象，例如： ```lua local lang language.load_sk(\"cxx\") if lang then print(lang:name()) end ``` ### language.load_ex 从源文件后缀名加载指定语言。 从源文件后缀名：`.cc, .c, .cpp, .mm, .swift, .go ..` 加载具体语言对象，例如： ```lua local lang language.load_sk(\".cpp\") if lang then print(lang:name()) end ``` ### language.sourcekind_of 获取指定源文件的源文件类型。 也就是从给定的一个源文件路径，获取它是属于那种源文件类型，例如： ```lua print(language.sourcekind_of(\"/xxxx/test.cpp\")) ``` 显示结果为：`cxx`，也就是 `c++` 类型，具体对应列表见：[language.sourcekinds](#languagesourcekinds) ## lib.detect 此模块提供了非常强大的探测功能，用于探测程序、编译器、语言特性、依赖包等。 > 此模块的接口分散在多个模块目录中，尽量通过导入单个接口来使用，这样效率更高。 ### detect.find_file 查找文件。 这个接口提供了比 [os.files](#os files) 更加强大的工程， 可以同时指定多个搜索目录，并且还能对每个目录指定附加的子目录，来模式匹配查找，相当于是 [os.files](#os files) 的增强版。 例如： ```lua import(\"lib.detect.find_file\") local file find_file(\"ccache\", { \"/usr/bin\", \"/usr/local/bin\"}) ``` 如果找到，返回的结果是：`/usr/bin/ccache` 它同时也支持模式匹配路径，进行递归查找，类似 `os.files`： ```lua local file find_file(\"test.h\", { \"/usr/include\", \"/usr/local/include/**\"}) ``` 不仅如此，里面的路径也支持内建变量，来从环境变量和注册表中获取路径进行查找： ```lua local file find_file(\"xxx.h\", { \"$(env PATH)\", \"$(reg HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\XXXX;Name)\"}) ``` 如果路径规则比较复杂多变，还可以通过自定义脚本来动态生成路径传入： ```lua local file find_file(\"xxx.h\", { \"$(env PATH)\", function () return val(\"HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\XXXX;Name\"):match(\"\\\"(. )\\\"\") end}) ``` 大部分场合下，上面的使用已经满足各种需求了，如果还需要一些扩展功能，可以通过传入第三个参数，自定义一些可选配置，例如： ```lua local file find_file(\"test.h\", { \"/usr\", \"/usr/local\"}, {suffixes {\"/include\", \"/lib\"}}) ``` 通过指定 suffixes 子目录列表，可以扩展路径列表（第二个参数），使得实际的搜索目录扩展为： ``` /usr/include /usr/lib /usr/local/include /usr/local/lib ``` 并且不用改变路径列表，就能动态切换子目录来搜索文件。 > 我们也可以通过 `xmake lua` 插件来快速调用和测试此接口：`xmake lua lib.detect.find_file test.h /usr/local` ### detect.find_path 查找路径。 这个接口的用法跟 [lib.detect.find_file](#detectfind_file) 类似，唯一的区别是返回的结果不同。 此接口查找到传入的文件路径后，返回的是对应的搜索路径，而不是文件路径本身，一般用于查找文件对应的父目录位置。 ```lua import(\"lib.detect.find_path\") local p find_path(\"include/test.h\", { \"/usr\", \"/usr/local\"}) ``` 上述代码如果查找成功，则返回：`/usr/local`，如果 `test.h` 在 `/usr/local/include/test.h` 的话。 还有一个区别就是，这个接口传入不只是文件路径，还可以传入目录路径来查找： ```lua local p find_path(\"lib/xxx\", { \"$(env PATH)\", \"$(reg HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\XXXX;Name)\"}) ``` 同样，此接口也支持模式匹配和后缀子目录： ```lua local p find_path(\"include/*.h\", { \"/usr\", \"/usr/local/**\"}, {suffixes \"/subdir\"}) ``` ### detect.find_library 查找库文件。 此接口用于指定的搜索目录中查找库文件（静态库，动态库），例如： ```lua import(\"lib.detect.find_library\") local library find_library(\"crypto\", {\"/usr/lib\", \"/usr/local/lib\"}) ``` 在 macosx 上运行，返回的结果如下： ```lua { filename libcrypto.dylib , linkdir /usr/lib , link crypto , kind shared } ``` 如果不指定是否需要静态库还是动态库，那么此接口会自动选择一个存在的库（有可能是静态库、也有可能是动态库）进行返回。 如果需要强制指定需要查找的库类型，可以指定 kind 参数为（`static/shared`）： ```lua local library find_library(\"crypto\", {\"/usr/lib\", \"/usr/local/lib\"}, {kind \"static\"}) ``` 此接口也支持 suffixes 后缀子目录搜索和模式匹配操作： ```lua local library find_library(\"cryp*\", {\"/usr\", \"/usr/local\"}, {suffixes \"/lib\"}) ``` ### detect.find_program 查找可执行程序。 这个接口比 [lib.detect.find_tool](#detectfind_tool) 较为原始底层，通过指定的参数目录来查找可执行程序。 ```lua import(\"lib.detect.find_program\") local program find_program(\"ccache\") ``` 上述代码犹如没有传递搜索目录，所以它会尝试直接执行指定程序，如果运行 ok，那么直接返回：`ccache`，表示查找成功。 指定搜索目录，修改尝试运行的检测命令参数（默认是：`ccache version`）： ```lua local program find_program(\"ccache\", {paths {\"/usr/bin\", \"/usr/local/bin\"}, check \" help\"}) ``` 上述代码会尝试运行：`/usr/bin/ccache help`，如果运行成功，则返回：`/usr/bin/ccache`。 如果 ` help` 也没法满足需求，有些程序没有 ` version/ help` 参数，那么可以自定义运行脚本，来运行检测： ```lua local program find_program(\"ccache\", {paths {\"/usr/bin\", \"/usr/local/bin\"}, check function (program) os.run(\"%s h\", program) end}) ``` 同样，搜索路径列表支持内建变量和自定义脚本： ```lua local program find_program(\"ccache\", {paths {\"$(env PATH)\", \"$(reg HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\AeDebug;Debugger)\"}}) local program find_program(\"ccache\", {paths {\"$(env PATH)\", function () return \"/usr/local/bin\" end}}) ``` <p class \"tip\"> 为了加速频发查找的效率，此接口是默认自带 cache 的，所以就算频繁查找相同的程序，也不会花太多时间。 如果要禁用 cache，可以在工程目录执行 `xmake f c` 清除本地 cache。 </p> 我们也可以通过 `xmake lua lib.detect.find_program ccache` 来快速测试。 ### detect.find_programver 查找可执行程序版本号。 ```lua import(\"lib.detect.find_programver\") local programver find_programver(\"ccache\") ``` 返回结果为：3.2.2 默认它会通过 `ccache version` 尝试获取版本，如果不存在此参数，可以自己指定其他参数： ```lua local version find_programver(\"ccache\", {command \" v\"}) ``` 甚至自定义版本获取脚本： ```lua local version find_programver(\"ccache\", {command function () return os.iorun(\"ccache version\") end}) ``` 对于版本号的提取规则，如果内置的匹配模式不满足要求，也可以自定义： ```lua local version find_programver(\"ccache\", {command \" version\", parse \"(%d+%.?%d*%.?%d*. )%s\"}) local version find_programver(\"ccache\", {command \" version\", parse function (output) return output:match(\"(%d+%.?%d*%.?%d*. )%s\") end}) ``` > 为了加速频发查找的效率，此接口是默认自带 cache 的，如果要禁用 cache，可以在工程目录执行 `xmake f c` 清除本地 cache。 我们也可以通过 `xmake lua lib.detect.find_programver ccache` 来快速测试。 ### detect.find_package 查找包文件。 这个接口不推荐直接使用（仅供内部使用），库集成，请尽量使用 `add_requires()` 和 `add_packages()`。 ### detect.find_tool 查找工具。 此接口也是用于查找可执行程序，不过比 [lib.detect.find_program](#detectfind_program) 更加的高级，功能也更加强大，它对可执行程序进行了封装，提供了工具这个概念： toolname: 工具名，可执行程序的简称，用于标示某个工具，例如：`gcc`, `clang` 等 program: 可执行程序命令，例如：`xcrun sdk macosx clang` 其对应关系如下： toolname program clang `xcrun sdk macosx clang` gcc `/usr/toolchains/bin/arm linux gcc` link `link.exe lib` [lib.detect.find_program](#detectfind_program) 只能通过传入的原始 program 命令或路径，去判断该程序是否存在。 而 `find_tool` 则可以通过更加一致的 toolname 去查找工具，并且返回对应的 program 完整命令路径，例如： ```lua import(\"lib.detect.find_tool\") local tool find_tool(\"clang\") ``` 返回的结果为：`{name \"clang\", program \"clang\"}`，这个时候还看不出区别，我们可以手动指定可执行的命令： ```lua local tool find_tool(\"clang\", {program \"xcrun sdk macosx clang\"}) ``` 返回的结果为：`{name \"clang\", program \"xcrun sdk macosx clang\"}` 而在 macosx 下，gcc 就是 clang，如果我们执行 `gcc version` 可以看到就是 clang 的一个马甲，我们可以通过 `find_tool` 接口进行智能识别： ```lua local tool find_tool(\"gcc\") ``` 返回的结果为：`{name \"clang\", program \"gcc\"}` 通过这个结果就可以看的区别来了，工具名实际会被标示为 clang，但是可执行的命令用的是 gcc。 我们也可以指定 `{version true}` 参数去获取工具的版本，并且指定一个自定义的搜索路径，也支持内建变量和自定义脚本哦： ```lua local tool find_tool(\"clang\", {version true, paths {\"/usr/bin\", \"/usr/local/bin\", \"$(env PATH)\", function () return \"/usr/xxx/bin\" end}}) ``` 返回的结果为：`{name \"clang\", program \"/usr/bin/clang\", version \"4.0\"}` 这个接口是对 `find_program` 的上层封装，因此也支持自定义脚本检测： ```lua local tool find_tool(\"clang\", {check \" help\"}) local tool find_tool(\"clang\", {check function (tool) os.run(\"%s h\", tool) end}) ``` 最后总结下，`find_tool` 的查找流程： 1. 优先通过 `{program \"xxx\"}` 的参数来尝试运行和检测。 2. 如果在 `xmake/modules/detect/tools` 下存在 `detect.tools.find_xxx` 脚本，则调用此脚本进行更加精准的检测。 3. 尝试从 `/usr/bin`，`/usr/local/bin` 等系统目录进行检测。 我们也可以在工程 `xmake.lua` 中 `add_moduledirs` 指定的模块目录中，添加自定义查找脚本，来改进检测机制： ``` projectdir xmake/modules detect/tools/find_xxx.lua ``` 例如我们自定义一个 `find_7z.lua` 的查找脚本： ```lua import(\"lib.detect.find_program\") import(\"lib.detect.find_programver\") function main(opt) init options opt opt or {} find program local program find_program(opt.program or \"7z\", opt.pathes, opt.check or \" help\") find program version local version nil if program and opt and opt.version then version find_programver(program, \" help\", \"(%d+%.?%d*)%s\") end ok? return program, version end ``` 将它放置到工程的模块目录下后，执行：`xmake l lib.detect.find_tool 7z` 就可以查找到了。 > 为了加速频发查找的效率，此接口是默认自带 cache 的，如果要禁用 cache，可以在工程目录执行 `xmake f c` 清除本地 cache。 我们也可以通过 `xmake lua lib.detect.find_tool clang` 来快速测试。 ### detect.find_toolname 查找工具名。 通过 program 命令匹配对应的工具名，例如： program toolname `xcrun sdk macosx clang` clang `/usr/bin/arm linux gcc` gcc `link.exe lib` link `gcc 5` gcc `arm android clang++` clangxx `pkg config` pkg_config toolname 相比 program，更能唯一标示某个工具，也方便查找和加载对应的脚本 `find_xxx.lua`。 ### detect.find_cudadevices 查找本机的 CUDA 设备。 通过 CUDA Runtime API 枚举本机的 CUDA 设备，并查询其属性。 ```lua import(\"lib.detect.find_cudadevices\") local devices find_cudadevices({skip_compute_mode_prohibited true}) local devices find_cudadevices({min_sm_arch 35, order_by_flops true}) ``` 返回的结果为：`{{ ['$id'] 0, name \"GeForce GTX 960M\", major 5, minor 0, ... }, ... }` 包含的属性依据当前 CUDA 版本会有所不同，可以参考 [CUDA 官方文档](https://docs.nvidia.com/cuda/cuda runtime api/structcudaDeviceProp.html#structcudaDeviceProp) 及其历史版本。 ### detect.features 获取指定工具的所有特性。 此接口跟 [compiler.features](#compilerfeatures) 类似，区别就是此接口更加的原始，传入的参数是实际的工具名 toolname。 并且此接口不仅能够获取编译器的特性，任何工具的特性都可以获取，因此更加通用。 ```lua import(\"lib.detect.features\") local features features(\"clang\") local features features(\"clang\", {flags \" O0\", program \"xcrun sdk macosx clang\"}) local features features(\"clang\", {flags {\" g\", \" O0\", \" std c++11\"}}) ``` 通过传入 flags，可以改变特性的获取结果，例如一些 c++11 的特性，默认情况下获取不到，通过启用 ` std c++11` 后，就可以获取到了。 所有编译器的特性列表，可以见：[compiler.features](#compilerfeatures)。 ### detect.has_features 判断指定特性是否支持。 此接口跟 [compiler.has_features](#compilerhas_features) 类似，但是更加原始，传入的参数是实际的工具名 toolname。 并且此接口不仅能够判断编译器的特性，任何工具的特性都可以判断，因此更加通用。 ```lua import(\"lib.detect.has_features\") local features has_features(\"clang\", \"cxx_constexpr\") local features has_features(\"clang\", {\"cxx_constexpr\", \"c_static_assert\"}, {flags {\" g\", \" O0\"}, program \"xcrun sdk macosx clang\"}) local features has_features(\"clang\", {\"cxx_constexpr\", \"c_static_assert\"}, {flags \" g\"}) ``` 如果指定的特性列表存在，则返回实际支持的特性子列表，如果都不支持，则返回 nil，我们也可以通过指定 flags 去改变特性的获取规则。 所有编译器的特性列表，可以见：[compiler.features](#compilerfeatures)。 ### detect.has_flags 判断指定参数选项是否支持。 此接口跟 [compiler.has_flags](#compilerhas_flags) 类似，但是更加原始，传入的参数是实际的工具名 toolname。 ```lua import(\"lib.detect.has_flags\") local ok has_flags(\"clang\", \" g\") local ok has_flags(\"clang\", {\" g\", \" O0\"}, {program \"xcrun sdk macosx clang\"}) local ok has_flags(\"clang\", \" g O0\", {toolkind \"cxx\"}) ``` 如果检测通过，则返回 true。 此接口的检测做了一些优化，除了 cache 机制外，大部分场合下，会去拉取工具的选项列表（` help`）直接判断，如果选项列表里获取不到的话，才会通过尝试运行的方式来检测。 ### detect.has_cfuncs 判断指定 c 函数是否存在。 此接口是 [lib.detect.check_cxsnippets](#detectcheck_cxsnippets) 的简化版本，仅用于检测函数。 ```lua import(\"lib.detect.has_cfuncs\") local ok has_cfuncs(\"setjmp\") local ok has_cfuncs({\"sigsetjmp((void*)0, 0)\", \"setjmp\"}, {includes \"setjmp.h\"}) ``` 对于函数的描述规则如下： 函数描述 说明 `sigsetjmp` 纯函数名 `sigsetjmp((void*)0, 0)` 函数调用 `sigsetjmp{int a 0; sigsetjmp((void*)a, a);}` 函数名 + {} 块 在最后的可选参数中，除了可以指定 `includes` 外，还可以指定其他的一些参数用于控制编译检测的选项条件： ```lua {verbose false, target [targetoption], includes .., configs {linkdirs .., links .., defines ..}} ``` 其中 verbose 用于回显检测信息，target 用于在检测前追加 target 中的配置信息, 而 config 用于自定义配置跟 target 相关的编译选项。 ### detect.has_cxxfuncs 判断指定 c++ 函数是否存在。 此接口跟 [lib.detect.has_cfuncs](#detecthas_cfuncs) 类似，请直接参考它的使用说明，唯一区别是这个接口用于检测 c++ 函数。 ### detect.has_cincludes 判断指定 c 头文件是否存在。 此接口是 [lib.detect.check_cxsnippets](#detectcheck_cxsnippets) 的简化版本，仅用于检测头文件。 ```lua import(\"lib.detect.has_cincludes\") local ok has_cincludes(\"stdio.h\") local ok has_cincludes({\"stdio.h\", \"stdlib.h\"}, {target target}) local ok has_cincludes({\"stdio.h\", \"stdlib.h\"}, {configs {defines \"_GNU_SOURCE 1\", languages \"cxx11\"}}) ``` ### detect.has_cxxincludes 判断指定 c++ 头文件是否存在。 此接口跟 [lib.detect.has_cincludess](#detecthas_cincludes) 类似，请直接参考它的使用说明，唯一区别是这个接口用于检测 c++ 头文件。 ### detect.has_ctypes 判断指定 c 类型是否存在。 此接口是 [lib.detect.check_cxsnippets](#detectcheck_cxsnippets) 的简化版本，仅用于检测函数。 ```lua import(\"lib.detect.has_ctypes\") local ok has_ctypes(\"wchar_t\") local ok has_ctypes({\"char\", \"wchar_t\"}, {includes \"stdio.h\"}) local ok has_ctypes(\"wchar_t\", {includes {\"stdio.h\", \"stdlib.h\"}, configs {\"defines \"_GNU_SOURCE 1\", languages \"cxx11\"}}) ``` ### detect.has_cxxtypes 判断指定 c++ 类型是否存在。 此接口跟 [lib.detect.has_ctypess](#detecthas_ctypes) 类似，请直接参考它的使用说明，唯一区别是这个接口用于检测 c++ 类型。 ### detect.check_cxsnippets 检测 c/c++ 代码片段是否能够编译通过。 通用的 c/c++ 代码片段检测接口，通过传入多个代码片段列表，它会自动生成一个编译文件，然后常识对它进行编译，如果编译通过返回 true。 对于一些复杂的编译器特性，连 [compiler.has_features](#compilerhas_features) 都无法检测到的时候，可以通过此接口通过尝试编译来检测它。 ```lua import(\"lib.detect.check_cxsnippets\") local ok check_cxsnippets(\"void test() {}\") local ok check_cxsnippets({\"void test(){}\", \"#define TEST 1\"}, {types \"wchar_t\", includes \"stdio.h\"}) ``` 此接口是 [detect.has_cfuncs](#detecthas_cfuncs), [detect.has_cincludes](#detecthas_cincludes) 和[detect.has_ctypes](detect has_ctypes)等接口的通用版本，也更加底层。 因此我们可以用它来检测：types, functions, includes 还有 links，或者是组合起来一起检测。 第一个参数为代码片段列表，一般用于一些自定义特性的检测，如果为空，则可以仅仅检测可选参数中条件，例如： ```lua local ok check_cxsnippets({}, {types {\"wchar_t\", \"char*\"}, includes \"stdio.h\", funcs {\"sigsetjmp\", \"sigsetjmp((void*)0, 0)\"}}) ``` 上面那个调用，会去同时检测 types, includes 和 funcs 是否都满足，如果通过返回 true。 还有其他一些可选参数： ```lua {verbose false, target [targetoption], sourcekind \"[cccxx]\"} ``` 其中 verbose 用于回显检测信息，target 用于在检测前追加 target 中的配置信息, sourcekind 用于指定编译器等工具类型，例如传入 `cxx` 强制作为 c++ 代码来检测。 ## net.http 此模块提供 http 的各种操作支持，目前提供的接口如下： ### http.download 下载 http 文件。 这个接口比较简单，就是单纯的下载文件。 ```lua import(\"net.http\") http.download(\"https://xmake.io\", \"/tmp/index.html\") ``` ## privilege.sudo 此接口用于通过 `sudo` 来运行命令，并且提供了平台一致性处理，对于一些需要 root 权限运行的脚本，可以使用此接口。 > 为了保证安全性，除非必须使用的场合，其他情况下尽量不要使用此接口。 ### sudo.has 判断 sudo 是否支持。 目前仅在 `macosx/linux` 下支持 sudo，windows 上的管理员权限运行暂时还不支持，因此建议使用前可以通过此接口判断支持情况后，针对性处理。 ```lua import(\"privilege.sudo\") if sudo.has() then sudo.run(\"rm /system/file\") end ``` ### sudo.run 安静运行原生 shell 命令。 具体用法可参考：[os.run](#os run)。 ```lua import(\"privilege.sudo\") sudo.run(\"rm /system/file\") ``` ### sudo.runv 安静运行原生 shell 命令，带参数列表。 具体用法可参考：[os.runv](#os runv)。 ### sudo.exec 回显运行原生 shell 命令。 具体用法可参考：[os.exec](#os exec)。 ### sudo.execv 回显运行原生 shell 命令，带参数列表。 具体用法可参考：[os.execv](#os execv)。 ### sudo.iorun 安静运行原生 shell 命令并获取输出内容。 具体用法可参考：[os.iorun](#os iorun)。 ### sudo.iorunv 安静运行原生 shell 命令并获取输出内容，带参数列表。 具体用法可参考：[os.iorunv](#os iorunv)。 ## devel.git 此接口提供了 git 各种命令的访问接口，相对于直接调用 git 命令，此模块提供了更加上层易用的封装接口，并且提供对 git 的自动检测和跨平台处理。 ### git.clone clone 代码库。 此接口对应 `git clone` 命令 ```lua import(\"devel.git\") git.clone(\"git@github.com:tboox/xmake.git\") git.clone(\"git@github.com:tboox/xmake.git\", {depth 1, branch \"master\", outputdir \"/tmp/xmake\"}) ``` ### git.pull 拉取代码库最新提交。 此接口对应 `git pull` 命令 ```lua import(\"devel.git\") git.pull() git.pull({remote \"origin\", tags true, branch \"master\", repodir \"/tmp/xmake\"}) ``` ### git.clean 清理代码库文件。 此接口对应 `git clean` 命令 ```lua import(\"devel.git\") git.clean() git.clean({repodir \"/tmp/xmake\", force true}) ``` ### git.checkout 签出指定分支版本。 此接口对应 `git checkout` 命令 ```lua import(\"devel.git\") git.checkout(\"master\", {repodir \"/tmp/xmake\"}) git.checkout(\"v1.0.1\", {repodir \"/tmp/xmake\"}) ``` ### git.refs 获取所有引用列表。 此接口对应 `git ls remote refs` 命令 ```lua import(\"devel.git\") local refs git.refs(url) ``` ### git.tags 获取所有标记列表。 此接口对应 `git ls remote tags` 命令 ```lua import(\"devel.git\") local tags git.tags(url) ``` ### git.branches 获取所有分支列表。 此接口对应 `git ls remote heads` 命令 ```lua import(\"devel.git\") local branches git.branches(url) ``` ## utils.archive 此模块用于压缩和解压文件。支持大部分常用压缩格式的解压缩，它会自动检测系统提供了哪些压缩工具，然后会使用最合适的压缩工具进行操作。 ### archive.archive 压缩文件 ```lua import(\"utils.archive\") archive.archive(\"/tmp/a.zip\", \"/tmp/outputdir\") archive.archive(\"/tmp/a.7z\", \"/tmp/outputdir\") archive.archive(\"/tmp/a.gzip\", \"/tmp/outputdir\") archive.archive(\"/tmp/a.tar.bz2\", \"/tmp/outputdir\") ``` 还可以添加一些配置选项，如递归目录，压缩质量，排除文件等。 ```lua import(\"utils.archive\") local options {} options.curdir \"/tmp\" options.recurse true options.compress \"fastestfasterdefaultbetterbest\" options.excludes {\"*/dir/*\", \"dir/*\"} archive.archive(\"/tmp/a.zip\", \"/tmp/outputdir\", options) ``` ### archive.extract 解压文件。 ```lua import(\"utils.archive\") archive.extract(\"/tmp/a.zip\", \"/tmp/outputdir\") archive.extract(\"/tmp/a.7z\", \"/tmp/outputdir\") archive.extract(\"/tmp/a.gzip\", \"/tmp/outputdir\") archive.extract(\"/tmp/a.tar.bz2\", \"/tmp/outputdir\") ``` ## utils.platform 此模块用于一些平台相关的辅助操作接口 ## cli ### cli.amalgamate 合并成单源码文件。 这是一个小工具模块，主要用于快速合并指定 target 里面的所有 c/c++ 和 头文件源码到单个源文件。 合并会将内部 includes 头文件全部展开，并生成 DAG，通过拓扑排序引入。 默认它会处理所有 target 的合并，例如： ```bash $ xmake l cli.amalgamate build/tbox.c generated! build/tbox.h generated! ``` 我们也可以指定合并需要的目标： ```bash $ xmake l cli.amalgamate tbox build/tbox.c generated! build/tbox.h generated! ``` 也可以在合并每个源文件时候，指定一个自定义的 unique ID 的宏定义，来处理符号冲突问题。 ```bash $ xmake l cli.amalgamate u MY_UNIQUEU_ID build/tbox.c generated! build/tbox.h generated! ``` 如果多个源文件内部有重名符号，就可以判断这个 `MY_UNIQUEU_ID` 宏是否被定义，如果定义了，说明是在单文件中，就自己在源码中处理下重名符号。 ```c #ifdef MY_UNIQUEU_ID // do some thing #endif ``` 我们也可以指定输出位置： ```bash $ xmake l cli.amalgamate o /xxx /xxx/tbox.c generated! /xxx/tbox.h generated! ```"},"/get_started/zh/module/native-modules.html":{"title":"","content":" class: heading_no_counter # Lua 原生模块 构建流程里可以使用原生模块。 我们知道，在 xmake 中，可以通过 import 接口去导入一些 lua 模块在脚本域中使用，但是如果一些模块的操作比较耗时，那么 lua 实现并不是理想的选择。 因此，新版本中，我们新增了 native lua 模块的支持，可以通过 native 实现，来达到提速优化的效果，并且模块导入和使用，还是跟 lua 模块一样简单。 使用原生模块时，xmake 会进行两段编译，先会自动编译原生模块，后将模块导入 lua 作为库或二进制，而对于用户，仅仅只需要调用 import 导入即可。 ## 定义动态库模块 动态库模块的好处是，不仅仅通过 native 实现了性能加速，另外避免了每次调用额外的子进程创建，因此更加的轻量，速度进一步得到提升。 我们可以先定义一个动态库模块，里面完全支持 lua 的所有 c API，因此我们也可以将一些第三方的开源 lua native 模块直接引入进来使用。 这里我们也有一个完整的导入 lua cjson 模块的例子可以参考：[native_module_cjson](https://github.com/xmake io/xmake/tree/master/tests/projects/other/native_module_cjson) 首先，我们先实现 shared 的 native 代码，所以接口通过 lua API 导出。 ```c++ // ./modules/foo/foo.c #include <xmi.h> static int c_add(lua_State* lua) { int a lua_tointeger(lua, 1); int b lua_tointeger(lua, 2); lua_pushinteger(lua, a + b); return 1; } static int c_sub(lua_State* lua) { int a lua_tointeger(lua, 1); int b lua_tointeger(lua, 2); lua_pushinteger(lua, a b); return 1; } int luaopen(foo, lua_State* lua) { // 收集 add 和 sub static const luaL_Reg funcs[] { {\"add\", c_add}, {\"sub\", c_sub}, {NULL, NULL} }; lua_newtable(lua); // 传递函数列表 luaL_setfuncs(lua, funcs, 0); return 1; } ``` 注意到这里，我们 include 了一个 `xmi.h` 的接口头文件，其实我们也可以直接引入 `lua.h`，`luaconf.h`，效果是一样的，但是会提供更好的跨平台性，内部会自动处理 lua/luajit 还有版本间的差异。 然后，我们配置 `add_rules(\"modules.shared\")` 作为 shared native 模块来编译，不需要引入任何其他依赖。 甚至连 lua 的依赖也不需要引入，因为 xmake 主程序已经对其导出了所有的 lua 接口，可直接使用，所以整个模块是非常轻量的。 ```lua ./modules/foo/xmake.lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\") 指定目标为库 lua 模块 add_rules(\"module.shared\") add_files(\"foo.c\") ``` ## 定义二进制模块 出了动态库模块，我们还提供了另外一种二进制模块的导入。它其实就是一个可执行文件，每次调用模块接口，都会去调用一次子进程。 那它有什么好处呢，尽管它没有动态库模块那么高效，但是它的模块实现更加的简单，不需要调用 lua API，仅仅只需要处理参数数据，通过 stdout 去输出返回值即可。 另外，相比二进制分发，它是通过源码分发的，因此也解决了跨平台的问题。 具体是使用动态库模块，还是二进制模块，具体看自己的需求，如果想要实现简单，可以考虑二进制模块，如果想要高效，就用动态库模块。 另外，如果需要通过并行执行来提速，也可以使用二进制模块。 ```c++ // ./modules/bar/bar.cpp #include <stdio.h> #include <stdlib.h> #include <cstdlib> int main(int argc, char** argv) { int a atoi(argv[1]); int b atoi(argv[2]); printf(\"%d\", a + b); return 0; } ``` ```lua ./modules/bar/xmake.lua add_rules(\"mode.debug\", \"mode.release\") target(\"add\") 指定目标为二进制 lua 模块 add_rules(\"module.binary\") add_files(\"bar.cpp\") ``` ## 导入原生模块 对于模块导入，我们仅仅需要调用 import，跟导入 lua 模块的用法完全一致。 ```lua ./xmake.lua add_rules(\"mode.debug\", \"mode.release\") 添加./modules 目录内原生模块 add_moduledirs(\"modules\") target(\"test\") set_kind(\"phony\") on_load(function(target) import(\"foo\", {always_build true}) import(\"bar\") print(\"foo: 1 + 1 %s\", foo.add(1, 1)) print(\"foo: 1 1 %s\", foo.sub(1, 1)) print(\"bar: 1 + 1 %s\", bar.add(1, 1)) end) ``` 由于插件模块的构建是跟主工程完全独立的，因此，native 模块只会被构建一次，如果想要触发增量的插件编译，需要配置上 `always_build true`，这样，xmake 就会每次检测插件代码是否有改动，如果有改动，会自动增量构建插件。 首次执行效果如下： ```bash $ xmake [50%]: cache compiling.release src/foo.c [50%]: cache compiling.release src/bar.c [75%]: linking.release libmodule_foo.dylib [75%]: linking.release module_bar [100%]: build ok, spent 1.296s foo: 1 + 1 2 foo: 1 1 0 bar: 1 + 1 2 [100%]: build ok, spent 0.447s ``` 第二次执行，就不会再构建插件，可以直接使用模块： ```bash $ xmake foo: 1 + 1 2 foo: 1 1 0 bar: 1 + 1 2 [100%]: build ok, spent 0.447s ``` ## 作为 codegen 来使用 通过新的 native 模块特性，我们也可以用来实现 auto codegen，然后根据自动生成的代码，继续执行后续编译流程。 这里也有完整的例子可以参考：[autogen_shared_module](https://github.com/xmake io/xmake/tree/master/tests/projects/other/autogen_shared_module)。"},"/get_started/zh/module/builtin-modules.html":{"title":"","content":" class: heading_no_counter # 内置模块 在自定义脚本、插件脚本、任务脚本、平台扩展、模板扩展等脚本代码中使用，也就是在类似下面的代码块中，可以使用这些模块接口： ```lua on_run(function (target) print(\"hello xmake!\") end) ``` > 为了保证外层的描述域尽可能简洁、安全，一般不建议在这个域使用接口和模块操作 api，因此大部分模块接口只能脚本域使用，来实现复杂功能。 当然少部分只读的内置接口还是可以在描述域使用的，具体见下表： > TODO。 在描述域使用接口调用的实例如下，一般仅用于条件控制： ```lua 扫描当前 xmake.lua 目录下的所有子目录，以每个目录的名字定义一个 task 任务 for _, taskname in ipairs(os.dirs(\"*\"), path.basename) do task(taskname, function() on_run(function () end) end) end ``` 上面所说的脚本域、描述域主要是指： ```lua 描述域 target(\"test\", function() 描述域 set_kind(\"static\") add_files(\"src/*.c\") on_run(function (target) 脚本域 end) end) 描述域 ``` ## import ### 导入扩展摸块 import 的主要用于导入 xmake 的扩展类库以及一些自定义的类库模块，一般用于： * 自定义脚本 ([on_build](/zh cn/manual/project_target?id targeton_build), [on_run](/zh cn/manual/project_target?id targeton_run) ..) * 插件开发 * 模板开发 * 平台扩展 * 自定义任务 task 导入机制如下： 1. 优先从当前脚本目录下导入 2. 再从扩展类库中导入 导入的语法规则： 基于 `.` 的类库路径规则，例如： ```lua import(\"core.base.option\") import(\"core.base.task\") function main() 获取参数选项 print(option.get(\"version\")) 运行任务和插件 task.run(\"hello\") end ``` 导入当前目录下的自定义模块： 目录结构： ``` plugin xmake.lua main.lua modules hello1.lua hello2.lua ``` 在 main.lua 中导入 modules ```lua import(\"modules.hello1\") import(\"modules.hello2\") ``` 导入后就可以直接使用里面的所有公有接口，私有接口用 `_` 前缀标示，表明不会被导出，不会被外部调用到。 除了当前目录，我们还可以导入其他指定目录里面的类库，例如： ```lua import(\"hello3\", {rootdir \"/home/xxx/modules\"}) ``` 为了防止命名冲突，导入后还可以指定的别名： ```lua import(\"core.platform.platform\", {alias \"p\"}) function main() 这样我们就可以使用 p 来调用 platform 模块的 plats 接口，获取所有 xmake 支持的平台列表了 utils.dump(p.plats()) end ``` import 不仅可以导入类库，还支持导入的同时作为继承导入，实现模块间的继承关系 ```lua import(\"xxx.xxx\", {inherit true}) ``` 这样导入的不是这个模块的引用，而是导入的这个模块的所有公有接口本身，这样就会跟当前模块的接口进行合并，实现模块间的继承。 另外还支持两个新属性：`import(\"xxx.xxx\", {try true, anonymous true})` * try 为 true，则导入的模块不存在的话，仅仅返回 nil，并不会抛异常后中断 xmake * anonymous 为 true，则导入的模块不会引入当前作用域，仅仅在 import 接口返回导入的对象引用 ### 自定义扩展模块 通过 import 我们除了可以导入 xmake 内置的很多扩展模块，还可以导入用户自己定义的扩展模块。 只需要将自己的模块放到工程目录下，按照上文介绍的导入方式进行导入即可。 那么，如果去定义模块呢？xmake 对模块的编写规范是有一套约定规则的，并没有沿用 lua 原生的 require 导入机制，并不需要在模块中使用 return 来全局返回它。 假如我们有一个模块文件 foo.lua，它的内容如下： ```lua function _foo(a, b) return a + b end function add(a, b) _foo(a, b) end function main(a, b) add(a, b) end ``` 其中 main 为入口函数，可选，如果设置，模块 foo 可以直接被调用，例如： ```lua import(\"foo\") foo(1, 2) ``` 或者直接这样： ```lua import(\"foo\")(1, 2) ``` 其他不带下划线的为 public 模块接口函数，例如 add。 ```lua import(\"foo\") foo.add(1, 2) ``` 而里面带下划线前缀的 `_foo` 是私有函数，模块内部使用，不对外导出，所以在外面用户是不能够调用它的。 ## inherit 导入并继承基类模块。 这个等价于 [import](#import) 接口的 `inherit` 模式，也就是： ```lua import(\"xxx.xxx\", {inherit true}) ``` 用 `inherit` 接口的话，会更简洁些： ```lu inherit(\"xxx.xxx\") ``` 使用实例，可以参看 xmake 的 tools 目录下的脚本：[clang.lua](#https://github.com/xmake io/xmake/blob/master/xmake/tools/clang.lua) 这个就是 clang 工具模块继承了 gcc 的部分实现。 ## try catch finally 异常捕获。 lua 原生并没有提供 try catch 的语法来捕获异常处理，但是提供了 `pcall/xpcall` 等接口，可在保护模式下执行 lua 函数。 因此，可以通过封装这两个接口，来实现 try catch 块的捕获机制。 我们可以先来看下，封装后的 try catch 使用方式： ```lua try { try 代码块 function () error(\"error message\") end, catch 代码块 catch { 发生异常后，被执行 function (errors) print(errors) end } } ``` 上面的代码中，在 try 块内部认为引发了一个异常，并且抛出错误消息，在 catch 中进行了捕获，并且将错误消息进行输出显示。 而 finally 的处理，这个的作用是对于 `try{}` 代码块，不管是否执行成功，都会执行到 finally 块中 也就说，其实上面的实现，完整的支持语法是：`try catch finally` 模式，其中 catch 和 finally 都是可选的，根据自己的实际需求提供 例如： ```lua try { try 代码块 function () error(\"error message\") end, catch 代码块 catch { 发生异常后，被执行 function (errors) print(errors) end }, finally 代码块 finally { 最后都会执行到这里 function (ok, errors) 如果 try{} 中存在异常，ok 为 true，errors 为错误信息，否则为 false，errors 为 try 中的返回值 end } } ``` 或者只有 finally 块： ```lua try { try 代码块 function () return \"info\" end, finally 代码块 finally { 由于此 try 代码没发生异常，因此 ok 为 true，errors 为返回值: \"info\" function (ok, errors) end } } ``` 处理可以在 finally 中获取 try 里面的正常返回值，其实在仅有 try 的情况下，也是可以获取返回值的： ```lua 如果没发生异常，result 为返回值：\"xxxx\"，否则为 nil local result try { function () return \"xxxx\" end } ``` 在 xmake 的自定义脚本、插件开发中，也是完全基于此异常捕获机制。 这样使得扩展脚本的开发非常的精简可读，省去了繁琐的 `if err ~ nil then` 返回值判断，在发生错误时，xmake 会直接抛出异常进行中断，然后高亮提示详细的错误信息。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") 在编译完 ios 程序后，对目标程序进行 ldid 签名 after_build(function (target)) os.run(\"ldid S %s\", target:targetfile()) end end) ``` 只需要一行 `os.run` 就行了，也不需要返回值判断是否运行成功，因为运行失败后，xmake 会自动抛异常，中断程序并且提示错误。 如果你想在运行失败后，不直接中断 xmake，继续往下运行，可以自己加个 try 快就行了： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") after_build(function (target)) try { function () os.run(\"ldid S %s\", target:targetfile()) end } end end) ``` 如果还想捕获出错信息，可以再加个 catch: ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") after_build(function (target)) try { function () os.run(\"ldid S %s\", target:targetfile()) end, catch { function (errors) print(errors) end } } end end) ``` 不过一般情况下，在 xmake 中写自定义脚本，是不需要手动加 try catch 的，直接调用各种 api，出错后让 xmake 默认的处理程序接管，直接中断就行了。 ## pairs 用于遍历字典。 这个是 lua 原生的内置 api，在 xmake 中，在原有的行为上对其进行了一些扩展，来简化一些日常的 lua 遍历代码。 先看下默认的原生写法： ```lua local t {a \"a\", b \"b\", c \"c\", d \"d\", e \"e\", f \"f\"} for key, val in pairs(t) do print(\"%s: %s\", key, val) end ``` 这对于通常的遍历操作就足够了，但是如果我们相对其中每个遍历出来的元素，获取其大写，我们可以这么写： ```lua for key, val in pairs(t, function (v) return v:upper() end) do print(\"%s: %s\", key, val) end ``` 甚至传入一些参数到第二个 `function` 中，例如： ```lua for key, val in pairs(t, function (v, a, b) return v:upper() .. a .. b end, \"a\", \"b\") do print(\"%s: %s\", key, val) end ``` ## ipairs 用于遍历数组。 这个是 lua 原生的内置 api，在 xmake 中，在原有的行为上对其进行了一些扩展，来简化一些日常的 lua 遍历代码。 先看下默认的原生写法： ```lua for idx, val in ipairs({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}) do print(\"%d %s\", idx, val) end ``` 扩展写法类似 [pairs](#pairs) 接口，例如： ```lua for idx, val in ipairs({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}, function (v) return v:upper() end) do print(\"%d %s\", idx, val) end for idx, val in ipairs({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}, function (v, a, b) return v:upper() .. a .. b end, \"a\", \"b\") do print(\"%d %s\", idx, val) end ``` 这样可以简化 `for` 块代码的逻辑，例如我要遍历指定目录，获取其中的文件名，但不包括路径，就可以通过这种扩展方式，简化写法： ```lua for _, filename in ipairs(os.dirs(\"*\"), path.filename) do ... end ``` ## print 换行打印终端日志。 此接口也是 lua 的原生接口，xmake 在原有行为不变的基础上也进行了扩展，同时支持：格式化输出、多变量输出。 先看下原生支持的方式： ```lua print(\"hello xmake!\") print(\"hello\", \"xmake!\", 123) ``` 并且同时还支持扩展的格式化写法： ```lua print(\"hello %s!\", \"xmake\") print(\"hello xmake! %d\", 123) ``` xmake 会同时支持这两种写法，内部会去自动智能检测，选择输出行为。 ## printf 无换行打印终端日志。 类似 [print](#print) 接口，唯一的区别就是不换行。 ## cprint 换行彩色打印终端日志。 行为类似 [print](#print)，区别就是此接口还支持彩色终端输出，并且支持 `emoji` 字符输出。 例如： ```lua cprint('${bright}hello xmake') cprint('${red}hello xmake') cprint('${bright green}hello ${clear}xmake') cprint('${blue onyellow underline}hello xmake${clear}') cprint('${red}hello ${magenta}xmake') cprint('${cyan}hello ${dim yellow}xmake') ``` 显示结果如下： ![cprint_colors](https://tboox.org/static/img/xmake/cprint_colors.png) 跟颜色相关的描述，都放置在 `${ }` 里面，可以同时设置多个不同的属性，例如： ``` ${bright red underline onyellow} ``` 表示：高亮红色，背景黄色，并且带下滑线 所有这些描述，都会影响后面一整行字符，如果只想显示部分颜色的文字，可以在结束位置，插入 `${clear}` 清楚前面颜色描述 例如： ``` ${red}hello ${clear}xmake ``` 这样的话，仅仅 hello 是显示红色，其他还是正常默认黑色显示。 其他颜色属于，我这里就不一一介绍，直接贴上 xmake 代码里面的属性列表吧： ```lua colors.keys { 属性 reset 0 重置属性 , clear 0 清楚属性 , default 0 默认属性 , bright 1 高亮 , dim 2 暗色 , underline 4 下划线 , blink 5 闪烁 , reverse 7 反转颜色 , hidden 8 隐藏文字 前景色 , black 30 , red 31 , green 32 , yellow 33 , blue 34 , magenta 35 , cyan 36 , white 37 背景色 , onblack 40 , onred 41 , ongreen 42 , onyellow 43 , onblue 44 , onmagenta 45 , oncyan 46 , onwhite 47 } ``` 除了可以色彩高亮显示外，如果你的终端是在 macosx 下，lion 以上的系统，xmake 还可以支持 emoji 表情的显示哦，对于不支持系统，会忽略显示，例如： ```lua cprint(\"hello xmake${beer}\") cprint(\"hello${ok_hand} xmake\") ``` 上面两行代码，我打印了一个 homebrew 里面经典的啤酒符号，下面那行打印了一个 ok 的手势符号： ![cprint_emoji](https://tboox.org/static/img/xmake/cprint_emoji.png) 所有的 emoji 表情，以及 xmake 里面对应的 key，都可以通过 [emoji 符号](http://www.emoji cheat sheet.com/) 里面找到。 同时支持 24 位真彩色输出，如果终端支持的话： ```lua import(\"core.base.colors\") if colors.truecolor() then cprint(\"${255;0;0}hello\") cprint(\"${on;255;0;0}hello${clear} xmake\") cprint(\"${bright 255;0;0 underline}hello\") cprint(\"${bright on;255;0;0 0;255;0}hello${clear} xmake\") end ``` xmake 对于 truecolor 的检测支持，是通过 `$COLORTERM` 环境变量来实现的，如果你的终端支持 truecolor，可以手动设置此环境变量，来告诉 xmake 启用 truecolor 支持。 可以通过下面的命令来启用和测试： ```bash $ export COLORTERM truecolor $ xmake version ``` 可通过 `COLORTERM nocolor` 来禁用色彩输出。 ## cprintf 无换行彩色打印终端日志。 此接口类似 [cprint](#cprint)，区别就是不换行输出。 ## format 格式化字符串。 如果只是想格式化字符串，不进行输出，可以使用这个接口，此接口跟 [string.format](#stringformat) 接口等价，只是个接口名简化版。 ```lua local s format(\"hello %s\", xmake) ``` ## vformat 格式化字符串，支持内置变量转义。 此接口跟 [format](#format) 接口类似，只是增加对内置变量的获取和转义支持。 ```lua local s vformat(\"hello %s $(mode) $(arch) $(env PATH)\", xmake) ``` ## raise 抛出异常中断程序。 如果想在自定义脚本、插件任务中中断 xmake 运行，可以使用这个接口抛出异常，如果上层没有显示调用 [try catch](#try catch finally) 捕获的话，xmake 就会中断执行，并且显示出错信息。 ```lua if (errors) raise(errors) ``` 如果在 try 块中抛出异常，就会在 catch 和 finally 中进行 errors 信息捕获，具体见：[try catch](#try catch finally) ## os 系统操作模块，属于内置模块，无需使用 [import](#import) 导入，可直接脚本域调用其接口。 此模块也是 lua 的原生模块，xmake 在其基础上进行了扩展，提供更多实用的接口。 > os 模块里面只有部分 readonly 接口（例如：`os.getenv`, `os.arch`）是可以在描述域中使用，其他接口只能在脚本域中使用，例如：`os.cp`, `os.rm` 等 接口 描述 支持版本 [os.cp](#oscp) 复制文件或目录 > 2.0.1 [os.mv](#osmv) 移动重命名文件或目录 > 2.0.1 [os.rm](#osrm) 删除文件或目录树 > 2.0.1 [os.trycp](#ostrycp) 尝试复制文件或目录 > 2.1.6 [os.trymv](#ostrymv) 尝试移动重命名文件或目录 > 2.1.6 [os.tryrm](#ostryrm) 尝试删除文件或目录树 > 2.1.6 [os.cd](#oscd) 进入指定目录 > 2.0.1 [os.rmdir](#osrmdir) 删除目录树 > 2.0.1 [os.mkdir](#osmkdir) 创建指定目录 > 2.0.1 [os.isdir](#osisdir) 判断目录是否存在 > 2.0.1 [os.isfile](#osisfile) 判断文件是否存在 > 2.0.1 [os.exists](#osexists) 判断文件或目录是否存在 > 2.0.1 [os.dirs](#osdirs) 遍历获取指定目录下的所有目录 > 2.0.1 [os.files](#osfiles) 遍历获取指定目录下的所有文件 > 2.0.1 [os.filedirs](#osfiledirs) 遍历获取指定目录下的所有文件或目录 > 2.0.1 [os.run](#osrun) 安静运行程序 > 2.0.1 [os.runv](#osrunv) 安静运行程序，带参数列表 > 2.1.5 [os.exec](#osexec) 回显运行程序 > 2.0.1 [os.execv](#osexecv) 回显运行程序，带参数列表 > 2.1.5 [os.iorun](#osiorun) 运行并获取程序输出内容 > 2.0.1 [os.iorunv](#osiorunv) 运行并获取程序输出内容，带参数列表 > 2.1.5 [os.getenv](#osgetenv) 获取环境变量 > 2.0.1 [os.setenv](#ossetenv) 设置环境变量 > 2.0.1 [os.tmpdir](#ostmpdir) 获取临时目录路径 > 2.0.1 [os.tmpfile](#ostmpfile) 获取临时文件路径 > 2.0.1 [os.curdir](#oscurdir) 获取当前目录路径 > 2.0.1 [os.filesize](#osfilesize) 获取文件大小 > 2.1.9 [os.scriptdir](#osscriptdir) 获取脚本目录路径 > 2.0.1 [os.programdir](#osprogramdir) 获取 xmake 安装主程序脚本目录 > 2.1.5 [os.programfile](#osprogramfile) 获取 xmake 可执行文件路径 > 2.1.5 [os.projectdir](#osprojectdir) 获取工程主目录 > 2.1.5 [os.arch](#osarch) 获取当前系统架构 > 2.0.1 [os.host](#oshost) 获取当前主机系统 > 2.0.1 [os.subhost](#ossubhost) 获取子系统 > 2.3.1 [os.subarch](#ossubarch) 获取子系统架构 > 2.3.1 [os.is_host](#osis_host) 判断给定系统是否正确 > 2.3.1 [os.is_arch](#osis_arch) 判断给定架构是否正确 > 2.3.1 [os.is_subhost](#osis_subhost) 判断给定子系统是否正确 > 2.3.1 [os.is_subarch](#osis_subarch) 判断子系统架构是否正确 > 2.3.1 [os.ln](#osln) 创建指向文件或文件夹的符号链接 > 2.2.2 [os.readlink](#osreadlink) 读取符号链接 > 2.2.2 [os.raise](#osraise) 抛出一个异常并中止脚本运行 > 2.2.8 [os.raiselevel](#osraiselevel) 抛出一个异常并中止脚本运行 > 2.2.8 [os.features](#osfeatures) 获取系统特性 > 2.3.1 [os.getenvs](#osgetenvs) 获取所有环境变量 > 2.2.6 [os.setenvs](#ossetenvs) 替换当前所有环境变量 > 2.2.6 [os.addenvs](#osaddenvs) 向当前环境变量中添加新值 > 2.5.6 [os.joinenvs](#osjoinenvs) 拼接环境变量 > 2.5.6 [os.setenvp](#ossetenvp) 使用给定分隔符设置环境变量 > 2.1.5 [os.addenvp](#osaddenvp) 使用给定分隔符向环境变量添加新值 > 2.1.5 [os.workingdir](#osworkingdir) 获取工作路径 > 2.1.9 [os.isroot](#osisroot) 判断当前 xmake 是否以管理员权限运行 > 2.1.9 [os.fscase](#osfscase) 判断当前系统的文件系统是否大小写敏感 > 2.1.9 [os.term](#osterm) 获取当前终端 > 2.7.3 [os.shell](#osshell) 获取当前 shell > 2.7.3 [os.cpuinfo](#oscpuinfo) 获取 CPU 信息 > 2.1.5 [os.meminfo](#osmeminfo) 获取内存信息 > 2.1.5 [os.default_njob](#osdefault_njob) 获取默认编译任务数 > 2.5.8 ### os.cp 复制文件或目录。 行为和 shell 中的 `cp` 命令类似，支持路径通配符匹配（使用的是 lua 模式匹配），支持多文件复制，以及内置变量支持。 例如： ```lua os.cp(\"$(scriptdir)/*.h\", \"$(buildir)/inc\") os.cp(\"$(projectdir)/src/test/**.h\", \"$(buildir)/inc\") ``` 上面的代码将：当前 `xmake.lua` 目录下的所有头文件、工程源码 test 目录下的头文件全部复制到 `$(buildir)` 输出目录中。 其中 `$(scriptdir)`, `$(projectdir)` 这些变量是 xmake 的内置变量，具体详情见：[内置变量](# 内置变量) 的相关文档。 而 `*.h` 和 `**.h` 中的匹配模式，跟 [add_files](#targetadd_files) 中的类似，前者是单级目录匹配，后者是递归多级目录匹配。 此接口同时支持目录的 ` 递归复制 `，例如： ```lua 递归复制当前目录到临时目录 os.cp(\"$(curdir)/test/\", \"$(tmpdir)/test\") ``` 上面的复制，会把所有文件全部展开复制到指定目录，丢失源目录层级，如果要按保持原有的目录结构复制，可以设置 rootdir 参数： ```lua os.cp(\"src/**.h\", \"/tmp/\", {rootdir \"src\"}) ``` 上面的脚本可以按 `src` 根目录，将 src 下的所有子文件保持目录结构复制过去。 > 尽量使用 `os.cp` 接口，而不是 `os.run(\"cp ..\")`，这样更能保证平台一致性，实现跨平台构建描述。 同时提供了 `{symlink true}` 参数，在复制文件时候保留符号链接。 ```lua os.cp(\"/xxx/foo\", \"/xxx/bar\", {symlink true}) ``` 和 Linux 上的 cp 命令不同，xmake 的 cp 接口无法将同名的文件夹复制到目标路径，最终只能保留一个文件夹。例如： 文件路径，A 和 B 有一个同名的文件夹 conf： ```bash . ├── A │ └── conf │ ├── 1 │ │ └── A1.txt │ └── 2 │ └── A2.txt ├── B │ └── conf │ ├── 1 │ │ └── B1.txt │ └── 2 │ └── B2.txt └── test.lua ``` 我们希望将 A 和 B 两个 conf 文件夹的内容都**合并**到 output 目录下： ```lua os.mkdir(\"output/test1\") os.cp(\"A/conf\", \"output/test1\", {rootdir \"A/conf\"}) os.cp(\"B/conf\", \"output/test1\", {rootdir \"B/conf\"}) ``` 合并完后丢失 A 的 conf 信息： ```bash $tree output/ output/ └── test1 ├── 1 │ └── B1.txt └── 2 └── B2.txt ``` 最终我们不得已通过 `bash c` 实现这个功能： ```lua os.mkdir(\"output/test5\") os.vrun(\"bash c 'cp r A/conf/* output/test5'\") os.vrun(\"bash c 'cp r B/conf/* output/test5'\") ``` 相关的讨论可见 xmake 源码的 `example/api/os.cp` 例子。 ### os.mv 移动重命名文件或目录。 跟 [os.cp](#oscp) 的使用类似，同样支持多文件移动操作和模式匹配，例如： ```lua 移动文件到临时目录 os.mv(\"$(buildir)/test1\", \"$(tmpdir)\") 文件移动不支持批量操作，也就是文件重命名 os.mv(\"$(buildir)/libtest.a\", \"$(buildir)/libdemo.a\") ``` ### os.rm 删除文件或目录树。 支持递归删除目录，批量删除操作，以及模式匹配和内置变量，例如： ```lua os.rm(\"$(buildir)/inc/**.h\") os.rm(\"$(buildir)/lib/\") ``` ### os.trycp 尝试复制文件或目录。 跟 [os.cp](#oscp) 类似，唯一的区别就是，此接口操作失败不会抛出异常中断 xmake，而是通过返回值标示是否执行成功。 ```lua if os.trycp(\"file\", \"dest/file\") then end ``` ### os.trymv 尝试移动文件或目录。 跟 [os.mv](#osmv) 类似，唯一的区别就是，此接口操作失败不会抛出异常中断 xmake，而是通过返回值标示是否执行成功。 ```lua if os.trymv(\"file\", \"dest/file\") then end ``` ### os.tryrm 尝试删除文件或目录。 跟 [os.rm](#osrm) 类似，唯一的区别就是，此接口操作失败不会抛出异常中断 xmake，而是通过返回值标示是否执行成功。 ```lua if os.tryrm(\"file\") then end ``` ### os.cd 进入指定目录。 这个操作用于目录切换，同样也支持内置变量，但是不支持模式匹配和多目录处理，例如： ```lua 进入临时目录 os.cd(\"$(tmpdir)\") ``` 如果要离开进入之前的目录，有多种方式： ```lua 进入上级目录 os.cd(\"..\") 进入先前的目录，相当于：cd os.cd(\" \") 进入目录前保存之前的目录，用于之后跨级直接切回 local oldir os.cd(\"./src\") ... os.cd(oldir) ``` ### os.rmdir 仅删除目录。 如果不是目录就无法删除。 ### os.mkdir 创建目录。 支持批量创建和内置变量，例如： ```lua os.mkdir(\"$(tmpdir)/test\", \"$(buildir)/inc\") ``` ### os.isdir 判断是否为目录。 如果目录不存在，则返回 false ```lua if os.isdir(\"src\") then ... end ``` ### os.isfile 判断是否为文件。 如果文件不存在，则返回 false ```lua if os.isfile(\"$(buildir)/libxxx.a\") then ... end ``` ### os.exists 判断文件或目录是否存在。 如果文件或目录不存在，则返回 false ```lua 判断目录存在 if os.exists(\"$(buildir)\") then ... end 判断文件存在 if os.exists(\"$(buildir)/libxxx.a\") then ... end ``` ### os.dirs 遍历获取指定目录下的所有目录。 支持 [add_files](#targetadd_files) 中的模式匹配，支持递归和非递归模式遍历，返回的结果是一个 table 数组，如果获取不到，返回空数组，例如： ```lua 递归遍历获取所有子目录 for _, dir in ipairs(os.dirs(\"$(buildir)/inc/**\")) do print(dir) end ``` ### os.files 遍历获取指定目录下的所有文件。 支持 [add_files](#targetadd_files) 中的模式匹配，支持递归和非递归模式遍历，返回的结果是一个 table 数组，如果获取不到，返回空数组，例如： ```lua 非递归遍历获取所有子文件 for _, filepath in ipairs(os.files(\"$(buildir)/inc/*.h\")) do print(filepath) end ``` ### os.filedirs 遍历获取指定目录下的所有文件和目录。 支持 [add_files](#targetadd_files) 中的模式匹配，支持递归和非递归模式遍历，返回的结果是一个 table 数组，如果获取不到，返回空数组，例如： ```lua 递归遍历获取所有子文件和目录 for _, filedir in ipairs(os.filedirs(\"$(buildir)/**\")) do print(filedir) end ``` ### os.run 安静运行原生 shell 命令。 用于执行第三方的 shell 命令，但不会回显输出，仅仅在出错后，高亮输出错误信息。 此接口支持参数格式化、内置变量，例如： ```lua 格式化参数传入 os.run(\"echo hello %s!\", \"xmake\") 列举构建目录文件 os.run(\"ls l $(buildir)\") ``` > 使用此接口执行 shell 命令，容易使构建跨平台性降低，对于 `os.run(\"cp ..\")` 这种尽量使用 `os.cp` 代替。如果必须使用此接口运行 shell 程序，请自行使用 [config.plat](#config plat) 接口判断平台支持。 ### os.runv 安静运行原生 shell 命令，带参数列表。 跟 [os.run](#osrun) 类似，只是传递参数的方式是通过参数列表传递，而不是字符串命令，例如： ```lua os.runv(\"echo\", {\"hello\", \"xmake!\"}) ``` 另外，此接口也支持 envs 参数设置： ```lua os.runv(\"echo\", {\"hello\", \"xmake!\"}, {envs {PATH \"xxx;xx\", CFLAGS \"xx\"}}) ``` ### os.exec 回显运行原生 shell 命令。 与 [os.run](#osrun) 接口类似，唯一的不同是，此接口执行 shell 程序时，是带回显输出的，一般调试的时候用的比较多 ### os.execv 回显运行原生 shell 命令，带参数列表。 跟 [os.exec](#osexec) 类似，只是传递参数的方式是通过参数列表传递，而不是字符串命令，例如： ```lua os.execv(\"echo\", {\"hello\", \"xmake!\"}) ``` 另外，此接口还支持一个可选的参数，用于传递设置：重定向输出，执行环境变量设置，例如： ```lua os.execv(\"echo\", {\"hello\", \"xmake!\"}, {stdout outfile, stderr errfile, envs {PATH \"xxx;xx\", CFLAGS \"xx\"}} ``` 其中，stdout 和 stderr 参数用于传递重定向输出和错误输出，可以直接传入文件路径，也可以传入 io.open 打开的文件对象。 xmake 还支持设置 stdin 参数，来支持重定向输入文件。 > stdout/stderr/stdin 可以同时支持：文件路径、文件对象、管道对象等三种类型值。 另外，如果想在这次执行中临时设置和改写一些环境变量，可以传递 envs 参数，里面的环境变量设置会替换已有的设置，但是不影响外层的执行环境，只影响当前命令。 我们也可以通过 `os.getenvs()` 接口获取当前所有的环境变量，然后改写部分后传入 envs 参数。 ### os.iorun 安静运行原生 shell 命令并获取输出内容。 与 [os.run](#osrun) 接口类似，唯一的不同是，此接口执行 shell 程序后，会获取 shell 程序的执行结果，相当于重定向输出。 可同时获取 `stdout`, `stderr` 中的内容，例如： ```lua local outdata, errdata os.iorun(\"echo hello xmake!\") ``` 我们也可以利用 `bash c` 来实现管道命令： ```lua local output os.iorun([[bash c \"cat /etc/passwd grep '/bin/bash' wc l tr d '\\n'\"]]) print(\"match lines count: [\" .. output .. \"]\") ``` ### os.iorunv 安静运行原生 shell 命令并获取输出内容，带参数列表。 跟 [os.iorun](#osiorun) 类似，只是传递参数的方式是通过参数列表传递，而不是字符串命令，例如： ```lua local outdata, errdata os.iorunv(\"echo\", {\"hello\", \"xmake!\"}) ``` 另外，此接口也支持 envs 参数设置： ```lua local outdata, errdata os.iorunv(\"echo\", {\"hello\", \"xmake!\"}, {envs {PATH \"xxx;xx\", CFLAGS \"xx\"}} ``` ### os.iorun_with_pipes 安静运行原生 shell 命令并获取输出内容，支持管道。 ```lua 可以运行带管道符的复杂 shell 命令 @see https://github.com/TOMO CAT/xmake/issues/140 官方实现方法比较复杂: https://github.com/xmake io/xmake/discussions/6002 local output os.iorun_with_pipes( \"cat /etc/passwd grep '/bin/bash' wc l tr d '\\n'\") print(\"match lines count: [\" .. output .. \"]\") ``` ### os.getenv 获取系统环境变量。 ```lua print(os.getenv(\"PATH\")) ``` ### os.setenv 设置系统环境变量。 ```lua os.setenv(\"HOME\", \"/tmp/\") ``` ### os.tmpdir 获取临时目录。 跟 [$(tmpdir)](#var tmpdir) 结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。 ```lua print(path.join(os.tmpdir(), \"file.txt\")) ``` 等价于： ```lua print(\"$(tmpdir)/file.txt\") ``` ### os.tmpfile 获取临时文件路径。 用于获取生成一个临时文件路径，仅仅是个路径，文件需要自己创建。 ### os.curdir 获取当前目录路径。 跟 [$(curdir)](#var curdir) 结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。 用法参考：[os.tmpdir](#ostmpdir)。 ### os.filesize 获取文件大小。 ```lua print(os.filesize(\"/tmp/a\")) ``` ### os.scriptdir 获取当前描述脚本的路径。 跟 [$(scriptdir)](#var scriptdir) 结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。 用法参考：[os.tmpdir](#ostmpdir)。 ### os.programdir 获取 xmake 安装主程序脚本目录。 跟 [$(programdir)](#var programdir) 结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。 ### os.programfile 获取 xmake 可执行文件路径。 ### os.projectdir 获取工程主目录。 跟 [$(projectdir)](#var projectdir) 结果一致，只不过是直接获取返回一个变量，可以用后续字符串维护。 ### os.arch 获取当前系统架构。 也就是当前主机系统的默认架构，例如我在 `linux x86_64` 上执行 xmake 进行构建，那么返回值是：`x86_64` ### os.host 获取当前主机的操作系统。 跟 [$(host)](#var host) 结果一致，例如我在 `linux x86_64` 上执行 xmake 进行构建，那么返回值是：`linux` ### os.subhost 获取当前子系统，如：在 Windows 上的 msys、cygwin。 ### os.subarch 获取子系统架构。 ### os.is_host 判断给定系统是否为当前系统。 ### os.is_arch 判断给定架构是否为当前架构。 ### os.is_subhost 判断给定子系统是否为当前子系统。 ### os.is_subarch 判断给定子系统架构是否为当前子系统架构。 ### os.ln 为一个文件或目录创建符号链接。 ```lua 创建一个指向 \"tmp.txt\" 文件的符号链接 \"tmp.txt.ln\" os.ln(\"xxx.txt\", \"xxx.txt.ln\") ``` ### os.readlink 读取符号链接内容。 ### os.raise 抛出一个异常并且中止当前脚本运行。 ```lua 抛出一个带 \"an error occurred\" 信息的异常 os.raise(\"an error occurred\") ``` > 推荐使用与 `os.raise` 等价的内置接口 `raise`，用法与 `os.raise` 一致 ### os.raiselevel 与 [os.raise](#osraise) 类似但是可以指定异常等级。 ```lua 抛出一个带 \"an error occurred\" 信息的异常 os.raise(3, \"an error occurred\") ``` ### os.features 获取系统特性。 ### os.getenvs 获取所有当前系统变量。 ```lua local envs os.getenvs() home directory (on linux) print(envs[\"HOME\"]) ``` ### os.setenvs 使用给定系统变量替换当前所有系统变量，并返回旧系统变量。 ### os.addenvs 向当前系统变量添加新变量，并且返回所有旧系统变量。 ```lua os.setenvs({EXAMPLE \"a/path\"}) add a custom variable to see addenvs impact on it local oldenvs os.addenvs({EXAMPLE \"some/path/\"}) print(os.getenvs()[\"EXAMPLE\"]) got some/path/;a/path print(oldenvs[\"EXAMPLE\"]) got a/path ``` ### os.joinenvs 拼接系统变量，与 [os.addenvs](#osaddenvs) 类似，但是不会对当前环境变量产生影响，若第二个参数为 `nil`，则使用原有环境变量。 ```lua os.joinenvs(envs, oldenvs) @param envs table 类型，新插入的环境变量 @param oldenvs table 类型，被插入的环境变量，若为 nil, 则为原有环境变量 @return table 类型，拼接后的环境变量 local envs0 {CUSTOM \"a/path\"} local envs1 {CUSTOM \"some/path/\"} print(os.joinenvs(envs0, envs1)) result is : { CUSTION \"a/path;some/path/\" } ``` ### os.setenvp 使用给定分隔符设置环境变量。 ### os.workingdir 获取工作目录。 ### os.isroot 判断 xmake 是否以管理员权限运行。 ### os.fscase 判断操作系统的文件系统是否大小写敏感。 ### os.term 获取当前终端 (windows terminal, vscode, xterm, ...)。 ### os.shell 获取当前 shell (pwsh, cmd, bash, zsh, ...)。 ### os.cpuinfo 获取当前 CPU 信息。 ```lua print(os.cpuinfo()) probably got { march \"Alder Lake\", model 154, ncpu 20, model_name \"12th Gen Intel(R) Core(TM) i9 12900H\", usagerate 0.041839182376862, vendor \"GenuineIntel\", family 6 } print(os.cpuinfo(\"march\")) probably got \"Alder Lake\" ``` ### os.meminfo 获取内存信息。 ```lua print(os.meminfo()) probably got { pagesize 4096, usagerate 0.60694103194103, availsize 12798, totalsize 32560 } print(os.meminfo(\"pagesize\")) probably got 4096 ``` ### os.default_njob 获取默认编译任务数。 ## macos macOS 系统操作模块，属于内置模块，无需使用 [import](#import) 导入，可直接脚本域调用其接口。 接口 描述 支持版本 [macos.version](#macosversion) 获取 macOS 系统版本 > 2.3.1 ### macos.version 获取 macOS 系统版本。 返回的版本是 semver 语义版本对象 ```lua if macos.version():ge(\"10.0\") then ... end ``` ## linuxos linux 系统操作模块，属于内置模块，无需使用 [import](#import) 导入，可直接脚本域调用其接口。 接口 描述 支持版本 [linuxos.name](#linuxosname) 获取 linux 系统发行版名称 > 2.5.2 [linuxos.version](#linuxosversion) 获取 linux 系统版本 > 2.5.2 [linuxos.kernelver](#linuxoskernelver) 获取 linux 系统内核版本 > 2.5.2 ### linuxos.name 获取 linux 系统发行版名称。 我们也可以通过下面的命令，快速获取查看 ```bash xmake l linuxos.name ``` 目前支持的一些名称有： * ubuntu * debian * archlinux * manjaro * linuxmint * centos * fedora * opensuse ### linuxos.version 获取 linux 系统版本。 返回的版本是 semver 语义版本对象 ```lua if linux.version():ge(\"10.0\") then ... end ``` ### linuxos.kernelver 获取 linux 系统内核版本。 返回的也是语义版本对象，也可以执行 `xmake l linuxos.kernelver` 快速查看 ## io io 操作模块，扩展了 lua 内置的 io 模块，提供更多易用的接口。 接口 描述 支持版本 [io.open](#ioopen) 打开文件用于读写 > 2.0.1 [io.load](#ioload) 从指定路径文件反序列化加载所有 table 内容 > 2.0.1 [io.save](#iosave) 序列化保存所有 table 内容到指定路径文件 > 2.0.1 [io.readfile](#io.readfile) 从指定路径文件读取所有内容 > 2.1.3 [io.writefile](#io.writefile) 写入所有内容到指定路径文件 > 2.1.3 [io.gsub](#iogsub) 全文替换指定路径文件的内容 > 2.0.1 [io.tail](#iotail) 读取和显示文件的尾部内容 > 2.0.1 [io.cat](#iocat) 读取和显示文件的所有内容 > 2.0.1 [io.print](#ioprint) 带换行格式化输出内容到文件 > 2.0.1 [io.printf](#ioprintf) 无换行格式化输出内容到文件 > 2.0.1 [io.lines](#iolines) 读取文件的所有行 > 2.2.9 [io.stdfile](#iostdfile) 获取标准输入输出文件 > 2.2.9 [io.openlock](#ioopenlock) 创建一把文件锁 > 2.2.9 [io.replace](#ioreplace) 根据表达式替换文件内容 > 2.3.8 ### io.open 打开文件用于读写。 这个是属于 lua 的原生接口，详细使用可以参看 lua 的官方文档：[The Complete I/O Model](https://www.lua.org/pil/21.2.html) 如果要读取文件所有内容，可以这么写： ```lua local file io.open(\"$(tmpdir)/file.txt\", \"r\") if file then local data file:read(\"*all\") file:close() end ``` 或者可以使用 [io.readfile](#io.readfile) 更加快速地读取。 如果要写文件，可以这么操作： ```lua 打开文件：w 为写模式, a 为追加写模式 local file io.open(\"xxx.txt\", \"w\") if file then 用原生的 lua 接口写入数据到文件，不支持格式化，无换行，不支持内置变量 file:write(\"hello xmake\\n\") 用 xmake 扩展的接口写入数据到文件，支持格式化，无换行，不支持内置变量 file:writef(\"hello %s\\n\", \"xmake\") 使用 xmake 扩展的格式化传参写入一行，带换行符，并且支持内置变量 file:print(\"hello %s and $(buildir)\", \"xmake\") 使用 xmake 扩展的格式化传参写入一行，无换行符，并且支持内置变量 file:printf(\"hello %s and $(buildir) \\n\", \"xmake\") 关闭文件 file:close() end ``` ### io.load 从指定路径文件反序列化加载所有 table 内容。 可以从文件中加载序列化好的 table 内容，一般与 [io.save](#iosave) 配合使用，例如： ```lua 加载序列化文件的内容到 table local data io.load(\"xxx.txt\") if data then 在终端中 dump 打印整个 table 中内容，格式化输出 utils.dump(data) end ``` ### io.save 序列化保存所有 table 内容到指定路径文件。 可以序列化存储 table 内容到指定文件，一般与 [io.load](#ioload) 配合使用，例如： ```lua io.save(\"xxx.txt\", {a \"a\", b \"b\", c \"c\"}) ``` 存储结果为： ``` { [\"b\"] \"b\" , [\"a\"] \"a\" , [\"c\"] \"c\" } ``` ### io.readfile 从指定路径文件读取所有内容。 可在不打开文件的情况下，直接读取整个文件的内容，更加的方便，例如： ```lua local data io.readfile(\"xxx.txt\") ``` ### io.writefile 写入所有内容到指定路径文件。 可在不打开文件的情况下，直接写入整个文件的内容，更加的方便，例如： ```lua io.writefile(\"xxx.txt\", \"all data\") ``` ### io.gsub 全文替换指定路径文件的内容。 类似 [string.gsub](#stringgsub) 接口，全文模式匹配替换内容，不过这里是直接操作文件，例如： ```lua 移除文件所有的空白字符 io.gsub(\"xxx.txt\", \"%s+\", \"\") ``` ### io.tail 读取和显示文件的尾部内容。 读取文件尾部指定行数的数据，并显示，类似 `cat xxx.txt tail n 10` 命令，例如： ```lua 显示文件最后 10 行内容 io.tail(\"xxx.txt\", 10) ``` ### io.cat 读取和显示文件的所有内容。 读取文件的所有内容并显示，类似 `cat xxx.txt` 命令，例如： ```lua io.cat(\"xxx.txt\") ``` ### io.print 带换行格式化输出内容到文件。 直接格式化传参输出一行字符串到文件，并且带换行，例如： ```lua io.print(\"xxx.txt\", \"hello %s!\", \"xmake\") ``` ### io.printf 无换行格式化输出内容到文件。 直接格式化传参输出一行字符串到文件，不带换行，例如： ```lua io.printf(\"xxx.txt\", \"hello %s!\\n\", \"xmake\") ``` ### io.lines 读取文件的所有行。 根据文件名返回该文件的所有行的内容 ```lua local lines io.lines(\"xxx.txt\") for line in lines do print(line) end ``` ### io.stdfile 获取标准输入输出文件。 根据文件名返回标准输入输出文件 ```lua 标准输入 io.stdin 标准输出 io.stdout 标准错误 io.stderr ``` ### io.openlock 创建一把文件锁。 为给定的文件返回一个文件锁对象 ```lua local lock io.openlock(\"xxx.txt\") lock:lock() lock:unlock() lock:close() ``` ### io.replace 根据表达式替换文件内容。 根据表达式和参数对文件进行全文替换 ```lua io.replace(filepath, pattern, replace, opt) io.replace(\"xxx.txt\", \"test\", \"xmake\", { plain true, encoding \"UTF 8\"}) io.replace(\"xxx.txt\", \"%d[^\\n]*\", \"xmake\") ``` 关于参数 `opt` 成员的解释： > .plain: 若为 true，使用 pattern 进行简单匹配；为 false，则进行模式匹配； > > .encoding: 指定文件编码格式 ## path 路径操作模块，实现跨平台的路径操作，这是 xmake 的一个自定义的模块。 接口 描述 支持版本 [path.join](#pathjoin) 拼接路径 > 2.0.1 [path.translate](#pathtranslate) 转换路径到当前平台的路径风格 > 2.0.1 [path.basename](#pathbasename) 获取路径最后不带后缀的文件名 > 2.0.1 [path.filename](#pathfilename) 获取路径最后带后缀的文件名 > 2.0.1 [path.extension](#pathextension) 获取路径的后缀名 > 2.0.1 [path.directory](#pathdirectory) 获取路径的目录名 > 2.0.1 [path.relative](#pathrelative) 转换成相对路径 > 2.0.1 [path.absolute](#pathabsolute) 转换成绝对路径 > 2.0.1 [path.is_absolute](#pathis_absolute) 判断是否为绝对路径 > 2.0.1 [path.splitenv](#pathsplitenv) 分割环境变量中的路径 > 2.2.7 ### path.join 拼接路径。 将多个路径项进行追加拼接，由于 `windows/unix` 风格的路径差异，使用 api 来追加路径更加跨平台，例如： ```lua print(path.join(\"$(tmpdir)\", \"dir1\", \"dir2\", \"file.txt\")) ``` 上述拼接在 unix 上相当于：`$(tmpdir)/dir1/dir2/file.txt`，而在 windows 上相当于：`$(tmpdir)\\\\dir1\\\\dir2\\\\file.txt` 如果觉得这样很繁琐，不够清晰简洁，可以使用：[path.translate](path translate) 方式，格式化转换路径字符串到当前平台支持的格式。 ### path.translate 转换路径到当前平台的路径风格。 格式化转化指定路径字符串到当前平台支持的路径风格，同时支持 `windows/unix` 格式的路径字符串参数传入，甚至混合传入，例如： ```lua print(path.translate(\"$(tmpdir)/dir/file.txt\")) print(path.translate(\"$(tmpdir)\\\\dir\\\\file.txt\")) print(path.translate(\"$(tmpdir)\\\\dir/dir2//file.txt\")) ``` 上面这三种不同格式的路径字符串，经过 `translate` 规范化后，就会变成当前平台支持的格式，并且会去掉冗余的路径分隔符。 ### path.basename 获取路径最后不带后缀的文件名。 ```lua print(path.basename(\"$(tmpdir)/dir/file.txt\")) ``` 显示结果为：`file` ### path.filename 获取路径最后带后缀的文件名。 ```lua print(path.filename(\"$(tmpdir)/dir/file.txt\")) ``` 显示结果为：`file.txt` ### path.extension 获取路径的后缀名。 ```lua print(path.extensione(\"$(tmpdir)/dir/file.txt\")) ``` 显示结果为：`.txt` ### path.directory 获取路径的目录名。 ```lua print(path.directory(\"$(tmpdir)/dir/file.txt\")) ``` 显示结果为：`$(tmpdir)/dir` ### path.relative 转换成相对路径。 ```lua print(path.relative(\"$(tmpdir)/dir/file.txt\", \"$(tmpdir)\")) ``` 显示结果为：`dir/file.txt` 第二个参数是指定相对的根目录，如果不指定，则默认相对当前目录： ```lua os.cd(\"$(tmpdir)\") print(path.relative(\"$(tmpdir)/dir/file.txt\")) ``` 这样结果是一样的。 ### path.absolute 转换成绝对路径。 ```lua print(path.absolute(\"dir/file.txt\", \"$(tmpdir)\")) ``` 显示结果为：`$(tmpdir)/dir/file.txt` 第二个参数是指定相对的根目录，如果不指定，则默认相对当前目录： ```lua os.cd(\"$(tmpdir)\") print(path.absolute(\"dir/file.txt\")) ``` 这样结果是一样的。 ### path.is_absolute 判断是否为绝对路径。 ```lua if path.is_absolute(\"/tmp/file.txt\") then 如果是绝对路径 end ``` ### path.splitenv 分割环境变量中的路径。 ```lua local pathes path.splitenv(vformat(\"$(env PATH)\")) for windows local pathes path.splitenv(\"C:\\\\Windows;C:\\\\Windows\\\\System32\") got {\"C:\\\\Windows\", \"C:\\\\Windows\\\\System32\"} for *nix local pathes path.splitenv(\"/usr/bin:/usr/local/bin\") got {\"/usr/bin\", \"/usr/local/bin\"} ``` 结果为一个包含了输入字符串中路径的数组。 ## table table 属于 lua 原生提供的模块，对于原生接口使用可以参考：[lua 官方文档](https://www.lua.org/manual/5.1/manual.html#5.5) xmake 中对其进行了扩展，增加了一些扩展接口： 接口 描述 支持版本 [table.join](#tablejoin) 合并多个 table 并返回 > 2.0.1 [table.join2](#tablejoin2) 合并多个 table 到第一个 table > 2.0.1 [table.unique](#tableunique) 对 table 中的内容进行去重 > 2.0.1 [table.slice](#tableslice) 获取 table 的切片 > 2.0.1 ### table.join 合并多个 table 并返回。 可以将多个 table 里面的元素进行合并后，返回到一个新的 table 中，例如： ```lua local newtable table.join({1, 2, 3}, {4, 5, 6}, {7, 8, 9}) ``` 结果为：`{1, 2, 3, 4, 5, 6, 7, 8, 9}` 并且它也支持字典的合并： ```lua local newtable table.join({a \"a\", b \"b\"}, {c \"c\"}, {d \"d\"}) ``` 结果为：`{a \"a\", b \"b\", c \"c\", d \"d\"}` ### table.join2 合并多个 table 到第一个 table。 类似 [table.join](#table.join)，唯一的区别是，合并的结果放置在第一个参数中，例如： ```lua local t {0, 9} table.join2(t, {1, 2, 3}) ``` 结果为：`t {0, 9, 1, 2, 3}` ### table.unique 对 table 中的内容进行去重。 去重 table 的元素，一般用于数组 table，例如： ```lua local newtable table.unique({1, 1, 2, 3, 4, 4, 5}) ``` 结果为：`{1, 2, 3, 4, 5}` ### table.slice 获取 table 的切片。 用于提取数组 table 的部分元素，例如： ```lua 提取第 4 个元素后面的所有元素，结果：{4, 5, 6, 7, 8, 9} table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4) 提取第 4 8 个元素，结果：{4, 5, 6, 7, 8} table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4, 8) 提取第 4 8 个元素，间隔步长为 2，结果：{4, 6, 8} table.slice({1, 2, 3, 4, 5, 6, 7, 8, 9}, 4, 8, 2) ``` ### table.contains 判断 table 中包含指定的值。 ```lua if table.contains(t, 1, 2, 3) then ... end ``` 只要 table 中包含 1, 2, 3 里面任意一个值，则返回 true ### table.orderkeys 获取有序的 key 列表。 `table.keys(t)` 返回的 key 列表顺序是随机的，想要获取有序 key 列表，可以用这个接口。 ## string 字符串模块为 lua 原生自带的模块，具体使用见：[lua 官方手册](https://www.lua.org/manual/5.1/manual.html#5.4) xmake 中对其进行了扩展，增加了一些扩展接口： 接口 描述 支持版本 [string.startswith](#stringstartswith) 判断字符串开头是否匹配 > 1.0.1 [string.endswith](#stringendswith) 判断字符串结尾是否匹配 > 1.0.1 [string.split](#stringsplit) 分割字符串 > 1.0.1 [string.trim](#stringtrim) 去掉字符串左右空白字符 > 1.0.1 [string.ltrim](#stringltrim) 去掉字符串左边空白字符 > 1.0.1 [string.rtrim](#stringrtrim) 去掉字符串右边空白字符 > 1.0.1 ### string.startswith 判断字符串开头是否匹配。 ```lua local s \"hello xmake\" if s:startswith(\"hello\") then print(\"match\") end ``` ### string.endswith 判断字符串结尾是否匹配。 ```lua local s \"hello xmake\" if s:endswith(\"xmake\") then print(\"match\") end ``` ### string.split 分割字符串。 按模式匹配分割字符串，忽略空串，例如： ```lua (\"1\\n\\n2\\n3\"):split('\\n') > 1, 2, 3 (\"abc123123xyz123abc\"):split('123') > abc, xyz, abc (\"abc123123xyz123abc\"):split('[123]+') > abc, xyz, abc ``` 按纯文本匹配分割字符串，忽略空串（省去了模式匹配，会提升稍许性能），例如： ```lua (\"1\\n\\n2\\n3\"):split('\\n', {plain true}) > 1, 2, 3 (\"abc123123xyz123abc\"):split('123', {plain true}) > abc, xyz, abc ``` 按模式匹配分割字符串，严格匹配，不忽略空串，例如： ```lua (\"1\\n\\n2\\n3\"):split('\\n', {strict true}) > 1, , 2, 3 (\"abc123123xyz123abc\"):split('123', {strict true}) > abc, , xyz, abc (\"abc123123xyz123abc\"):split('[123]+', {strict true}) > abc, xyz, abc ``` 按纯文本匹配分割字符串，严格匹配，不忽略空串（省去了模式匹配，会提升稍许性能），例如： ```lua (\"1\\n\\n2\\n3\"):split('\\n', {plain true, strict true}) > 1, , 2, 3 (\"abc123123xyz123abc\"):split('123', {plain true, strict true}) > abc, , xyz, abc ``` 限制分割块数 ```lua (\"1\\n\\n2\\n3\"):split('\\n', {limit 2}) > 1, 2\\n3 (\"1.2.3.4.5\"):split('%.', {limit 3}) > 1, 2, 3.4.5 ``` ### string.trim 去掉字符串左右空白字符。 ```lua string.trim(\" hello xmake! \") ``` 结果为：\"hello xmake!\" ### string.ltrim 去掉字符串左边空白字符。 ```lua string.ltrim(\" hello xmake!\") ``` 结果为：\"hello xmake!\" ### string.rtrim 去掉字符串右边空白字符。 ```lua string.rtrim(\"hello xmake! \") ``` 结果为：\"hello xmake!\" ## coroutine 协程模块是 lua 原生自带的模块，具使用见：[lua 官方手册](https://www.lua.org/manual/5.1/manual.html#5.2) ## signal 我们可以在 lua 层，注册 SIGINT 等信号处理函数，来定制化响应逻辑。 ### signal.register 注册信号处理器。 目前仅仅支持 SIGINT 信号的处理，同时它也是支持 windows 等主流平台的。 ```lua import(\"core.base.signal\") function main() signal.register(signal.SIGINT, function (signo) print(\"signal.SIGINT(%d)\", signo) end) io.read() end ``` 这对于当一些子进程内部屏蔽了 SIGINT，导致卡死不退出，即使用户按了 `Ctrl+C` 退出了 xmake 进程，它也没有退出时候， 我们就可以通过这种方式去强制退掉它。 ```lua import(\"core.base.process\") import(\"core.base.signal\") function main() local proc signal.register(signal.SIGINT, function (signo) print(\"sigint\") if proc then proc:kill() end end) proc process.open(\"./trap.sh\") if proc then proc:wait() proc:close() end end ``` 关于这个问题的背景，可以参考：[#4889](https://github.com/xmake io/xmake/issues/4889) ### signal.ignore 忽略某个信号。 我们也可以通过 `signal.ignore` 这个接口，去忽略屏蔽某个信号的处理。 ```lua signal.ignore(signal.SIGINT) ``` ### signal.reset 重置某个信号。 我们也可以清除某个信号的处理函数，回退到默认的处理逻辑。 ```lua signal.reset(signal.SIGINT) ```"}}