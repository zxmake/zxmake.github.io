{"/get_started/zh/rule/index.html":{"title":"","content":" class: heading_no_counter # rule xmake 不仅原生支持多语言文件的构建，还允许用户通过自定义构建规则实现复杂的未知文件构建。 自定义构建规则可以使用 `set_extensions` 将一组文件扩展名关联到它们。 一旦这些扩展与规则相关联，稍后对 `add_files` 的调用将自动使用此自定义规则。 这是一个示例规则，它将使用 Pandoc 将添加到构建目标的 Markdown 文件转换为 HTML 文件： ```lua define a build rule for a markdown file rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build_file(function (target, sourcefile, opt) import(\"core.project.depend\") import(\"utils.progress\") it only for v2.5.9, we need use print to show progress below v2.5.8 make sure build directory exists os.mkdir(target:targetdir()) replace .md with .html local targetfile path.join(target:targetdir(), path.basename(sourcefile) .. \".html\") only rebuild the file if its changed since last run depend.on_changed(function () call pandoc to make a standalone html file from a markdown file os.vrunv('pandoc', {\" s\", \" f\", \"markdown\", \" t\", \"html\", \" o\", targetfile, sourcefile}) progress.show(opt.progress, \"${color.build.object}markdown %s\", sourcefile) end, {files sourcefile}) end) end) target(\"test\", function() set_kind(\"object\") make the test target support the construction rules of the markdown file add_rules(\"markdown\") adding a markdown file to build add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` 还有一种以 `on_build_files` 形式代替 `on_build_file` 的方法，它允许您在一个函数调用中处理整个文件集。 第二种称为 `on_buildcmd_file` 和 `on_buildcmd_files` 的形式是声明性的；它不是运行任意 Lua 来构建目标，而是运行 Lua 来了解这些目标是如何构建的。 > `buildcmd` 的优点是可以将这些规则导出到根本不需要 xmake 即可运行的 makefile。 我们可以使用 buildcmd 进一步简化它，如下所示： ```lua define a build rule for a markdown file rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_buildcmd_file(function (target, batchcmds, sourcefile, opt) make sure build directory exists batchcmds:mkdir(target:targetdir()) replace .md with .html local targetfile path.join(target:targetdir(), path.basename(sourcefile) .. \".html\") call pandoc to make a standalone html file from a markdown file batchcmds:vrunv('pandoc', {\" s\", \" f\", \"markdown\", \" t\", \"html\", \" o\", targetfile, sourcefile}) batchcmds:show_progress(opt.progress, \"${color.build.object}markdown %s\", sourcefile) only rebuild the file if its changed since last run batchcmds:add_depfiles(sourcefile) end) end) target(\"test\", function() set_kind(\"object\") make the test target support the construction rules of the markdown file add_rules(\"markdown\") adding a markdown file to build add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` 无论文件扩展名如何，文件都可以分配给特定规则。您可以通过在添加文件时设置 `rule` 自定义属性来完成此操作，如下例所示： ```lua target(\"test\", function() ... add_files(\"src/test/*.md.in\", {rule \"markdown\"}) end) ``` 一个 target 可以叠加应用多个 rules 去更加定制化实现自己的构建行为，甚至支持不同的构建环境。 > 通过 `add_files(\"*.md\", {rule \"markdown\"})` 方式指定的规则，优先级高于 `add_rules(\"markdown\")` 设置的规则。"},"/get_started/zh/rule/builtin-rules.html":{"title":"","content":" class: heading_no_counter # 内建规则 xmake 提供了一些内置规则去简化日常 xmake.lua 描述，以及一些常用构建环境的支持。 我们可以通过运行以下命令，查看完整的内置规则列表： ```bash $ xmake show l rules ``` ## mode.debug 为当前工程 xmake.lua 添加 debug 编译模式的配置规则，例如： ```lua add_rules(\"mode.debug\") ``` 相当于： ```lua if is_mode(\"debug\") then set_symbols(\"debug\") set_optimize(\"none\") end ``` 我们可以通过：`xmake f m debug` 来切换到此编译模式。 ## mode.release 为当前工程 xmake.lua 添加 release 编译模式的配置规则，例如： ```lua add_rules(\"mode.release\") ``` > 此模式默认不会带调试符号。 相当于： ```lua if is_mode(\"release\") then set_symbols(\"hidden\") set_optimize(\"fastest\") set_strip(\"all\") end ``` 我们可以通过：`xmake f m release` 来切换到此编译模式。 ## mode.releasedbg 为当前工程 xmake.lua 添加 releasedbg 编译模式的配置规则，例如： ```lua add_rules(\"mode.releasedbg\") ``` > 与 release 模式相比，此模式还会额外开启调试符号，这通常是非常有用的。 相当于： ```lua if is_mode(\"releasedbg\") then set_symbols(\"debug\") set_optimize(\"fastest\") set_strip(\"all\") end ``` 我们可以通过：`xmake f m releasedbg` 来切换到此编译模式。 ## mode.minsizerel 为当前工程 xmake.lua 添加 minsizerel 编译模式的配置规则，例如： ```lua add_rules(\"mode.minsizerel\") ``` > 与 release 模式相比，此模式更加倾向于最小代码编译优化，而不是速度优先。 相当于： ```lua if is_mode(\"minsizerel\") then set_symbols(\"hidden\") set_optimize(\"smallest\") set_strip(\"all\") end ``` 我们可以通过：`xmake f m minsizerel` 来切换到此编译模式。 ## mode.check 为当前工程 xmake.lua 添加 check 编译模式的配置规则，一般用于内存检测，例如： ```lua add_rules(\"mode.check\") ``` 相当于： ```lua if is_mode(\"check\") then set_symbols(\"debug\") set_optimize(\"none\") add_cxflags(\" fsanitize address\", \" ftrapv\") add_mxflags(\" fsanitize address\", \" ftrapv\") add_ldflags(\" fsanitize address\") end ``` 我们可以通过：`xmake f m check` 来切换到此编译模式。 ## mode.profile 为当前工程 xmake.lua 添加 profile 编译模式的配置规则，一般用于性能分析，例如： ```lua add_rules(\"mode.profile\") ``` 相当于： ```lua if is_mode(\"profile\") then set_symbols(\"debug\") add_cxflags(\" pg\") add_ldflags(\" pg\") end ``` 我们可以通过：`xmake f m profile` 来切换到此编译模式。 ## mode.coverage 为当前工程 xmake.lua 添加 coverage 编译模式的配置规则，一般用于覆盖分析，例如： ```lua add_rules(\"mode.coverage\") ``` 相当于： ```lua if is_mode(\"coverage\") then add_cxflags(\" coverage\") add_mxflags(\" coverage\") add_ldflags(\" coverage\") end ``` 我们可以通过：`xmake f m coverage` 来切换到此编译模式。 ## mode.valgrind 此模式提供 valgrind 内存分析检测支持。 ```lua add_rules(\"mode.valgrind\") ``` 我们可以通过：`xmake f m valgrind` 来切换到此编译模式。 ## mode.asan 此模式提供 AddressSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.asan\") ``` 我们可以通过：`xmake f m asan` 来切换到此编译模式。 ## mode.tsan 此模式提供 ThreadSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.tsan\") ``` 我们可以通过：`xmake f m tsan` 来切换到此编译模式。 ## mode.lsan 此模式提供 LeakSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.lsan\") ``` 我们可以通过：`xmake f m lsan` 来切换到此编译模式。 ## mode.ubsan 此模式提供 UndefinedBehaviorSanitizer 内存分析检测支持。 ```lua add_rules(\"mode.ubsan\") ``` 我们可以通过：`xmake f m ubsan` 来切换到此编译模式。 ## qt.static 用于编译生成 Qt 环境的静态库程序： ```lua target(\"test\", function() add_rules(\"qt.static\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ## qt.shared 用于编译生成 Qt 环境的动态库程序： ```lua target(\"test\", function() add_rules(\"qt.shared\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ## qt.console 用于编译生成 Qt 环境的控制台程序： ```lua target(\"test\", function() add_rules(\"qt.console\") add_files(\"src/*.cpp\") end) ``` ## qt.quickapp 用于编译生成 Qt 环境的 Quick(qml) ui 应用程序。 ```lua target(\"test\", function() add_rules(\"qt.quickapp\") add_files(\"src/*.cpp\") add_files(\"src/qml.qrc\") end) ``` ## qt.quickapp_static 用于编译生成 Qt 环境的 Quick(qml) ui 应用程序（静态链接版本）。 > 需要切换到静态库版本 Qt SDK ```lua target(\"test\", function() add_rules(\"qt.quickapp_static\") add_files(\"src/*.cpp\") add_files(\"src/qml.qrc\") end) ``` ## qt.widgetapp 用于编译 Qt Widgets(ui/moc) 应用程序 ```lua target(\"test\", function() add_rules(\"qt.widgetapp\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add_files(\"src/mainwindow.h\") 添加带有 Q_OBJECT 的 meta 头文件 end) ``` ## qt.widgetapp_static 用于编译 Qt Widgets(ui/moc) 应用程序（静态库版本） > 需要切换到静态库版本 Qt SDK ```lua target(\"test\", function() add_rules(\"qt.widgetapp_static\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add_files(\"src/mainwindow.h\") 添加带有 Q_OBJECT 的 meta 头文件 end) ``` 更多 Qt 相关描述见：[#160](https://github.com/xmake io/xmake/issues/160) ## xcode.bundle 用于编译生成 ios/macos bundle 程序 ```lua target(\"test\", function() add_rules(\"xcode.bundle\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` ## xcode.framework 用于编译生成 ios/macos framework 程序 ```lua target(\"test\", function() add_rules(\"xcode.framework\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` ## xcode.application 用于编译生成 ios/macos 应用程序 ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") end) ``` ## plugin.compile_commands.autoupdate 我们也可以使用这个规则来自动更新生成 compile_commandss.json ```lua add_rules(\"plugin.compile_commands.autoupdate\", {outputdir \".vscode\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` ## utils.symbols.export_list 我们可以在 xmake.lua 里面直接定义导出的符号列表，例如： ```lua target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.c\") add_rules(\"utils.symbols.export_list\", {symbols { \"add\", \"sub\"}}) end) ``` 或者，在 `*.export.txt` 文件中添加导出的符号列表。 ```lua target(\"foo2\", function() set_kind(\"shared\") add_files(\"src/foo.c\") add_files(\"src/foo.export.txt\") add_rules(\"utils.symbols.export_list\") end) ``` 完整的工程例子见：[导出符号例子](https://github.com/xmake io/xmake/tree/dev/tests/projects/c/shared_library_export_list) ## utils.install.cmake_importfiles 可以使用此规则在安装 target 目标库文件的时候，导出 .cmake 文件，用于其他 cmake 项目的库导入和查找。 ## utils.install.pkgconfig_importfiles 可以使用此规则在安装 target 目标库文件的时候，导出 pkgconfig/.pc 文件，用于其他项目的库导入和查找。 ## utils.bin2c 可以使用此规则，在项目中引入一些二进制文件，并见他们作为 c/c++ 头文件的方式提供开发者使用，获取这些文件的数据。 比如，我们可以在项目中，内嵌一些 png/jpg 资源文件到代码中。 ```lua target(\"console\", function() set_kind(\"binary\") add_rules(\"utils.bin2c\", {extensions {\".png\", \".jpg\"}}) add_files(\"src/*.c\") add_files(\"res/*.png\", \"res/*.jpg\") end) ``` > extensions 的设置是可选的，默认后缀名是 .bin 然后，我们就可以通过 `#include \"filename.png.h\"` 的方式引入进来使用，xmake 会自动帮你生成对应的头文件，并且添加对应的搜索目录。 ```c static unsigned char g_png_data[] { #include \"image.png.h\" }; int main(int argc, char** argv) { printf(\"image.png: %s, size: %d\\n\", g_png_data, sizeof(g_png_data)); return 0; } ``` 生成头文件内容类似： ```console cat build/.gens/test/macosx/x86_64/release/rules/c++/bin2c/image.png.h 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x78, 0x6D, 0x61, 0x6B, 0x65, 0x21, 0x0A, 0x00 ``` ## utils.glsl2spv 可以使用此规则，在项目中引入 `*.vert/*.frag` 等 glsl shader 文件，然后实现自动编译生成 `*.spv` 文件。 另外，我们还支持以 C/C++ 头文件的方式，二进制内嵌 spv 文件数据，方便程序使用。 ### 编译生成 spv 文件 xmake 会自动调用 glslangValidator 或者 glslc 去编译 shaders 生成 .spv 文件，然后输出到指定的 `{outputdir \"build\"}` 目录下。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"glslang\", {configs {binaryonly true}}) target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.glsl2spv\", {outputdir \"build\"}) add_files(\"src/*.c\") add_files(\"src/*.vert\", \"src/*.frag\") add_packages(\"glslang\") end) ``` > 注，这里的 `add_packages(\"glslang\")` 主要用于引入和绑定 glslang 包中的 glslangValidator，确保 xmake 总归能够使用它。 当然，如果用户自己系统上已经安装了它，也可以不用额外绑定这个包，不过我还是建议添加一下。 ### 编译生成 c/c++ 头文件 我们也可以内部借助 bin2c 模块，将编译后的 spv 文件生成对应的二进制头文件，方便用户代码中直接引入，我们只需要启用 `{bin2c true}`。: ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"glslang\", {configs {binaryonly true}}) target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.glsl2spv\", {bin2c true}) add_files(\"src/*.c\") add_files(\"src/*.vert\", \"src/*.frag\") add_packages(\"glslang\") end) ``` 然后我们可以在代码这么引入： ```c static unsigned char g_test_vert_spv_data[] { #include \"test.vert.spv.h\" }; static unsigned char g_test_frag_spv_data[] { #include \"test.frag.spv.h\" }; ``` 跟 bin2c 规则的使用方式类似，完整例子见：[glsl2spv example](https://github.com/xmake io/xmake/tree/master/tests/projects/other/glsl2spv) ## utils.hlsl2spv 除了 `utils.glsl2spv` 规则，我们现在还支持 `utils.hlsl2spv` 规则。 ```bash add_rules(\"mode.debug\", \"mode.release\") add_requires(\"glslang\", {configs {binaryonly true}}) target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.hlsl2spv\", {bin2c true}) add_files(\"src/*.c\") add_files(\"src/*.hlsl\", \"src/*.hlsl\") add_packages(\"directxshadercompiler\") end) ``` ## python.library 我们可以用这个规则，配合 pybind11 生成 python 库模块，它会调整 python 库的模块名。 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"pybind11\") target(\"example\", function() add_rules(\"python.library\") add_files(\"src/*.cpp\") add_packages(\"pybind11\") set_languages(\"c++11\") end) ``` 带有 soabi： ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"pybind11\") target(\"example\", function() add_rules(\"python.library\", {soabi true}) add_files(\"src/*.cpp\") add_packages(\"pybind11\") set_languages(\"c++11\") end) ``` ## nodejs.module 构建 nodejs 模块。 ```lua add_requires(\"node addon api\") target(\"foo\", function() set_languages(\"cxx17\") add_rules(\"nodejs.module\") add_packages(\"node addon api\") add_files(\"*.cc\") end) ``` ## utils.ipsc ipsc 编译器规则支持，使用方式如下： ```lua target(\"test\", function() set_kind(\"binary\") add_rules(\"utils.ispc\", {header_extension \"_ispc.h\"}) set_values(\"ispc.flags\", \" target host\") add_files(\"src/*.ispc\") add_files(\"src/*.cpp\") end) ```"},"/get_started/zh/rule/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 ## rule 定义规则： ```lua rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build_file(function (target, sourcefile, opt) os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. \".html\")) end) end) ``` ## rule:add_deps 关联依赖可以绑定一批规则，也就是不必对 target 挨个去使用 `add_rules()` 添加规则，只需要应用一个规则，就能生效它和它的所有依赖规则。 例如： ```lua rule(\"foo\", function() add_deps(\"bar\") end) rule(\"bar\", function() ... end) ``` 我们只需要 `add_rules(\"foo\")`，就能同时应用 foo 和 bar 两个规则。 但是，默认情况下，依赖之间是不存在执行的先后顺序的，foo 和 bar 的 `on_build_file` 等脚本是并行执行的，顺序未定义。 如果要严格控制执行顺序，可以配置 `add_deps(\"bar\", {order true})`，告诉 xmake，我们需要根据依赖顺序来执行同级别的脚本。 例如： ```lua rule(\"foo\", function() add_deps(\"bar\", {order true}) on_build_file(function (target, sourcefile) end) end) rule(\"bar\", function() on_build_file(function (target, sourcefile) end) end) ``` bar 的 `on_build_file` 将会被先执行。 不过，这种控制依赖的方式，只适合 foo 和 bar 两个规则都是自定义规则，如果想要将自己的规则插入到 xmake 的内置规则之前执行，这就不适用了。 这个时候，我们需要使用更加灵活的动态规则创建和注入的方式，去修改内置规则。 例如，我们想在内置的 `c++.build` 规则之前，执行自定义 cppfront 规则的 `on_build_file` 脚本，我们可以通过下面的方式来实现。 ```lua rule(\"cppfront\", function() set_extensions(\".cpp2\") on_load(function (target) local rule target:rule(\"c++.build\"):clone() rule:add(\"deps\", \"cppfront\", {order true}) target:rule_add(rule) end) on_build_file(function (target, sourcefile, opt) print(\"build cppfront file\") end) end) target(\"test\", function() set_kind(\"binary\") add_rules(\"cppfront\") add_files(\"src/*.cpp\") add_files(\"src/*.cpp2\") end) ``` ## rule:add_imports 为所有自定义脚本预先导入扩展模块。 使用方式和说明请见：[target:add_imports](#targetadd_imports)，用法相同。 ## rule:set_extensions 设置规则支持的文件扩展类型。 通过设置支持的扩展文件类型，将规则应用于带这些后缀的文件上，例如： ```lua 定义一个 markdown 文件的构建规则 rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build_file(function (target, sourcefile, opt) os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. \".html\")) end) end) target(\"test\", function() set_kind(\"binary\") 使 test 目标支持 markdown 文件的构建规则 add_rules(\"markdown\") 添加 markdown 文件的构建 add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` ## rule:on_load 自定义加载脚本。 用于实现自定规则的加载脚本，当加载 target 的时候，会被执行，可在里面自定义设置一些 target 配置，例如： ```lua rule(\"test\", function() on_load(function (target) target:add(\"defines\", \"TEST\") end) end) ``` ## rule:on_link 自定义链接脚本。 用于实现自定规则的链接脚本，会覆盖被应用的 target 的默认链接行为，例如： ```lua rule(\"test\", function() on_link(function (target) end) end) ``` ## rule:on_config 自定义配置脚本。 在 `xmake config` 执行完成后，Build 之前会执行此脚本，通常用于编译前的配置工作。它与 on_load 不同的是，on_load 只要 target 被加载就会执行，执行时机更早。 如果一些配置，无法在 on_load 中过早配置，那么都可以在 on_config 中去配置它。 另外，它的执行时机比 before_build 还要早，大概的执行流程如下： ``` on_load > after_load > on_config > before_build > on_build > after_build ``` ## rule:on_build 自定义编译脚本。 用于实现自定规则的构建脚本，会覆盖被应用的 target 的默认构建行为，例如： ```lua rule(\"markdown\", function() on_build(function (target) end) end) ``` ## rule:on_clean 自定义清理脚本。 用于实现自定规则的清理脚本会，覆盖被应用的 target 的默认清理行为，例如： ```lua rule(\"markdown\", function() on_clean(function (target) remove sourcefile.html end) end) ``` ## rule:on_package 自定义打包脚本。 用于实现自定规则的打包脚本，覆盖被应用的 target 的默认打包行为, 例如： ```lua rule(\"markdown\", function() on_package(function (target) package sourcefile.html end) end) ``` ## rule:on_install 自定义安装脚本。 用于实现自定规则的安装脚本，覆盖被应用的 target 的默认安装行为, 例如： ```lua rule(\"markdown\", function() on_install(function (target) end) end) ``` ## rule:on_uninstall 自定义卸载脚本。 用于实现自定规则的卸载脚本，覆盖被应用的 target 的默认卸载行为, 例如： ```lua rule(\"markdown\", function() on_uninstall(function (target) end) end) ``` ## rule:on_build_file 自定义编译脚本，一次处理一个源文件。 ```lua rule(\"markdown\", function() on_build_file(function (target, sourcefile, opt) print(\"%%%d: %s\", opt.progress, sourcefile) end) end) ``` 其中第三个参数 opt 是可选参数，用于获取一些编译过程中的信息状态，例如：opt.progress 为当期的编译进度。 ## rule:on_buildcmd_file 自定义批处理编译脚本，一次处理一个源文件。 这个接口里面的脚本不会直接构建源文件，但是会通过 batchcmds 对象，构造一个批处理命令行任务， xmake 在实际执行构建的时候，一次性执行这些命令。 这对于 `xmake project` 此类工程生成器插件非常有用，因为生成器生成的第三方工程文件并不支持 `on_build_files` 此类内置脚本的执行支持。 但是 `on_buildcmd_files` 构造的最终结果，就是一批原始的 cmd 命令行，可以直接给其他工程文件作为 custom commands 来执行。 另外，相比 `on_build_files`，它也简化对扩展文件的编译实现，更加的可读易配置，对用户也更加友好。 ```lua rule(\"foo\", function() set_extensions(\".xxx\") on_buildcmd_file(function (target, batchcmds, sourcefile, opt) batchcmds:vrunv(\"gcc\", {\" o\", objectfile, \" c\", sourcefile}) batchcmds:add_depfiles(\"/xxxxx/dependfile.h\", ...) batchcmds:add_depvalues(...) batchcmds:set_depmtime(os.mtime(...)) batchcmds:set_depcache(\"xxxx.d\") end) end) ``` 除了 `batchcmds:vrunv`，我们还支持一些其他的批处理命令，例如： ```lua batchcmds:show(\"hello %s\", \"xmake\") batchcmds:vrunv(\"gcc\", {\" o\", objectfile, \" c\", sourcefile}, {envs {LD_LIBRARY_PATH \"/xxx\"}}) batchcmds:mkdir(\"/xxx\") and cp, mv, rm, ln .. batchcmds:compile(sourcefile_cx, objectfile, {configs {includedirs sourcefile_dir, languages (sourcekind \"cxx\" and \"c++11\")}}) batchcmds:link(objectfiles, targetfile, {configs {linkdirs \"\"}}) ``` 同时，我们在里面也简化对依赖执行的配置，下面是一个完整例子： ```lua rule(\"lex\", function() set_extensions(\".l\", \".ll\") on_buildcmd_file(function (target, batchcmds, sourcefile_lex, opt) imports import(\"lib.detect.find_tool\") get lex local lex assert(find_tool(\"flex\") or find_tool(\"lex\"), \"lex not found!\") get c/c++ source file for lex local extension path.extension(sourcefile_lex) local sourcefile_cx path.join(target:autogendir(), \"rules\", \"lex_yacc\", path.basename(sourcefile_lex) .. (extension \".ll\" and \".cpp\" or \".c\")) add objectfile local objectfile target:objectfile(sourcefile_cx) table.insert(target:objectfiles(), objectfile) add commands batchcmds:show_progress(opt.progress, \"${color.build.object}compiling.lex %s\", sourcefile_lex) batchcmds:mkdir(path.directory(sourcefile_cx)) batchcmds:vrunv(lex.program, {\" o\", sourcefile_cx, sourcefile_lex}) batchcmds:compile(sourcefile_cx, objectfile) add deps batchcmds:add_depfiles(sourcefile_lex) local dependfile target:dependfile(objectfile) batchcmds:set_depmtime(os.mtime(dependfile)) batchcmds:set_depcache(dependfile) end) end) ``` `add_depfiles` 设置这个目标文件依赖的源文件。`set_depmtime` 设置目标文件的修改时间，如果有任意源文件的修改时间大于它，则认为需要重新生成这个目标文件。这里使用 dependfile 而不是 objectfile 的原因见 [issues 748](https://github.com/xmake io/xmake/issues/748)。`set_depcache` 设置存储依赖信息的文件。 关于这个的详细说明和背景，见：[issue 1246](https://github.com/xmake io/xmake/issues/1246) ## rule:on_build_files 自定义编译脚本，一次处理多个源文件。 大部分的自定义构建规则，每次都是处理单独一个文件，输出一个目标文件，例如：a.c > a.o 但是，有些情况下，我们需要同时输入多个源文件一起构建生成一个目标文件，例如：a.c b.c d.c > x.o 对于这种情况，我们可以通过自定义这个脚本来实现： ```lua rule(\"markdown\", function() on_build_files(function (target, sourcebatch, opt) build some source files for _, sourcefile in ipairs(sourcebatch.sourcefiles) do ... end end) end) ``` ## rule:on_buildcmd_files 自定义批处理编译脚本，一次处理多个源文件。 关于这个的详细说明，见：[rule:on_buildcmd_file](#ruleon_buildcmd_file) ```lua rule(\"foo\", function() set_extensions(\".xxx\") on_buildcmd_files(function (target, batchcmds, sourcebatch, opt) for _, sourcefile in ipairs(sourcebatch.sourcefiles) do batchcmds:vrunv(\"gcc\", {\" o\", objectfile, \" c\", sourcefile}) end end) end) ``` ## rule:before_config 自定义配置前脚本。 用于实现自定义 target 配置前的执行脚本，例如： ```lua rule(\"test\", function() before_config(function (target) end) end) ``` 它会在 on_config 之前被执行。 ## rule:before_link 自定义链接前脚本。 用于实现自定义 target 链接前的执行脚本，例如： ```lua rule(\"test\", function() before_link(function (target) end) end) ``` ## rule:before_build 自定义编译前脚本。 用于实现自定义 target 构建前的执行脚本，例如： ```lua rule(\"markdown\", function() before_build(function (target) end) end) ``` ## rule:before_clean 自定义清理前脚本。 用于实现自定义 target 清理前的执行脚本，例如： ```lua rule(\"markdown\", function() before_clean(function (target) end) end) ``` ## rule:before_package 自定义打包前脚本。 用于实现自定义 target 打包前的执行脚本, 例如： ```lua rule(\"markdown\", function() before_package(function (target) end) end) ``` ## rule:before_install 自定义安装前脚本。 用于实现自定义 target 安装前的执行脚本，例如： ```lua rule(\"markdown\", function() before_install(function (target) end) end) ``` ## rule:before_uninstall 自定义卸载前脚本。 用于实现自定义 target 卸载前的执行脚本，例如： ```lua rule(\"markdown\", function() before_uninstall(function (target) end) end) ``` ## rule:before_build_file 自定义编译前脚本，一次处理一个源文件。 跟 [rule:on_build_file](#ruleon_build_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:before_buildcmd_file 自定义编译前批处理脚本，一次处理一个源文件。 跟 [rule:on_buildcmd_file](#ruleon_buildcmd_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:before_build_files 自定义编译前脚本，一次处理多个源文件。 跟 [rule:on_build_files](#ruleon_build_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:before_buildcmd_files 自定义编译前批处理脚本，一次处理多个源文件。 跟 [rule:on_buildcmd_files](#ruleon_buildcmd_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之前， 一般用于对某些源文件进行编译前的预处理。 ## rule:after_config 自定义配置后脚本。 用于实现自定义 target 配置后的执行脚本，例如： ```lua rule(\"test\", function() after_config(function (target) end) end) ``` 它会在 on_config 之后被执行。 ## rule:after_link 自定义链接后脚本。 用于实现自定义 target 链接后的执行脚本，用法跟 [rule:before_link](#rulebefore_link) 类似。 ## rule:after_build 自定义编译后脚本。 用于实现自定义 target 构建后的执行脚本，用法跟 [rule:before_build](#rulebefore_build) 类似。 ## rule:after_clean 自定义清理后脚本。 用于实现自定义 target 清理后的执行脚本，用法跟 [rule:before_clean](#rulebefore_clean) 类似。 ## rule:after_package 自定义打包后脚本。 用于实现自定义 target 打包后的执行脚本, 用法跟 [rule:before_package](#rulebefore_package) 类似。 ## rule:after_install 自定义安装后脚本。 用于实现自定义 target 安装后的执行脚本，用法跟 [rule:before_install](#rulebefore_install) 类似。 ## rule:after_uninstall 自定义卸载后脚本。 用于实现自定义 target 卸载后的执行脚本，用法跟 [rule:before_uninstall](#rulebefore_uninstall) 类似。 ## rule:after_build_file 自定义编译后脚本，一次处理一个源文件。 跟 [rule:on_build_file](#ruleon_build_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之后， 一般用于对某些编译后对象文件进行后期处理。 ## rule:after_buildcmd_file 自定义编译后批处理脚本，一次处理一个源文件。 跟 [rule:on_buildcmd_file](#ruleon_buildcmd_file) 用法类似，不过这个接口被调用的时机是在编译某个源文件之后， 一般用于对某些编译后对象文件进行后期处理。 ## rule:after_build_files 自定义编译后脚本，一次处理多个源文件。 跟 [rule:on_build_files](#ruleon_build_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之后， 一般用于对某些编译后对象文件进行后期处理。 ## rule:after_buildcmd_files 自定义编译后批处理脚本，一次处理多个源文件。 跟 [rule:on_buildcmd_files](#ruleon_buildcmd_files) 用法类似，不过这个接口被调用的时机是在编译某些源文件之后， 一般用于对某些编译后对象文件进行后期处理。"},"/get_started/zh/tutorial/syntax-description.html":{"title":"","content":" class: heading_no_counter # 语法描述 xmake 的工程描述文件 xmake.lua 虽然基于 lua 语法，但是为了使得更加方便简洁得编写项目构建逻辑，xmake 对其进行了一层封装，使得编写 xmake.lua 不会像写 makefile 那样繁琐 基本上写个简单的工程构建描述，只需四行就能搞定，例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` ## 域配置语法 我们默认约定的域配置语法，尽管非常简洁，但是对自动格式化缩进和 IDE 不是很友好。 ```lua target(\"foo\") set_kind(\"binary\") add_files(\"src/*.cpp\") target_end() ``` 另外，它不能自动结束当前 target 作用域，用户需要显式调用 `target_end()`。 虽然，上面我们提到，可以使用 `do end` 模式来解决自动缩进问题，但是需要 `target_end()` 的问题还是存在。 ```lua target(\"bar\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end target_end() ``` 我们提供了一种更好的可选域配置语法，来解决自动缩进，target 域隔离问题，例如： ```lua add_defines(\"ROOT\") target(\"foo\", function () set_kind(\"binary\") add_files(\"src/*.cpp\") add_defines(\"FOO\") end) target(\"bar\", function () set_kind(\"binary\") add_files(\"src/*.cpp\") add_defines(\"BAR\") end) ``` foo 和 bar 两个域是完全隔离的，我们即使在它们中间配置其他设置，也不会影响它们，另外，它还对 LSP 非常友好。 > 因此我们约定，xmake.lua 的域配置语法，默认采用可选的 `function () end` 模式，其他模式后续可能会被移除。 ## 配置分离 xmake.lua 采用二八原则实现了描述域、脚本域两层分离式配置。 什么是二八原则呢，简单来说，大部分项目的配置，80% 的情况下，都是些基础的常规配置，比如：`add_cxflags`, `add_links`等， 只有剩下不到 20% 的地方才需要额外做些复杂来满足一些特殊的配置需求。 而这剩余的 20% 的配置通常比较复杂，如果直接充斥在整个 xmake.lua 里面，会把整个项目的配置整个很混乱，非常不可读。 因此，xmake 通过描述域、脚本域两种不同的配置方式，来隔离 80% 的简单配置以及 20% 的复杂配置，使得整个 xmake.lua 看起来非常的清晰直观，可读性和可维护性都达到最佳。 ### 描述域 对于刚入门的新手用户，或者仅仅是维护一些简单的小项目，通过完全在描述配置就已经完全满足需求了，那什么是描述域呢？它长这样： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") add_syslinks(\"pthread\") end) ``` 一眼望去，其实就是个 `set_xxx`/`add_xxx` 的配置集，对于新手，完全可以不把它当做 lua 脚本，仅仅作为普通的，但有一些基础规则的配置文件就行了。 如果因为，看着有括号，还是像脚本语言的函数调用，那我们也可以这么写（是否带括号看个人喜好）： ```lua target \"test\"     set_kind \"binary\"     add_files \"src/*.c\"     add_defines \"DEBUG\"     add_syslinks \"pthread\" ``` 这是不是看着更像配置文件了？其实描述域就是配置文件，类似像 json 等 key/values 的配置而已，所以即使完全不会 lua 的新手，也是能很快上手的。 而且，对于通常的项目，仅通过 `set_xxx/add_xxx` 去配置各种项目设置，已经完全满足需求了。 这也就是开头说的：80% 的情况下，可以用最简单的配置规则去简化项目的配置，提高可读性和可维护性，这样对用户和开发者都会非常的友好，也更加直观。 如果我们要针对不同平台，架构做一些条件判断怎么办？没关系，描述域除了基础配置，也是支持条件判断，以及 for 循环的： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") if is_plat(\"linux\", \"macosx\") then add_links(\"pthread\", \"m\", \"dl\") end end) ``` ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") for _, name in ipairs({\"pthread\", \"m\", \"dl\"}) do add_links(name) end end) ``` 这是不是看着有点像 lua 了？虽说，平常可以把它当做普通配置问题，但是 xmake 毕竟基于 lua，所以描述域还是支持 lua 的基础语言特性的。 > 不过需要注意的是，描述域虽然支持 lua 的脚本语法，但在描述域尽量不要写太复杂的 lua 脚本，比如一些耗时的函数调用和 for 循环 并且在描述域，主要目的是为了设置配置项，因此 xmake 并没有完全开放所有的模块接口，很多接口在描述域是被禁止调用的， 即使开放出来的一些可调用接口，也是完全只读的，不耗时的安全接口，比如：`os.getenv()` 等读取一些常规的系统信息，用于配置逻辑的控制。 > 另外需要注意一点，xmake.lua 是会被多次解析的，用于在不同阶段解析不同的配置域：比如：`option()`, `target()` 等域。 因此，不要想着在 xmake.lua 的描述域，写复杂的 lua 脚本，也**不要在描述域调用 print 去显示信息，因为会被执行多遍**。 ### 脚本域 限制描述域写复杂的 lua，各种 lua 模块和接口都用不了？怎么办？这个时候就是脚本域出场的时候了。 如果用户已经完全熟悉了 xmake 的描述域配置，并且感觉有些满足不了项目上的一些特殊配置维护了，那么我们可以在脚本域做更加复杂的配置逻辑： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_load(function (target) if is_plat(\"linux\", \"macosx\") then target:add(\"links\", \"pthread\", \"m\", \"dl\") end end) after_build(function (target) import(\"core.project.config\") local targetfile target:targetfile() os.cp(targetfile, path.join(config.buildir(), path.filename(targetfile))) print(\"build %s\", targetfile) end) end) ``` 只要是类似：`on_xxx`, `after_xxx`, `before_xxx` 等字样的 function body 内部的脚本，都属于脚本域。 在脚本域中，用户可以干任何事，xmake 提供了 import 接口可以导入 xmake 内置的各种 lua 模块，也可以导入用户提供的 lua 脚本。 我们可以在脚本域实现你想实现的任意功能，甚至写个独立项目出来都是可以的。 对于一些脚本片段，不是很臃肿的话，像上面这么内置写写就足够了，如果需要实现更加复杂的脚本，不想充斥在一个 xmake.lua 里面，可以把脚本分离到独立的 lua 文件中去维护。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_load(\"modules.test.load\") on_install(\"modules.test.install\") end) ``` 我们可以把自定义的脚本放置到 xmake.lua 对应目录下，`modules/test/load.lua` 和 `modules/test/install.lua` 中独立维护。 这些独立的 lua 脚本里面，我们还可以通过[import](/zh cn/manual/builtin_modules?id import)导入各种内置模块和自定义模块进来使用，就跟平常写lua, java 没啥区别。 而对于脚本的域的不同阶段，`on_load` 主要用于 target 加载时候，做一些动态化的配置（注意这里不像描述域，只会执行一遍）。 其他阶段，还有很多，比如：`on/after/before`_`build/install/package/run` 等，具体看下后面的 target api 手册部分吧，这里就不细说了。 ## 配置类型 在描述域配置中，分配置域和配置项，配置域里面可以通过 `set_xxx`/`add_xxx` 的接口，配置各种配置项。 ```lua target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 像上述配置中，target 就属于配置域，它下面的所有 `set_xx`/`add_xxx` 接口配置都属于配置项，对这个 target 局部生效。 我们可以把它理解成局部作用域，类似 c 里面的 block 块： ``` target(\"test1\") { set_kind(\"binary\") add_files(\"src/*.c\") } target(\"test2\") { set_kind(\"binary\") add_files(\"src/*.c\") } ``` 不过，为了简化写法，xmake 约定每个新定义的 target 域开始，上一个配置域就自动结束了，当然，如果这样用户觉得有困扰，也可以手动配置离开域： ```lua target(\"test1\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() target(\"test2\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() ``` ### 配置域 目前提供的配置域有：`target()`, `option()`, `task()`, `package()` 每个域的详细说明，见：[API手册](/zh cn/manual/project_target) ### 配置项 只要是带有 `set_xxx` 和 `add_xxx` 字样的配置，都属于配置项，一个配置域里面可以设置多个配置项。 关于配置项的规范说明，见：[接口规范](/zh cn/manual/specification) ## 作用域 xmake 的描述语法是按作用域划分的，主要分为： 外部作用域 内部作用域 接口作用域 那哪些属于外部，哪些又属于内部呢，看看下面的注释，就知道个大概了： ```lua 外部作用域 target(\"test\", function() 外部作用域 set_kind(\"binary\") add_files(\"src/*.c\") on_run(function () 内部作用域 end) after_package(function () 内部作用域 end) end) 外部作用域 task(\"hello\", function() 外部作用域 on_run(function () 内部作用域 end) end) ``` 简单的说，就是在自定义脚本 `function () end` 之内的都属于内部作用域，也就是脚本作用域，其他地方都是都属于于外部作用域。。 ### 外部作用域 对于大部分工程来说，并不需要很复杂的工程描述，也不需要自定义脚本支持，只需要简单的 `set_xxx` 或者 `add_xxx` 就能满足需求了 那么根据二八定律，80% 的情况下，我们只需要这么写： ```lua target(\"test\", function() set_kind(\"static\") add_files(\"src/test/*.c\") end) target(\"demo\", function() add_deps(\"test\") set_kind(\"binary\") add_links(\"test\") add_files(\"src/demo/*.c\") end) ``` 不需要复杂的 api 调用，也不需要各种繁琐的变量定义，以及 if 判断 和 for 循环，要的就是简洁可读，一眼看过去，就算不懂 lua 语法也没关系 就当做简单的描述语法，看上去有点像函数调用而已，会点编程的基本一看就知道怎么配置。 为了做到简洁、安全，在这个作用域内，很多 lua 内置 api 是不开放出来的，尤其是跟写文件、修改操作环境相关的，仅仅提供一些基本的只读接口，和逻辑操作 目前外部作用域开放的 lua 内置 api 有： table string pairs ipairs print os 当然虽然内置 lua api 提供不多，但 xmake 还提供了很多扩展 api，像描述 api 就不多说，详细可参考：[API手册](/zh cn/manual/builtin_modules) 还有些辅助 api，例如： dirs：扫描获取当前指定路径中的所有目录 files：扫描获取当前指定路径中的所有文件 format: 格式化字符串，string.format 的简写版本 还有变量定义、逻辑操作也是可以使用的，毕竟是基于 lua 的，该有的基础语法，还是要有的，我们可以通过 if 来切换编译文件： ```lua target(\"test\", function() set_kind(\"static\") if is_plat(\"iphoneos\") then add_files(\"src/test/ios/*.c\") else add_files(\"src/test/*.c\") end end) ``` 需要注意的是，变量定义分全局变量和局部变量，局部变量只对当前 xmake.lua 有效，不影响子 xmake.lua ```lua 局部变量，只对当前xmake.lua有效 local var1 0 全局变量，影响所有之后 includes() 包含的子 xmake.lua var2 1 includes(\"src\") ``` ### 内部作用域 也称插件、脚本作用域，提供更加复杂、灵活的脚本支持，一般用于编写一些自定义脚本、插件开发、自定义 task 任务、自定义模块等等 一般通过 `function () end` 包含，并且被传入到 `on_xxx`, `before_xxx` 和 `after_xxx` 接口内的，都属于自作用域。 例如： ```lua 自定义脚本 target(\"hello\", function() after_build(function () 内部作用域 end) end) 自定义任务、插件 task(\"hello\", function() on_run(function () 内部作用域 end) end) ``` 在此作用域中，不仅可以使用大部分 lua 的 api，还可以使用很多 xmake 提供的扩展模块，所有扩展模块，通过 import 来导入 具体可参考：[import模块导入文档](/zh cn/manual/builtin_modules?id import) 这里我们给个简单的例子，在编译完成后，对 ios 目标程序进行 ldid 签名： ```lua target(\"iosdemo\", function() set_kind(\"binary\") add_files(\"*.m\") after_build(function (target) 执行签名，如果失败，自动中断，给出高亮错误信息 os.run(\"ldid S$(projectdir)/entitlements.plist %s\", target:targetfile()) end) end) ``` 需要注意的是，在内部作用域中，所有的调用都是启用异常捕获机制的，如果运行出错，会自动中断 xmake，并给出错误提示信息 因此，脚本写起来，不需要繁琐的 `if retval then` 判断，脚本逻辑更加一目了然 ### 接口作用域 在外部作用域中的所有描述api设置，本身也是有作用域之分的，在不同地方调用，影响范围也不相同，例如： ```lua 全局根作用域，影响所有 target，包括 includes() 中的子工程 target 设置 add_defines(\"DEBUG\") 定义或者进入 demo 目标作用域（支持多次进入来追加设置） target(\"demo\", function() set_kind(\"shared\") add_files(\"src/*.c\") 当前 target 作用域，仅仅影响当前 target add_defines(\"DEBUG2\") end) 选项设置，仅支持局部设置，不受全局 api 设置所影响 option(\"test\", function() 当前选项的局部作用域 set_default(false) end) 其他target设置， DDEBUG 也会被设置上 target(\"demo2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) 重新进入demo目标作用域 target(\"demo\", function() 追加宏定义，只对当前demo目标有效 add_defines(\"DEBUG3\") end) ``` 通常情况下，进入另一个 target/option 域设置，会自动离开上个 target/option 域，但是有时候为了比较一些作用域污染情况，我们可以显示离开某个域，例如： ```lua option(\"test\") set_default(false) option_end() target(\"demo\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() ``` 调用 `option_end()`, `target_end()` 即可显式的离开当前 target/option 域设置。 ### 代码格式化 由于默认的描述域配置语法的缩进并不符合 lua 格式规范，因此 lua language server 是不支持对它进行格式化处理的。 如果想要让 IDE，编辑器更好的对配置进行格式化缩进支持，我么可以通过 `do end` 的写法来处理： ```lua target(\"bar\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end target(\"foo\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end ``` 这样，Lua LSP 就能把它作为标准的 lua 代码进行正确的格式化，是否需要这么做，看用户自己的需求。 如果没有代码自动格式化的使用习惯，那就不需要这么做。 ## 多级配置 在脚本域我们可以通过 import 导入各种丰富的扩展模块来使用，而在描述域我们可以通过[includes](/#/zh cn/manual/global_interfaces?id includes)接口，来引入项目子目录下的 xmake.lua 配置。 记住：xmake 的 includes 是按照 tree 结构来处理配置关系的，子目录下的 xmake.lua 里面的 target 配置会继承父 xmake.lua 中的根域配置，例如： 目前有如下项目结构： ``` projectdir xmake.lua src xmake.lua ``` `projectdir/xmake.lua` 是项目的根 xmake.lua 配置，而 `src/xmake.lua` 是项目的子配置。 `projectdir/xmake.lua` 内容： ```lua add_defines(\"ROOT\") target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST1\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST2\") end) includes(\"src\") ``` 里面全局根域配置了 `add_defines(\"ROOT\")`，会影响下面的所有 target 配置，包括 includes 里面子 xmake.lua 中的所有 target 配置，所以这个是全局总配置。 而在 test1/test2 里面的 `add_defines(\"TEST1\")` 和 `add_defines(\"TEST2\")` 属于局部配置，只对当前 target 生效。 `src/xmake.lua` 内容： ```lua add_defines(\"ROOT2\") target(\"test3\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST3\") end) ``` 在 `src/xmake.lua` 子配置中，也有个全局根域，配置了 `add_defines(\"ROOT2\")`，这个属于子配置根域，只对当前子 xmake.lua 里面所有 target 生效，也会对下级 includes 里面的子 xmake.lua 中 target 生效，因为之前说了，xmake 是 tree 状结构的配置继承关系。 所以，这几个 target 的最终配置结果依次是： ``` target(\"test1\"): DROOT DTEST1 target(\"test2\"): DROOT DTEST2 target(\"test3\"): DROOT DROOT2 DTEST3 ``` ## 语法简化 xmake.lua 的配置域语法，非常灵活，可以在相关域做各种复杂灵活的配置，但是对于许多精简的小块配置，这个时候就稍显冗余了： ```lua option(\"test1\", function() set_default(true) set_showmenu(true) set_description(\"test1 option\") end) option(\"test2\", function() set_default(true) set_showmeu(true) end) option(\"test3\", function() set_default(\"hello\") end) ``` 对于上面的这些小块 option 域设置，我们可以简化下成单行描述： ```lua option(\"test1\", {default true, showmenu true, description \"test1 option\"}) option(\"test2\", {default true, showmenu true}) option(\"test3\", {default \"hello\"}) ``` 除了 option 域，对于其他域也是支持这种简化写法的，例如： ```lua target(\"demo\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 简化为： ```lua target(\"demo\", {kind \"binary\", files \"src/*.c\"}) ``` 或者 ```lua target(\"demo\", { kind \"binary\", files \"src/*.c\" }) ``` 当然，如果配置需求比较复杂的，还是原有的多行设置方式更加方便，这个就看自己的需求来评估到底使用哪种方式了。"},"/get_started/zh/tutorial/quick-start.html":{"title":"","content":" class: heading_no_counter # 快速开始 ## 创建工程 创建一个名叫 `hello` 的 `c` 控制台工程： ```bash $ xmake create language c project ./hello # 或 $ xmake create l c P ./hello ``` 执行完后，将会生成一个简单工程结构： ``` ./hello/ ├── src │ └── main.c └── xmake.lua ``` 其中 `xmake.lua` 是工程描述文件，内容非常简单，告诉 xmake 添加 `src` 目录下的所有 `.c` 源文件： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"hello\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 目前支持的语言如下： * c/c++ * objc/c++ * cuda * asm * swift * dlang * golang * rust > 如果你想了解更多参数选项，请运行: `xmake create help`。 ## 构建工程 ```bash $ cd hello $ xmake ``` ## 运行程序 ```bash $ xmake run hello ``` ## 调试程序 首先你需要切换到 debug 模式去重新编译程序。 ```bash $ xmake config m debug $ xmake ``` 然后执行下面的命令去开始调试： ```bash $ xmake run d hello ``` xmake 将会使用调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。 ```bash (gdb) b main Breakpoint 1 at 0x115c: file src/main.c, line 4. (gdb) r Starting program: /tmp/test xmake/hello/build/linux/x86_64/debug/hello [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64 linux gnu/libthread_db.so.1\". Breakpoint 1, main (argc 1, argv 0x7fffffffdac8) at src/main.c:4 4 printf(\"hello world!\\n\"); (gdb) ``` 如果想要使用指定的调试器： ```bash $ xmake f debugger gdb $ xmake run d hello ``` > 你也可以使用简写的命令行选项，例如: `xmake r` 或者 `xmake run`。"},"/get_started/zh/tutorial/build-policies.html":{"title":"","content":" class: heading_no_counter # 构建策略 xmake 有很多的默认行为，比如：自动检测和映射 flags、跨 target 并行构建等，虽然提供了一定的智能化处理，但众口难调，不一定满足所有的用户的使用习惯和需求。 因此 xmake 提供默认构建策略的修改设置，开放给用户一定程度上的可配置性。 它主要通过 [set_policy](https://xmake.io/#/zh cn/manual/project_target?id targetset_policy) 接口来配置。 我们通常可以用它来配置修改 target，package 以及工程整体的一些行为策略。 使用方式如下： ```lua set_policy(\"check.auto_ignore_flags\", false) ``` 只需要在项目根域设置这个配置，就可以禁用 flags 的自动检测和忽略机制，另外 `set_policy` 也可以针对某个特定的 target 局部生效。 ```lua target(\"test\", function() set_policy(\"check.auto_ignore_flags\", false) end) ``` > 另外，如果设置的策略名是无效的，xmake 也会有警告提示。 如果要获取当前 xmake 支持的所有策略配置列表和描述，可以执行下面的命令： ```bash $ xmake l core.project.policy.policies { \"check.auto_map_flags\" { type \"boolean\", description \"Enable map gcc flags to the current compiler and linker automatically.\", default true }, \"build.across_targets_in_parallel\" { type \"boolean\", description \"Enable compile the source files for each target in parallel.\", default true }, \"check.auto_ignore_flags\" { type \"boolean\", description \"Enable check and ignore unsupported flags automatically.\", default true } } ``` 我们也可以通过命令行的方式去设置修改内部的策略: ```bash $ xmake f policies package.fetch_only ``` 默认设置策略名，就是启用状态，当然我们也可以指定设置其他值，禁用它。 ```bash $ xmake f policies package.precompiled:n ``` 或者同时配置多个策略值，用逗号分割。 ```bash $ xmake f policies package.precompiled:n,package.install_only ``` ### check.auto_ignore_flags xmake 默认会对所有 `add_cxflags`, `add_ldflags` 接口设置的原始 flags 进行自动检测，如果检测当前编译器和链接器不支持它们，就会自动忽略。 这通常是很有用的，像一些可选的编译 flags，即使不支持也能正常编译，但是强行设置上去，其他用户在编译的时候，有可能会因为编译器的支持力度不同，出现一定程度的编译失败。 但由于自动检测并不保证100%可靠，有时候会有一定程度的误判，所以某些用户并不喜欢这个设定（尤其是针对交叉编译工具链，更容易出现失败）。 目前如果检测失败，会有警告提示避免用户莫名躺坑，例如： ```bash warning: add_ldflags(\" static\") is ignored, please pass `{force true}` or call `set_policy(\"check.auto_ignore_flags\", false)` if you want to set it. ``` 根据提示，我们可以自己分析判断，是否需要强制设置这个 flags，一种就是通过： ```lua add_ldflags(\" static\", {force true}) ``` 来显示的强制设置上它，跳过自动检测，这对于偶尔的 flags 失败，是很有效快捷的处理方式，但是对于交叉编译时候，一堆的 flags 设置检测不过的情况下，每个都设置 force 太过于繁琐。 这个时候，我们就可以通过 `set_policy` 来对某个 target 或者整个 project 直接禁用默认的自动检测行为： ```lua set_policy(\"check.auto_ignore_flags\", false) target(\"test\", function() add_ldflags(\" static\") end) ``` 然后我们就可以随意设置各种原始 flags，xmake 不会去自动检测和忽略他们了。 ### check.auto_map_flags 这是 xmake 的另外一个对 flags 的智能分析处理，通常像 `add_links`, `add_defines` 这种 xmake 内置的 api 去设置的配置，是具有跨平台特性的，不同编译器平台会自动处理成对应的原始 flags。 但是，有些情况，用户还是需要自己通过 `add_cxflags`, `add_ldflags` 设置原始的编译链接 flags，这些 flags 并不能很好的跨编译器。 就拿 ` O0` 的编译优化 flags 来说，虽然有 `set_optimize` 来实现跨编译器配置，但如果用户直接设置 `add_cxflags(\" O0\")` 呢？gcc/clang 下可以正常处理，但是 msvc 下就不支持了。 也许我们能通过 `if is_plat() then` 来分平台处理，但很繁琐，因此 xmake 内置了 flags 的自动映射功能。 基于 gcc flags 的普及性，xmake 采用 gcc 的 flags 命名规范，对其根据不同的编译实现自动映射，例如： ```lua add_cxflags(\" O0\") ``` 这一行设置，在 gcc/clang 下还是 ` O0`，但如果当前是 msvc 编译器，那边会自动映射为 msvc 对应 ` Od` 编译选项来禁用优化。 整个过程，用户是完全无感知的，直接执行 xmake 就可以跨编译器完成编译。 > 当然，目前的自动映射实现还不是很成熟，没有 100% 覆盖所有 gcc 的 flags，所以还是有不少 flags 是没去映射的。 也有部分用户并不喜欢这种自动映射行为，那么我们可以通过下面的设置完全禁用这个默认的行为： ```bash set_policy(\"check.auto_map_flags\", false) ``` ### build.across_targets_in_parallel 这个策略也是默认开启的，主要用于跨 target 间执行并行构建，v2.3.3 之前的版本，并行构建只能针对单个 target 内部的所有源文件， 跨 target 的编译，必须要要等先前的 target 完全 link 成功，才能执行下一个 target 的编译，这在一定程度上会影响编译速度。 然而每个 target 的源文件是可以完全并行化处理的，最终在一起执行 link 过程，v2.3.3 之后的版本通过这个优化，构建速度提升了30%。 当然，如果有些特殊的 target 里面的构建源文件要依赖先前的 target（尤其是一些自定义 rules 的情况，虽然很少遇到），我们也可以通过下面的设置禁用这个优化行为： ```bash set_policy(\"build.across_targets_in_parallel\", false) ``` ### build.fence 由于配置 `set_policy(\"build.across_targets_in_parallel\", false)` 存在局限性，它会限制父 target 和它的所有依赖的子 target 之间的并行度，影响的范围有点大。 而我们做 codegen 时候，有时候仅仅只是想对其中某个依赖的 target 限制并行度，作为 codegen 程序，提前让它完成编译。 这个时候，`build.across_targets_in_parallel` 就无法精细控制了，编译速度也无法达到最优。 因此，我们新增了 `build.fence` 策略，它可以仅仅只针对特定的子 target 限制并行编译链接。 相关的背景细节，可以看下：[#5003](https://github.com/xmake io/xmake/issues/5003) 例如： ```lua target(\"autogen\", function() set_default(false) set_kind(\"binary\") set_plat(os.host()) set_arch(os.arch()) add_files(\"src/autogen.cpp\") set_languages(\"c++11\") set_policy(\"build.fence\", true) end) target(\"test\", function() set_kind(\"binary\") add_deps(\"autogen\") add_rules(\"autogen\") add_files(\"src/main.cpp\") add_files(\"src/*.in\") end) ``` 其中 autogen 目标程序需要在 test 程序的源码被编译前，就要完成编译链接，因为 test 目标需要运行 autogen 程序，去动态生成一些源码参与编译。 而针对 autogen 配置 `set_policy(\"build.fence\", true)` 就可以实现这个目的。 ### build.merge_archive 如果设置了这个策略，那么使用 `add_deps()` 依赖的目标库不再作为链接存在，而是直接把它们合并到父目标库中去。 例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"add\", function() set_kind(\"static\") add_files(\"src/add.c\") add_files(\"src/subdir/add.c\") end) target(\"sub\", function() set_kind(\"static\") add_files(\"src/sub.c\") add_files(\"src/subdir/sub.c\") end) target(\"mul\", function() set_kind(\"static\") add_deps(\"add\", \"sub\") add_files(\"src/mul.c\") set_policy(\"build.merge_archive\", true) end) target(\"test\", function() add_deps(\"mul\") add_files(\"src/main.c\") end) ``` libmul.a 静态库会自动合并 libadd.a 和 libsub.a 两个子依赖的静态库。 ### build.ccache Xmake 默认是开启内置的编译缓存的，通过设置这个策略，可以显式禁用缓存。 ```lua set_policy(\"build.ccache\", false) ``` 当然，我们也可以命令行去禁用它。 ```bash $ xmake f ccache n ``` 或者 ```bash $ xmake f policies build.ccache:n ``` ### build.warning 默认编译通常不会实时回显警告输出，我们通常需要使用 `xmake w` 开启，或者通过 `xmake g build_warning y` 来全局开启它。 现在，我们也可以在 xmake.lua 配置中去默认启用警告回显输出。 ```lua set_policy(\"build.warning\", true) set_warnings(\"all\", \"extra\") ``` 这个时候，即使我们执行 `xmake` 命令，也能直接回显警告输出。 ### build.optimization.lto xmake 改进了对 LTO 链接时优化的支持，对 gcc/clang/msvc 等不同平台下都进行了适配，只需要启用这个策略，就能对特定 target 开启 LTO。 ```lua set_policy(\"build.optimization.lto\", true) ``` 我们也可以通过命令行选项快速开启。 ```bash $ xmake f policies build.optimization.lto ``` ### build.cuda.devlink 可以通过这个配置，显示开启对特定目标的设备链接。 这通常用于 Cuda 项目的构建，以及非 Cuda binary/shared 依赖 Cuda static 目标的情况，这个时候，Cuda static 目标就需要显示配置这个，开启设备链接。 ```lua target(\"test\", function() set_kind(\"static\") set_policy(\"build.cuda.devlink\", true) end) ``` 而默认 Cuda binary/shared 是开启 devlink 的，我们也可以通过策略显示禁用它。 关于这个的详细背景说明，见：[#1976](https://github.com/xmake io/xmake/issues/1976) ### build.sanitizer.address Address Sanitizer（ASan）是一个快速的内存错误检测工具，由编译器内置支持，通常我们需要在编译和链接的 flags 中同时配置 ` fsanitize address` 才能正确开启。 而我们可以通过开启这个策略，就可以快速全局启用它，这会使得编译出来的程序，直接支持 ASan 检测。 例如，我们可以通过命令行的方式去启用： ```bash $ xmake f policies build.sanitizer.address ``` 也可以通过接口配置去全局启用： ```lua set_policy(\"build.sanitizer.address\", true) ``` 当然，我们也可以单独对某个特定的 target 去配置开启。 另外，如果全局配置它，我们就可以同时对所有依赖包也生效。 ```lua set_policy(\"build.sanitizer.address\", true) add_requires(\"zlib\") add_requires(\"libpng\") ``` 它等价于，对每个包依次设置 asan 配置。 ```lua add_requires(\"zlib\", {configs {asan true}}) add_requires(\"libpng\", {configs {asan true}}) ``` > `add_rules(\"mode.asan\", \"mode.tsan\", \"mode.ubsan\", \"mode.msan\")` 将被废弃，尽可能使用这些新的策略，因为这些构建模式无法同步对依赖包生效。 另外，我们也可以同时生效多个 sanitizer 检测，例如： ```lua set_policy(\"build.sanitizer.address\", true) set_policy(\"build.sanitizer.undefined\", true) ``` 或者 ``` $ xmake f policies build.sanitizer.address,build.sanitizer.undefined ``` ### build.sanitizer.thread 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测线程安全问题。 ### build.sanitizer.memory 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测内存问题。 ### build.sanitizer.leak 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测内存泄漏问题。 ### build.sanitizer.undefined 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测 undefined 问题。 ### build.always_update_configfiles 这个策略用于对 `add_configfiles` 配置文件的自动生成行为。默认情况下，xmake 仅仅只会在首次 `xmake config` 时候，或者 xmake.lua 配置有改动的是否，才会触发 configfiles 的重新生成。 之后的每次构建，只要配置没有变化，就不会重新生成 configfiles。 但是，如果我们的 configfiles 中有使用 GIT_COMMIT 等变量，想要每次构建时候，总是重新生成最新的配置，那么可以配置它。 具体使用背景，可以看下：[#4747](https://github.com/xmake io/xmake/issues/4747) ### build.intermediate_directory 配置启用或禁用构建的内部子目录。 默认情况下，执行 `xmake` 编译项目会自动在 build 目录下根据平台。架构，编译模式生成子目录，分别存储对象文件，目标文件。例如： ```bash build/ └── macosx └── x86_64 └── release └─test ``` 如果配置禁用此策略，那么生成的产物将会直接生成到 build 根目录下。变成： ```bash build/ └─ test ``` ### build.rpath 配置启用或者禁用构建时的 target rpath 设置。 默认情况下，如果 `target(foo)` 依赖动态库 bar，那么生成的 foo 可执行文件会自动加上 bar 的 rpath，这能保证用户直接执行 foo 程序，也能正确找到 bar。 如果你想禁用这个行为，可以显式配置禁用它。 ### install.rpath 尽管构建后的程序，会被设置 rpath，但是当 `xmake install` 安装后，它构建时候的 rpath 就不一定完全适用了，因此 xmake 会自动修改调整 rpath，使得安装后的程序，同样可以找到它的依赖库。 不过前提是，用户自己先得通过 `add_rpathdirs(\"/xxx\", {installonly true})` 去配置独立的安装 rpath。 而我们也可以通过这个 policy 去禁用默认的安装阶段 rpath 设置行为。 ### run.autobuild 这个策略用于调整 `xmake run` 的行为，默认情况下，执行 `xmake run` 并不会自动构建目标程序，如果程序还没被编译，就是提示用户手动构建一下。 而开启这个策略，我们就可以在运行程序前，先自动构建对应的目标程序。 ```bash $ xmake f policies run.autobuild $ xmake run ``` 如果想要全局生效这个策略，可以全局开启它。 ```bash $ xmake g policies run.autobuild ``` ### preprocessor.linemarkers 通常用户编译缓存中，预处理器的生成策略，默认开启，如果配置关闭这个策略，那么缓存生成的预处理文件内容将不包含 linemarkers 信息，这会极大减少预处理文件大小。 也会提升缓存的处理效率，但是缺点就是会丢失源码行信息，如果遇到编译错误，将无法看到准确的出错代码行。 ### preprocessor.gcc.directives_only 这也是用于预处理器的策略，默认开启，这会提升 gcc 下编译缓存预处理的效率，但是如果源文件中包含 `__DATE__`, `__TIME__` 等宏，就会导致缓存出现不一致。 因此，可以根据自身工程代码，按需关闭此策略，确保生成的结果一致。 ### package.requires_lock 可用于开启 `add_requires()` 引入的依赖包的版本锁定。 具体看下：[依赖包的锁定和升级](https://xmake.io/#/zh cn/package/remote_package?id %e4%be%9d%e8%b5%96%e5%8c%85%e7%9a%84%e9%94%81%e5%ae%9a%e5%92%8c%e5%8d%87%e7%ba%a7) ### package.fetch_only 如果开启这个策略，那么所有的依赖包仅仅只会从系统获取，不会从远程下载安装。 ### package.install_only 如果开启这个策略，那么所有的依赖包仅仅只会走远程下载安装，不会从系统查找获取。 ### package.librarydeps.strict_compatibility 默认禁用，如果启用它，那么当前包和它的所有库依赖包之间会保持严格的兼容性，任何依赖包的版本更新，都会强制触发当前包的重新编译安装。 以确保所有的包都是二进制兼容的，不会因为某个依赖包接口改动，导致和其他已被安装的其他包一起链接时候，发生链接和运行错误。 ```lua package(\"foo\") add_deps(\"bar\", \"zoo\") set_policy(\"package.librarydeps.strict_compatibility\", true) ``` 例如，如果 bar 或者 zoo 的版本有更新，那么 foo 也会重新编译安装。 ### package.strict_compatibility 默认禁用，如果启用它，那么当前包和其他所有依赖它的包之间会保持严格的兼容性，这个包的版本更新，都会强制触发其他父包的重新编译安装。 以确保所有的包都是二进制兼容的，不会因为某个依赖包接口改动，导致和其他已被安装的其他包一起链接时候，发生链接和运行错误。 ```lua package(\"foo\", function() set_policy(\"package.strict_compatibility\", true) end) package(\"bar\", function() add_deps(\"foo\") end) package(\"zoo\", function() add_deps(\"foo\") end) ``` 例如，如果 foo 的版本有更新，那么 bar 和 zoo 都会被强制重新编译安装。 ### package.install_always 每次运行 `xmake f c` 重新配置的时候，总是会重新安装包，这对于本地第三方源码包集成时候比较有用。 因为，用户可能随时需要修改第三方源码，然后重新编译集成它们。 之前只能通过每次修改包版本号，来触发重新编译，但是有了这个策略，就能每次都会触发重编。 ```lua add_rules(\"mode.debug\", \"mode.release\") package(\"foo\", function() add_deps(\"cmake\") set_sourcedir(path.join(os.scriptdir(), \"foo\")) set_policy(\"package.install_always\", true) on_install(function (package) local configs {} table.insert(configs, \" DCMAKE_BUILD_TYPE \" .. (package:debug() and \"Debug\" or \"Release\")) table.insert(configs, \" DBUILD_SHARED_LIBS \" .. (package:config(\"shared\") and \"ON\" or \"OFF\")) import(\"package.tools.cmake\").install(package, configs) end) on_test(function (package) assert(package:has_cfuncs(\"add\", {includes \"foo.h\"})) end) end) add_requires(\"foo\") target(\"demo\", function() set_kind(\"binary\") add_files(\"src/main.c\") add_packages(\"foo\") end) ``` ### package.download.http_headers 设置包下载的 http headers 如果有些包的 url 下载，需要设置特定 http headers，才能通过下载，可以通过这个策略来指定。 ```lua package(\"xxx\") set_policy(\"package.download.http_headers\", \"TEST1: foo\", \"TEST2: bar\") ``` 我们也可以设置指定的 urls 的 http headers： ```lua add_urls(\"https://github.com/madler/zlib/archive/$(version).tar.gz\", { http_headers {\"TEST1: foo\", \"TEST2: bar\"} }) ```"},"/get_started/zh/tutorial/builtin-variables.html":{"title":"","content":" class: heading_no_counter # 内置变量 xmake 提供了 `$(varname)` 的语法，来支持内置变量的获取，例如： ```lua add_cxflags(\" I$(buildir)\") ``` 它将会在在实际编译的时候，将内置的 `buildir` 变量转换为实际的构建输出目录：` I./build` 一般内置变量可用于在传参时快速获取和拼接变量字符串，例如： ```lua target(\"test\", function() 添加工程源码目录下的源文件 add_files(\"$(projectdir)/src/*.c\") 添加构建目录下的头文件搜索路径 add_includedirs(\"$(buildir)/inc\") end) ``` 也可以在自定义脚本的模块接口中使用，例如： ```lua target(\"test\", function() on_run(function (target) 复制当前脚本目录下的头文件到输出目录 os.cp(\"$(scriptdir)/xxx.h\", \"$(buildir)/inc\") end) end) ``` 所有的内置变量，也可以通过 [val](#val) 接口，来获取他们的值。 这种使用内置变量的方式，使得描述编写更加的简洁易读，下面是一些 xmake 内置的变量，可以直接获取： 接口 描述 [$(os)](#varos) 获取当前编译平台的操作系统 [$(host)](#varhost) 获取本机操作系统 [$(tmpdir)](#vartmpdir) 获取临时目录 [$(curdir)](#varcurdir) 获取当前目录 [$(buildir)](#varbuildir) 获取构建输出目录 [$(scriptdir)](#varscriptdir) 获取工程描述脚本目录 [$(globaldir)](#varglobaldir) 获取全局配置目录 [$(configdir)](#varconfigdir) 获取本地工程配置目录 [$(programdir)](#varprogramdir) xmake 安装脚本目录 [$(projectdir)](#varprojectdir) 获取工程根目录 [$(shell)](#varshell) 执行外部 shell 命令 [$(env)](#varenv) 获取外部环境变量 [$(reg)](#varreg) 获取 windows 注册表配置项的值 当然这种变量模式，也是可以扩展的，默认通过 `xmake f var val` 命令，配置的参数都是可以直接获取，例如： ```lua target(\"test\", function() add_defines(\" DTEST $(var)\") end) ``` > 所有 `xmake f xxx ...` 配置的参数值，都是可以通过内置变量获取到，例如：`xmake f arch x86` 对应 `$(arch)`，其他的还有 `$(plat)`, `$(mode)` 等等。 > 具体有哪些参数，可以通过：`xmake f h` 查看。 既然支持直接从配置选项中获取，那么当然也就能很方便的扩展自定义的选项，来获取自定义的变量了，具体如何自定义选项见：[option](#option) ## var.$(os) 获取当前编译平台的操作系统。 如果当前编译的是 iphoneos，那么这个值就是：`ios`，以此类推。 ## var.$(host) 获取本机操作系统。 指的是当前本机环境的主机系统，如果你是在 macOS 上编译，那么系统就是：`macosx` ## var.$(tmpdir) 获取临时目录。 一般用于临时存放一些非永久性文件。 ## var.$(curdir) 获取当前目录。 一般默认是执行 `xmake` 命令时的工程根目录，当然如果通过 [os.cd](#os cd) 改变了目录的话，这个值也会一起改变。 ## var.$(buildir) 获取当前的构建输出目录。 默认一般为当前工程根目录下的：`./build` 目录，也可以通过执行：`xmake f o /tmp/build` 命令来修改默认的输出目录。 ## var.$(scriptdir) 获取当前工程描述脚本的目录。 也就是对应 `xmake.lua` 所在的目录路径。 ## var.$(globaldir) 全局配置目录。 xmake 的 `xmake gglobal` 全局配置命令，数据存储的目录路径，在里面可以放置一些自己的插件、平台脚本。 默认为：`~/.config` ## var.$(configdir) 当前工程配置目录。 当前工程的配置存储目录，也就是 `xmake fconfig` 配置命令的存储目录，默认为：`projectdir/.config` ## var.$(programdir) xmake 安装脚本目录。 也就是 `XMAKE_PROGRAM_DIR` 环境变量所在目录，我们也可以通过设置这个环境量，来修改 xmake 的加载脚本，实现版本切换。 ### var.$(projectdir) 工程根目录。 也就是 `xmake P xxx` 命令中指定的目录路径，默认不指定就是 `xmake` 命令执行时的当前目录，一般用于定位工程文件。 ## var.$(shell) 执行外部 shell 命令。 除了内置的变量处理，xmake 还支持原生 shell 的运行，来处理一些 xmake 内置不支持的功能 例如，现在有个需求，我想用在编译 linux 程序时，调用 `pkg config` 获取到实际的第三方链接库名，可以这么做： ```lua target(\"test\", function() set_kind(\"binary\") if is_plat(\"linux\") then add_ldflags(\"$(shell pkg config libs sqlite3)\") end end) ``` 当然，xmake 有自己的自动化第三库检测机制，一般情况下不需要这么麻烦，而且 lua 自身的脚本化已经很不错了。 但是这个例子可以说明，xmake 是完全可以通过原生 shell，来与一些第三方的工具进行配合使用。 ## var.$(env) 获取外部环境变量。 例如，可以通过获取环境变量中的路径： ```lua target(\"test\", function() add_includedirs(\"$(env PROGRAMFILES)/OpenSSL/inc\") end) ```"},"/get_started/zh/tutorial/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 ## 命名规范 接口的命名，是有按照预定义的一些规范来命名的，这样更加方便理解和易于使用，目前命名按照如下一些规则： 接口规则 描述 `is_`, `has_` 前缀的接口 表示为条件判断 `set_` 前缀的接口 表示为覆盖设置 `add_` 前缀的接口 表示为追加设置 `s` 后缀的接口 表示支持多值传入，例如：`add_files(\"*.c\", \"test.cpp\")` `on_` 前缀的接口 表示为覆盖内置脚本 `before_` 前缀的接口 表示为在内置脚本运行前，执行此脚本 `after_` 前缀的接口 表示为在内置脚本运行后，执行此脚本 `scope(\"name\")` 的接口 表示为定义一个描述域，例如：`target(\"xxx\")`, `option(\"xxx\")` 描述域 / 描述设置 建议缩进表示 ## 条件判断 条件判断的 api，一般用于必须要处理特定平台的编译逻辑的场合。通常跟 lua 的 if 语句配合使用。 ### is_os #### 判断当前构建目标的操作系统 ```lua 如果当前操作系统是 ios if is_os(\"ios\") then add_files(\"src/xxx/*.m\") end ``` 目前支持的操作系统有： * linux * android * macosx * ios ### is_arch #### 判断当前编译架构 用于检测编译配置：`xmake f a armv7` ```lua 如果当前架构是 x86_64 或者 i386 if is_arch(\"x86_64\", \"i386\") then add_files(\"src/xxx/*.c\") end 如果当前平台是 armv7, arm64, armv7s, armv7 a if is_arch(\"armv7\", \"arm64\", \"armv7s\", \"armv7 a\") then ... end ``` 如果像上面那样一个个去判断所有 arm 架构，也许会很繁琐，毕竟每个平台的架构类型很多，xmake 提供了比 [add_files](#targetadd_files) 更强的 lua 正则表达式匹配模式，来更加简洁的进行判断： ```lua 如果当前平台是 arm 平台 if is_arch(\"arm.*\") then ... end ``` 用 `.*` 就可以匹配所有了。 ### is_plat #### 判断当前编译平台 用于检测编译配置：`xmake f p iphoneos` ```lua 如果当前平台是 android if is_plat(\"android\") then add_files(\"src/xxx/*.c\") end 如果当前平台是 macosx 或者 iphoneos if is_plat(\"macosx\", \"iphoneos\") then add_frameworks(\"Foundation\") end ``` 目前支持的平台有： * cross * linux * macosx * android * iphoneos * watchos 当然你也可以自己扩展添加自己的平台，甚至直接指定自己的平台名： ```bash $ xmake f p other sdk ... ``` 如果指定的平台名不存在，就会自动切到 `cross` 平台进行交叉编译，但是却可以通过 `is_plat(\"other\")` 来判断自己的平台逻辑。 ### is_host #### 判断当前主机环境的操作系统 有些编译平台是可以在多个不同的操作系统进行构建的，例如：android 的 ndk 就支持 linux 和 macOS 环境。 这个时候就可以通过这个接口，区分当前是在哪个系统环境下进行的构建。 ```lua 如果当前主机环境是 linux if is_host(\"linux\") then add_includedirs(\"/usr/includess\") else add_includedirs(\".\") end ``` 目前支持的主机环境有： * linux * macosx 你也可以通过 [$(host)](/zh cn/manual/builtin_variables?id varhost) 内置变量或者 [os.host](/zh cn/manual/builtin_modules?id oshost) 接口，来进行获取 ### is_cross #### 判断当前平台是否为交叉编译 如果当前的目标架构和平台，不是当前的主机平台，属于交叉编译，这个接口就会返回 true。 ### is_mode #### 判断当前编译模式 用于检测编译配置：`xmake f m debug` 编译模式的类型并不是内置的，可以自由指定，一般指定：`debug`, `release`, `profile` 这些就够用了，当然你也可以在 xmake.lua 使用其他模式名来判断。 ```lua 如果当前编译模式是 debug if is_mode(\"debug\") then 添加 DEBUG 编译宏 add_defines(\"DEBUG\") 启用调试符号 set_symbols(\"debug\") 禁用优化 set_optimize(\"none\") end 如果是 release 或者 profile 模式 if is_mode(\"release\", \"profile\") then 如果是 release 模式 if is_mode(\"release\") then 隐藏符号 set_symbols(\"hidden\") strip 所有符号 set_strip(\"all\") 忽略帧指针 add_cxflags(\" fomit frame pointer\") add_mxflags(\" fomit frame pointer\") 如果是 profile 模式 else 启用调试符号 set_symbols(\"debug\") end 添加扩展指令集 add_vectorexts(\"sse2\", \"sse3\", \"ssse3\", \"mmx\") end ``` ### is_kind #### 判断当前编译类型 判断当前是否编译的是动态库还是静态库，用于检测编译配置：`xmake f k [staticshared]` 一般用于如下场景： ```lua target(\"test\") 通过配置设置目标的 kind set_kind(\"$(kind)\") add_files(\"src/*c\") 如果当前编译的是静态库，那么添加指定文件 if is_kind(\"static\") then add_files(\"src/xxx.c\") end ``` 编译配置的时候，可手动切换，编译类型： ```bash # 编译静态库 $ xmake f k static $ xmake ``` ```bash # 编译动态库 $ xmake f k shared $ xmake ``` ### is_config #### 判断指定配置是否为给定的值 用于判断指定配置是否为给定的值，可用于描述域。 例如： ```console $ xmake f test hello1 ``` ```lua 自定义一个配置选项到命令行菜单 option(\"test\", function() set_showmenu(true) set_description(\"The test config option\") end) 如果自定义的 test 配置值是 hello1 或者 hello2 if is_config(\"test\", \"hello1\", \"hello2\") then add_defines(\"HELLO\") end ``` 可以用来根据配置值增加对应的依赖包，例如： ```lua 根据 lua_flavor 的配置值，选择依赖 lua 还是 luajit option(\"lua_flavor\", function() set_showmenu(true) set_values(\"luajit\", \"lua\") end) if is_config(\"lua_flavor\", \"luajit\") then add_requires(\"luajit\") elseif is_config(\"lua_flavor\", \"lua\") then add_requires(\"lua\") end ``` 不仅如此，我们还可以设置模式匹配规则去判断值，例如： ```lua 如果自定义的 test 配置值带有 hello 前缀 if is_config(\"test\", \"hello.*\") then add_defines(\"HELLO\") end ``` > 此接口不仅能够判断通过 [option](#option) 定义的自定义配置选项，同时还能判断内置的全局配置、本地配置 ### has_config #### 判断配置是否启用或者存在 用于检测自定义或者内置的编译配置是否存在或启用，可用于描述域。 例如以下配置情况，都会返回 true: ```console # 启用某个配置选项（如果是 boolean 类型配置） $ xmake f test1 y $ xmake f test1 yes $ xmake f test1 true # 设置某个配置选项的值 $ xmake f test2 value ``` ```lua 如果 test1 或者 test2 被设置或者启用 if has_config(\"test1\", \"test2\") then add_defines(\"TEST\") end ``` 而下面的情况则会禁用配置，返回 false： ```console # 禁用配置（如果是 boolean 类型配置） $ xmake f test1 n $ xmake f test1 no $ xmake f test1 false ``` > 此接口不仅能够判断内置的全局配置、本地配置，同时还可以判断通过 [option](#option) 定义的自定义配置选项。 ### has_package #### 判断依赖包是否启用或者存在 此接口用于检测远程依赖包是否存在或启用，可用于描述域。 一般配合 [add_requires](/zh cn/manual/global_interfaces?id add_requires) 一起使用，例如： ```lua add_requires(\"tbox\", {optional true}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"tbox\") if has_package(\"tbox\") then add_defines(\"HAVE_TBOX\") end end) ``` 如果通过 `add_requires` 添加的可选依赖包，远程下载安装失败，或者当前平台不支持导致实际上没有被正常安装上，那么 `has_package` 就会返回 false，表示不存在，然后对其他 flags 定义甚至源文件编译控制做一些特殊处理。 > 此接口跟 [has_config](#has_config) 的区别在于，[has_config](#has_config) 用于 [option](#option)，而它用于 [add_requires](#add_requires)。 ## 全局接口 全局接口影响整个工程描述，被调用后，后面被包含进来的所有子 `xmake.lua` 都会受影响。 ### includes #### 添加子工程文件和目录 我们能够使用此接口添加工程子文件 (xmake.lua) 或者带有 xmake.lua 的工程子目录。 ``` projectdir subdirs xmake.lua src ``` 添加子工程目录： ```lua includes(\"subdirs\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 或者添加子工程文件： ```lua includes(\"subdirs/xmake.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 我们也可以通过模式匹配的方式，递归添加多个工程子目录文件： ```lua includes(\"**/xmake.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` includes 包含内置的一些辅助配置脚本，例如： ```lua includes(\"@builtin/check\") ``` 会引入内置提供的一些检测辅助接口。 还有 ```lua includes(\"@builtin/qt\") ``` 会引入一些内置的 Qt 相关辅助接口。 其中 `@builtin` 是告诉 xmake 从内置的 includes 目录中引入配置脚本。 也就是这个路径下的配置文件：[includes](https://github.com/xmake io/xmake/tree/master/xmake/includes) 我们可以向上面那样，按目录整个引入，也可以引入单个配置文件，例如： ```lua includes(\"@builtin/check/check_cfuncs.lua\") ``` 仅仅引入 check 目录下 check_cfuncs 相关的辅助脚本。 而通过 `@builtin` 我们就能很好的区分是引入当前用户工程目录下的文件，还是 xmake 安装目录下的内置文件。 ### set_project #### 设置工程名 设置工程名，在 doxygen 自动文档生成插件、工程文件生成插件中会用到，一般设置在 xmake.lua 的最开头，当然放在其他地方也是可以的 ```lua 设置工程名 set_project(\"xutil\") 设置工程版本 set_version(\"1.5.1\") ``` ### set_version #### 设置工程版本 设置项目版本，可以放在 xmake.lua 任何地方，一般放在最开头，例如： ```lua set_version(\"1.5.1\") ``` 支持 buildversion 的配置： ```lua set_version(\"1.5.1\", {build \"%Y%m%d%H%M\"}) ``` 我们也能够添加版本宏定义到头文件，请参考：[add_configfiles](/manual/project_target?id add template configuration files) > 我们可以全局设置版本，但现在我们也可以在 target 域去单独设置它。 同时支持配置 soname 版本，用于控制 so/dylib 动态库的版本兼容性控制。 我们可以配置 soname 的版本后缀名称，xmake 会在编译、安装动态库的时候，自动生成符号链接，执行指定版本的动态库。 例如，如果我们配置： ```lua set_version(\"1.0.1\", {soname true}) ``` xmake 会自动解析版本号的 major 版本作为 soname 版本，生成的结构如下： ``` └── lib ├── libfoo.1.0.1.dylib ├── libfoo.1.dylib > libfoo.1.0.1.dylib └── libfoo.dylib > libfoo.1.dylib ``` 当然，我们也可以指定 soname 到特定的版本命名： ```lua set_version(\"1.0.1\", {soname \"1.0\"}) > libfoo.so.1.0, libfoo.1.0.dylib set_version(\"1.0.1\", {soname \"1\"}) > libfoo.so.1, libfoo.1.dylib set_version(\"1.0.1\", {soname \"A\"}) > libfoo.so.A, libfoo.A.dylib set_version(\"1.0.1\", {soname \"\"}) > libfoo.so, libfoo.dylib ``` 而如果没设置 soname，那么默认不开启 soname 版本兼容控制： ```lua set_version(\"1.0.1\") > libfoo.so, libfoo.dylib ``` ### set_xmakever #### 设置最小 xmake 版本 用于处理 xmake 版本兼容性问题，如果项目的 `xmake.lua`，通过这个接口设置了最小 xmake 版本支持，那么用户环境装的 xmake 低于要求的版本，就会提示错误。 一般情况下，建议默认对其进行设置，这样对用户比较友好，如果 `xmake.lua` 中用到了高版本的 api 接口，用户那边至少可以知道是否因为版本不对导致的构建失败。 设置如下： ```lua 设置最小版本为：2.1.0，低于此版本的 xmake 编译此工程将会提示版本错误信息 set_xmakever(\"2.1.0\") ``` ### add_moduledirs #### 添加模块目录 xmake 内置的扩展模块都在 `xmake/modules` 目录下，可通过 [import](#import) 来导入他们，如果自己在工程里面实现了一些扩展模块， 可以放置在这个接口指定的目录下，import 也就会能找到，并且优先进行导入。 ### add_plugindirs #### 添加插件目录 xmake 内置的插件都是放在 `xmake/plugins` 目录下，但是对于用户自定义的一些特定工程的插件，如果不想放置在 xmake 安装目录下，那么可以在 `xmake.lua` 中进行配置指定的其他插件路径。 ```lua 将当前工程下的 plugins 目录设置为自定义插件目录 add_plugindirs(\"$(projectdir)/plugins\") ``` 这样，xmake 在编译此工程的时候，也就加载这些插件。 ### get_config #### 获取给定的配置值 此接口用于快速获取给定的配置值，可用于描述域。 ```lua if get_config(\"myconfig\") \"xxx\" then add_defines(\"HELLO\") end ``` ### set_config #### 设置给定的默认配置值 此接口从 2.2.2 版本开始引入，用于快速在 xmake.lua 中设置一个默认配置值，仅用于描述域。 之前很多配置，包括编译工具链，构建目录等只能通过 `$ xmake f name value` 的方式来配置，如果我们想写死在 xmake.lua 提供一个默认值，就可以通过下面的方式来配置： ```lua set_config(\"name\", \"value\") set_config(\"buildir\", \"other/buildir\") set_config(\"cc\", \"gcc\") set_config(\"ld\", \"g++\") ``` 不过，我们还是可以通过 `$ xmake f name value` 的方式，去修改 xmake.lua 中的默认配置。 ### add_requires #### 添加需要的依赖包 xmake 的依赖包管理是完全支持语义版本选择的，例如：\"~1.6.1\"，对于语义版本的具体描述见：[https://semver.org/](https://semver.org/) ##### 语义版本 ```lua add_requires(\"tbox 1.6.*\", \"pcre 8.x\", \"libpng ^1.18\") add_requires(\"libpng ~1.16\", \"zlib 1.1.2 > 1.2.11 <1.3.0\") ``` 目前 xmake 使用的语义版本解析器是 [uael](https://github.com/uael) 贡献的 [sv](https://github.com/uael/sv) 库，里面也有对版本描述写法的详细说明，可以参考下：[版本描述说明](https://github.com/uael/sv#versions) ##### 最近版本 当然，如果我们对当前的依赖包的版本没有特殊要求，那么可以直接这么写： ```lua add_requires(\"tbox\", \"libpng\", \"zlib\") ``` 默认，没设置版本号，xmake 会选取最近版本的包，等价于 `add_requires(\"zlib latest\")` ##### 分支选择 这会使用已知的最新版本包，或者是 master 分支的源码编译的包，如果当前包有 git repo 地址，我们也能指定特定分支版本： ```lua add_requires(\"tbox master\") add_requires(\"tbox dev\") ``` 如果指定的依赖包当前平台不支持，或者编译安装失败了，那么 xmake 会编译报错，这对于有些必须要依赖某些包才能工作的项目，这是合理的。 但是如果有些包是可选的依赖，即使没有也可以正常编译使用的话，可以设置为可选包： ##### Git commit 选择 我们可以对 git 维护的包直接指定 git commit 来选择版本。 ```lua add_requires(\"tbox e807230557aac69e4d583c75626e3a7ebdb922f8\") ``` ##### 可选包 ```lua add_requires(\"zlib\", {optional true}) ``` ##### 禁用系统包 默认的设置，xmake 会去优先检测系统库是否存在（如果没设置版本要求），如果用户完全不想使用系统库以及第三方包管理提供的库，那么可以设置： ```lua add_requires(\"zlib\", {system false}) ``` ##### 禁用包校验 默认包安装，对于下载的包都是会去自动校验完整性，避免被篡改，但是如果安装一些未知新版本的包，就不行了。 用户可以通过 `{verify false}` 强行禁用包完整性校验来临时安装他们（但通常不推荐这么做）。 ```lua add_requires(\"zlib\", {verify false}) ``` ##### 使用调试包 如果我们想同时源码调试依赖包，那么可以设置为使用 debug 版本的包（当然前提是这个包支持 debug 编译）： ```lua add_requires(\"zlib\", {debug true}) ``` 如果当前包还不支持 debug 编译，可在仓库中提交修改编译规则，对 debug 进行支持，例如： ```lua package(\"openssl\", function() on_install(\"linux\", \"macosx\", function (package) os.vrun(\"./config %s prefix \\\"%s\\\"\", package:debug() and\" debug\"or\"\", package:installdir()) os.vrun(\"make j4\") os.vrun(\"make install\") end) end) ``` ##### 作为私有包使用 如果这个包，我们仅仅用于包定义，不想对外默认导出 links/linkdirs 信息，可以作为私有包提供。 这通常对于做包时候，很有用。 ```lua package(\"test\") add_deps(\"zlib\", {private true}) on_install(function (package) local zlib package:dep(\"zlib\"):fetch() TODO end) ``` 如果自己定义的一个 test 包，私有依赖一个 zlib 包，等待 zlib 安装完成后，获取里面的包文件信息做进一步处理安装，但是 zlib 包本身不会再对外导出 links/linkdirs。 尽管，`add_requires` 也支持这个选项，但是不对外导出 links/linkdirs，所以通常不会去这么用，仅仅对于做包很有帮助。 ##### 使用动态库 默认的包安装的是静态库，如果要启用动态库，可以配置如下： ```lua add_requires(\"zlib\", {configs {shared true}}) ``` > 当然，前提是这个包的定义里面，有对 `package:config(\"shared\")` 判断处理，官方 xmake repo 仓库里面，通常都是严格区分支持的。 ##### 禁用 pic 支持 默认安装的 linux 包，都是开启 pic 编译的，这对于动态库中依赖静态库非常有用，但如果想禁用 pic，也是可以的。 ```lua add_requires(\"zlib\", {configs {pic false}}) ``` ##### 特定配置包 某些包在编译时候有各种编译选项，我们也可以传递进来： ```lua add_requires(\"boost\", {configs {context true, coroutine true}}) ``` 比如上面，安装的 boost 包，是启用了它内部的一些子模块特性（带有协程模块支持的包）。 当然，具体支持哪些配置，每个包都是不同的，可以通过 `xmake require info boost` 命令查看里面的 configs 部分列表。 因为，每个包定义里面，都会有自己的配置选项，并且通过 `package:config(\"coroutine\")` 在安装时候去判断启用它们。 ##### 安装第三方管理器的包 目前支持安装下面这些第三方包管理器中包。 * Conan (conan::openssl/1.1.1g) * Conda (conda::libpng 1.3.67) * Vcpkg (vcpkg::ffmpeg) * Homebrew/Linuxbrew (brew::pcre2/libpcre2 8) * Pacman on archlinux/msys2 (pacman::libcurl) * Apt on ubuntu/debian (apt::zlib1g dev) * Clib (clib::clibs/bytes@0.0.4) * Dub (dub::log 0.4.3) * Portage on Gentoo/Linux (portage::libhandy) 例如添加 conan 的依赖包： ```lua add_requires(\"conan::zlib/1.2.11\", {alias \"zlib\", debug true}) add_requires(\"conan::openssl/1.1.1g\", {alias \"openssl\", configs {options \"OpenSSL:shared True\"}}) target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"openssl\", \"zlib\") ``` 执行 xmake 进行编译后： ```console ruki:test_package ruki$ xmake checking for the architecture ... x86_64 checking for the Xcode directory ... /Applications/Xcode.app checking for the SDK version of Xcode ... 10.14 note: try installing these packages (pass y to skip confirm)? > conan::zlib/1.2.11 (debug) > conan::openssl/1.1.1g please input: y (y/n) > installing conan::zlib/1.2.11 .. ok > installing conan::openssl/1.1.1g .. ok [0%]: cache compiling.release src/main.c [100%]: linking.release test ``` 关于这个的完整介绍和所有第三方包的安装使用，可以参考文档：[第三方依赖包安装](https://xmake.io/#/zh cn/package/remote_package?id %e7%ac%ac%e4%b8%89%e6%96%b9%e4%be%9d%e8%b5%96%e5%8c%85%e5%ae%89%e8%a3%85) ##### 另一种简化的配置语法 我们通常使用的常用配置语法： ```lua add_requires(\"boost> 1.78.0\", {configs {iostreams true, system true, thread true}}) ``` 对于大部分 boolean 配置，我们可以通过下面的写法，去简化配置。 ```lua add_requires(\"boost[iostreams,system,thread] > 1.78.0\") ``` 这对于 `xrepo install` 独立 cli 命令下带复杂配置的安装，会省事不少，用户可以根据自己的喜好需求，选择使用。 ```console xrepo install boost[iostreams,system,thread] ``` 另外，除了 boolean 配置，还支持 string 和 array 配置值。boolean 值，也可以设置 ` n/y` 去禁用和启用。 ```lua add_requires(\"boost[iostreams,system,thread,key value] > 1.78.0\") add_requires(\"boost[iostreams y,thread n] > 1.78.0\") add_requires(\"ffmpeg[shared,debug,codecs [foo,bar,zoo]]\") ``` ### add_requireconfs #### 设置指定依赖包的配置 我们可以用这个接口来对 `add_requires()` 定义的包和它的依赖包的配置进行扩充和改写，它有下面几种用法。 ##### 扩充指定包的配置 这是基本用法，比如我们已经通过 `add_requires(\"zlib\")` 声明了一个包，想要在后面对这个 zlib 的配置进行扩展，改成动态库编译，可以通过下面的方式配置。 ```lua add_requires(\"zlib\") add_requireconfs(\"zlib\", {configs {shared true}}) ``` 它等价于 ```lua add_requires(\"zlib\", {configs {shared true}}) ``` ##### 设置通用的默认配置 上面的用法，我们还看不出有什么实际用处，但如果依赖多了就能看出效果了，比如下面这样： ```lua add_requires(\"zlib\", {configs {shared true}}) add_requires(\"pcre\", {configs {shared true}}) add_requires(\"libpng\", {configs {shared true}}) add_requires(\"libwebp\", {configs {shared true}}) add_requires(\"libcurl\", {configs {shared false}}) ``` 是不是非常繁琐，如果我们用上 `add_requireconfs` 来设置默认配置，就可以极大的简化成下面的配置： ```lua add_requireconfs(\"*\", {configs {shared true}}) add_requires(\"zlib\") add_requires(\"pcre\") add_requires(\"libpng\") add_requires(\"libwebp\") add_requires(\"libcurl\", {configs {shared false}}) ``` 上面的配置，我们通过 `add_requireconfs(\"*\", {configs {shared true}})` 使用模式匹配的方式，设置所有的依赖包默认走动态库编译安装。 但是，我们又通过 `add_requires(\"libcurl\", {configs {shared false}})` 将 libcurl 进行了特殊配置，强制走静态库编译安装。 最终的配置结果为：zlib/pcre/libpng/libwebp 是 shared 库，libcurl 是静态库。 我们通过模式匹配的方式，可以将一些每个包的常用配置都放置到统一的 `add_requireconfs` 中去预先配置好，极大简化每个 `add_requires` 的定义。 > 默认情况下，对于相同的配置，xmake 会优先使用 add_requires 中的配置，而不是 add_requireconfs。 如果 `add_requires(\"zlib 1.2.11\")` 中设置了版本，就会优先使用 add_requires 的配置，完全忽略 add_requireconfs 里面的版本配置，当然我们也可以通过 override 来完全重写 `add_requires` 中指定的版本。 ```lua add_requires(\"zlib 1.2.11\") add_requireconfs(\"zlib\", {override true, version \"1.2.10\"}) ``` ##### 改写包依赖配置 其实 `add_requireconfs` 最大的用处是可以让用户改写安装包的特定依赖包的配置。 什么意思呢，比如我们项目中集成使用 libpng 这个包，并且使用了动态库版本，但是 libpng 内部依赖的 zlib 库其实还是静态库版本。 ```lua add_requires(\"libpng\", {configs {shared true}}) ``` 那如果我们想让 libpng 依赖的 zlib 包也改成动态库编译，应该怎么配置呢？这就需要 `add_requireconfs` 了。 ```lua add_requires(\"libpng\", {configs {shared true}}) add_requireconfs(\"libpng.zlib\", {configs {shared true}}) ``` 通过 `libpng.zlib` 依赖路径的写法，指定内部某个依赖，改写内部依赖配置。 如果依赖路径很深，比如 `foo > bar > xyz` 的依赖链，我们可以写成：`foo.bar.xyz` 我们也可以改写 libpng 依赖的内部 zlib 库版本： ```lua add_requires(\"libpng\") add_requireconfs(\"libpng.zlib\", {override true, version \"1.2.10\"}) ``` ##### 级联依赖的模式匹配 如果一个包的依赖非常多，且依赖层次也很深，怎么办呢，比如 libwebp 这个包，它的依赖有： ``` libwebp libpng zlib cmake libjpeg libtiff zlib giflib cmake ``` 如果我想改写 libwebp 里面的所有的依赖库都加上特定配置，那么挨个配置，就会非常繁琐，这个时候就需要 `add_requireconfs()` 的递归依赖模式匹配来支持了。 ```lua add_requires(\"libwebp\") add_requireconfs(\"libwebp.**cmake\", {configs {cxflags \" DTEST\"}}) ``` 上面的配置，我们将 libwebp 中所以的库依赖就额外加上了 ` DTEST` 来编译，但是 cmake 依赖属于构建工具依赖，我们可以通过 `xxx` 的方式排除它。 这里的模式匹配写法，与 `add_files()` 非常类似。 我们在给几个例子，比如这回我们只改写 libwebp 下单级的依赖配置，启用调试库： ```lua add_requires(\"libwebp\") add_requireconfs(\"libwebp.*cmake\", {debug true}) ``` ### add_repositories #### 添加依赖包仓库 如果需要的包不在官方仓库 [xmake repo](https://github.com/xmake io/xmake repo) 中，我们可以提交贡献代码到仓库进行支持。 但如果有些包仅用于个人或者私有项目，我们可以建立一个私有仓库 repo，仓库组织结构可参考：[xmake repo](https://github.com/xmake io/xmake repo) 比如，现在我们有一个一个私有仓库 repo：`git@github.com:myrepo/xmake repo.git` 我们可以通过此接口来添加： ```lua add_repositories(\"my repo git@github.com:myrepo/xmake repo.git\") ``` 如果我们只是想添加一两个私有包，这个时候特定去建立一个 git repo 太小题大做了，我们可以直接把包仓库放置项目里面，例如： ``` projectdir myrepo packages t/tbox/xmake.lua z/zlib/xmake.lua src main.c xmake.lua ``` 上面 myrepo 目录就是自己的私有包仓库，内置在自己的项目里面，然后在 xmake.lua 里面添加一下这个仓库位置： ```lua add_repositories(\"my repo myrepo\") ``` 这个可以参考 [benchbox](https://github.com/tboox/benchbox) 项目，里面就内置了一个私有仓库。 注：其中 myrepo 是 xmake 命令执行目录的相对路径，它不会自动根据配置文件所在目录自动转换，如果想要设置到相对于当前 xmake.lua 文件的路径，可以通过 rootdir 参数指定。 ```lua add_repositories(\"my repo myrepo\", {rootdir os.scriptdir()}) ``` 不过这个参数设置只有 v2.5.7 以上版本才支持。 ### set_defaultplat #### 设置默认的编译平台 用于设置工程默认的编译平台，如果没有设置，默认平台跟随当前系统平台，也就是 os.host()。 比如，在 macOS 上默认编译平台是 macosx，如果当前项目是 ios 项目，那么可以设置默认编译平台为 iphoneos。 ```lua set_defaultplat(\"iphoneos\") ``` 它等价于，`xmake f p iphoneos`。 ### set_defaultarchs #### 设置默认的编译架构 用于设置工程默认的编译架构，如果没有设置，默认平台跟随当前系统架构，也就是 os.arch()。 ```lua set_defaultplat(\"iphoneos\") set_defaultarchs(\"arm64\") ``` 它等价于，`xmake f p iphoneos a arm64`。 我们也可以设置多个平台下的默认架构。 ```lua set_defaultarchs(\"iphoneosarm64\", \"windowsx64\") ``` 在 iphoneos 上默认编译 arm64 架构，在 windows 上默认编译 x64 架构。 ### set_defaultmode #### 设置默认的编译模式 用于设置工程默认的编译模式，如果没有设置，默认是 release 模式编译。 ```lua set_defaultmode(\"releasedbg\") ``` 它等价于，`xmake f m releasedbg`。 ### set_allowedplats #### 设置允许编译的平台列表 用于设置工程支持的编译平台列表，如果用户指定了其他平台，会提示错误，这通常用于限制用户指定错误的无效平台。 如果没有设置，那么没有任何平台限制。 ```lua set_allowedplats(\"windows\", \"mingw\") ``` 设置当前项目仅仅支持 windows 和 mingw 平台。 ### set_allowedarchs #### 设置允许编译的平台架构 用于设置工程支持的编译架构列表，如果用户指定了其他架构，会提示错误，这通常用于限制用户指定错误的无效架构。 如果没有设置，那么没有任何架构限制。 ```lua set_allowedarchs(\"x64\", \"x86\") ``` 当前项目，仅仅支持 x64/x86 平台。 我们也可以同时指定多个平台下允许的架构列表。 ```lua set_allowedarchs(\"windowsx64\", \"iphoneosarm64\") ``` 设置当前项目在 windows 上仅仅支持 x64 架构，并且在 iphoneos 上仅仅支持 arm64 架构。 ### set_allowedmodes #### 设置允许的编译模式列表 用于设置工程支持的编译模式列表，如果用户指定了其他模式，会提示错误，这通常用于限制用户指定错误的无效模式。 如果没有设置，那么没有任何模式限制。 ```lua set_allowedmodes(\"release\", \"releasedbg\") ``` 设置当前项目仅仅支持 release/releasedbg 两个编译模式。 ## 辅助接口 ### 自动检测辅助接口 xmake 提供了一些内置的辅助函数，可以直接使用 includes 导入，具体有哪些内置函数可以看下：[Helper functions](https://github.com/xmake io/xmake/tree/master/xmake/includes) 我们可以使用这些接口，检测 links, c/c++ type, includes 和 编译器特性，并且写入宏定义到 config.h 其中，我们提供了两类接口，`check_xxx` 和 `configvar_check_xxx`，带有 `configvar_` 前缀的接口会在检测通过后，写入 `add_configfiles` 指定的 config.h.in 模板文件。 而 `check_xxx` 仅仅只是定义相关 macros 参与编译，但不会持久化到 `config.h.in` 中去。 相关 issues 见： * [#342](https://github.com/xmake io/xmake/issues/342) * [#1715](https://github.com/xmake io/xmake/issues/1715) 我们可以一次性引入所有检测接口： ```lua includes(\"@builtin/check\") ``` 当然我们也可以按需引入单个脚本： ```lua includes(\"@builtin/check/check_links.lua\") ``` 而原有的引入路径，没有区分是否为用户路径，不方便管理维护，且容易被用户配置干扰，后面会逐步废弃。 #### 检测 links 我们可以通过尝试链接来检测指定的 links 是否通过。 ```lua includes(\"check_links.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_links(\"HAS_PTHREAD\", {\"pthread\", \"m\", \"dl\"}) end) ``` config.h.in ```c ${define HAS_PTHREAD} ``` config.h ```c #define HAS_PTHREAD 1 /* #undef HAS_PTHREAD */ ``` #### 检测 c/c++ 类型 我们也能够检测 c/c++ 类型是否存在。 `configvar_check_ctypes` 用于检测 c 代码类型，`configvar_check_cxxtypes` 用于检测 c++ 代码类型。 ```lua includes(\"check_ctypes.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_ctypes(\"HAS_WCHAR\", \"wchar_t\") configvar_check_ctypes(\"HAS_WCHAR_AND_FLOAT\", {\"wchar_t\", \"float\"}) end) ``` config.h.in ```c ${define HAS_WCHAR} ${define HAS_WCHAR_AND_FLOAT} ``` config.h ```c /* #undef HAS_WCHAR */ /* #undef HAS_WCHAR_AND_FLOAT */ ``` #### 检测 c/c++ 函数 `configvar_check_cfuncs` 用于检测 c 代码函数，`configvar_check_cxxfuncs` 用于检测 c++ 代码函数。 ```lua includes(\"check_cfuncs.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_cfuncs(\"HAS_SETJMP\", \"setjmp\", {includes {\"signal.h\", \"setjmp.h\"}}) end) ``` config.h.in ```c ${define HAS_SETJMP} ``` config.h ```c #define HAS_SETJMP 1 /* #undef HAS_SETJMP */ ``` #### 检测 c/c++ 头文件 `configvar_check_cincludes` 用于检测 c 代码头文件，`configvar_check_cxxincludes` 用于检测 c++ 代码头文件。 ```lua includes(\"check_cincludes.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_cincludes(\"HAS_STRING_H\", \"string.h\") configvar_check_cincludes(\"HAS_STRING_AND_STDIO_H\", {\"string.h\", \"stdio.h\"}) end) ``` config.h.in ```c ${define HAS_STRING_H} ${define HAS_STRING_AND_STDIO_H} ``` config.h ```c /* #undef HAS_STRING_H */ #define HAS_STRING_AND_STDIO_H 1 ``` #### 检测 c/c++ 代码片段 `configvar_check_csnippets` 用于检测 c 代码片段，`configvar_check_cxxsnippets` 用于检测 c++ 代码片段。 ```lua includes(\"check_csnippets.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_csnippets(\"HAS_STATIC_ASSERT\", \"_Static_assert(1, \\\"\\\");\") end) ``` config.h.in ```c ${define HAS_STATIC_ASSERT} ``` config.h ```c #define HAS_STATIC_ASSERT 1 ``` xmake 对 check_csnippets 做了改进，新增 `tryrun` 和 `output` 参数去尝试运行和捕获输出。 ```lua includes(\"check_csnippets.lua\") target(\"test\") set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") check_csnippets(\"HAS_INT_4\", \"return (sizeof(int) 4)? 0 : 1;\", {tryrun true}) check_csnippets(\"INT_SIZE\", 'printf(\"%d\", sizeof(int)); return 0;', {output true, number true}) configvar_check_csnippets(\"HAS_LONG_8\", \"return (sizeof(long) 8)? 0 : 1;\", {tryrun true}) configvar_check_csnippets(\"PTR_SIZE\", 'printf(\"%d\", sizeof(void*)); return 0;', {output true, number true}) ``` 如果启用捕获输出，`config.h.in` 的 `${define PTR_SIZE}` 会自动生成 `#define PTR_SIZE 4`。 其中，`number true` 设置，可以强制作为 number 而不是字符串值，否则默认会定义为 `#define PTR_SIZE \"4\"` #### 检测编译器特性 ```lua includes(\"check_features.lua\") target(\"test\", function() set_kind(\"binary\") add_files(\"*.c\") add_configfiles(\"config.h.in\") configvar_check_features(\"HAS_CONSTEXPR\", \"cxx_constexpr\") configvar_check_features(\"HAS_CONSEXPR_AND_STATIC_ASSERT\", {\"cxx_constexpr\", \"c_static_assert\"}, {languages \"c++11\"}) end) ``` config.h.in ```c ${define HAS_CONSTEXPR} ${define HAS_CONSEXPR_AND_STATIC_ASSERT} ``` config.h ```c /* #undef HAS_CONSTEXPR */ #define HAS_CONSEXPR_AND_STATIC_ASSERT 1 ``` 所有 c 编译器特性列表： 特性名 c_static_assert c_restrict c_variadic_macros c_function_prototypes 所有 c++ 编译器特性列表： 特性名 cxx_variable_templates cxx_relaxed_constexpr cxx_aggregate_default_initializers cxx_contextual_conversions cxx_attribute_deprecated cxx_decltype_auto cxx_digit_separators cxx_generic_lambdas cxx_lambda_init_captures cxx_binary_literals cxx_return_type_deduction cxx_decltype_incomplete_return_types cxx_reference_qualified_functions cxx_alignof cxx_attributes cxx_inheriting_constructors cxx_thread_local cxx_alias_templates cxx_delegating_constructors cxx_extended_friend_declarations cxx_final cxx_nonstatic_member_init cxx_override cxx_user_literals cxx_constexpr cxx_defaulted_move_initializers cxx_enum_forward_declarations cxx_noexcept cxx_nullptr cxx_range_for cxx_unrestricted_unions cxx_explicit_conversions cxx_lambdas cxx_local_type_template_args cxx_raw_string_literals cxx_auto_type cxx_defaulted_functions cxx_deleted_functions cxx_generalized_initializers cxx_inline_namespaces cxx_sizeof_member cxx_strong_enums cxx_trailing_return_types cxx_unicode_literals cxx_uniform_initialization cxx_variadic_templates cxx_decltype cxx_default_function_template_args cxx_long_long_type cxx_right_angle_brackets cxx_rvalue_references cxx_static_assert cxx_extern_templates cxx_func_identifier cxx_variadic_macros cxx_template_template_parameters c++17 特性检测： 特性名 cxx_aggregate_bases cxx_aligned_new cxx_capture_star_this cxx_constexpr cxx_deduction_guides cxx_enumerator_attributes cxx_fold_expressions cxx_guaranteed_copy_elision cxx_hex_float cxx_if_constexpr cxx_inheriting_constructors cxx_inline_variables cxx_namespace_attributes cxx_noexcept_function_type cxx_nontype_template_args cxx_nontype_template_parameter_auto cxx_range_based_for cxx_static_assert cxx_structured_bindings cxx_template_template_args cxx_variadic_using c++20 特性检测： 特性名 cxx_aggregate_paren_init cxx_char8_t cxx_concepts cxx_conditional_explicit cxx_consteval cxx_constexpr cxx_constexpr_dynamic_alloc cxx_constexpr_in_decltype cxx_constinit cxx_deduction_guides cxx_designated_initializers cxx_generic_lambdas cxx_impl_coroutine cxx_impl_destroying_delete cxx_impl_three_way_comparison cxx_init_captures cxx_modules cxx_nontype_template_args cxx_using_enum cstd 和 c++ std 版本支持，相关 issues: [#1715](https://github.com/xmake io/xmake/issues/1715) ```lua configvar_check_features(\"HAS_CXX_STD_98\", \"cxx_std_98\") configvar_check_features(\"HAS_CXX_STD_11\", \"cxx_std_11\", {languages \"c++11\"}) configvar_check_features(\"HAS_CXX_STD_14\", \"cxx_std_14\", {languages \"c++14\"}) configvar_check_features(\"HAS_CXX_STD_17\", \"cxx_std_17\", {languages \"c++17\"}) configvar_check_features(\"HAS_CXX_STD_20\", \"cxx_std_20\", {languages \"c++20\"}) configvar_check_features(\"HAS_C_STD_89\", \"c_std_89\") configvar_check_features(\"HAS_C_STD_99\", \"c_std_99\") configvar_check_features(\"HAS_C_STD_11\", \"c_std_11\", {languages \"c11\"}) configvar_check_features(\"HAS_C_STD_17\", \"c_std_17\", {languages \"c17\"}) ``` #### 检测内置宏定义 编译器存在一些内置的宏定义，比如：`__GNUC__` 等，我们可以通过 `check_macros` 和 `configvar_check_macros` 辅助脚本来检测它们是否存在。 相关 issues: [#1715](https://github.com/xmake io/xmake/issues/1715) ```lua 检测宏是否定义 configvar_check_macros(\"HAS_GCC\", \"__GNUC__\") 检测宏没有被定义 configvar_check_macros(\"NO_GCC\", \"__GNUC__\", {defined false}) 检测宏条件 configvar_check_macros(\"HAS_CXX20\", \"__cplusplus> 202002L\", {languages \"c++20\"}) ``` #### 检测类型大小 在先前的版本中，我们可以通过 `check_csnippets` 和 `output true` 的方式，来实现类型检测。 ```lua check_csnippets(\"INT_SIZE\", 'printf(\"%d\", sizeof(int)); return 0;', {output true, number true}) ``` 但是这种方式，是通过尝试运行测试代码，然后获取运行输出结果，提取类型大小信息。 这对于交叉编译，就不适用了。 xmake 新增了 `check_sizeof` 辅助接口，可以通过直接解析测试程序的二进制文件，提取类型大小信息。 由于不需要运行测试，这种方式不仅可以支持交叉编译，而且对检测效率也有极大的提升，使用也更加的简单。 ```lua includes(\"@builtin/check\") target(\"test\", function() set_kind(\"static\") add_files(\"*.cpp\") check_sizeof(\"LONG_SIZE\", \"long\") check_sizeof(\"STRING_SIZE\", \"std::string\", {includes \"string\"}) end) ``` ```bash $ xmake f c checking for LONG_SIZE ... 8 checking for STRING_SIZE ... 24 ``` 另外，我也可以通过 `target:check_sizeof` 在脚本域进行检测。 #### 检测大小端 xmake 新增了 `check_bigendian` 接口，来判断当前编译目标是否为大端模式。 ```lua includes(\"@builtin/check\") target(\"test\", function() set_kind(\"static\") add_files(\"*.cpp\") check_bigendian(\"IS_BIG_ENDIAN\") end) ``` 如果检测通过，当前是大端模式，那么会定义 `IS_BIG_ENDIAN 1`。"},"/get_started/zh/toolchain/builtin-toolchains.html":{"title":"","content":" class: heading_no_counter # 内置工具链 ## Gcc 如果 linux 上安装了 gcc 工具链，通常 xmake 都会优先探测使用，当然我们也可以手动切换到 gcc 来构建。 ```console $ xmake f toolchain gcc c $ xmake ``` ### 使用指定版本的 Gcc 如果用户额外安装了 gcc 11, gcc 10 等特定版本的 gcc 工具链，在本地的 gcc 程序命名可能是 `/usr/bin/gcc 11`。 一种办法是通过 `xmake f cc gcc 11 cxx gcc 11 ld g++ 11` 挨个指定配置来切换，但非常繁琐。 所以，xmake 也提供了更加快捷的切换方式： ```console $ xmake f toolchain gcc 11 c $ xmake ``` 只需要指定 `gcc 11` 对应的版本名，就可以快速切换整个 gcc 工具链。 ## Clang 在 macOS 和 linux，通常 xmake 也会优先尝试去自动探测和使用它，当然我们也可以手动切换。 ```console $ xmake f toolchain clang c $ xmake ``` ## LLVM 除了独立 clang 编译器，如果用户安装了完整 llvm 工具链，我们也可以整个切换过去，包括 `llvm ar` 等工具。 ```console $ xmake f toolchain llvm sdk /xxxx/llvm $ xmake ``` 如果是手动下载的 llvm sdk，我们需要额外指定 llvm sdk 根目录，确保 xmake 能找到它，当然，如果用户已经安装到 PATH 目录下，` sdk` 参数的设置也是可选的。 ## Circle xmake 新增了 circle 编译器的支持，这是个新的 C++20 编译器，额外附带了一些有趣的编译期元编程特性，有兴趣的同学可以到官网查看：<https://www.circle lang.org/> ```console $ xmake f toolchain circle $ xmake ``` ## Tinyc [Tiny C 编译器](https://bellard.org/tcc/) 非常的轻量，在一些不想安装 msvc/llvm 等重量型编译器的情况下，使用它可能快速编译一些 c 代码。 ```console $ xmake f toolchain tinycc $ xmake ``` 使用的时候，请先把 tinycc 编译器加入 PATH 环境。 我们也可以使用远程工具链自动下载集成它，真正做到全平台一键编译，无任何用户手动安装操作。 ```lua add_requires(\"tinycc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"@tinycc\") end) ``` ## Armcc for Keil/MDK 对 Keil/MDK 下 armcc 的工具链支持，相关 issue 见：[#1753](https://github.com/xmake io/xmake/issues/1753) ```console xmake f p cross a cortex m3 toolchain armcc c xmake ``` 这个工具链主要用于嵌入式交叉编译，所以指定了 ` p cross` 交叉编译平台，` a cortex m3` 指定使用的 cpu，这里复用了 ` a/ arch` 参数。 ## Armclang for Keil/MDK 对 Keil/MDK 下 armclang 的工具链支持，相关 issue 见：[#1753](https://github.com/xmake io/xmake/issues/1753) ```console xmake f p cross a cortex m3 toolchain armclang c xmake ``` 这个工具链主要用于嵌入式交叉编译，所以指定了 ` p cross` 交叉编译平台，` a cortex m3` 指定使用的 cpu，这里复用了 ` a/ arch` 参数。 ## GNU RM 另外一个嵌入式 arm 的交叉工具链，官网：<https://developer.arm.com/tools and software/open source software/developer tools/gnu toolchain/gnu rm> ```console $ xmake f toolchain gnu rm c $ xmake ``` ## SDCC 也是一个嵌入式的 arm 编译工具链。 ```console $ xmake f toolchain sdcc a stm8 $ xmake ``` 我们可以指定 ` a stm8` 切换 cpu 架构，目前支持的有： stm8 mcs51 z80 z180 r2k r3ka s08 hc08 ## Zig 如果要构建 Zig 程序，我们默认执行 xmake 就能自动使用 zig 工具链，但前提是 zig 已经在 PATH 环境下。 ```console $ xmake ``` 当然，我们也可以手动设置它。 ```console $ xmake f toolchain zig c $ xmake ``` 也可以指定 zig 编译器的路径。 ```console $ xmake f toolchain zig zc /xxxx/zig c $ xmake ``` ### Zig CC 我们也可以使用 zig 提供的 `zig cc` 编译器去编译 C/C++ 代码。 ```console $ xmake f cc \"zig cc\" cxx \"zig cc\" ld \"zig c++\" c $ xmake ``` ### 交叉编译 另外，我们也可以使用 zig 实现交叉编译。 ```console $ xmake f p cross cross riscv64 linux musl toolchain zig $ xmake ``` 或者编译 arm64 架构： ```console $ xmake f toolchain zig a arm64 c $ xmake ``` ## Emcc (WASM) 如果要编译 wasm 程序，我们只需要切换到 wasm 平台，默认就会使用 emcc 工具链去编译。 ```console $ xmake f p wasm $ xmake ``` ## Wasi (WASM) 这是另外一个启用了 WASI 的 Wasm 工具链，我们需要手动切换使用。 ```console $ xmake f p wasm toolchain wasi $ xmake ``` ## Icc (Intel C/C++ Compiler) 我们也可以切换到 Intel 的 C/C++ 编译器去使用。 ```console $ xmake f toolchain icc c $ xmake ``` ## Ifort (Intel Fortain Compiler) 我们也可以切换到 Intel 的 Fortran 编译器去使用。 ```console $ xmake f toolchain ifort c $ xmake ``` ## gfortran 除了 Intel 的 Fortran 编译器，我们还有 gnu fortran 编译器可用。 ```console $ xmake f toolchain gfortran c $ xmake ``` ## fpc (Free Pascal) 对于 pascal 程序，xmake 默认就会使用 fpc 编译器来编译。 ```console $ xmake ``` 当然，我们也可以手动切换。 ```console $ xmake f toolchain fpc c $ xmake ``` ## Dlang 对于 dlang 程序，xmake 默认就会使用 dmd 编译器来编译。 ```console $ xmake ``` 当然，我们也可以手动切换。 ```console $ xmake f toolchain dlang c $ xmake ``` 需要注意的是，此处的 dlang 工具链其实内部包含了对 `dmd`, `ldc2` 和 `gdc` 的自动探测和切换。 ## Cuda 对于 Cuda 程序，我们需要手动切换到 cuda 工具链。 ```console $ xmake f toolchain cuda c $ xmake ``` 我们也可以手动切换 nvcc 内部调用的 C/C++ 编译器。 ```console $ xmake f toolchain cuda cu ccbin clang c $ xmake ``` ## 汇编器 关于独立的汇编器工具链，xmake 支持：yasm, nasm, fasm 三个，可以随意切换，如果没设置，默认使用 gcc/clang/msvc 自带的汇编器。 ```console $ xmake f toolchain nasm c $ xmake ``` 也可以单独指定汇编器路径 ```console $ xmake f toolchain nasm as /xxx/nasm c $ xmake ``` ## Go golang 编译工具链，默认编译 go 程序会自动启用。 ```console $ xmake ``` ## Rust rust 编译工具链，默认编译 rust 程序会自动启用。 ```console $ xmake ``` 目前 rust 工具链还可以支持 android 等交叉编译环境。 ```console $ xmake f p android ndk ~/android ndk r20b c $ xmake ``` ## NDK Android 的 NDK 编译工具链，只要启用 android 平台，就会默认启用。 ```console $ xmake f p android ndk ~/android ndk r20b c $ xmake ``` 如果 ` ndk` 参数不指定，xmake 也会默认从 AndroidSDK/ndk bundle 目录，以及 `$ANDROID_NDK_HOME`, `ANDROID_NDK_ROOT` 等环境变量中去探测它。 另外，我们也可以设置导全局的 `xmake g ndk ` 配置中，避免每次重复设置。"},"/get_started/zh/toolchain/remote-toolchains.html":{"title":"","content":" class: heading_no_counter # 远程工具链 我们可以拉取指定的工具链来集成编译项目，xmake 也支持将依赖包切换到对应的远程工具链参与编译后集成进来。 相关例子代码见：[Toolchain/Packages Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/package) 相关的 issue [#1217](https://github.com/xmake io/xmake/issues/1217) ## 拉取指定版本的 llvm 工具链 我们使用 llvm 10 中的 clang 来编译项目。 ```lua add_requires(\"llvm 10.x\", {alias \"llvm 10\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"llvm@llvm 10\") end) ``` ## 拉取交叉编译工具链 我们也可以拉取指定的交叉编译工具链来编译项目。 ```lua add_requires(\"muslcc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"@muslcc\") end) ``` ## 拉取工具链并且集成对应工具链编译的依赖包 我们也可以使用指定的 muslcc 交叉编译工具链去编译和集成所有的依赖包。 ```lua add_requires(\"muslcc\") add_requires(\"zlib\", \"libogg\", {system false}) set_toolchains(\"@muslcc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\", \"libogg\") end) ``` 完整例子见：[Examples (muslcc)](https://github.com/xmake io/xmake/blob/master/tests/projects/package/toolchain_muslcc/xmake.lua) ## 拉取集成 Zig 工具链 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"zig 0.7.x\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.zig\") set_toolchains(\"@zig\") end) ```"},"/get_started/zh/toolchain/custom-toolchains.html":{"title":"","content":" class: heading_no_counter # 自定义工具链 xmake 支持在用户的项目 xmake.lua 中自定义工具链，例如： ```lua define toolchain toolchain(\"myclang\", function() mark as standalone toolchain set_kind(\"standalone\") set toolset set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") add_defines(\"MYCLANG\") check toolchain on_check(function (toolchain) return import(\"lib.detect.find_tool\")(\"clang\") end) on load on_load(function (toolchain) get march local march is_arch(\"x86_64\", \"x64\") and \" m64\" or \" m32\" init flags for c/c++ toolchain:add(\"cxflags\", march) toolchain:add(\"ldflags\", march) toolchain:add(\"shflags\", march) if not is_plat(\"windows\") and os.isdir(\"/usr\") then for _, includedir in ipairs({\"/usr/local/include\", \"/usr/include\"}) do if os.isdir(includedir) then toolchain:add(\"includedirs\", includedir) end end for _, linkdir in ipairs({\"/usr/local/lib\", \"/usr/lib\"}) do if os.isdir(linkdir) then toolchain:add(\"linkdirs\", linkdir) end end end init flags for objc/c++ (with ldflags and shflags) toolchain:add(\"mxflags\", march) init flags for asm toolchain:add(\"asflags\", march) end) end) ``` 然后通过下面的命令切到自己定义的工具链就行了： ```bash $ xmake f toolchain myclang ``` 当然，我们也可以通过 `set_toolchains` 接口直接对指定 target 切换设置到自定义工具链。 在自定义工具前，我们可以通过先运行以下命令，查看完整的内置工具链列表，确保 xmake 没有提供，如果有的话，直接使用就行了，没必要自己定义： ```bash $ xmake show l toolchains ``` 下面是自定义 toolchain 目前支持的接口列表： 接口 描述 [toolchain](#toolchain) 定义工具链 [set_kind](#toolchainset_kind) 设置工具链类型 [set_toolset](#toolchainset_toolset) 设置工具集 [set_sdkdir](#toolchainset_sdkdir) 设置工具链 sdk 目录路径 [set_bindir](#toolchainset_bindir) 设置工具链 bin 目录路径 [on_check](#toolchainon_check) 检测工具链 [on_load](#toolchainonon_load) 加载工具链 [toolchain_end](#toolchain_end) 结束定义工具链 [add_includedirs](/zh cn/manual/project_target?id targetadd_includedirs) 添加头文件搜索目录 [add_defines](/zh cn/manual/project_target?id targetadd_defines) 添加宏定义 [add_undefines](/zh cn/manual/project_target?id targetadd_undefines) 取消宏定义 [add_cflags](/zh cn/manual/project_target?id targetadd_cflags) 添加 c 编译选项 [add_cxflags](/zh cn/manual/project_target?id targetadd_cxflags) 添加 c/c++ 编译选项 [add_cxxflags](/zh cn/manual/project_target?id targetadd_cxxflags) 添加 c++ 编译选项 [add_mflags](/zh cn/manual/project_target?id targetadd_mflags) 添加 objc 编译选项 [add_mxflags](/zh cn/manual/project_target?id targetadd_mxflags) 添加 objc/objc++ 编译选项 [add_mxxflags](/zh cn/manual/project_target?id targetadd_mxxflags) 添加 objc++ 编译选项 [add_scflags](/zh cn/manual/project_target?id targetadd_scflags) 添加 swift 编译选项 [add_asflags](/zh cn/manual/project_target?id targetadd_asflags) 添加汇编编译选项 [add_gcflags](/zh cn/manual/project_target?id targetadd_gcflags) 添加 go 编译选项 [add_dcflags](/zh cn/manual/project_target?id targetadd_dcflags) 添加 dlang 编译选项 [add_rcflags](/zh cn/manual/project_target?id targetadd_rcflags) 添加 rust 编译选项 [add_cuflags](/zh cn/manual/project_target?id targetadd_cuflags) 添加 cuda 编译选项 [add_culdflags](/zh cn/manual/project_target?id targetadd_culdflags) 添加 cuda 设备链接选项 [add_ldflags](/zh cn/manual/project_target?id targetadd_ldflags) 添加链接选项 [add_arflags](/zh cn/manual/project_target?id targetadd_arflags) 添加静态库归档选项 [add_shflags](/zh cn/manual/project_target?id targetadd_shflags) 添加动态库链接选项 [add_languages](/zh cn/manual/project_target?id targetadd_languages) 添加语言标准 [add_frameworks](/zh cn/manual/project_target?id targetadd_frameworks) 添加链接框架 [add_frameworkdirs](/zh cn/manual/project_target?id targetadd_frameworkdirs) 添加链接框架 ## toolchain ### 定义工具链 可以在用户项目 xmake.lua 中定义，也可以通过 includes 独立到单独的 xmake.lua 去专门定义各种工具链 ```lua toolchain(\"myclang\", function() set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") end) ``` ### 定义交叉工具链 我们也可以在 xmake.lua 中针对不同的交叉工具链 sdk 进行自定义配置，通常只需要指定 sdkdir，xmake 就可以自动检测其他的配置，比如 cross 等信息，例如: ```lua toolchain(\"my_toolchain\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/arm linux musleabi cross\") end) target(\"hello\", function() set_kind(\"binary\") add_files(\"apps/hello/*.c\") end) ``` 这是一个最精简的交叉工具链配置，仅仅设置了对应的 sdk 路径，然后通过 `set_kind(\"standalone\")` 将其标记为完整独立的工具链。 这个时候，我们就可以通过命令行 ` toolchain my_toolchain` 去手动切换到此工具链来使用。 ```console xmake f toolchain my_toolchain xmake ``` 另外，我们还可以直接在 xmake.lua 中通过 `set_toolchains` 将其绑定到对应的 target 上去，那么仅仅只在编译此 target 时候，才会切换到我们自定义的工具链。 ```lua toolchain(\"my_toolchain\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/arm linux musleabi cross\") end) target(\"hello\", function() set_kind(\"binary\") add_files(\"apps/hello/*.c\") set_toolchains(\"my_toolchain\") end) ``` 这样，我们不再需要手动切换工具链了，只需要执行 xmake，就会默认自动切换到 my_toolchain 工具链。 这对于嵌入式开发来讲尤其有用，因为嵌入式平台的交叉编译工具链非常多，我们经常需要各种切换来完成不同平台的编译。 因此，我们可以将所有的工具链定义放置到独立的 lua 文件中去定义，例如： ``` projectdir xmake.lua toolchains my_toolchain1.lua my_toolchain2.lua ... ``` 然后，我们只需要再 xmake.lua 中通过 includes 去引入它们，并根据不同的自定义平台，绑定不同的工具链： ```lua includes(\"toolchains/*.lua\") target(\"hello\", function() set_kind(\"binary\") add_files(\"apps/hello/*.c\") if is_plat(\"myplat1\") then set_toolchains(\"my_toolchain1\") elseif is_plat(\"myplat2\") then set_toolchains(\"my_toolchain2\") end end) ``` 这样，我们就可以编译的时候，直接快速切换指定平台，来自动切换对应的工具链了。 ```console xmake f p myplat1 xmake ``` 如果，有些交叉编译工具链结构复杂，自动检测还不足够，那么可以根据实际情况，使用 `set_toolset`, `set_cross` 和 `set_bindir` 等接口，针对性的配置上其他的设置。 例如下面的例子，我们还额外添加了一些 cxflags/ldflags 以及内置的系统库 links。 ```lua toolchain(\"my_toolchain\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/arm linux musleabi cross\") on_load(function (toolchain) add flags for arch if toolchain:is_arch(\"arm\") then toolchain:add(\"cxflags\", \" march armv7 a\", \" msoft float\", {force true}) toolchain:add(\"ldflags\", \" march armv7 a\", \" msoft float\", {force true}) end toolchain:add(\"ldflags\", \" static\", {force true}) toolchain:add(\"syslinks\", \"gcc\", \"c\") end) end) ``` 更多自定义工具链的例子，我们可以看下面的接口文档，也可以到 xmake 的源码的目录参考内置的工具链定义：[内部工具链列表](https://github.com/xmake io/xmake/blob/master/xmake/toolchains/) ## toolchain:set_kind ### 设置工具链类型 目前仅支持设置为 `standalone` 类型，表示当前工具链是独立完整的工具链，包括 cc/cxx/ld/sh/ar 等编译器、归档器、链接器等一整套工具集的配置。 通常用于某个 target 被同时设置了多个工具链的情况，但同时只能生效一个独立工具链，通过此配置可以保证生效的工具链存在互斥关系，比如 gcc/clang 工具链不会同时生效。 而像 yasm/nasm 这种局部工具链，属于附加的局部工具链扩展，不用设置 standalone，因为 clang/yasm 两个工具链有可能同时存在。 > 只要记住，存在完整编译环境的工具链，都设置为 standalone 就行。 ## toolchain:set_toolset 设置工具集。 用于设置每个单独工具名和路径，例如： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") end) ``` 关于这个接口的详情，可以看下：[target.set_toolset](/zh cn/manual/project_target?id targetset_toolset) ## toolchain:set_sdkdir 设置工具链 sdk 目录路径。 通常我们可以通过 `xmake f toolchain myclang sdk xxx` 来配置 sdk 目录，但是每次配置比较繁琐，我们也可以通过此接口预先配置到 xmake.lua 中去，方便快速切换使用。 ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_sdkdir(\"/tmp/sdkdir\") set_toolset(\"cc\", \"clang\") end) ``` ## toolchain:set_bindir 设置工具链 bin 目录路径。 通常我们可以通过 `xmake f toolchain myclang bin xxx` 来配置 sdk 目录，但是每次配置比较繁琐，我们也可以通过此接口预先配置到 xmake.lua 中去，方便快速切换使用。 ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_bindir(\"/tmp/sdkdir/bin\") set_toolset(\"cc\", \"clang\") end) ``` ## toolchain:on_check 检测工具链。 用于检测指定工具链所在 sdk 或者程序在当前系统上是否存在，通常用于多个 standalone 工具链的情况，进行自动探测和选择有效工具链。 而对于 `xmake f toolchain myclang` 手动指定的场景，此检测配置不是必须的，可以省略。 ```lua toolchain(\"myclang\", function() on_check(function (toolchain) return import(\"lib.detect.find_tool\")(\"clang\") end) end) ``` ## toolchain:on_load 加载工具链。 对于一些复杂的场景，我们可以在 on_load 中动态灵活的设置各种工具链配置，比在描述域设置更加灵活，更加强大： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") on_load(function (toolchain) set toolset toolchain:set(\"toolset\", \"cc\", \"clang\") toolchain:set(\"toolset\", \"ld\", \"clang++\") init flags local march toolchain:is_arch(\"x86_64\", \"x64\") and \" m64\" or \" m32\" toolchain:add(\"cxflags\", march) toolchain:add(\"ldflags\", march) toolchain:add(\"shflags\", march) end) end) ```"},"/get_started/zh/tutorial/configuration.html":{"title":"","content":" class: heading_no_counter # 配置说明 通过 `xmake fconfig` 配置命令，设置构建前的相关配置信息，详细参数选项，请运行: `xmake f help`。 > **Tips**: > 你可以使用命令行缩写来简化输入，也可以使用全名，例如: > > * `xmake f` 或者 `xmake config` > * `xmake f p linux` 或者 `xmake config plat linux` ## 目标平台 ### 主机平台 ```bash $ xmake ``` > xmake将会自动探测当前主机平台，默认自动生成对应的目标程序。 ### Linux ```bash $ xmake f p linux [ a i386x86_64] $ xmake ``` ### Android ```bash $ xmake f p android ndk ~/files/android ndk r10e/ [ a armeabi v7aarm64 v8a] $ xmake ``` 如果要手动指定 ndk 中具体某个工具链，而不是使用默认检测的配置，可以通过[ bin](# bin)来设置，例如： ```bash $ xmake f p android ndk ~/files/android ndk r10e/ a arm64 v8a bin ~/files/android ndk r10e/toolchains/aarch64 linux android 4.9/prebuilt/darwin x86_64/bin ``` [ bin](# bin)主要用于设置选择编译工具的具体 bin 目录，这个的使用跟[交叉编译](#交叉编译配置)中的[ bin](# bin)的行为是一致的。 > 如果手动设置了 bin 目录，没有通过检测，可以看下是否 ` arch ` 参数没有匹配对。 ### iPhoneOS ```bash $ xmake f p iphoneos [ a armv7armv7sarm64i386x86_64] $ xmake ``` 由于 m1 设备上模拟器也支持 arm64 架构，因此之前单纯从 arch 去区分是否为模拟器，已无法满足需求。 因此我们新增了一个参数配置去区分是否为模拟器目标。 ```bash $ xmake f p iphoneos appledev simulator $ xmake f p watchos appledev simulator $ xmake f p appletvos appledev simulator ``` ### Mac Catalyst 我们也可以指定构建 Mac Catalyst 程序。 ```bash $ xmake f appledev catalyst ``` ### Apple WatchOS ```bash $ xmake f p watchos [ a i386armv7k] $ xmake ``` ### Wasm (WebAssembly) 此平台用于编译 WebAssembly 程序（内部会使用 emcc 工具链），在切换此平台之前，我们需要先进入 Emscripten 工具链环境，确保 emcc 等编译器可用。 ```bash $ xmake f p wasm $ xmake ``` xmake 也支持 Qt for wasm 编译，只需要： ```bash $ xmake f p wasm [ qt ~/Qt] $ xmake ``` 其中 ` qt` 参数设置是可选的，通常 xmake 都能检测到 qt 的 sdk 路径。 需要注意的一点是，Emscripten 和 Qt SDK 的版本是有对应关系的，不匹配的版本，可能会有 Qt/Wasm 之间的兼容问题。 关于版本对应关系，可以看下：[https://wiki.qt.io/Qt_for_WebAssembly](https://wiki.qt.io/Qt_for_WebAssembly) 更多详情见：[https://github.com/xmake io/xmake/issues/956](https://github.com/xmake io/xmake/issues/956) 除了 emscripten 以外，还有一个常用的 wasm 工具链 wasi sdk，用于构建基于 wasi 的程序，我们仅仅只需要切换工具链即可。 ```bash $ xmake f p wasm toolchain wasi $ xmake ``` ### HarmonyOS (鸿蒙) xmake 也提供了鸿蒙 OS 平台的 native 工具链编译支持： ```bash $ xmake f p harmony ``` xmake 会自动探测默认的 SDK 路径，当然我们也可以指定 Harmony SDK 路径。 ```bash $ xmake f p Harmony sdk /Users/ruki/Library/Huawei/Sdk/openharmony/10/native ``` ## 交叉编译配置 通常，如果我们需要在当前 pc 环境编译生成其他设备上才能运行的目标文件时候，就需要通过对应的交叉编译工具链来编译生成它们，比如在 macos 上编译 linux 的程序，或者在 linux 上编译其他嵌入式设备的目标文件等。 通常的交叉编译工具链都是基于 gcc/clang 的，大都具有类似如下的结构： ``` /home/toolchains_sdkdir bin arm linux armeabi gcc arm linux armeabi ld ... lib libxxx.a include xxx.h ``` 每个工具链都有对应的 include/lib 目录，用于放置一些系统库和头文件，例如 libc, stdc++ 等，而 bin 目录下放置的就是编译工具链一系列工具。例如： ``` arm linux armeabi ar arm linux armeabi as arm linux armeabi c++ arm linux armeabi cpp arm linux armeabi g++ arm linux armeabi gcc arm linux armeabi ld arm linux armeabi nm arm linux armeabi strip ``` 其中 `arm linux armeabi ` 前缀就是 cross，通过用来标示目标平台和架构，主要用于跟主机自身的 gcc/clang 进行区分。 里面的 gcc/g++ 就是 c/c++ 的编译器，通常也可以作为链接器使用，链接的时候内部会去调用 ld 来链接，并且自动追加一些 c++ 库。 cpp 是预处理器，as 是汇编器，ar 用于生成静态库，strip 用于裁剪掉一些符号信息，使得目标程序会更加的小。nm 用于查看导出符号列表。 ### 自动探测和编译 如果我们的交叉编译工具链是上文的结构，xmake 会自动检测识别这个 sdk 的结构，提取里面的 cross，以及 include/lib 路径位置，用户通常不需要做额外的参数设置，只需要配置好 sdk 根目录就可以编译了，例如： ```bash $ xmake f p cross sdk /home/toolchains_sdkdir $ xmake ``` 其中，` p cross` 用于指定当前的平台是交叉编译平台，` sdk ` 用于指定交叉工具链的根目录。 > 注：我们也可以指定 ` p linux` 平台来配置交叉编译，效果是一样的，唯一的区别是额外标识了 linux 平台名，方便 xmake.lua 里面通过 `is_plat(\"linux\")` 来判断平台。 这个时候，xmake 会去自动探测 gcc 等编译器的前缀名 cross：`arm linux armeabi `，并且编译的时候，也会自动加上**链接库**和**头文件**的搜索选项，例如： ``` I/home/toolchains_sdkdir/include L/home/toolchains_sdkdir/lib ``` 这些都是 xmake 自动处理的，不需要手动配置他们。 ### 手动配置编译 如果上面的自动检测对某些工具链，还无法完全通过编译，就需要用户自己手动设置一些交叉编译相关的配置参数，来调整适应这些特殊的工具链了，下面我会逐一讲解如何配置。 ### 设置工具链 bin 目录 对于不规则工具链目录结构，靠单纯地[ sdk](# sdk)选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的 bin 目录位置。 例如：一些特殊的交叉工具链的，编译器bin目录，并不在 `/home/toolchains_sdkdir/bin` 这个位置，而是独立到了 `/usr/opt/bin`。 这个时候，我们可以在设置了 sdk 参数的基础上追加 bin 目录的参数设置，来调整工具链的 bin 目录。 ```bash $ xmake f p cross sdk /home/toolchains_sdkdir bin /usr/opt/bin $ xmake ``` ### 设置交叉工具链工具前缀 像 `aarch64 linux android ` 这种，通常如果你配置了` sdk` 或者 ` bin` 的情况下，xmake 会去自动检测的，不需要自己手动设置。 但是对于一些极特殊的工具链，一个目录下同时有多个 cross 前缀的工具 bin 混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个 bin。 例如，toolchains 的 bin 目录下同时存在两个不同的编译器： ``` /opt/bin armv7 linux gcc aarch64 linux gcc ``` 我们现在想要选用 armv7 的版本，那么我们可以追加 ` cross ` 配置编译工具前缀名，例如： ```bash $ xmake f p cross sdk /usr/toolsdk bin /opt/bin cross armv7 linux ``` ### 设置 c/c++ 编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p cross sdk /user/toolsdk cc armv7 linux clang cxx armv7 linux clang++ ``` 当然，我们也可以指定编译器全路径。 ` cc` 用于指定 c 编译器名，` cxx` 用于指定 c++ 编译器名。 > 注：如果存在 CC/CXX 环境变量的话，会优先使用当前环境变量中指定的值。 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 这个时候我们可以通过： ```bash xmake f cxx clang++@/home/xxx/c++mips.exe ``` 设置 c++mips.exe 编译器作为类 clang++ 的使用方式来编译。 也就是说，在指定编译器为 `c++mips.exe` 的同时，告诉 xmake，它跟 clang++ 用法和参数选项基本相同。 ### 设置 c/c++ 链接器 如果还要继续细分选择链接器，则继续追加相关链接器选项，例如： ```bash $ xmake f p cross sdk /user/toolsdk ld armv7 linux clang++ sh armv7 linux clang++ ar armv7 linux ar ``` ld 指定可执行程序链接器，sh 指定共享库程序链接器，ar 指定生成静态库的归档器。 注：如果存在 LD/SH/AR 环境变量的话，会优先使用当前环境变量中指定的值。 ### 设置头文件和库搜索目录 如果 sdk 里面还有额外的其他 include/lib 目录不在标准的结构中，导致交叉编译找不到库和头文件，那么我们可以通过 ` includedirs` 和 ` linkdirs` 来追加搜索路径，然后通过 ` links` 添加额外的链接库。 ```bash $ xmake f p cross sdk /usr/toolsdk includedirs /usr/toolsdk/xxx/include linkdirs /usr/toolsdk/xxx/lib links pthread ``` > 注：如果要指定多个搜索目录，可以通过 `:` 或者 `;` 来分割，也就是不同主机平台的路径分隔符，linux/macos下用`:`，win下用`;`。 ### 设置编译和链接选项 我们也可以根据实际情况通过 ` cflags`, ` cxxflags`，` ldflags`，` shflags` 和 ` arflags` 额外配置一些编译和链接选项。 * cflags: 指定c编译参数 * cxxflags：指定c++编译参数 * cxflags: 指定c/c++编译参数 * asflags: 指定汇编器编译参数 * ldflags: 指定可执行程序链接参数 * shflags: 指定动态库程序链接参数 * arflags: 指定静态库的生成参数 例如： ```bash $ xmake f p cross sdk /usr/toolsdk cflags \" DTEST I/xxx/xxx\" ldflags \" lpthread\" ``` ### 项目描述设置 #### set_toolchains 这对某个特定的 target 单独切换设置不同的工具链，和 set_toolset 不同的是，此接口是对完整工具链的整体切换，比如 cc/ld/sh 等一系列工具集。 这也是推荐做法，因为像 gcc/clang 等大部分编译工具链，编译器和链接器都是配套使用的，要切就得整体切，单独零散的切换设置会很繁琐。 比如我们切换 test 目标到 clang+yasm 两个工具链： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"clang\", \"yasm\") end) ``` #### set_toolset 如果觉得每次通过命令行配置比较繁琐，有些配置可以通过在 xmake.lua 预先配置好，来简化命令配置，比如编译器的指定，就可以通过 `set_toolset` 来对每个 target 单独设置。 ```lua target(\"test\", function() set_kind(\"binary\") set_toolset(\"cxx\", \"clang\") set_toolset(\"ld\", \"clang++\") end) ``` 强制 test 目标的编译器和链接器使用 clang 编译器，或者指定交叉编译工具链中的编译器名或者路径。 #### set_config 我们也可以通过 `set_config` 来设置在 `xmake f/config` 命令中的每个配置参数的默认值，这是个全局 api，对每个 target 都会生效。 ```lua set_config(\"cflags\", \" DTEST\") set_config(\"sdk\", \"/home/xxx/tooksdk\") set_config(\"cc\", \"gcc\") set_config(\"ld\", \"g++\") ``` 不过，我们还是可以通过 `xmake f name value` 的方式，去修改 xmake.lua 中的默认配置。 ### 自定义编译平台 如果某个交叉工具链编译后目标程序有对应的平台需要指定，并且需要在 xmake.lua 里面根据不同的交叉编译平台，还需要配置一些额外的编译参数，那么上文的 ` p cross` 设置就不能满足需求了。 其实，` p/ plat ` 参数也可以设置为其他自定义的值，只需要跟 `is_plat` 保持对应关系就可以，所有非内置平台名，都会默认采用交叉编译模式，例如： ```bash $ xmake f p myplat sdk /usr/local/arm xxx gcc/ $ xmake ``` 我们传入了 myplat 自定义平台名，作为当前交叉工具链的编译平台，然后 xmake.lua 里面我们对这个平台，配置下对应的设置： ```lua if is_plat(\"myplat\") then add_defines(\"TEST\") end ``` 通过这种方式，xmake 就可以很方便的扩展处理各种编译平台，用户可以自己扩展支持 freebsd, netbsd, sunos 等其他各种平台的交叉编译。 我摘录一段之前移植 libuv 写的交叉编译的配置，直观感受下： ```lua for dragonfly/freebsd/netbsd/openbsd platform if is_plat(\"dragonfly\", \"freebsd\", \"netbsd\", \"openbsd\") then add_files(\"src/unix/bsd ifaddrs.c\") add_files(\"src/unix/freebsd.c\") add_files(\"src/unix/kqueue.c\") add_files(\"src/unix/posix hrtime.c\") add_headerfiles(\"(include/uv bsd.h)\") end for sunos platform if is_plat(\"sunos\") then add_files(\"src/unix/no proctitle.c\") add_files(\"src/unix/sunos.c\") add_defines(\"__EXTENSIONS_\", \"_XOPEN_SOURCE 600\") add_headerfiles(\"(include/uv sunos.h)\") end ``` 然后，我们就可以切换这些平台来编译： ```bash $ xmake f p [dragonflyfreebsdnetbsdopenbsdsunos] sdk /home/arm xxx gcc/ $ xmake ``` 另外，内置的 linux 平台也是支持交叉编译的，如果不想配置其他平台名，统一作为 linux 平台来交叉编译，也是可以的。 ```bash $ xmake f p linux sdk /usr/local/arm xxx gcc/ $ xmake ``` 只要设置了 ` sdk ` 等参数，就会启用linux平台的交叉编译模式。 ### 常用工具链配置 完整的工具链列表，请执行下面的命令查看： ```bash $ xmake show l toolchains ``` 上文讲述的是通用的交叉编译工具链配置，如果一些特定的工具链需要额外传入 ` ldflags/ includedirs` 等场景就比较繁琐了, 因此 xmake 也内置了一些常用工具链，可以省去交叉编译工具链复杂的配置过程，只需要执行： ```bash $ xmake f toolchain gnu rm sdk /xxx/ $ xmake ``` 就可以快速切换的指定的交叉编译工具链，如果这个工具链需要追加一些特定的 flags 设置，也会自动设置好，简化配置。 其中，gnu rm 就是内置的 GNU Arm Embedded Toolchain。 比如，我们也可以快速从 gcc 工具链整体切换到 clang 或者 llvm 工具链，不再需要 `xmake f cc clang cxx clang ld clang++` 等挨个配置了。 ```bash $ xmake f toolchain clang $ xmake ``` 或者 ```bash $ xmake f toolchain llvm sdk /xxx/llvm $ xmake ``` 具体 xmake 持哪些工具链，可以通过下面的命令查看： ```bash $ xmake show l toolchains xcode Xcode IDE vs VisualStudio IDE yasm The Yasm Modular Assembler clang A C language family frontend for LLVM go Go Programming Language Compiler dlang D Programming Language Compiler sdcc Small Device C Compiler cuda CUDA Toolkit ndk Android NDK rust Rust Programming Language Compiler llvm A collection of modular and reusable compiler and toolchain technologies cross Common cross compilation toolchain nasm NASM Assembler gcc GNU Compiler Collection mingw Minimalist GNU for Windows gnu rm GNU Arm Embedded Toolchain envs Environment variables toolchain fasm Flat Assembler ``` #### 自定义工具链 另外，我们也可以在 xmake.lua 中自定义 toolchain，然后通过 `xmake f toolchain myclang` 指定切换，例如： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") ... end) ``` 关于这块的详情介绍，可以到[自定义工具链](/zh cn/manual/custom_toolchain)章节查看 更多详情见：[#780](https://github.com/xmake io/xmake/issues/780) #### LLVM 工具链 llvm 工具链下载地址：<https://releases.llvm.org/> ```bash $ xmake f p cross toolchain llvm sdk \"C:\\Program Files\\LLVM\" $ xmake ``` #### GNU RM 工具链 工具链地址：<https://developer.arm.com/tools and software/open source software/developer tools/gnu toolchain/gnu rm/downloads#> ```bash $ xmake f p cross toolchain gnu rm sdk /xxx/cc arm none eabi 9 2019 q4 major $ xmake ``` #### TinyC 工具链 ```bash $ xmake f toolchain tinyc $ xmake ``` > Releases 目录下，我们还提供了特殊的 xmake tinyc vX.X.X.win32.exe 安装包，内置 tinyc 工具链，无需依赖 msvc，也可以编译 c 代码，开箱即用无依赖。 #### Emcc 工具链 通常只需要切换到 Wasm 平台，里面内置了 emcc 工具链，还会额外调整目标程序的扩展名为 `*.html` 以及输出 `*.wasm`。 ```bash $ xmake f p wasm $ xmake ``` 不过我们也能够直接切换到 emcc 工具链，但是后缀名不会被修改。 ```bash $ xmake f toolchain emcc $ xmake ``` #### Intel C++ 编译工具链 ```bash $ xmake f toolchain icc $ xmake ``` #### Intel Fortran 编译工具链 ```bash $ xmake f toolchain ifort $ xmake ``` ### 通用交叉编译配置 参数名 描述 [ sdk](# sdk) 设置交叉工具链的sdk根目录 [ bin](# bin) 设置工具链bin目录 [ cross](# cross) 设置交叉工具链工具前缀 [ as](# as) 设置`asm`汇编器 [ cc](# cc) 设置`c`编译器 [ cxx](# cxx) 设置`c++`编译器 [ mm](# mm) 设置`objc`编译器 [ mxx](# mxx) 设置`objc++`编译器 [ sc](# sc) 设置`swift`编译器 [ gc](# gc) 设置`golang`编译器 [ dc](# dc) 设置`dlang`编译器 [ rc](# rc) 设置`rust`编译器 [ cu](# cu) 设置`cuda`编译器 [ ld](# ld) 设置`c/c++/objc/asm`链接器 [ sh](# sh) 设置`c/c++/objc/asm`共享库链接器 [ ar](# ar) 设置`c/c++/objc/asm`静态库归档器 [ scld](# scld) 设置`swift`链接器 [ scsh](# scsh) 设置`swift`共享库链接器 [ gcld](# gcld) 设置`golang`链接器 [ gcar](# gcar) 设置`golang`静态库归档器 [ dcld](# dcld) 设置`dlang`链接器 [ dcsh](# dcsh) 设置`dlang`共享库链接器 [ dcar](# dcar) 设置`dlang`静态库归档器 [ rcld](# rcld) 设置`rust`链接器 [ rcsh](# rcsh) 设置`rust`共享库链接器 [ rcar](# rcar) 设置`rust`静态库归档器 [ cu ccbin](# cu ccbin) 设置`cuda` host编译器 [ culd](# culd) 设置`cuda`链接器 [ asflags](# asflags) 设置`asm`汇编编译选项 [ cflags](# cflags) 设置`c`编译选项 [ cxflags](# cxflags) 设置`c/c++`编译选项 [ cxxflags](# cxxflags) 设置`c++`编译选项 [ mflags](# mflags) 设置`objc`编译选项 [ mxflags](# mxflags) 设置`objc/c++`编译选项 [ mxxflags](# mxxflags) 设置`objc++`编译选项 [ scflags](# scflags) 设置`swift`编译选项 [ gcflags](# gcflags) 设置`golang`编译选项 [ dcflags](# dcflags) 设置`dlang`编译选项 [ rcflags](# rcflags) 设置`rust`编译选项 [ cuflags](# cuflags) 设置`cuda`编译选项 [ ldflags](# ldflags) 设置链接选项 [ shflags](# shflags) 设置共享库链接选项 [ arflags](# arflags) 设置静态库归档选项 > 如果你想要了解更多参数选项，请运行: `xmake f help`。 #### sdk * 设置交叉工具链的sdk根目录 大部分情况下，都不需要配置很复杂的 toolchains 前缀，例如：`arm linux ` 什么的 只要这个工具链的 sdk 目录满足如下结构（大部分的交叉工具链都是这个结构）： ``` /home/toolchains_sdkdir bin arm linux gcc arm linux ld ... lib libxxx.a include xxx.h ``` 那么，使用 xmake 进行交叉编译的时候，只需要进行如下配置和编译： ```bash $ xmake f p linux sdk /home/toolchains_sdkdir $ xmake ``` 这个时候，xmake 会去自动探测，gcc 等编译器的前缀名：`arm linux `，并且编译的时候，也会自动加上**链接库**和**头文件**的搜索选项，例如： ``` I/home/toolchains_sdkdir/include L/home/toolchains_sdkdir/lib ``` 这些都是xmake自动处理的，不需要手动配置他们。。 #### bin * 设置工具链bin目录 对于不规则工具链目录结构，靠单纯地[ sdk]( sdk)选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的 bin 目录位置。 例如：一些特殊的交叉工具链的，编译器 bin 目录，并不在 `/home/toolchains_sdkdir/bin` 这个位置，而是独立到了 `/usr/opt/bin`。 ```bash $ xmake f p linux sdk /home/toolchains_sdkdir bin /usr/opt/bin $ xmake ``` #### cross * 设置交叉工具链工具前缀 像 `aarch64 linux android ` 这种，通常如果你配置了[ sdk](# sdk)或者[ bin](# bin)的情况下，xmake 会去自动检测的，不需要自己手动设置。 但是对于一些极特殊的工具链，一个目录下同时有多个 cross 前缀的工具 bin 混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个 bin。 例如，toolchains 的 bin 目录下同时存在两个不同的编译器： ``` /opt/bin armv7 linux gcc aarch64 linux gcc ``` 我们现在想要选用 armv7 的版本，则配置如下： ```bash $ xmake f p linux sdk /usr/toolsdk bin /opt/bin cross armv7 linux ``` #### as * 设置 `asm` 汇编器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk as armv7 linux as ``` 如果存在 `AS` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f as gcc@/home/xxx/asmips.exe` 设置ccmips.exe编译器作为类 gcc 的使用方式来编译。 > 也就是说，在指定编译器为 `asmips.exe` 的同时，告诉 xmake，它跟 gcc 用法和参数选项基本相同。 #### cc * 设置c编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk cc armv7 linux clang ``` 如果存在 `CC` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f cc gcc@/home/xxx/ccmips.exe` 设置 ccmips.exe 编译器作为类 gcc 的使用方式来编译。 > 也就是说，在指定编译器为 `ccmips.exe` 的同时，告诉 xmake，它跟 gcc 用法和参数选项基本相同。 #### cxx * 设置 `c++` 编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk cxx armv7 linux clang++ ``` 如果存在 `CXX` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f cxx clang++@/home/xxx/c++mips.exe` 设置 c++mips.exe 编译器作为类 clang++ 的使用方式来编译。 > 也就是说，在指定编译器为 `c++mips.exe` 的同时，告诉 xmake，它跟 clang++ 用法和参数选项基本相同。 #### ld * 设置 `c/c++/objc/asm` 链接器 如果还要继续细分选择链接器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk ld armv7 linux clang++ ``` 如果存在 `LD` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么链接器工具检测就会失败。 > 这个时候我们可以通过：`xmake f ld g++@/home/xxx/c++mips.exe` 设置 c++mips.exe 链接器作为类 g++ 的使用方式来编译。 > 也就是说，在指定链接器为 `c++mips.exe` 的同时，告诉 xmake，它跟 g++ 用法和参数选项基本相同。 #### sh * 设置 `c/c++/objc/asm` 共享库链接器 ```bash $ xmake f p linux sdk /user/toolsdk sh armv7 linux clang++ ``` 如果存在 `SH` 环境变量的话，会优先使用当前环境变量中指定的值。 #### ar * 设置 `c/c++/objc/asm` 静态库归档器 ```bash $ xmake f p linux sdk /user/toolsdk ar armv7 linux ar ``` 如果存在`AR`环境变量的话，会优先使用当前环境变量中指定的值。 ## 全局配置 我们也可以将一些常用配置保存到全局配置中，来简化频繁地输入： 例如: ```bash $ xmake g ndk ~/files/android ndk r10e/ ``` 现在，我们重新配置和编译 `android` 程序： ```bash $ xmake f p android $ xmake ``` 以后，就不需要每次重复配置 ` ndk 参数了。 > 每个命令都有其简写，例如: `xmake g` 或者 `xmake global`。 ## 清除配置 有时候，配置出了问题编译不过，或者需要重新检测各种依赖库和接口，可以加上 ` c` 参数，清除缓存的配置，强制重新检测和配置： ```bash $ xmake f c $ xmake ``` 或者： ```bash $ xmake f p iphoneos c $ xmake ``` ## 导入导出配置 我们还可以导入导出已经配置好的配置集，方便配置的快速迁移。 ### 导出配置 ```bash $ xmake f export /tmp/config.txt $ xmake f m debug xxx y export /tmp/config.txt ``` ### 导入配置 ```bash $ xmake f import /tmp/config.txt $ xmake f m debug xxx y import /tmp/config.txt ``` ### 导出配置（带菜单） ```bash $ xmake f menu export /tmp/config.txt $ xmake f menu m debug xxx y export /tmp/config.txt ``` ### 导入配置（带菜单） ```bash $ xmake f menu import /tmp/config.txt $ xmake f menu m debug xxx y import /tmp/config.txt ```"},"/get_started/zh/tutorial/install.html":{"title":"","content":" class: heading_no_counter # 安装 ## 源码编译安装 ### 安装 > 切记，xmake 不建议在 root 下安装和使用，所以尽量不要在 root 下拉取源码编译安装。 ```bash git clone https://github.com/TOMO CAT/xmake.git cd ./xmake bash scripts/install.sh ``` 如果没有外网环境，可以通过 gitee 镜像拉取（xmake repo 也会自动切到 gitee 源）： ```bash git clone https://gitee.com/tomocat/xmake.git ``` 安装完后检查是否安装完成： ```bash xmake version ``` ### 启用 Luajit 对于一些大型项目（比如包含 300+ targets），我们可以启用 Luajit 加速构建，提升构建速度。 ```bash bash scripts/install.sh runtime luajit ``` ### 仅更新 lua 脚本 这个开发者本地调试 xmake 源码才需要： ```bash ./scripts/get.sh __local__ __install_only__ ``` ### 编译 xmake bundle 包 默认编译方式会安装 xmake 二进制和 Lua 脚本，这样做的好处是方便源码调试 Lua 脚本，但是不方便发布和迁移，可以只编译 xmake 二进制： ```bash # TODO: ``` ### root 下安装 xmake 不推荐 root 下安装使用，因为这很不安全。因此以 root 用户运行 xmake 会打印一条 warning 日志，用户可以设置环境变量 `XMAKE_ROOT y` 屏蔽相关的报警，用户需要随时注意root下误操作系统文件文件的风险。 ### 启用 ccache 默认情况下 xmake 用的是内部的 xcache，但可能会出现一些非预期的 bug。如果需要启用 ccache，可以手动安装 ccache，xmake会自动检测并使用。 ## 更新升级 我们可以通过 `xmake update` 命令来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个 tag 版本： ```bash # 如果不是 force 的话, xmake 版本一样就会跳过安装, 不会精确到 git tag / branch # 例如 xmake v3.0.4+dev.39db22335 版本也会跳过 xmake update force diagnosis verbose v3.0.4 ``` 我们也可以指定更新到 master/dev 分支版本： ```bash xmake update master xmake update dev ``` 从指定 git 源更新： ```bash # 指定 github 源 xmake update github:TOMO CAT/xmake#master # 指定 gitee 源 xmake update gitee:tomocat/xmake#dev ``` 如果 xmake/core 没动过，仅仅更新 xmake 的 lua 脚本改动，可以加 ` s/ scriptonly` 快速更新 lua 脚本： ```bash xmake update scriptonly force dev ``` ## 卸载 最后，我们如果要卸载 xmake，也是支持的： ```bash rm rf /usr/local/share/xmake rm /usr/local/bin/xrepo rm /usr/local/bin/xmake ```"},"/get_started/zh/tutorial/FAQ.html":{"title":"","content":" class: heading_no_counter # FAQ ## 怎样获取更多参数选项信息？ 获取主菜单的帮助信息，里面有所有 action 和 plugin 的列表描述。 ```bash $ xmake [ h help] ``` 获取配置菜单的帮助信息，里面有所有配置选项的描述信息，以及支持平台、架构列表。 ```bash $ xmake f [ h help] ``` 获取 action 和 plugin 命令菜单的帮助信息，里面有所有内置命令和插件任务的参数使用信息。 ```bash $ xmake [actionplugin] [ h help] ``` 例如，获取 `run` 命令的参数信息 : ```bash $ xmake run help ``` ## 怎样实现静默构建，不输出任何信息？ ```bash $ xmake [ q quiet] ``` ## 如果 xmake 运行失败了怎么办？ 可以先尝试清除下配置，重新构建下： ```bash $ xmake f c $ xmake ``` 如果还是失败了，请加上 ` v` 或者 ` verbose` 选项重新执行 xmake 后，获取更加详细的输出信息 例如： ```hash $ xmake [ v verbose] ``` 并且可以加上 ` D` 选项获取出错时的 xmake 的调试栈信息和其他更详细的诊断信息 , 然后你可以提交这些信息到 [issues](https://github.com/TOMO CAT/xmake/issues)。 ```bash $ xmake v D ``` ## 怎样看实时编译警告信息 ? 为了避免刷屏，在构建时候，默认是不实时输出警告信息的，如果想要看的话可以加上 ` w` 选项启用编译警告输出就行了。 ```bash $ xmake [ w warning] ``` ## 怎样基于源码自动生成 xmake.lua？ 如果你想临时写一两个测试代码、或者手上有一些移植过来的零散源码想要快速编译运行，可以不用专门写 xmake.lua，直接运行： ```bash $ xmake ``` xmake 会自动扫描分析当前的源码目录，识别程序结构和类型，生成一个 xmake.lua，并且会尝试直接构建它。 如果编译成功，可以直接运行： ```bash $ xmake run ``` 当然，如果仅仅只是想要生成 xmake.lua，默认不去构建，可以执行： ```bash $ xmake f y ``` 更多相关介绍，请参考文章：[xmake 新增智能代码扫描编译模式，无需手写任何 make 文件](https://tboox.org/cn/2017/01/07/build without makefile/) ## 为什么 xmake.lua 会被执行多遍？ xmake.lua 里面分描述域和脚本域，在描述域里面会对各种配置域进行分阶段多次解析，有可能会执行多遍，因此不要在描述域写复杂的脚本。 如果要写各种复杂脚本，请在脚本域内进行配置，`target/on_load` 的脚本域里面同样可以灵活配置各种 target 相关设置，并且提供更强大的 lua 脚本模块支持。 更多细节见：[描述语法说明](/zh cn/guide/syntax_description) ## 如何调试 Xmake 源码? ### 下载源码 由于 xmake 使用了 git submodules 维护子模块，因此我们可以通过下面几种方式拉取完整源码。 #### 使用 git 拉取 ```bash $ git clone recursive https://github.com/TOMO CAT/xmake.git ``` 或者 ```bash $ git clone https://github.com/TOMO CAT/xmake.git $ git submodule update init ``` #### 从 Github Releases 下载源码包 由于 github 本身的 downloads 附件下载不支持归档 submodules，因此 Xmake 每次发版都会完整打包一份额外的 tar 包源码上传到 Releases 上。 因此，不要下载错误的链接地址 不完整源码：<https://github.com/TOMO CAT/xmake/archive/refs/tags/v3.0.4.tar.gz> 完整源码包：<https://github.com/TOMO CAT/xmake/releases/download/v3.0.4/xmake v3.0.4.tar.gz> ```bash wget https://github.com/TOMO CAT/xmake/releases/download/v3.0.4/xmake v3.0.4.tar.gz tar xvf xmake v3.0.4.tar.gz C xmake cd xmake ``` > Xmake 的 tar 源码包没有顶层 xmake 根目录，因此解压时候最好带上 ` C xmake` 指定下输出目录。 ### 编译源码 类 unix 平台环境编译 Xmake，我们只需要在源码根目录执行 make 就行了。 ```bash $ cd xmake $ ./configure $ make ``` ### 加载调试 如果编译完成，我们就可以加载刚刚编译好的 Xmake 二进制 core 程序，然后运行本地的 Lua 脚本了。 在 Linux/macOS/FreeBSD 上只需要运行： ```bash $ cd xmake $ source scripts/srcenv.profile ``` 就能进入本地源码调试环境。 我们也可以运行： ```bash $ xmake l os.programdir ``` 来验证我们是否真的加载了本地的 Lua 脚本环境。 ### 调试 core 二进制 通常调试 Xmake 的 Lua 脚本，只需要直接修改当前源码目录的 Lua 脚本就行了，实时生效的，我们并不需要重复编译 core 二进制。 但是如果是 Xmake 的 C 端 core 程序有问题，需要调试或者加模块，那么就需要重复编译了。 编译完成，也是实时生效的，我们可以在 C 代码里通过： ```c xu_trace_i(\"hello %s\", \"xmake\"); ``` 来格式化打印各种输出。 如果是 sv 等 Xmake 依赖的各种 submodules 子模块有问题，需要调试。 我们也可以直接进入子模块源码，修改后重新编译执行。 但是，如果需要贡献修复补丁，我们需要提交 pr 给子模块的仓库才行，补丁合并后，作者会在特定时间同步到到 xmake 源码仓库。 ### 断点调试 xmake 也支持 Lua 断点调试支持，配合 [VSCode EmmyLua](https://github.com/EmmyLua/VSCode EmmyLua) 插件，我们可以很方便的在 VSCode 中断点调试 xmake 自身源码。 首先，我们需要在 VSCode 的插件市场安装 VSCode EmmyLua 插件，然后执行下面的命令更新下 xmake repo 仓库保持最新。 ```bash xrepo update repo ``` > Xmake 也需要保持最新版本。 然后，在自己的工程目录下执行以下命令： ```bash $ xrepo env b emmylua_debugger xmake build ``` 其中 `xrepo env b emmylua_debugger` 用于绑定 EmmyLua 调试器插件环境，而 ` ` 后面的参数，就是我们实际需要被调试的 xmake 命令。 通常我们仅仅调试 `xmake build` 构建，如果想要调试其他命令，可以自己调整，比如想要调试 `xmake install o /tmp` 安装命令，那么可以改成： ```bash $ xrepo env b emmylua_debugger xmake install o /tmp ``` 执行完上面的命令后，它不会立即退出，会一直处于等待调试状态，有可能没有任何输出。 这个时候，我们不要急着退出它，继续打开 VSCode，并在 VSCode 中打开 Xmake 的 Lua 脚本源码目录。 也就是这个目录：[Xmake Lua Scripts](https://github.com/xmake io/xmake/tree/master/xmake)，我们可以下载的本地，也可以直接打开 Xmake 安装目录中的 lua 脚本目录。 然后切换到 VSCode 的调试 Tab 页，点击 `RunDebug` > `Emmylua New Debug` 就能连接到我们的 `xmake build` 命令调试端，开启调试。 如下图所示，默认的起始断点会自动中断到 `debugger:_start_emmylua_debugger` 内部，我们可以点击单步跳出当前函数，就能进入 main 入口。 ![](./image/xmake debug.png) 然后设置自己的断点，点击继续运行，就能中断到自己想要调试的代码位置。 我们也可以在项目工程的配置脚本中设置断点，也可以实现快速调试自己的配置脚本，而不仅仅是 xmake 自身源码。 ![](./image/xmake debug2.png) ### 远程调试 xmake 也能支持远程调试，在虚拟机中调试往往体验不佳，因此通常会远程连到其他主机上去调试 xmake 源码。 我们先在远程机器上开启远程编译服务： ```bash $ xmake service ``` 然后本机打开需要构建的工程目录，执行远程连接，然后执行 `xmake service sync xmakesrc ` 去同步本地源码： ```bash $ xmake service connect $ xmake service sync xmakesrc ~/projects/personal/xmake/xmake/ $ xmake build $ xmake run ``` 这样，我们就能本地修改 xmake 脚本源码，然后同步到远程机器上，再远程执行 xmake 构建命令获取对应的调试输出，以及分析构建行为。 我们也能够通过 `xmake service pull ` 命令，回拉远程的文件到本地，进行分析。 > 注：详细的远程编译特性说明，见 [远程编译文档](http://xmake.io/#/zh cn/features/remote_build)。 ![](./image/xmake remote.png) ## 如何调试仓库包? 调试的方式有很多种，这里我主要介绍最常使用的调试方式，那就是直接拉取 xmake repo 仓库来调试。 ```bash $ git clone https://github.com/xmake io/xmake repo.git $ xmake l scripts/test.lua vD shallow zlib ``` 使用上面 test.lua 脚本命令来调试包，我们可以重复安装测试指定的包，` shallow` 告诉 xmake 每次测试不去重复完整安装它的所有依赖包，仅仅测试按照当前包。 我们也可以测试指定的平台，架构，编译模式， vs_runtime 和动态库，静态库等等。 ```bash $ xmake l scripts/test.lua vD shallow p mingw mingw /xxx/sdk zlib $ xmake l scripts/test.lua vD shallow p iphoneos a arm64 zlib $ xmake l scripts/test.lua vD shallow k shared vs_runtime MD zlib $ xmake l scripts/test.lua vD shallow m debug zlib ``` ### 调试本地包源码 有时候，由于包的源码和构建脚本有问题，我们需要修改一些代码才能继续测试安装，如果通过 add_patches/io.replace 的方式在 on_install 里面去修改调试，非常繁琐。 因此，我们可以通过指定 ` d package_sourcedir` 方式，直接让测试脚本进入我们预先下载好的包源码目录，测试编译安装，我们每次的代码修改不会被重置。 ```bash $ xmake l scripts/test.lua vD shallow d /tmp/zlib 1.2.11 zlib ``` 等修改调试通过后，我们再根据改动，通过 `git diff > fix.patch` 生成补丁文件，通过 `add_patches` 配置应用补丁包，来修复包的安装。 ### 远程调试包源码 我们也可以远程调试包，先开启远程服务： ```bash $ xmake service ``` 然后传入 ` remote` 参数，即可实现远程包编译测试。 ```bash $ xmake l scripts/test.lua vD shallow remote /tmp/zlib 1.2.11 zlib ``` ## 下载包提示证书校验失败怎么办？ ```bash curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.se/docs/sslcerts.html curl failed to verify the legitimacy of the server and therefore could not establish a secure connection to it. To learn more about this situation and how to fix it, please visit the web page mentioned above. ``` 如果你在使用 Xmake 安装依赖包时候，遇到上面的证书验证问题，你可以尝试更新 curl 证书去修复它，或者直接全局配置禁用证书验证来绕过它。 ```bash $ xmake g insecure ssl y ``` 当然，禁用证书验证会带来一定的安全性风险，不过好在 xmake repo 仓库中的包，有严格的 sha256 校验，即使下载被劫持，最终也会 xmake 的 sha256 校验检测到，作为无效下载。"},"/get_started/zh/tutorial/project-examples.html":{"title":"","content":" class: heading_no_counter # 工程例子 以下是一些常用的工程例子，更多的 examples 可以到 [project examples](https://github.com/TOMO CAT/xmake/tree/master/tests/projects) 中查看。 我们也可以通过 `xmake create` 命令创建各种常用的空工程来快速开始，具体对于这个命令的介绍以及支持的工程模板可以敲下面的命令查看： ```bash xmake create help ``` ## 可执行程序 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") end) ``` 完整例子请执行下面的命令来创建： ```bash xmake create l c t console test ``` ## 静态库程序 ```lua target(\"library\", function() set_kind(\"static\") add_files(\"src/library/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") add_deps(\"library\") end) ``` 通过 `add_deps` 将一个静态库自动链接到 test 可执行程序。 完整例子请执行下面的命令来创建： ```bash xmake create l c t static test ``` ## 动态库程序 ```lua target(\"library\", function() set_kind(\"shared\") add_files(\"src/library/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") add_deps(\"library\") end) ``` 通过 `add_deps` 将一个动态库自动链接到 test 可执行程序。 完整例子请执行下面的命令来创建： ```bash xmake create l c t shared test ``` ## Wasm 程序 所有 c/c++ 程序，我们都可以编译成 Wasm，无需任何 xmake.lua 配置改动，只需要切换到 wasm 编译平台进行编译。 ```bash $ xmake f p wasm $ xmake ``` 详细的 Wasm 编译配置见：[Wasm 配置](/zh cn/guide/configuration?id wasm) 另外，在编译带有 ` preload file assets/xxx.md` 设置的文件时候，我们也可以通过配置，简化对它的设置。 ```lua target(\"test5\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_values(\"wasm.preloadfiles\", \"src/xxx.md\") add_values(\"wasm.preloadfiles\", \"src/xxx2.md\") end) ``` ## Qt 程序 创建一个空工程： ```bash $ xmake create t qt.console test $ xmake create t qt.static test $ xmake create t qt.shared test $ xmake create t qt.quickapp test $ xmake create t qt.widgetapp test ``` 更多工程模板见：`xmake create help`。 默认会自动探测 Qt 环境，当然也可以指定 Qt SDK 环境目录： ```bash $ xmake f qt ~/Qt/Qt5.9.1 ``` 上述指定的 MingW SDK 用的是 Qt 下 Tools 目录自带的环境，当然如果有其他第三方 MingW 编译环境，也可以手动指定, 具体可以参考：[MingW 编译配置](/zh cn/guide/configuration?id mingw)。 更多详情可以参考：[#160](https://github.com/xmake io/xmake/issues/160) 另外，当前 xmake 也支持 Qt/Wasm，详情见：[Wasm 配置](/zh cn/guide/configuration?id wasm) ```bash $ xmake f p wasm ``` ### 静态库程序 ```lua target(\"qt_static_library\", function() add_rules(\"qt.static\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ### 动态库程序 ```lua target(\"qt_shared_library\", function() add_rules(\"qt.shared\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ### 控制台程序 ```lua target(\"qt_console\", function() add_rules(\"qt.console\") add_files(\"src/*.cpp\") end) ``` ### Quick 应用程序 ```lua target(\"qt_quickapp\", function() add_rules(\"qt.quickapp\") add_files(\"src/*.cpp\") add_files(\"src/qml.qrc\") end) ``` > 如果使用的自己编译的 static 版本 QT SDK，那么需要切换到 `add_rules(\"qt.quickapp_static\")` 静态规则才行，因为链接的库是不同的，需要做静态链接。 ### Quick Plugin 程序 完整例子见：[quickplugin example](https://github.com/xmake io/xmake/tree/master/tests/projects/qt/quickplugin) ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"demo\", function() add_rules(\"qt.qmlplugin\") add_headerfiles(\"src/*.h\") add_files(\"src/*.cpp\") set_values(\"qt.qmlplugin.import_name\", \"My.Plugin\") end) ``` ### Widgets 应用程序 ```lua target(\"qt_widgetapp\", function() add_rules(\"qt.widgetapp\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add_files(\"src/mainwindow.h\") 添加带有 Q_OBJECT 的meta头文件 end) ``` ### Android 应用程序 可以直接切到 android 平台编译 Quick/Widgets 应用程序，生成 apk 包，并且可通过 `xmake install` 命令安装到设备： ```bash $ xmake create t quickapp_qt l c++ appdemo $ cd appdemo $ xmake f p android ndk ~/Downloads/android ndk r19c/ android_sdk ~/Library/Android/sdk/ c $ xmake [ 0%]: compiling.qt.qrc src/qml.qrc [ 50%]: cache compiling.release src/main.cpp [100%]: linking.release libappdemo.so [100%]: generating.qt.app appdemo.apk ``` 然后安装到设备： ```bash $ xmake install installing appdemo ... installing build/android/release/appdemo.apk .. Success install ok!👌 ``` ### 目前支持的 Qt SDK #### 来自 Qt 官方提供的 SDK 安装包 在 macos 上通常能自动探测到，但是也可以手动指定 Qt SDK 路径。 ```bash $ xmake f qt [qt sdk path] ``` #### 来自 Ubuntu Apt 安装包 使用 apt 安装完 Qt SDK，xmake 也能够自动检测到。 ```bash $ sudo apt install y qtcreator qtbase5 dev $ xmake ``` #### 来自 msys2/pacman 的 Qt Mingw 安装包 xmake 也支持从 pacman 安装的 Qt Mingw SDK ```bash $ pacman S mingw w64 x86_64 qt5 mingw w64 x86_64 qt creator $ xmake ``` #### 来自 aqtinstall 脚本的 Qt SDK 包 [aqtinstall](https://github.com/miurahr/aqtinstall) 安装的 Qt SDK 是完全基于官方 SDK 结构的，所以 xmake 也完全支持。 但是，通常需要自己指定 SDK 路径。 ```bash $ xmake f qt [Qt SDK] ``` #### 跨平台 Qt 交叉编译 对于跨平台 Qt 开发，xmake 支持为主机工具和目标平台使用单独的 SDK。这在为不同于开发机器的平台构建 Qt 应用程序时特别有用。 ` qt_host` 选项允许您指定与构建机器兼容的 Qt 工具的位置，而 ` qt` 指向目标平台的 SDK： ```bash $ xmake f qt [target Qt sdk] qt_host [host Qt sdk] ``` **重要注意事项**： * 确保主机和目标 Qt 版本匹配，否则可能会导致构建问题。 * 本机部署工具（如 `windeployqt` 和 `macdeployqt`）必须在各自的平台上运行，因此跨平台任务（如 `xmake install`）可能会失败。 #### 来自 xmake repo 仓库的 Qt 包 xmake 现在官方提供了 Qt5 SDK 的各种模块包，可以自动集成使用，无需任何手动安装。 只需要配置集成包就行了，xmake 会自动处理 Qt 的安装集成，并且自动编译项目。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"qt5widgets\") target(\"test\", function() add_rules(\"qt.widgetapp\") add_packages(\"qt5widgets\") add_headerfiles(\"src/*.h\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add files with Q_OBJECT meta (only for qt.moc) add_files(\"src/mainwindow.h\") end) ``` 除了 `qt5widgets` 包，仓库还提供了 `qt5gui`, `qt5network` 等包，可以使用。 配置完，只需要执行： ```bash $ xmake ``` #### 来自 vcpkg/conan 的 Qt 包 暂时还没时间支持，请尽量使用上面的方式集成 Qt SDK。 ## umdf 驱动程序 ```lua target(\"echo\", function() add_rules(\"wdk.driver\", \"wdk.env.umdf\") add_files(\"driver/*.c\") add_files(\"driver/*.inx\") add_includedirs(\"exe\") end) target(\"app\", function() add_rules(\"wdk.binary\", \"wdk.env.umdf\") add_files(\"exe/*.cpp\") end) ``` ### wdm 驱动程序 ```lua target(\"kcs\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") add_values(\"wdk.man.flags\", \" prefix Kcs\") add_values(\"wdk.man.resource\", \"kcsCounters.rc\") add_values(\"wdk.man.header\", \"kcsCounters.h\") add_values(\"wdk.man.counter_header\", \"kcsCounters_counters.h\") add_files(\"*.c\", \"*.rc\", \"*.man\") end) ``` ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") add_values(\"wdk.tracewpp.flags\", \" func:TracePrint((LEVEL,FLAGS,MSG,...))\") add_files(\"*.c\", {rule \"wdk.tracewpp\"}) add_files(\"*.rc\", \"*.inf\") add_files(\"*.mofmsdsm.mof\") add_files(\"msdsm.mof\", {values {wdk_mof_header \"msdsmwmi.h\"}}) end) ``` ### 生成驱动包 可以通过以下命令生成 .cab 驱动包： ```bash $ xmake [ppackage] $ xmake [ppackage] o outputdir ``` 输出的目录结构如下： ``` drivers sampledsm debug/x86/sampledsm.cab release/x64/sampledsm.cab debug/x86/sampledsm.cab release/x64/sampledsm.cab ``` ### 驱动签名 默认编译禁用签名，可以通过 `set_values(\"wdk.sign.mode\", ...)` 设置签名模式来启用签名。 #### 测试签名 测试签名一般本机调试时候用，可以使用 xmake 自带的 test 证书来进行签名，例如： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") end) ``` 不过这种情况下，需要用户手动在管理员模式下，执行一遍：`$xmake l utils.wdk.testcert install`，来生成和注册 test 证书到本机环境。 这个只需要执行一次就行了，后续就可以正常编译和签名了。 当然也可以使用本机已有的有效证书去签名。 从 sha1 来选择合适的证书进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") set_values(\"wdk.sign.thumbprint\", \"032122545DCAA6167B1ADBE5F7FDF07AE2234AAA\") end) ``` 从 store/company 来选择合适的证书进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") set_values(\"wdk.sign.store\", \"PrivateCertStore\") set_values(\"wdk.sign.company\", \"tboox.org(test)\") end) ``` #### 正式签名 通过指定对应的正式签名证书文件进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"release\") set_values(\"wdk.sign.company\", \"xxxx\") set_values(\"wdk.sign.certfile\", path.join(os.projectdir(), \"xxxx.cer\")) end) ``` ### 生成低版本驱动 如果想在 wdk10 环境编译生成 win7, win8 等低版本系统支持的驱动，可以通过设置 `wdk.env.winver` 来切换系统版本： ```lua set_values(\"wdk.env.winver\", \"win10\") set_values(\"wdk.env.winver\", \"win10_rs3\") set_values(\"wdk.env.winver\", \"win81\") set_values(\"wdk.env.winver\", \"win8\") set_values(\"wdk.env.winver\", \"win7\") set_values(\"wdk.env.winver\", \"win7_sp1\") set_values(\"wdk.env.winver\", \"win7_sp2\") set_values(\"wdk.env.winver\", \"win7_sp3\") ``` 我们也可以手动指定编译的目标程序支持的 windows 版本： ```bash $ xmake f wdk_winver [win10_rs3win8win7win7_sp1] $ xmake ``` ## iOS/MacOS 程序 ### App 应用程序 用于生成 `*.app/*.ipa` 应用程序，同时支持 iOS/MacOS。 ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") end) ``` > 可以支持直接添加 `*.metal` 文件，xmake 会自动生成 default.metallib 提供给应用程序加载使用。 #### 创建工程 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.macapp l objc test $ xmake create t xcode.iosapp l objc test ``` #### 编译 ```bash $ xmake f p [iphoneosmacosx] $ xmake [ 18%]: compiling.xcode.release src/Assets.xcassets [ 27%]: processing.xcode.release src/Info.plist [ 72%]: compiling.xcode.release src/Base.lproj/Main.storyboard [ 81%]: compiling.xcode.release src/Base.lproj/LaunchScreen.storyboard [ 45%]: cache compiling.release src/ViewController.m [ 63%]: cache compiling.release src/AppDelegate.m [ 54%]: cache compiling.release src/SceneDelegate.m [ 36%]: cache compiling.release src/main.m [ 90%]: linking.release test [100%]: generating.xcode.release test.app [100%]: build ok! ``` #### 配置签名 对于 iOS 程序，默认会检测系统先用可用签名来签名 app，当然我们也可以手动指定其他签名证书： ```bash $ xmake f p iphoneos xcode_codesign_identity 'Apple Development: xxx@gmail.com (T3NA4MRVPU)' xcode_mobile_provision 'iOS Team Provisioning Profile: org.tboox.test xcode_bundle_identifier org.tboox.test' $ xmake ``` 如果每次这么配置签名觉得繁琐的话，可以设置到 `xmake global` 全局配置中，也可以在 xmake.lua 中对每个 target 单独设置： ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") add_values(\"xcode.bundle_identifier\", \"org.tboox.test\") add_values(\"xcode.codesign_identity\", \"Apple Development: xxx@gmail.com (T3NA4MRVPU)\") add_values(\"xcode.mobile_provision\", \"iOS Team Provisioning Profile: org.tboox.test\") end) ``` 那如何知道我们需要的签名配置呢？一种就是在 xcode 里面查看，另外 xmake 也提供了一些辅助工具可以 dump 出当前可用的所有签名配置： ```bash $ xmake l private.tools.codesign.dump codesign identities { \"Apple Development: waruqi@gmail.com (T3NA4MRVPU)\" \"AF73C231A0C35335B72761BD3759694739D34EB1\" } mobile provisions { \"iOS Team Provisioning Profile: org.xmake.test\" \"<?xml version \"1.0\" encoding \"UTF 8\"?> <!DOCTYPE plist PUBLIC \" //Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList 1.0.dtd\"> <plist version \"1.0\"> <dict> \t<key>AppIDName</key> \t<string>XC org xmake test5</string> \t<key>ApplicationIdentifierPrefix</key> \t<array> \t<string>43AAQM58X3</string> ... ``` 我们也提供了其他辅助工具来对已有的 ipa/app 程序进行重签名，例如： ```bash $ xmake l utils.ipa.resign test.ipatest.app [codesign_identity] [mobile_provision] [bundle_identifier] ``` 其中，后面的签名参数都是可选的，如果没设置，那么默认会探测使用一个有效的签名： ```bash $ xmake l utils.ipa.resign test.ipa $ xmake l utils.ipa.resign test.app \"Apple Development: cat@gmail.com (T3NA4MRVPU)\" $ xmake l utils.ipa.resign test.ipa \"Apple Development: cat@gmail.com (T3NA4MRVPU)\" iOS Team Provisioning Profile: org.xmake.test\" org.xmake.test ``` #### 运行应用程序 目前仅支持运行macos程序： ```bash $ xmake run ``` 效果如下： ![](/assets/img/guide/macapp.png) #### 生成程序包 如果是 iOS 程序会生成 ipa 安装包，如果是 macos 会生成 dmg （dmg 包生成暂时还在开发中）。 ```bash $ xmake package output: build/iphoneos/release/arm64/test.ipa package ok! ``` 我们也提供了辅助工具，来对指定 app 程序进行打包： ```bash $ xmake l utils.ipa.package test.app output.ipa [iconfile.png] ``` #### 安装 如果是 iOS 程序会安装 ipa 到设备，如果是 macos 会安装 app 到 /Applications 目录。 ```bash $ xmake install ``` 我们也提供了辅助工具，来对指定ipa/app程序安装到设备： ```bash $ xmake l utils.ipa.install test.app $ xmake l utils.ipa.install test.ipa ``` #### 卸载 > 目前仅支持 macos 程序卸载 ```bash $ xmake uninstall ``` ### Framework 库程序 ```lua target(\"test\", function() add_rules(\"xcode.framework\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.framework l objc test ``` 另外，xmake 还提供了带有 framework 库使用的完整 iosapp/macapp 空工程模板，可以完整体验 framework 的编译，依赖使用以及集成到 app 应用程序中。 同时，如果我们开启了模拟器，xmake 可以支持直接 `xmake install` 和 `xmake run` 将 app 安装到模拟器并加载运行。 ```bash $ xmake create t xcode.iosapp_with_framework l objc testapp $ cd testapp $ xmake f p iphoneos a x86_64 $ xmake $ xmake install $ xmake run ``` ### Bundle程序 ```lua target(\"test\", function() add_rules(\"xcode.bundle\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.bundle l objc test ``` ## Protobuf程序 ### 使用c库 ```lua add_requires(\"protobuf c\") target(\"console_c\", function() set_kind(\"binary\") add_packages(\"protobuf c\") add_rules(\"protobuf.c\") add_files(\"src/*.c\") add_files(\"src/*.proto\") end) ``` 我们还可以设置 `proto_public true` 来导出 proto 的头文件搜索目录，开放给其他父 target 继承使用。 ```lua add_packages(\"protobuf c\", {public true}) add_files(\"src/**.proto\", {proto_public true}) ``` 注：由于 protobuf 生成的头文件引用了 protobuf c 包的头文件，因此，我们也需要将包的头文件标记为 `{public true}` 对外导出它。 ### 使用c++库 ```lua add_requires(\"protobuf cpp\") target(\"console_c++\", function() set_kind(\"binary\") set_languages(\"c++11\") add_packages(\"protobuf cpp\") add_rules(\"protobuf.cpp\") add_files(\"src/*.cpp\") add_files(\"src/*.proto\") end) ``` 我们还可以设置 `proto_public true` 来导出 proto 的头文件搜索目录，开放给其他父 target 继承使用。 ```lua add_packages(\"protobuf cpp\", {public true}) add_files(\"src/**.proto\", {proto_public true}) ``` 注：由于 protobuf 生成的头文件引用了 protobuf cpp 包的头文件，因此，我们也需要将包的头文件标记为 `{public true}` 对外导出它。 ## Cuda程序 创建一个空工程： ```bash $ xmake create P test l cuda $ cd test $ xmake ``` ```lua define target target(\"cuda_console\", function() set_kind(\"binary\") add_files(\"src/*.cu\") generate SASS code for SM architecture of current host add_cugencodes(\"native\") generate PTX code for the virtual architecture to guarantee compatibility add_cugencodes(\"compute_30\") end) ``` > 默认构建会启用 device link。（参见 [Separate Compilation and Linking of CUDA C++ Device Code](https://devblogs.nvidia.com/separate compilation linking cuda device code/)） 如果要显式禁用 device link，可以通过 `set_policy(\"build.cuda.devlink\", false)` 来设置。 > cuda 源文件中的 device 函数需要被 device link 且只 device link 一次。在 `shared` 或 `binary` 的 target 上 xmake 会自动进行 device link ，这时它们依赖的 `static` target 也会同时被 device link ，因此默认情况下 `static` target 不会被 device link。然而，如果最终的 `shared` 或 `binary` 的 target 不包含任何 cuda 源文件，则不会发生 device link 阶段，导致出现 undefined reference 错误。这种情况下，需要手动为 `static` target 指定 `add_values(\"cuda.build.devlink\", true)`. 默认会自动探测 cuda 环境，当然也可以指定 Cuda SDK 环境目录，或者指定 cuda 版本（此时将在默认安装目录进行查找）： ```bash $ xmake f cuda /usr/local/cuda 9.1/ $ xmake f cuda 9.1 $ xmake ``` 更多详情可以参考：[#158](https://github.com/xmake io/xmake/issues/158) ## Lex & Yacc程序 ```lua target(\"calc\", function() set_kind(\"binary\") add_rules(\"lex\", \"yacc\") add_files(\"src/*.l\", \"src/*.y\") end) ``` ## OpenMP 程序 我们不需要额外配置 rules，仅仅通过一个通用的 openmp 包就可以实现相同的效果。 ```lua add_requires(\"openmp\") target(\"loop\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"openmp\") end) ``` ## Fortran 程序 我们可以通过下面的命令，快速创建一个基于 fortran 的空工程： ```bash $ xmake create l fortran t console test ``` 它的xmake.lua内容如下： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.f90\") end) ``` 更多代码例子可以到这里查看：[Fortran Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/fortran) ## Go 程序 xmake 也支持 go 程序的构建，也提供了空工程的创建命令支持: ```bash $ xmake create l go t console test ``` xmake.lua 内容如下: ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.go\") end) ``` 更多例子见：[Go Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/go) ## Dlang 程序 创建空工程： ```bash $ xmake create l dlang t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") end) ``` xmake 也提供对 dub 包管理的支持，可以快速集成 dlang 的第三方依赖包： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"dub::log 0.4.3\", {alias \"log\"}) add_requires(\"dub::dateparser\", {alias \"dateparser\"}) add_requires(\"dub::emsi_containers\", {alias \"emsi_containers\"}) add_requires(\"dub::stdx allocator\", {alias \"stdx allocator\"}) add_requires(\"dub::mir core\", {alias \"mir core\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") add_packages(\"log\", \"dateparser\", \"emsi_containers\", \"stdx allocator\", \"mir core\") end) ``` 不过还有一些不完善的地方，比如目前必须手动配置所有级联依赖包，会稍微繁琐些，后续有待改进。 更多例子见：[Dlang Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/dlang) ## Rust程序 创建空工程： ```bash $ xmake create l rust t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") end) ``` 更多例子见：[Rust Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/rust) ### 添加 Cargo 包依赖 例子: https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cargo_deps ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::base64 0.13.0\") add_requires(\"cargo::flate2 1.0.17\", {configs {features \"zlib\"}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::base64\", \"cargo::flate2\") end) ``` ### 集成 Cargo.toml 的依赖包 上面直接使用 `add_requires(\"cargo::base64 0.13.0\")` 的方式集成依赖，会有一个问题： 如果依赖很多，并且有几个依赖都共同依赖了相同的子依赖，那么会出现重定义问题，因此如果我们使用完整的 Cargo.toml 去管理依赖就不会存在这个问题。 例如： ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::test\", {configs {cargo_toml path.join(os.projectdir(), \"Cargo.toml\")}}) target(\"test\") set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::test\") ``` 完整例子见：[cargo_deps_with_toml](https://github.com/xmake io/xmake/blob/dev/tests/projects/rust/cargo_deps_with_toml/xmake.lua) ### 使用 cxxbridge 在 c++ 中调用 rust 例子: <https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library> ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cargo::cxx 1.0\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.rs\") set_values(\"rust.cratetype\", \"staticlib\") add_packages(\"cargo::cxx\") end) target(\"test\", function() set_kind(\"binary\") add_rules(\"rust.cxxbridge\") add_deps(\"foo\") add_files(\"src/main.cc\") add_files(\"src/bridge.rsx\") end) ``` foo.rs ```rust #[cxx::bridge] mod foo { extern \"Rust\" { fn add(a: i32, b: i32) > i32; } } pub fn add(a: i32, b: i32) > i32 { return a + b; } ``` 我们还需要在 c++ 项目中添加桥接文件 bridge.rsx ```rust #[cxx::bridge] mod foo { extern \"Rust\" { fn add(a: i32, b: i32) > i32; } } ``` main.cc ```c++ #include <stdio.h> #include \"bridge.rs.h\" int main(int argc, char** argv) { printf(\"add(1, 2) %d\\n\", add(1, 2)); return 0; } ``` ### 在 Rust 中调用 C++ 例子: <https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/rust_call_cxx_library> ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.cc\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.rs\") end) ``` main.rs ```rust extern \"C\" { \tfn add(a: i32, b: i32) > i32; } fn main() { unsafe { \t println!(\"add(1, 2) {}\", add(1, 2)); } } ``` foo.cc ```c++ extern \"C\" int add(int a, int b) { return a + b; } ``` ## Swift 程序 创建空工程： ```bash $ xmake create l swift t console test ``` xmake.lua内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.swift\") end) ``` 更多例子见：[Swift Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/swift) ## Objc 程序 创建空工程： ```bash $ xmake create l objc t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.m\") end) ``` 更多例子见：[Objc Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/objc++) ## Objc 程序 创建空工程： ```bash $ xmake create l objc t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.m\") end) ``` 更多例子见：[Objc Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/objc++) ## Zig 程序 创建空工程： ```bash $ xmake create l zig t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.zig\") end) ``` 更多例子见：[Zig Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/zig) ## Linux Bpf 程序 xmake 支持 bpf 程序构建，同时支持 linux 以及 android 平台，能够自动拉取 llvm 和 android ndk 工具链。 更多详情见：[#1274](https://github.com/xmake io/xmake/issues/1274) ```lua add_rules(\"mode.release\", \"mode.debug\") add_rules(\"platform.linux.bpf\") add_requires(\"linux tools\", {configs {bpftool true}}) add_requires(\"libbpf\") if is_plat(\"android\") then add_requires(\"ndk > 22.x\") set_toolchains(\"@ndk\", {sdkver \"23\"}) else add_requires(\"llvm > 10.x\") set_toolchains(\"@llvm\") add_requires(\"linux headers\") end target(\"minimal\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"linux tools\", \"linux headers\", \"libbpf\") set_license(\"GPL 2.0\") end) ``` ## Vala 程序 xmake 支持构建 Vala 程序，我们需要应用 `add_rules(\"vala\")` 规则，并且 glib 包是必须的。 相关 issues: [#1618](https://github.com/xmake io/xmake/issues/1618) `add_values(\"vala.packages\")` 用于告诉 valac，项目需要哪些包，它会引入相关包的 vala api，但是包的依赖集成，还是需要通过 `add_requires(\"lua\")` 下载集成。 ### 控制台程序 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"lua\", \"glib\") target(\"test\", function() set_kind(\"binary\") add_rules(\"vala\") add_files(\"src/*.vala\") add_packages(\"lua\", \"glib\") add_values(\"vala.packages\", \"lua\") end) ``` ### 静态库程序 我们能够通过 `add_values(\"vala.header\", \"mymath.h\")` 设置导出的接口头文件名，通过 `add_values(\"vala.vapi\", \"mymath 1.0.vapi\")` 设置导出的 vapi 文件名。 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"glib\") target(\"mymath\", function() set_kind(\"static\") add_rules(\"vala\") add_files(\"src/mymath.vala\") add_values(\"vala.header\", \"mymath.h\") add_values(\"vala.vapi\", \"mymath 1.0.vapi\") add_packages(\"glib\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"mymath\") add_rules(\"vala\") add_files(\"src/main.vala\") add_packages(\"glib\") end) ``` ### 动态库程序 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"glib\") target(\"mymath\", function() set_kind(\"shared\") add_rules(\"vala\") add_files(\"src/mymath.vala\") add_values(\"vala.header\", \"mymath.h\") add_values(\"vala.vapi\", \"mymath 1.0.vapi\") add_packages(\"glib\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"mymath\") add_rules(\"vala\") add_files(\"src/main.vala\") add_packages(\"glib\") end) ``` 更多例子：[Vala examples](https://github.com/xmake io/xmake/tree/master/tests/projects/vala) ## Pascal 程序 我们能够支持构建 Pascal 程序，相关 issues 见：[#388](https://github.com/xmake io/xmake/issues/388) ### 控制台程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.pas\") end) ``` ### 动态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.pas\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.pas\") end) ``` 更多例子：[Pascal examples](https://github.com/xmake io/xmake/tree/master/tests/projects/pascal) ## Swig 模块 xmake 支持构建 Swig 模块，我们提供了 `swig.c` 和 `swig.cpp` 规则，分别对应支持生成 c/c++ 模块接口代码，配合 xmake 的包管理系统实现完全自动化的模块和依赖包整合。 相关 issues: [#1622](https://github.com/xmake io/xmake/issues/1622) ### Lua/C 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"lua\") target(\"example\", function() add_rules(\"swig.c\", {moduletype \"lua\"}) add_files(\"src/example.i\", {swigflags \" no old metatable bindings\"}) add_files(\"src/example.c\") add_packages(\"lua\") end) ``` ### Python/C 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"python 3.x\") target(\"example\", function() add_rules(\"swig.c\", {moduletype \"python\"}) add_files(\"src/example.i\", {scriptdir \"share\"}) add_files(\"src/example.c\") add_packages(\"python\") end) ``` ### Python/C++ 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"python 3.x\") target(\"example\", function() add_rules(\"swig.cpp\", {moduletype \"python\"}) add_files(\"src/example.i\", {scriptdir \"share\"}) add_files(\"src/example.cpp\") add_packages(\"python\") end) ``` ### Java/C 模块 [完整例子](https://github.com/xmake io/xmake/blob/dev/tests/projects/swig/java_c) ```lua make sure you config to an enviroment with jni.h for example: xmake f c p android target(\"example\", function() set_kind('shared') set moduletype to java add_rules(\"swig.c\", {moduletype \"java\"}) test jar build add_rules(\"swig.c\", {moduletype \"java\" , buildjar true}) use swigflags to provider package name and output path of java files add_files(\"src/example.i\", {swigflags { \" package\", \"com.example\", \" outdir\", \"build/java/com/example/\" }}) add_files(\"src/example.c\") add_includedirs(\"src\") before_build(function() ensure output path exists before running swig os.mkdir(\"build/java/com/example/\") end) end) ``` 我们也可以配置 ```lua add_rules(\"swig.c\", {moduletype \"java\", buildjar true}) ``` 去同时构建 jar 包，方便直接使用。 ## C++20 模块 ### 快速开始 xmake 采用 `.mpp` 作为默认的模块扩展名，但是也同时支持 `.ixx`, `.cppm`, `.mxx` 等扩展名。 目前 xmake 已经完整支持 gcc11/clang/msvc 的 C++20 Modules 构建支持，并且能够自动分析模块间的依赖关系，实现最大化并行编译。 ```lua set_languages(\"c++20\") target(\"class\", function() set_kind(\"binary\") add_files(\"src/*.cpp\", \"src/*.mpp\") end) ``` 更多例子见：[C++ Modules](https://github.com/xmake io/xmake/tree/master/tests/projects/c%2B%2B/modules) ### Cpp Only 工程 xmake 对 C++20 模块的实现进行了重构和升级，新增了对 Headerunits 的支持，我们可以在模块中引入 Stl 和 用户头文件模块。 相关的补丁见：[#2641](https://github.com/xmake io/xmake/pull/2641)。 注：通常我们至少需要添加一个 `.mpp` 文件，才能开启 C++20 modules 编译，如果只有 cpp 文件，默认是不会开启模块编译的。 但是，如果我们仅仅只是想在 cpp 文件中使用模块的 Headerunits 特性，比如引入一些 stl Headerunits 在 cpp 中使用， 那么我们也可以通过设置 `set_policy(\"build.c++.modules\", true)` 来强行开启 C++ Modules 编译，例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") set_languages(\"c++20\") set_policy(\"build.c++.modules\", true) end) ``` ### 模块的分发和集成 #### 分发 C++ Modules 包 我们先使用 xmake.lua 维护模块的构建，并通过指定 `{install true}`，来告诉 xmake 哪些模块文件需要安装对外分发。 ```lua add_rules(\"mode.release\", \"mode.debug\") set_languages(\"c++20\") target(\"foo\", function() set_kind(\"static\") add_files(\"*.cpp\") add_files(\"*.mpp\", { install true }) end) ``` 然后，我们把它做成包，可以提交到 [xmake repo](https://github.com/xmake io/xmake repo) 仓库，当然也可以直接做成本地包，或者私有仓库包。 这里，为了方便测试验证，我们仅仅通过 `set_sourcedir` 将它做成本地包。 ```lua package(\"foo\", function() set_sourcedir(path.join(os.scriptdir(), \"src\")) on_install(function(package) import(\"package.tools.xmake\").install(package, {}) end) end) ``` #### 集成 C++ Modules 包 然后，我们通过 `add_requires(\"foo\")` 的包集成接口，对 C++ Modules 包进行快速集成使用。 由于 foo 的模块包，我们放在私有仓库中定义，所以我们通过 `add_repositories(\"my repo my repo\")` 引入自己的包仓库。 如果，包已经提交到 xmake repo 官方仓库，就不需要额外配置它。 ```lua add_rules(\"mode.release\", \"mode.debug\") set_languages(\"c++20\") add_repositories(\"my repo my repo\") add_requires(\"foo\", \"bar\") target(\"packages\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"foo\", \"bar\") set_policy(\"build.c++.modules\", true) end) ``` 集成好包后，我们就可以执行 `xmake` 命令，一键下载、编译、集成 C++ Modules 包来使用。 ```bash $ xmake checking for platform ... linux checking for architecture ... x86_64 note: install or modify (m) these packages (pass y to skip confirm)? in my repo: > foo latest > bar latest please input: y (y/n/m) > install bar latest .. ok > install foo latest .. ok [ 0%]: generating.module.deps src/main.cpp [ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/b/bar/latest/4e0143c97b65425b855ad5fd03038b6a/modules/bar/bar.mpp [ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/f/foo/latest/4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp [ 14%]: compiling.module.release bar [ 14%]: compiling.module.release foo [ 57%]: compiling.release src/main.cpp [ 71%]: linking.release packages [100%]: build ok! ``` 注：每个包安装后，会在包路径下，存储维护模块的 meta info 文件，这是 `p2473r1.pdf` 中约定的一种格式规范，也许它不是最终的标准，但这并不影响我们现在去使用模块的分发。 ```bash $ cat ./build/.packages/f/foo/latest/4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp.meta info {\"_VENDOR_extension\":{\"xmake\":{\"name\":\"foo\",\"file\":\"foo.mpp\"}},\"definitions\":{},\"include_paths\":{}} ``` 完整的例子工程见：[C++ Modules 包分发例子工程](https://github.com/xmake io/xmake/tree/master/tests/projects/c%2B%2B/modules/packages) ### 支持 C++23 Std Modules [Arthapz](https://github.com/Arthapz) 也帮忙改进了对 C++23 Std Modules 的支持。 目前三个编译器对它的支持进展： #### Clang 目前最新的 clang 似乎也还没完全支持 C++23 std modules，当前还是 draft patch 状态，[#D135507](https://reviews.llvm.org/D135507)。 但是，Xmake 也对它进行了支持，如果大家想要尝鲜，可以自行合入这个 patch，然后使用 xmake 来测试。 另外，低版本的 clang 也有对非标准的 std modules 做了实验性支持。 我们还是可以在低版本 clang 中尝试性使用 xmake 来构建 std modules，尽管它可能还只是个玩具（会遇到很多问题）。 相关讨论见：[#3255](https://github.com/xmake io/xmake/pull/3255) #### Gcc 目前还不支持。 ## 合并静态库 ### 自动合并 target 库 我们可以通过设置 `build.merge_archive` 策略，启用自动合并依赖的所有静态库，例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"add\", function() set_kind(\"static\") add_files(\"src/add.c\") add_files(\"src/subdir/add.c\") end) target(\"sub\", function() set_kind(\"static\") add_files(\"src/sub.c\") add_files(\"src/subdir/sub.c\") end) target(\"mul\", function() set_kind(\"static\") add_deps(\"add\", \"sub\") add_files(\"src/mul.c\") set_policy(\"build.merge_archive\", true) end) ``` mul 静态库自动合并了 add 和 sub 静态库，生成一个包含 add/sub 代码的完整 libmul.a 库。 这个合并相对比较稳定完善，支持 ar 和 msvc/lib.exe，也支持交叉编译工具链生成的静态库合并，也支持带有重名 obj 文件的静态库。 ### 合并指定的静态库文件 如果自动合并不满足需求，我们也可以主动调用 `utils.archive.merge_archive` 模块在 `after_link` 阶段合并指定的静态库列表。 ```lua target(\"test\", function() after_link(function (target) import(\"utils.archive.merge_staticlib\") merge_staticlib(target, \"libout.a\", {\"libfoo.a\", \"libbar.a\"}) end) end) ``` ### 使用 add_files 合并静态库 其实，我们之前的版本已经支持通过 `add_files(\"*.a\")` 来合并静态库。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"*.a\") add_files(\"*.c\") end) ``` 但是它有一些缺陷：如果使用 ar，可能会存在 .obj 对象文件同名冲突导致合并失败，因此推荐使用上文介绍的合并方式，更加的稳定可靠，也更加的简单。 相关 issues: [#1638](https://github.com/xmake io/xmake/issues/1638) ## Nim 程序 xmake 支持 Nimlang 项目，相关 issues 见：[#1756](https://github.com/xmake io/xmake/issues/1756) ### 创建空工程 我们可以使用 `xmake create` 命令创建空工程。 ```bash xmake create l nim t console test xmake create l nim t static test xmake create l nim t shared test ``` ### 控制台程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake v [ 33%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache o:b uild/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### 静态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.nim\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake v [ 33%]: linking.release libfoo.a /usr/local/bin/nim c opt:speed nimcache:build/.gens/foo/macosx/x86_64/release/nimcache app :staticlib noMain passC: DNimMain NimMain_B6D5BD02 passC: DNimMainInner NimMainInner_B6D5B D02 passC: DNimMainModule NimMainModule_B6D5BD02 passC: DPreMain PreMain_B6D5BD02 passC: D PreMainInner PreMainInner_B6D5BD02 o:build/macosx/x86_64/release/libfoo.a src/foo.nim [ 66%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache pa ssL: Lbuild/macosx/x86_64/release passL: lfoo o:build/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### 动态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.nim\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake rv [ 33%]: linking.release libfoo.dylib /usr/local/bin/nim c opt:speed nimcache:build/.gens/foo/macosx/x86_64/release/nimcache app :lib noMain o:build/macosx/x86_64/release/libfoo.dylib src/foo.nim [ 66%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache pa ssL: Lbuild/macosx/x86_64/release passL: lfoo o:build/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### C 代码混合编译 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ### Nimble 依赖包集成 完整例子见：[Nimble Package Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/nim/nimble_package) ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"nimble::zip >0.3\") target(\"test, function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"nimble::zip\") end) ``` main.nim ```nim import zip/zlib echo zlibVersion() ``` ### Native 依赖包集成 完整例子见：[Native Package Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/nim/native_package) ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"zlib\") end) ``` main.nim ```nim proc zlibVersion(): cstring {.cdecl, importc} echo zlibVersion() ``` ## Keil/MDK 嵌入式程序 相关例子工程：[Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/embed/mdk/hello) xmake 会自动探测 Keil/MDK 安装的编译器，相关 issues [#1753](https://github.com/xmake io/xmake/issues/1753)。 使用 armcc 编译 ```bash $ xmake f p cross a cortex m3 toolchain armcc c $ xmake ``` 使用 armclang 编译 ```bash $ xmake f p cross a cortex m3 toolchain armclang c $ xmake ``` ### 可执行程序 ```lua target(\"hello\", function() add_deps(\"foo\") add_rules(\"mdk.binary\") add_files(\"src/*.c\", \"src/*.s\") add_includedirs(\"src/lib/cmsis\") set_runtimes(\"microlib\") end) ``` 需要注意的是，目前一些 mdk 程序都使用了 microlib 库运行时，它需要编译器加上 `__MICROLIB` 宏定义，链接器加上 ` library_type microlib` 等各种配置。 我们可以通过 `set_runtimes(\"microlib\")` 直接设置到 microlib 运行时库，可以自动设置上所有相关选项。 ### 静态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() add_rules(\"mdk.static\") add_files(\"src/foo/*.c\") set_runtimes(\"microlib\") end) ``` ## Keil/C51 嵌入式程序 ### 可执行程序 ```lua target(\"hello\", function() add_rules(\"c51.binary\") set_toolchains(\"c51\") add_files(\"src/main.c\") end) ``` ## Lua 模块 参考 <https://github.com/xmake io/luarocks build xmake> 如果你的 lua 模块含有 C 代码，你可以使用 [LuaNativeObjects](https://github.com/Neopallium/LuaNativeObjects) 去从 lua 代码生成 C 代码。 参考[例子](https://github.com/Freed Wu/rime.nvim/blob/main/xmake.lua)。 ## Nodejs 模块 参考[例子](https://github.com/tonyfettes/coc rime/blob/master/xmake.lua)。 ## Linux 内核驱动模块 xmake 完整支持了 Linux 内核驱动模块的构建，这也许首个也是唯一一个支持编译 Linux 内核驱动的第三方构建工具了。 ### Hello world 模块 完整例子：[Linux Kernel Driver Modules](https://github.com/xmake io/xmake/tree/master/tests/projects/linux/driver/hello) 它的配置非常简单，只需要配置上支持模块的 linux headers 包，然后应用 `platform.linux.module` 构建规则就行了。 ```lua add_requires(\"linux headers\", {configs {driver_modules true}}) target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") add_packages(\"linux headers\") set_license(\"GPL 2.0\") end) ``` 然后直接执行 xmake 命令，一键编译，生成内核驱动模块 hello.ko。 ```bash $ xmake [ 20%]: cache compiling.release src/add.c [ 20%]: cache compiling.release src/hello.c [ 60%]: linking.release build/linux/x86_64/release/hello.ko [100%]: build ok! ``` 我们也可以看完整构建命令参数。 ```bash $ xmake v [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/linux/x86_64/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/linux/x86_64/release/src/hello.c.o src/hello.c [ 60%]: linking.release build/linux/x86_64/release/hello.ko /usr/bin/ld m elf_x86_64 r o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/release/src/add.c.o build/.objs/hello/linux/x86_64/release/src/hello.c.o /usr/src/linux headers 5.11.0 41 generic/scripts/mod/modpost m a o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.c /usr/bin/ld m elf_x86_64 r build id sha1 T /usr/src/linux headers 5.11.0 41 generic/scripts/module.lds o build/linux/x86_64/release/hello.ko build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.o ``` 通过 `add_requires(\"linux headers\", {configs {driver_modules true}})` 配置包，xmake 会自动优先从系统中查找对应的 linux headers 包。 如果没找到，xmake 也会自动下载它，然后自动配置构建带有 driver modules 的内核源码后，使用它继续构建内核模块。 ### 自定义 linux headers 路径 有很多用户反馈，大多数情况下，linux 内核驱动构建都是基于定制版的 linux kernel，因此需要能够自定义配置 linux headers 路径，而不是走远程依赖包模式。 其实，我们通过自己重写 linux headers 包，也是可以做到这一点的。 ```lua package(\"linux headers\") on_fetch(function (package, opt) return {includedirs \"/usr/src/linux headers 5.0/include\"} end) package_end() add_requires(\"linux headers\") target(\"test\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") add_packages(\"linux headers\") end) ``` 不过这样，也许还有点繁琐，因此我们支持更加方便的设置 linux headers 路径。 ```lua target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") set_values(\"linux.driver.linux headers\", \"/usr/src/linux headers 5.11.0 41 generic\") end) ``` 我们也可以通过定义 option 选项，将 linux headers 路径作为 `xmake f linux headers /usr/src/linux headers` 的方式传入。 ```lua option(\"linux headers\", {showmenu true, description \"Set linux headers path.\"}) target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") set_values(\"linux.driver.linux headers\", \"$(linux headers)\") end) ``` 更多详情见：[#1923](https://github.com/xmake io/xmake/issues/1923) ### 交叉编译 我们也支持内核驱动模块的交叉编译，比如在 Linux x86_64 上使用交叉编译工具链来构建 Linux Arm/Arm64 的驱动模块。 我们只需要准备好自己的交叉编译工具链，通过 ` sdk ` 指定它的根目录，然后配置切换到 ` p cross` 平台， 最后指定需要构建的架构 arm/arm64 即可。 这里用到的交叉工具链，可以从这里下载: [Download toolchains](https://releases.linaro.org/components/toolchain/binaries/latest 7/aarch64 linux gnu/) 更多，交叉编译配置文档，见：[配置交叉编译](/zh cn/guide/configuration?id common cross compilation configuration) > 目前仅仅支持 arm/arm64 交叉编译架构，后续会支持更多的平台架构。 #### 构建 Arm 驱动模块 ```bash $ xmake f p cross a arm sdk /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf c $ xmake v checking for arm linux gnueabihf g++ ... /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf g++ checking for the linker (ld) ... arm linux gnueabihf g++ checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf g++ ... ok checking for flags ( fPIC) ... ok checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc ... ok checking for flags ( fPIC) ... ok checking for flags ( O2) ... ok checking for ccache ... /usr/bin/ccache [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/cross/arm/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/cross/arm/release/src/hello.c.o src/hello.c checking for flags ( MMD MF) ... ok checking for flags ( fdiagnostics color always) ... ok [ 60%]: linking.release build/cross/arm/release/hello.ko /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf ld EB r o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.o build/.objs/hello/cross/arm/release/src/add.c.o build/.objs/hello/cross/arm/release/src/hello.c.o /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/mod/modpost m a o build/.objs/hello/cross/arm/release/build/cross/arm/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.c /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf ld EB be8 r build id sha1 T /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/module.lds o build/cross/arm/release/hello.ko build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.o [100%]: build ok! ``` #### 构建 Arm64 驱动模块 ```bash $ xmake f p cross a arm64 sdk /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu c checking for aarch64 linux gnu g++ ... /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++ checking for the linker (ld) ... aarch64 linux gnu g++ checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++ ... ok checking for flags ( fPIC) ... ok checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc ... ok checking for flags ( fPIC) ... ok checking for flags ( O2) ... ok checking for ccache ... /usr/bin/ccache [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/cross/arm64/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/cross/arm64/release/src/hello.c.o src/hello.c checking for flags ( MMD MF) ... ok checking for flags ( fdiagnostics color always) ... ok [ 60%]: linking.release build/cross/arm64/release/hello.ko /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu ld EL maarch64elf r o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/src/add.c.o build/.objs/hello/cross/arm64/release/src/hello.c.o /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/mod/modpost m a o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.c /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu ld EL maarch64elf r build id sha1 T /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/module.lds o build/cross/arm64/release/hello.ko build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o [100%]: build ok! ``` ## ASN.1 程序 ASN.1 程序，需要借助 [ASN.1 Compiler](https://github.com/vlm/asn1c) 去生成相关的 .c 文件参与项目编译。 而 Xmake 内置提供了 `add_rules(\"asn1c\")` 规则去处理 `.c` 文件生成，`add_requires(\"asn1c\")` 自动拉取集成 ASN.1 编译器工具。 下面是一个基础的配置例子： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"asn1c\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_files(\"src/*.asn1\") add_rules(\"asn1c\") add_packages(\"asn1c\") end) ``` 具体见 [完整例子工程](https://github.com/xmake io/xmake/tree/master/tests/projects/c/asn1c)。 ## Verilog 仿真程序 ### iVerilog 仿真器 通过 `add_requires(\"iverilog\")` 配置，我们能够自动拉取 iverilog 工具链包，然后使用 `set_toolchains(\"@iverilog\")` 自动绑定工具链来编译工程。 ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") end) ``` #### 设置抽象配置 ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") add_defines(\"TEST\") add_includedirs(\"inc\") set_languages(\"v1800 2009\") end) ``` 我们可以通过 `set_languages(\"v1800 2009\")` 来设置切换 Verilog 的语言标准。 目前支持的一些取值和映射关系如下： ```lua [\"v1364 1995\"] \" g1995\" [\"v1364 2001\"] \" g2001\" [\"v1364 2005\"] \" g2005\" [\"v1800 2005\"] \" g2005 sv\" [\"v1800 2009\"] \" g2009\" [\"v1800 2012\"] \" g2012\" ``` #### 设置自定义 flags ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") add_values(\"iverilogs.flags\", \" DTEST\") end) ``` #### 构建工程 ```bash $ xmake checking for iverilog ... iverilog checking for vvp ... vvp [ 50%]: linking.iverilog hello.vvp [100%]: build ok! ``` #### 运行程序 ```bash $ xmake run hello world! LXT2 info: dumpfile hello.vcd opened for output. src/main.v:6: $finish called at 0 (1s) ``` 更多完整例子：[iVerilog Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/embed/iverilog) ### Verilator 仿真器 通过 `add_requires(\"verilator\")` 配置，我们能够自动拉取 verilator 工具链包，然后使用 `set_toolchains(\"@verilator\")` 自动绑定到工具链来编译工程。 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_files(\"src/*.cpp\") end) ``` verilator 工程，我们需要一个额外的 `sim_main.cpp` 文件参与编译，作为程序的入口代码。 ``` #include \"hello.h\" #include \"verilated.h\" int main(int argc, char** argv) { VerilatedContext* contextp new VerilatedContext; contextp >commandArgs(argc, argv); hello* top new hello{contextp}; while (!contextp >gotFinish()) { top >eval(); } delete top; delete contextp; return 0; } ``` #### 设置抽象配置 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_defines(\"TEST\") add_includedirs(\"inc\") set_languages(\"v1800 2009\") end) ``` 我们可以通过 `set_languages(\"v1800 2009\")` 来设置切换 Verilog 的语言标准。 目前支持的一些取值和映射关系如下： ```lua Verilog [\"v1364 1995\"] \"+1364 1995ext+v\", [\"v1364 2001\"] \"+1364 2001ext+v\", [\"v1364 2005\"] \"+1364 2005ext+v\", SystemVerilog [\"v1800 2005\"] \"+1800 2005ext+v\", [\"v1800 2009\"] \"+1800 2009ext+v\", [\"v1800 2012\"] \"+1800 2012ext+v\", [\"v1800 2017\"] \"+1800 2017ext+v\", ``` #### 设置自定义 flags ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_files(\"src/*.cpp\") add_values(\"verilator.flags\", \" trace\", \" timing\") end) ``` #### 构建工程 ```bash $ xmake [ 0%]: compiling.verilog src/main.v [ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__Slow.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0__Slow.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello.cpp [ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated_threads.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello__Syms.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h07139e86__0.cpp [ 15%]: cache compiling.release src/sim_main.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0.cpp [ 84%]: linking.release hello [100%]: build ok! ``` #### 运行程序 ```bash $ xmake run ruki 2:hello ruki$ xmake run hello world! src/main.v:4: Verilog $finish ``` 更多完整例子：[Verilator](https://github.com/xmake io/xmake/tree/master/tests/projects/embed/verilator) #### 编译静态库 我们也提供了 `verilator.static` 规则来编译生成 verilator 静态库。 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.static\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") end) target(\"test\", function() add_deps(\"hello\") add_files(\"src/*.cpp\") end) ``` ## Cppfront 程序 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cppfront\") target(\"test\", function() add_rules(\"cppfront\") set_kind(\"binary\") add_files(\"src/*.cpp2\") add_packages(\"cppfront\") end) ``` ## Cosmocc 程序 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cosmocc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"@cosmocc\") end) ```"},"/get_started/zh/tutorial/environment-variables.html":{"title":"","content":" class: heading_no_counter # 环境变量 我们可以执行下面的命令，获取所有 xmake 用到的环境变量，以及当前被设置的值。 ```bash $ xmake show l envs XMAKE_RAMDIR Set the ramdisk directory. <empty> XMAKE_GLOBALDIR Set the global config directory of xmake. /Users/ruki/.xmake XMAKE_ROOT Allow xmake to run under root. <empty> XMAKE_COLORTERM Set the color terminal environment. <empty> XMAKE_PKG_INSTALLDIR Set the install directory of packages. <empty> XMAKE_TMPDIR Set the temporary directory. /var/folders/vn/ppcrrcm911v8b4510klg9xw80000gn/T/.xmake501/211104 XMAKE_PKG_CACHEDIR Set the cache directory of packages. <empty> XMAKE_PROGRAM_DIR Set the program scripts directory of xmake. /Users/ruki/.local/share/xmake XMAKE_PROFILE Start profiler, e.g. perf, trace. <empty> XMAKE_RCFILES Set the runtime configuration files. XMAKE_CONFIGDIR Set the local config directory of project. /Users/ruki/projects/personal/xmake docs/.xmake/macosx/x86_64 XMAKE_LOGFILE Set the log output file path. <empty> ``` ## XMAKE_RAMDIR 设置 ramdisk 目录路径 ramdisk 目录是内存文件系统的目录位置，通常 `os.tmpdir()` 接口会用到，xmake 内部使用的临时文件，如果用户设置 ramdisk 路径，则会优先存储在这个上面，提升整体编译速度。 ## XMAKE_TMPDIR 设置用户的临时目录 默认 xmake 会使用 `/tmp/.xmake`，当然用户可以通过这个变量去修改默认路径。 ## XMAKE_CONFIGDIR 设置本地工程配置目录 每个项目的本地编译配置，默认会存储在当前项目根目录的 `.xmake` 路径下，然后根据不同的平台，架构区分，例如： ```bash .xmake/macosx/x86_64 ``` 我们如果不想存储在项目根目录，也可以自己设置到其他路径，比如 build 目录下等等。 ## XMAKE_GLOBALDIR 设置全局配置文件根目录 也就是 `xmake g/global` 全局配置的存储目录，还有安装包，缓存等其他全局文件，默认都会存储在这个目录下。 默认路径为：`~/.xmake`。 ## XMAKE_ROOT 允许用户在 root 模式下运行 通常 xmake 是默认禁止在 root 下运行，这非常不安全。但是如果用户非要在 root 下运行，也可以设置这个变量，强制开启。 ```bash export XMAKE_ROOT y ``` ## XMAKE_COLORTERM 设置 Terminal 的色彩输出 目前可以设置这几个值： 值 描述 nocolor 禁用彩色输出 color8 8 色输出支持 color256 256 色输出支持 truecolor 真彩色输出支持 通常，用户不需要设置它们，xmake 会自动探测用户终端支持的色彩范围，如果用户不想输出色彩，可以设置 nocolor 来全局禁用。 或者用 `xmake g theme plain` 也可以全局禁用。 ## XMAKE_PKG_INSTALLDIR 设置依赖包的安装根目录 xmake 的远程包安装的全局目录默认是 `~/.xmake/packages`，但是用户也可以设置这个变量，去单独修改它。 我们也可以使用 `xmake g pkg_installdir /xxx` 去设置它，效果是一样的。 ## XMAKE_PKG_CACHEDIR 设置依赖包的缓存目录 默认路径在 `~/.xmake/cache` 目录，存储包安装过程中的各种缓存文件，比较占存储空间，用户也可以单独设置它。 当然，xmake 在每个月都会自动清理上个月的所有缓存文件。 ## XMAKE_PROGRAM_DIR 设置 xmake 的脚本目录 xmake 的所有 lua 脚本随安装程序一起安装，默认都在安装目录下，但是如果想要切到自己下载的脚本目录下，方便本地修改调试，可以设置此变量。 如果要查看当前 xmake 在使用的脚本目录，可以执行： ```bash $ xmake l os.programdir /Users/ruki/.local/share/xmake ``` ## XMAKE_PROFILE 开启性能分析 这仅仅对 xmake 的开发者开放，用于分析 xmake 运行过程中的耗时情况，追踪调用过程。 ### 分析函数调用耗时 ```bash $ XMAKE_PROFILE perf:call xmake [ 25%]: cache compiling.release src/main.cpp [ 50%]: linking.release test [100%]: build ok! 0.238, 97.93%, 1, runloop : @programdir/core/base/scheduler.lua: 805 0.180, 74.04%, 25, _resume : [C]: 1 0.015, 6.34%, 50, _co_groups_resume : @programdir/core/base/scheduler.lua: 299 0.011, 4.37%, 48, wait : @programdir/core/base/poller.lua: 111 0.004, 1.70%, 62, status : @programdir/core/base/scheduler.lua: 71 0.004, 1.53%, 38, is_dead : @programdir/core/base/scheduler.lua: 76 0.003, 1.44%, 50, next : @programdir/core/base/timer.lua: 74 0.003, 1.33%, 48, delay : @programdir/core/base/timer.lua: 60 0.002, 1.02%, 24, is_suspended : @programdir/core/base/scheduler.lua: 86 ``` ### 分析进程耗时 可以用于分析每个文件的编译耗时，以及一些运行瓶颈。 ```bash $ XMAKE_PROFILE perf:process xmake r [ 7%]: compiling.release src/header.h [ 23%]: compiling.release src/test.cpp [ 30%]: compiling.release src/test8.cpp [ 38%]: compiling.release src/test4.cpp [ 46%]: compiling.release src/test5.cpp [ 53%]: compiling.release src/test7.cpp [ 61%]: compiling.release src/test6.cpp [ 69%]: compiling.release src/test2.cpp [ 76%]: compiling.release src/main.cpp [ 84%]: compiling.release test3.cpp [ 84%]: compiling.release src/test.c [ 92%]: linking.release main [100%]: build ok, spent 2.754s 1411.000, 22.19%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_37317EEDB62F4F3088AF6A2E2A649460 fdiagnostics color always x c++ header o build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch src/header.h 508.000, 7.99%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_1ABAE1FAD68D45008DC76A3A00697820 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/main.cpp.o src/main.cpp 473.000, 7.44%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_1C0BE5280C6F4E208F919577A48AAA40 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/test3.cpp.o test3.cpp 451.000, 7.09%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_877D3D9B6BBA4D308BFB5E4EBD751340 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test6.cpp.o src/test6.cpp 404.000, 6.35%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C9968E2873B648208A8C3F2BA7573640 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test7.cpp.o src/test7.cpp 402.000, 6.32%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_7F6DFA37FF494D208EADF9737484EC40 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test2.cpp.o src/test2.cpp 383.000, 6.02%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_63C9E23AE7E047308F762C7C02A56B50 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test4.cpp.o src/test4.cpp 374.000, 5.88%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C3A0EF96A7C14D00879BFAEFD26E9D20 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test8.cpp.o src/test8.cpp 368.000, 5.79%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_BADB46AF75CB4610857EF5083BD54D30 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test.cpp.o src/test.cpp 363.000, 5.71%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_0247BDB87DD14500816471184D4E8140 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test5.cpp.o src/test5.cpp 156.000, 2.45%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fPIC Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F0FF8220B33B46208D39A98937D55E50 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 133.000, 2.09%, 3, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang version 107.000, 1.68%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang O3 Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C8A96266E0034C20898C147FC52F3A40 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 105.000, 1.65%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fdiagnostics color always Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_48A2FA7BE7AB44008B60558E412A9D30 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 105.000, 1.65%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ fPIC target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F510FB15C9A647108111A7010EFED240 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 91.000, 1.43%, 3, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ version 74.000, 1.16%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden O3 DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_BF6B4B6DACB843008E822CEFDC711230 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test.c.o src/test.c 73.000, 1.15%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ o build/macosx/x86_64/release/main build/.objs/main/macosx/x86_64/release/src/test.cpp.o build/.objs/main/macosx/x86_64/release/src/test8.cpp.o build/.objs/main/macosx/x86_64/release/src/test4.cpp.o build/.objs/main/macosx/x86_64/release/src/test5.cpp.o build/.objs/main/macosx/x86_64/release/src/test7.cpp.o build/.objs/main/macosx/x86_64/release/src/test6.cpp.o build/.objs/main/macosx/x86_64/release/src/test2.cpp.o build/.objs/main/macosx/x86_64/release/src/main.cpp.o build/.objs/main/macosx/x86_64/release/test3.cpp.o build/.objs/main/macosx/x86_64/release/src/test.c.o target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz Wl, x Wl, dead_strip 70.000, 1.10%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fPIC Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_6D0B6327841A47208939EEF194F38B50 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 68.000, 1.07%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang O3 Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_8AB279F8450D4D108E92951CC9C1C650 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 65.000, 1.02%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fdiagnostics color always Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_D25F0DB04D6D430084C098F1E1F76C00 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp ``` ### 追踪 xmake 的运行过程 ```bash $ XMAKE_PROFILE trace xmake func : @programdir/core/base/scheduler.lua: 457 is_suspended : @programdir/core/base/scheduler.lua: 86 status : @programdir/core/base/scheduler.lua: 71 thread : @programdir/core/base/scheduler.lua: 66 thread : @programdir/core/base/scheduler.lua: 66 length : @programdir/core/base/heap.lua: 120 ``` ### 分析运行卡死问题 可以用于获取 xmake 运行卡死时的栈。启用此特性后，通过 Ctrl+C 中断后就能获取栈。 ```bash $ XMAKE_PROFILE stuck xmake l test.lua <Ctrl+C> stack traceback: [C]: in function 'base/io.file_read' @programdir/core/base/io.lua:177: in method '_read' @programdir/core/sandbox/modules/io.lua:90: in function <@programdir/core/sandbox/module s/io.lua:89> (...tail calls...) /Users/ruki/share/test.lua:2: in function </Users/ruki/share/test.lua:1> (...tail calls...) @programdir/plugins/lua/main.lua:123: in function <@programdir/plugins/lua/main.lua:79> (...tail calls...) [C]: in function 'xpcall' @programdir/core/base/utils.lua:280: in function 'sandbox/modules/utils.trycall' (...tail calls...) @programdir/core/base/task.lua:519: in function 'base/task.run' @programdir/core/main.lua:278: in upvalue 'cotask' @programdir/core/base/scheduler.lua:371: in function <@programdir/core/base/scheduler.lu a:368> ``` ## XMAKE_RCFILES 设置全局配置文件 我们可以设置一些 xmakerc.lua 全局配置文件，在用户编译项目的时候，全局引入它们，比如全局引入一些用户自定义的帮助脚本，工具链什么的。 ```bash $ export XMAKE_RCFILES xmakerc.lua $ xmake ``` 如果不设置，默认路径为：`~/.xmake/xmakerc.lua`。 ## XMAKE_LOGFILE 设置日志文件路径 默认 xmake 会回显输出到终端，我们在可以通过设置这个路径，开启日志自动存储到指定文件，但它不会影响终端的正常回显输出。 ## XMAKE_MAIN_REPO 设置官方包主仓库地址 xmake 默认内置了三个主仓库地址，它们是完全相同的，xmake 会根据当前网络状态选择最优的地址来使用。 ``` https://github.com/xmake io/xmake repo.git https://gitlab.com/tboox/xmake repo.git https://gitee.com/tboox/xmake repo.git ``` 但如果 xmake 选择错误，可能会导致仓库下载失败，而通过这个环境变量，我们可以自己设置固定使用指定的仓库地址，不再进行自动选择。 ```bash $ export XMAKE_MAIN_REPO https://github.com/xmake io/xmake repo.git ``` ## XMAKE_BINARY_REPO 设置官方包预编译仓库地址 类似 `XMAKE_MAIN_REPO`，唯一的区别是，这个用于切换预编译仓库的地址。 ```bash $ export XMAKE_BINARY_REPO https://github.com/xmake mirror/build artifacts.git ``` ## XMAKE_THEME 设置主题 通常我们可以通过 `xmake g theme plain` 来设置颜色主题，但是它是全局的，如果想单独对当前终端会话设置，我们就可以使用这个环境变量来设置。 ```bash $ export XMAKE_THEME plain ``` ## XMAKE_STATS 开启或禁用用户量统计 由于目前 xmake 还在发展初期，我们需要知道大概的用户量增长情况，以便于提供我们持续更新 xmake 的动力。 因此 xmake 默认每天的第一次项目构建，会在后台进程自动 git clone 一个空仓库：<https://github.com/xmake io/xmake stats> 然后借用 github 自身提供的 Traffic 统计图表来获取大概的用户量。 对于每个项目，每天只会统计一次，并且不会泄露任何用户隐私，因为仅仅只是多了一次额外的 git clone 操作，另外我们 clone 的是一个空仓库，不会耗费用户多少流量。 当然，并不是每个用户都希望这么做，用户完全有权利去禁用这个行为，我们只需要设置： ```bash export XMAKE_STATS n ``` 就可以完全禁用它，另外我们也会在 ci 上自动禁用这个行为。 什么时候移除它？ 这个行为并不会永久存在，等到 xmake 有了足够多的用户量，或者有了其他更好的统计方式，我们会考虑移除相关统计代码。 当然，如果有非常多的用户反馈不愿意接受它，我们也会考虑移除它。 关于这个的相关 issues 见：[#1795](https://github.com/xmake io/xmake/issues/1795)"},"/get_started/zh/target/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 定义和设置子工程模块，每个 `target` 对应一个子工程，最后会生成一个目标程序，有可能是可执行程序，也有可能是库模块。 > target 的接口，都是可以放置在 target 外面的全局作用域中的，如果在全局中设置，那么会影响所有子工程 target。 例如： ```lua 会同时影响 test 和 test2 目标 add_defines(\"DEBUG\") target(\"test\", function() add_files(\"*.c\") end) target(\"test2\", function() add_files(\"*.c\") end) ``` > `target` 域是可以重复进入来实现分离设置的。 ## 定义工程目标 定义一个新的控制台工程目标，工程名为 `test`，最后生成的目标名也是 `test`。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 可以重复调用这个 api，进入 target 域修改设置 ```lua 定义目标 demo，并进入 demo 设置模式 target(\"demo\", function() set_kind(\"binary\") add_files(\"src/demo.c\") end) 定义和设置其他目标 target(\"other\", function() ... end) 重新进入 demo 目标域，添加 test.c 文件 target(\"demo\", function() add_files(\"src/test.c\") end) ``` > 所有根域的设置，会全局影响所有 target 目标，但是不会影响 option 的定义。 ```lua 在根域对所有 target 添加 DDEBUG 的宏定义，影响所有 target（demo 和 test 都会加上此宏定义） add_defines(\"DEBUG\") target(\"demo\", function() set_kind(\"binary\") add_files(\"src/demo.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/test.c\") end) ``` ## target:set_kind ### 设置目标编译类型 设置目标类型，目前支持的类型有： 值 描述 phony 假的目标程序 binary 二进制程序 static 静态库程序 shared 动态库程序 object 仅仅编译对象集合 headeronly 仅仅头文件集合 #### binary 可执行文件类型 ```lua target(\"demo\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` > 如果没有设置 set_kind 接口，默认就是 binary 类型。 所以我们简化为： ```lua target(\"demo\", function() add_files(\"src/*.c\") end) ``` 甚至: ```lua target(\"demo\", {files \"src/*.c\"}) ``` #### static 静态库目标类型 ```lua target(\"demo\", function() set_kind(\"static\") add_files(\"src/*.c\") end) ``` #### shared 动态库目标类型 ```lua target(\"demo\", function() set_kind(\"shared\") add_files(\"src/*.c\") end) ``` #### object 纯对象文件列表类型 通常用于两个目标程序间，部分对象文件共享，仅仅编译一次。也可以用于分离对象文件列表，配置不同的编译参数。 #### phony 空目标类型 它是一个特殊的目标程序类型，它不生成任何实际的程序文件，仅仅用于组合其他目标程序的依赖关系。 ```lua target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) target(\"demo\", function() set_kind(\"phony\") add_deps(\"test1\", \"test2\") end) ``` 比如上述配置，我们就可以在执行 `xmake build demo` 编译的时候，同时编译相关的两个依赖程序：test1 和 test2。 #### headeronly 纯头文件目标类型 xmake 新增了 `headeronly` 目标类型，这个类型的目标程序，我们不会实际编译它们，因为它没有源文件需要被编译。 但是它包含了头文件列表，这通常用于 headeronly 库项目的安装，IDE 工程的文件列表生成，以及安装阶段的 cmake/pkgconfig 导入文件的生成。 例如： ```lua add_rules(\"mode.release\", \"mode.debug\") target(\"foo\", function() set_kind(\"headeronly\") add_headerfiles(\"src/foo.h\") add_rules(\"utils.install.cmake_importfiles\") add_rules(\"utils.install.pkgconfig_importfiles\") end) ``` 更多详情见：[#1747](https://github.com/xmake io/xmake/issues/1747) ## target:set_strip ### 设置是否 strip 信息 设置当前目标的 strip 模式，目前支持以下模式： 值 描述 debug 链接的时候，strip 掉调试符号 all 链接的时候，strip 掉所有符号，包括调试符号 这个 api 一般在 release 模式下使用，可以生成更小的二进制程序： ```lua target(\"xxxx\", function() set_strip(\"all\") end) ``` > 这个 api 不一定非得在 target 之后使用，如果没有 target 指定，那么将会设置到全局模式。 ## target:set_enabled ### 设置是否启用或禁用目标 如果设置 `set_enabled(false)`，则会直接禁用对应的 target，包括 target 的加载和信息获取，而 [set_default](#target%3Aset_default) 仅仅只是设置默认不去编译，但是 target 还是能获取到相关信息的，默认也会被加载。 ## target:set_default ### 设置是否为默认构建安装目标 这个接口用于设置给定工程目标是否作为默认构建，如果没有调用此接口进行设置，那么这个目标就是默认被构建的，例如： ```lua target(\"test1\", function() set_default(false) end) target(\"test2\", function() set_default(true) end) target(\"test3\", function() ... end) ``` 上述代码的三个目标，在执行 `xmake`, `xmake install`, `xmake package`, `xmake run` 等命令的时候，如果不指定目标名，那么： 目标名 行为 test1 不会被默认构建、安装、打包和运行 test2 默认构建、安装、打包和运行 test3 默认构建、安装、打包和运行 通过上面的例子，可以看到默认目标可以设置多个，运行的时候也会依次运行。 > 需要注意的是，`xmake uninstall` 和 `xmake clean` 命令不受此接口设置影响，因为用户大部分情况下都是喜欢清除和卸载所有。 如果不想使用默认的目标，那么可以手动指定需要构建安装的目标： ```bash $ xmake build targetname $ xmake install targetname ``` 如果要强制构建安装所有目标，可以传入 `[ a all]` 参数： ```bash $ xmake build [ a all] $ xmake install [ a all] ``` ## target:set_options ### 设置关联选项 添加选项依赖，如果通过 [option](#option) 接口自定义了一些选项，那么只有在指定 `target` 目标域下，添加此选项，才能进行关联生效。 ```lua 定义一个 hello 选项 option(\"hello\", function() set_default(false) set_showmenu(true) add_defines(\"HELLO_ENABLE\") end) target(\"test\", function() 如果 hello 选项被启用了，这个时候就会将 DHELLO_ENABLE 宏应用到 test 目标上去 set_options(\"hello\") end) ``` > 只有调用 `set_options` 进行关联生效后，[option](#option) 中定义的一些设置才会影响到此 `target` 目标，例如：宏定义、链接库、编译选项等等。 ## target:set_symbols ### 设置符号信息 设置目标的符号模式，如果当前没有定义 target，那么将会设置到全局状态中，影响所有后续的目标。 目前主要支持以下几个级别： 值 描述 gcc/clang msvc debug 添加调试符号 g /Zi /Pdxxx.pdb debug, edit 仅 msvc 生效，配合 debug 级别使用 忽略 /ZI /Pdxxx.pdb debug, embed 仅 msvc 生效，配合 debug 级别使用 忽略 /Z7 hidden 设置符号不可见 fvisibility hidden 忽略 这两个值也可以同时被设置，例如： ```lua 添加调试符号, 设置符号不可见 set_symbols(\"debug\", \"hidden\") ``` 如果没有调用这个 api，默认是禁用调试符号的。 > 通过跟 `set_strip(\"all\")` 配合同时设置，可以自动生成独立的调试符号，例如对于 ios 程序，就是 `.dSYM` 文件，对于 android 等其他程序，就是 `.sym` 符号文件。 如果 target 同时设置了下面两个设置，就会启用符号文件生成： ```lua target(\"test\", function() set_symbols(\"debug\") set_strip(\"all\") end) ``` 对于内置的 release 模式，默认不启用符号生成，仅仅只是 strip targetfile，如果要启用，只需要再额外开启 debug 符号就行，因为 mode.release 内部默认已经启用了 strip 了。 ```lua add_rules(\"mode.release\") target(\"test\", function() set_symbols(\"debug\") end) ``` ios 程序会生成 `.dSYM` 文件，然后同时 Strip 自身符号： ```console [62%]: linking.release libtest.dylib [62%]: generating.release test.dSYM ``` android 程序会生成 `.sym` 文件（其实就是带符号的 so/binary 程序），然后同时 Strip 自身符号： ```console [62%]: linking.release libtest.so [62%]: generating.release test.sym ``` ## target:set_basename ### 设置目标文件名 默认情况下，生成的目标文件名基于 `target(\"name\")` 中配置的值，例如： ```lua 目标文件名为：libxxx.a target(\"xxx\", function() set_kind(\"static\") end) 目标文件名为：libxxx2.so target(\"xxx2\", function() set_kind(\"shared\") end) ``` 默认的命名方式，基本上可以满足大部分情况下的需求，但是如果有时候想要更加定制化目标文件名。 例如，按编译模式和架构区分目标名，这个时候可以使用这个接口，来设置： ```lua target(\"xxx\", function() set_kind(\"static\") set_basename(\"xxx_$(mode)_$(arch)\") end) ``` 如果这个时候，编译配置为：`xmake f m debug a armv7`，那么生成的文件名为：`libxxx_debug_armv7.a` 如果还想进一步定制目标文件的目录名，可参考：[set_targetdir](#target%3Aset_targetdir)。 或者通过编写自定义脚本，实现更高级的逻辑，具体见：[after_build](#target%3Aafter_build) 和 [os.mv](/zh cn/manual/builtin_modules?id osmv)。 ## target:set_filename ### 设置目标文件全名 它跟 [set_basename](#target%3Aset_basename) 的区别在于，[set_basename](#target%3Aset_basename)设置名字不带后缀跟前缀，例如：`libtest.a`，basename 如果改成 test2 后就变成了 `libtest2.a`。 而 filename 的修改，是修改整个目标文件名，包括前后缀，例如可以直接把 `libtest.a` 改成 `test.dll`，这个对于 [set_basename](#target%3Aset_basename) 是做不到的。 ## target:set_prefixname ### 设置目标文件的前置名 修改设置目标文件的前置名，例如将默认的：`libtest.so` 改成 `test.so` ```lua target(\"test\", function() set_prefixname(\"\") end) ``` ## target:set_suffixname ### 设置目标文件的后置名 修改设置目标文件的后置名，例如将默认的：`libtest.so` 改成 `libtest d.so` ```lua target(\"test\", function() set_suffixname(\" d\") end) ``` ## target:set_extension ### 设置目标文件的扩展名 修改设置目标文件的扩展名，例如将默认的：`libtest.so` 改成 `test.dll` ```lua target(\"test\", function() set_prefixname(\"\") set_extension(\".dll\") end) ``` ## target:set_warnings ### 设置警告级别 设置当前目标的编译的警告级别，一般支持一下几个级别： 值 描述 gcc/clang msvc none 禁用所有警告 w W0 less 启用较少的警告 W1 W1 more 启用较多的警告 W3 W3 extra 启用额外警告 Wextra pedantic 启用非语言标准的使用警告 Wpedantic all 启用所有警告 Wall W3 allextra 启用所有警告 + 额外的警告 Wall Wextra W4 everything 启用全部支持的警告 Wall Wextra Weffc++ / Weverything Wall error 将所有警告作为编译错误 Werror WX 这个 api 的参数是可以混合添加的，例如： ```lua 启用所有警告，并且作为编译错误处理 set_warnings(\"all\", \"error\") ``` 如果当前没有目标，调用这个 api 将会设置到全局模式。。 ## target:set_optimize ### 设置优化级别 设置目标的编译优化等级，如果当前没有设置目标，那么将会设置到全局状态中，影响所有后续的目标。 目前主要支持一下几个级别： 值 描述 gcc/clang msvc none 禁用优化 O0 Od fast 快速优化 O1 default faster 更快的优化 O2 O2 fastest 最快运行速度的优化 O3 Ox fp:fast smallest 最小化代码优化 Os O1 GL aggressive 过度优化 Ofast Ox fp:fast 例如： ```lua 最快运行速度的优化 set_optimize(\"fastest\") ``` ## target:set_languages ### 设置代码语言标准 设置目标代码编译的语言标准，如果当前没有目标存在，将会设置到全局模式中。 支持的语言标准目前主要有以下几个： 值 描述 ansi c 语言标准: ansi c89 c 语言标准: c89 gnu89 c 语言标准: gnu89 c99 c 语言标准: c99 gnu99 c 语言标准: gnu99 c11 c 语言标准: c11 c17 c 语言标准: c17 clatest c 语言标准: clatest 值 描述 cxx98 c++ 语言标准:`c++98` gnuxx98 c++ 语言标准:`gnu++98` cxx11 c++ 语言标准:`c++11` gnuxx11 c++ 语言标准:`gnu++11` cxx14 c++ 语言标准:`c++14` gnuxx14 c++ 语言标准:`gnu++14` cxx1z c++ 语言标准:`c++1z` gnuxx1z c++ 语言标准:`gnu++1z` cxx17 c++ 语言标准:`c++17` gnuxx17 c++ 语言标准:`gnu++17` cxx20 c++ 语言标准:`c++20` gnuxx20 c++ 语言标准:`gnu++20` cxxlatest c++ 语言标准:`c++latest` gnuxxlatest c++ 语言标准:`gnu++latest` c 标准和 c++ 标准可同时进行设置，例如： ```lua 设置 c 代码标准：c99， c++ 代码标准：c++11 set_languages(\"c99\", \"cxx11\") ``` 并不是设置了指定的标准，编译器就一定会按这个标准来编译，毕竟每个编译器支持的力度不一样，但是 xmake 会尽最大可能的去适配当前编译工具的支持标准。 ## target:set_fpmodels ### 设置 float point 编译模式 此接口用于设置浮点的编译模式，对数学计算相关优化的编译抽象设置，提供：fast, strict, except, precise 等几种常用的级别，有些可同时设置，有些是有冲突的，最后设置的生效。 关于这些级别的说明，可以参考下微软的文档：[Specify floating point behavior](https://docs.microsoft.com/en us/cpp/build/reference/fp specify floating point behavior?view vs 2019) 当然，对应 gcc/icc 等其他编译器，xmake 会映射到不同的编译 flags。 ```lua set_fpmodels(\"fast\") set_fpmodels(\"strict\") set_fpmodels(\"fast\", \"except\") set_fpmodels(\"precise\") default ``` 关于这块详情见：[https://github.com/xmake io/xmake/issues/981](https://github.com/xmake io/xmake/issues/981) ## target:set_targetdir ### 设置生成目标文件目录 设置目标程序文件的输出目录，一般情况下，不需要设置，默认会输出在 build 目录下 而 build 的目录可以在工程配置的时候，手动修改： ```bash xmake f o /tmp/build ``` 修改成 `/tmp/build` 后，目标文件默认输出到 `/tmp/build` 下面。 而如果用这个接口去设置，就不需要每次敲命令修改了，例如： ```lua target(\"test\", function() set_targetdir(\"/tmp/build\") end) ``` > 如果显示设置了 `set_targetdir`， 那么优先选择 `set_targetdir` 指定的目录为目标文件的输出目录。 ## target:set_objectdir ### 设置对象文件生成目录 设置目标 target 的对象文件 (`*.o/obj`) 的输出目录，例如: ```lua target(\"test\", function() set_objectdir(\"$(buildir)/.objs\") end) ``` ## target:set_dependir ### 设置依赖文件生成目录 设置目标 target 的编译依赖文件 (`.deps`) 的输出目录，例如: ```lua target(\"test\", function() set_dependir(\"$(buildir)/.deps\") end) ``` ## target:add_imports ### 为自定义脚本预先导入扩展模块 通常，我们在 [on_build](#targeton_build) 等自定义脚本内部，可以通过 `import(\"core.base.task\")` 的方式导入扩展模块， 但是对于自定义脚本比较多的情况下，每个自定义脚本都重复导入一遍，非常的繁琐，那么可以通过这个接口，实现预先导入，例如： ```lua target(\"test\", function() on_load(function (target) import(\"core.base.task\") import(\"core.project.project\") task.run(\"xxxx\") end) on_build(function (target) import(\"core.base.task\") import(\"core.project.project\") task.run(\"xxxx\") end) on_install(function (target) import(\"core.base.task\") import(\"core.project.project\") task.run(\"xxxx\") end) end) ``` 通过此接口可以简化为： ```lua target(\"test\", function() add_imports(\"core.base.task\", \"core.project.project\") on_load(function (target) task.run(\"xxxx\") end) on_build(function (target) task.run(\"xxxx\") end) on_install(function (target) task.run(\"xxxx\") end) end) ``` ## target:add_rules ### 添加规则到目标 我们可以通过预先设置规则支持的文件后缀，来扩展其他文件的构建支持： ```lua 定义一个 markdown 文件的构建规则 rule(\"markdown\", function() set_extensions(\".md\", \".markdown\") on_build(function (target, sourcefile) os.cp(sourcefile, path.join(target:targetdir(), path.basename(sourcefile) .. \".html\")) end) end) target(\"test\", function() set_kind(\"binary\") 使 test 目标支持 markdown 文件的构建规则 add_rules(\"markdown\") 添加 markdown 文件的构建 add_files(\"src/*.md\") add_files(\"src/*.markdown\") end) ``` 我们可以在 add_rules 时传参： ```lua rule(\"my_rule\", function() on_load(function (target) local my_arg target:extraconf(\"rules\", \"my_rule\", \"my_arg\") \"my arg\" end) end) target(\"test\", function() add_rules(\"my_rule\", { my_arg \"my arg\"}) end) ``` 我们也可以指定应用局部文件到规则，具体使用见：[add_files](#targetadd_files)。 ## target:on_load ### 自定义目标加载脚本 在 target 初始化加载的时候，将会执行此脚本，在里面可以做一些动态的目标配置，实现更灵活的目标描述定义，例如： ```lua target(\"test\", function() on_load(function (target) target:add(\"defines\", \"DEBUG\", \"TEST \\\"hello\\\"\") target:add(\"linkdirs\", \"/usr/lib\", \"/usr/local/lib\") target:add({includedirs \"/usr/include\", \"links\" \"pthread\"}) end) end) ``` 可以在 `on_load` 里面，通过 `target:set`, `target:add` 来动态添加各种 target 属性。 ## target:on_config ### 自定义配置脚本 在 `xmake config` 执行完成后，Build 之前会执行此脚本，通常用于编译前的配置工作。它与 on_load 不同的是，on_load 只要 target 被加载就会执行，执行时机更早。 如果一些配置，无法在 on_load 中过早配置，那么都可以在 on_config 中去配置它。 另外，它的执行时机比 before_build 还要早，大概的执行流程如下： ``` on_load > after_load > on_config > before_build > on_build > after_build ``` ## target:on_link ### 自定义链接脚本 用于定制化处理 target 的链接过程。 ```lua target(\"test\", function() on_link(function (target) print(\"link it\") end) end) ``` ## target:on_build ### 自定义编译脚本 覆盖 target 目标默认的构建行为，实现自定义的编译过程，一般情况下，并不需要这么做，除非确实需要做一些 xmake 默认没有提供的编译操作。 你可以通过下面的方式覆盖它，来自定义编译操作： ```lua target(\"test\", function() 设置自定义编译脚本 on_build(function (target) print(\"build it\") end) end) ``` 所有 target 的自定义脚本都可以针对不同平台和架构，分别处理，例如： ```lua target(\"test\", function() on_build(\"iphoneosarm*\", function (target) print(\"build for iphoneos and arm\") end) end) ``` 其中如果第一个参数为字符串，那么就是指定这个脚本需要在哪个 `平台 架构` 下，才会被执行，并且支持模式匹配，例如 `arm*` 匹配所有 arm 架构。 当然也可以只设置平台，不设置架构，这样就是匹配指定平台下，执行脚本： ```lua target(\"test\", function() on_build(\"windows\", function (target) print(\"build for windows\") end) end) ``` > 一旦对这个 target 目标设置了自己的 build 过程，那么 xmake 默认的构建过程将不再被执行。 ## target:on_build_file ### 自定义编译脚本, 实现单文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，替换每个源文件编译过程： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_build_file(function (target, sourcefile, opt) end) end) ``` 如果不想重写内置的编译脚本，仅仅只是在编译前后添加一些自己的处理，其实用：[target.before_build_file](#targetbefore_build_file)和 [target.after_build_file](#targetafter_build_file) 会更加方便，不需要调用 `opt.origin`。 ## target:on_build_files ### 自定义编译脚本, 实现多文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，替换一批同类型源文件编译过程： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_build_files(function (target, sourcebatch, opt) end) end) ``` 设置此接口后，对应源文件列表中文件，就不会出现在自定义的 [target.on_build_file](#targeton_build_file) 了，因为这个是包含关系。 其中 sourcebatch 描述了这批同类型源文件： `sourcebatch.sourcekind`: 获取这批源文件的类型，比如：cc, as, .. `sourcebatch.sourcefiles()`: 获取源文件列表 `sourcebatch.objectfiles()`: 获取对象文件列表 `sourcebatch.dependfiles()`: 获取对应依赖文件列表，存有源文件中编译依赖信息，例如：xxx.d ## target:on_clean ### 自定义清理脚本 覆盖 target 目标的 `xmake [cclean}` 的清理操作，实现自定义清理过程。 ```lua target(\"test\", function() 设置自定义清理脚本 on_clean(function (target) 仅删掉目标文件 os.rm(target:targetfile()) end) end) ``` 一些 target 接口描述如下： target 接口 描述 target:name() 获取目标名 target:targetfile() 获取目标文件路径 target:get(\"kind\") 获取目标的构建类型 target:get(\"defines\") 获取目标的宏定义 target:get(\"xxx\") 其他通过 `set_/add_` 接口设置的 target 信息，都可以通过此接口来获取 target:add(\"links\", \"pthread\") 添加目标设置 target:set(\"links\", \"pthread\", \"z\") 覆写目标设置 target:deps() 获取目标的所有依赖目标 target:dep(\"depname\") 获取指定的依赖目标 target:sourcebatches() 获取目标的所有源文件列表 ## target:on_package ### 自定义打包脚本 覆盖 target 目标的 `xmake [ppackage}` 的打包操作，实现自定义打包过程，如果你想对指定 target 打包成自己想要的格式，可以通过这个接口自定义它。 这个接口还是挺实用的，例如，编译完 jni 后，将生成的 so，打包进 apk 包中。 ```lua 定义一个 android app 的测试 demo target(\"demo\", function() 生成动态库：libdemo.so set_kind(\"shared\") 设置对象的输出目录，可选 set_objectdir(\"$(buildir)/.objs\") 每次编译完的 libdemo.so 的生成目录，设置为 app/libs/armeabi set_targetdir(\"libs/armeabi\") 添加 jni 的代码文件 add_files(\"jni/*.c\") 设置自定义打包脚本，在使用 xmake 编译完 libdemo.so 后，执行 xmake p 进行打包 会自动使用 ant 将 app 编译成 apk 文件 on_package(function (target) 使用 ant 编译 app 成 apk 文件，输出信息重定向到日志文件 os.run(\"ant debug\") end) end) ``` ## target:on_install ### 自定义安装脚本 覆盖 target 目标的 `xmake [iinstall}` 的安装操作，实现自定义安装过程。 例如，将生成的 apk 包，进行安装。 ```lua target(\"test\", function() 设置自定义安装脚本，自动安装 apk 文件 on_install(function (target) 使用 adb 安装打包生成的 apk 文件 os.run(\"adb install r ./bin/Demo debug.apk\") end) end) ``` ## target:on_uninstall ### 自定义卸载脚本 覆盖 target 目标的 `xmake [uuninstall}` 的卸载操作，实现自定义卸载过程。 ```lua target(\"test\", function() on_uninstall(function (target) ... end) end) ``` ## target:on_run ### 自定义运行脚本 覆盖 target 目标的 `xmake [rrun}` 的运行操作，实现自定义运行过程。 例如，运行安装好的 apk 程序： ```lua target(\"test\", function() 设置自定义运行脚本，自动运行安装好的 app 程序，并且自动获取设备输出信息 on_run(function (target) os.run(\"adb shell am start n com.demo/com.demo.DemoTest\") os.run(\"adb logcat\") end) end) ``` ## target:before_link ### 在链接之前执行一些自定义脚本 用于在链接之前增加一些自定义的操作。 ```lua target(\"test\", function() before_link(function (target) print(\"\") end) end) ``` ## target:before_build ### 在构建之前执行一些自定义脚本 并不会覆盖默认的构建操作，只是在构建之前增加一些自定义的操作。 ```lua target(\"test\", function() before_build(function (target) print(\"\") end) end) ``` ## target:before_build_file ### 自定义编译前的脚本, 实现单文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在每个源文件编译过程之前执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") before_build_file(function (target, sourcefile, opt) end) end) ``` ## target:before_build_files ### 自定义编译前的脚本, 实现多文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在一批同类型源文件编译过程之前执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") before_build_files(function (target, sourcebatch, opt) end) end) ``` ## target:before_clean ### 在清理之前执行一些自定义脚本 并不会覆盖默认的清理操作，只是在清理之前增加一些自定义的操作。 ```lua target(\"test\", function() before_clean(function (target) print(\"\") end) end) ``` ## target:before_package #### 在打包之前执行一些自定义脚本 并不会覆盖默认的打包操作，只是在打包之前增加一些自定义的操作。 ```lua target(\"test\", function() before_package(function (target) print(\"\") end) end) ``` ## target:before_install ### 在安装之前执行一些自定义脚本 并不会覆盖默认的安装操作，只是在安装之前增加一些自定义的操作。 ```lua target(\"test\", function() before_install(function (target) print(\"\") end) end) ``` ## target:before_uninstall ### 在卸载之前执行一些自定义脚本 并不会覆盖默认的卸载操作，只是在卸载之前增加一些自定义的操作。 ```lua target(\"test\", function() before_uninstall(function (target) print(\"\") end) end) ``` ## target:before_run ### 在运行之前执行一些自定义脚本 并不会覆盖默认的运行操作，只是在运行之前增加一些自定义的操作。 ```lua target(\"test\", function() before_run(function (target) print(\"\") end) end) ``` ## target:after_link ### 在链接之后执行一些自定义脚本 用于在链接之后增加一些自定义的操作。 ```lua target(\"test\", function() after_link(function (target) print(\"\") end) end) ``` ## target:after_build ### 在构建之后执行一些自定义脚本 并不会覆盖默认的构建操作，只是在构建之后增加一些自定义的操作。 例如，对于 ios 的越狱开发，构建完程序后，需要用 `ldid` 进行签名操作 ```lua target(\"test\", function() after_build(function (target) os.run(\"ldid S %s\", target:targetfile()) end) end) ``` ## target:after_build_file ### 自定义编译前的脚本, 实现单文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在每个源文件编译过程之后执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") after_build_file(function (target, sourcefile, opt) end) end) ``` ## target:after_build_files ### 自定义编译前的脚本, 实现多文件构建 通过此接口，可以用来 hook 指定 target 内置的构建过程，在一批同类型源文件编译过程之后执行一些自定义脚本： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") after_build_files(function (target, sourcebatch, opt) end) end) ``` ## target:after_clean ### 在清理之后执行一些自定义脚本 并不会覆盖默认的清理操作，只是在清理之后增加一些自定义的操作。 一般可用于清理编译某 target 自动生成的一些额外的临时文件，这些文件 xmake 默认的清理规则可能没有清理到，例如： ```lua target(\"test\", function() after_clean(function (target) os.rm(\"$(buildir)/otherfiles\") end) end) ``` ## target:after_package ### 在打包之后执行一些自定义脚本 并不会覆盖默认的打包操作，只是在打包之后增加一些自定义的操作。 ```lua target(\"test\", function() after_package(function (target) print(\"\") end) end) ``` ## target:after_install ### 在安装之后执行一些自定义脚本 并不会覆盖默认的安装操作，只是在安装之后增加一些自定义的操作。 ```lua target(\"test\", function() after_install(function (target) print(\"\") end) end) ``` ## target:after_uninstall ### 在卸载之后执行一些自定义脚本 并不会覆盖默认的卸载操作，只是在卸载之后增加一些自定义的操作。 ```lua target(\"test\", function() after_uninstall(function (target) print(\"\") end) end) ``` ## target:after_run ### 在运行之后执行一些自定义脚本 并不会覆盖默认的运行操作，只是在运行之后增加一些自定义的操作。 ```lua target(\"test\", function() after_run(function (target) print(\"\") end) end) ``` ## target:set_pcheader ### 设置 C 预编译头文件 xmake 支持通过预编译头文件去加速 c 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pcheader(\"header.h\") end) ``` ## target:set_pcxxheader ### 设置 C++ 预编译头文件 xmake 支持通过预编译头文件去加速 c++ 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pcxxheader(\"header.h\") end) ``` ## target:set_pmheader ### 设置 ObjC 预编译头文件 xmake 支持通过预编译头文件去加速 ObjC 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pmheader(\"header.h\") end) ``` ## target:set_pmxxheader ### 设置 ObjC++ 预编译头文件 xmake 支持通过预编译头文件去加速 ObjC++ 程序编译，目前支持的编译器有：gcc, clang 和 msvc。 使用方式如下： ```lua target(\"test\", function() set_pmxxheader(\"header.h\") end) ``` ## target:add_deps ### 添加子工程目标依赖 添加当前目标的依赖目标，编译的时候，会去优先编译依赖的目标，然后再编译当前目标。。。 ```lua target(\"test1\", function() set_kind(\"static\") set_files(\"*.c\") end) target(\"test2\", function() set_kind(\"static\") set_files(\"*.c\") end) target(\"demo\", function() add_deps(\"test1\", \"test2\") end) ``` 上面的例子，在编译目标 demo 的时候，需要先编译 test1, test2 目标，因为 demo 会去用到他们 > target 会自动继承依赖目标中的配置和属性，不需要额外调用 `add_links`, `add_linkdirs` 和 `add_rpathdirs` 等接口去关联依赖目标了。 并且继承关系是支持级联的，例如： ```lua target(\"library1\", function() set_kind(\"static\") add_files(\"*.c\") add_includedirs(\"inc\") 默认私有头文件目录不会被继承 add_includedirs(\"inc1\", {public true}) 此处的头文件相关目录也会被继承 end) target(\"library2\", function() set_kind(\"static\") add_deps(\"library1\") add_files(\"*.c\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"library2\") end) ``` 如果我们不想继承依赖 target 的任何配置，如何操作呢？ ```lua add_deps(\"dep1\", \"dep2\", {inherit false}) ``` 通过显式设置 inherit 配置，来告诉 xmake，这两个依赖的配置是否需要被继承，如果不设置，默认就是启用继承的。 通过 `add_includedirs(\"inc1\", {public true})`, 设置 public 为 true, 将 includedirs 的设置公开给其他依赖的子 target 继承。 目前对于 target 的编译链接 flags 相关接口设置，都是支持继承属性的，可以人为控制是否需要导出给其他 target 来依赖继承，目前支持的属性有： 属性 描述 private 默认设置，作为当前 target 的私有配置，不会被依赖的其他 target 所继承 public 公有配置，当前 target，依赖的子 target 都会被设置 interface 接口设置，仅被依赖的子 target 所继承设置，当前 target 不参与 对于这块的详细说明，可以看下：[https://github.com/xmake io/xmake/issues/368](https://github.com/xmake io/xmake/issues/368) ## target:add_links ### 添加链接库名 为当前目标添加链接库，一般这个要与 [add_linkdirs](#targetadd_linkdirs) 配对使用。 ```lua target(\"demo\", function() 添加对 libtest.a 的链接，相当于 ltest add_links(\"test\") 添加链接搜索目录 add_linkdirs(\"$(buildir)/lib\") end) ``` add_links 还支持添加库的完整路径，例如：`add_links(\"/tmp/libfoo.a\")`，显式的指定库文件。 ## target:add_syslinks ### 添加系统链接库名 这个接口使用上跟 [add_links](#targetadd_links) 类似，唯一的区别就是，通过这个接口添加的链接库顺序在所有 `add_links` 之后。 因此主要用于添加系统库依赖，因为系统库的链接顺序是非常靠后的，例如： ```lua add_syslinks(\"pthread\", \"m\", \"dl\") target(\"demo\", function() add_links(\"a\", \"b\") add_linkdirs(\"$(buildir)/lib\") end) ``` 上面的配置，即使 `add_syslinks` 被优先提前设置了，但最后的链接顺序依然是：` la lb lpthread lm ldl` ## target:add_linkorders ### 调整链接顺序 用于调整 target 内部的链接顺序。 由于 xmake 提供了 `add_links`, `add_deps`, `add_packages`, `add_options` 接口，可以配置目标、依赖，包和选项中的链接。 但是它们之间的链接顺序，在之前可控性比较弱，只能按固定顺序生成，这对于一些复杂的项目，就有点显得力不从心了。 更多详情和背景见：[#1452](https://github.com/xmake io/xmake/issues/1452) #### 排序链接 为了更加灵活的调整 target 内部的各种链接顺序，我们新增了 `add_linkorders` 接口，用于配置目标、依赖、包、选项、链接组引入的各种链接顺序。 例如： ```lua add_links(\"a\", \"b\", \"c\", \"d\", \"e\") e > b > a add_linkorders(\"e\", \"b\", \"a\") e > d add_linkorders(\"e\", \"d\") ``` add_links 是配置的初始链接顺序，然后我们通过 add_linkorders 配置了两个局部链接依赖 `e > b > a` 和 `e > d` 后。 xmake 内部就会根据这些配置，生成 DAG 图，通过拓扑排序的方式，生成最终的链接顺序，提供给链接器。 当然，如果存在循环依赖，产生了环，它也会提供警告信息。 #### 排序链接和链接组 另外，对于循环依赖，我们也可以通过 `add_linkgroups` 配置链接组的方式也解决。 并且 `add_linkorders` 也能够对链接组进行排序。 ```lua add_links(\"a\", \"b\", \"c\", \"d\", \"e\") add_linkgroups(\"c\", \"d\", {name \"foo\", group true}) add_linkorders(\"e\", \"linkgroup::foo\") ``` 如果要排序链接组，我们需要对每个链接组取个名，`{name \"foo\"}` ，然后就能在 `add_linkorders` 里面通过 `linkgroup::foo` 去引用配置了。 2.9.6 版本新增 as_needed 配置项，可以用于禁用 as_needed。（默认不配置，就是开启状态。） ```lua add_linkgroups(\"c\", \"d\", {as_needed false}) ``` 对应的 flags 如下。 ```bash Wl, no as needed c d Wl, as needed ``` #### 排序链接和 frameworks 我们也可以排序链接和 macOS/iPhoneOS 的 frameworks。 ```lua add_links(\"a\", \"b\", \"c\", \"d\", \"e\") add_frameworks(\"Foundation\", \"CoreFoundation\") add_linkorders(\"e\", \"framework::CoreFoundation\") ``` #### 完整例子 相关的完整例子，我们可以看下： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"libpng\") target(\"bar\", function() set_kind(\"shared\") add_files(\"src/foo.cpp\") add_linkgroups(\"m\", \"pthread\", {whole true}) end) target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.cpp\") add_packages(\"libpng\", {public true}) end) target(\"demo\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.cpp\") if is_plat(\"linux\", \"macosx\") then add_syslinks(\"pthread\", \"m\", \"dl\") end if is_plat(\"macosx\") then add_frameworks(\"Foundation\", \"CoreFoundation\") end add_linkorders(\"framework::Foundation\", \"png16\", \"foo\") add_linkorders(\"dl\", \"linkgroup::syslib\") add_linkgroups(\"m\", \"pthread\", {name \"syslib\", group true}) end) ``` 完整工程在：[linkorders example](https://github.com/xmake io/xmake/blob/master/tests/projects/c%2B%2B/linkorders/xmake.lua) ## target:add_linkgroups ### 添加链接组 这个链接组的特性，目前主要用于 linux 平台的编译，仅支持 gcc/clang 编译器。 需要注意的是 gcc/clang 里面的链接组概念主要特指：` Wl, start group` 而 xmake 对齐进行了封装，做了进一步抽象，并且不仅仅用于处理 ` Wl, start group`，还可以处理 ` Wl, whole archive` 和 ` Wl, Bstatic`。 下面我们会一一对其进行讲解。 更多详情见：[#1452](https://github.com/xmake io/xmake/issues/1452) #### start group 支持 ` Wl, start group` 和 ` Wl, end group` 是用于处理复杂库依赖关系的链接器选项，确保链接器可以解决符号依赖并成功连接多个库。 在 xmake 中，我们可以通过下面的方式实现： ```lua add_linkgroups(\"a\", \"b\", {group true}) ``` 它会对应生成 ` Wl, start group la lb Wl, end group` 链接选项。 如果 a 和 b 库之间有符号的循环依赖，也不会报链接错误，能够正常链接成功。 对于不支持的平台和编译，会退化成 ` la lb` #### whole archive 支持 ` whole archive` 是一个链接器选项，通常用于处理静态库。 它的作用是告诉链接器将指定的静态库中的所有目标文件都包含到最终可执行文件中，而不仅仅是满足当前符号依赖的目标文件。 这可以用于确保某些库的所有代码都被链接，即使它们在当前的符号依赖关系中没有直接引用。 更多信息，可以参考 gcc/clang 的文档。 在 xmake 中，我们可以通过下面的方式实现： ```lua add_linkgroups(\"a\", \"b\", {whole true}) ``` 它会对应生成 ` Wl, whole archive la lb Wl, no whole archive` 链接选项。 对于不支持的平台和编译，会退化成 ` la lb` 另外，我们可以同时配置 group/whole： ```lua add_linkgroups(\"a\", \"b\", {whole true, group true}) ``` #### Bstatic 支持 ` Bstatic` 也是用于编译器（如 gcc）的选项，用于指示编译器在链接时只使用静态库而不使用共享库。 更多信息，可以参考 gcc/clang 的文档。 在 xmake 中，我们可以通过下面的方式实现： ```lua add_linkgroups(\"a\", \"b\", {static true}) ``` 它会对应生成 ` Wl, Bstatic la lb Wl, Bdynamic` 链接选项。 ## target:add_files ### 添加源代码文件 用于添加目标工程的源文件，甚至库文件，目前支持的一些文件类型： 支持的源文件类型 描述 .c/.cpp/.cc/.cxx c++ 文件 .s/.S/.asm 汇编文件 .m/.mm objc 文件 .swift swift 文件 .go golang 文件 .o/.obj 对象文件 .a/.lib 静态库文件，会自动合并库到目标程序 .rc msvc 的资源文件 .manifest windows manifest 文件 .def windows dll 导出文件 .ld/.lds linker scripts 文件，通常用于 gcc/clang .map/.ver version script 文件，通常用于 gcc/clang 其中通配符 `*` 表示匹配当前目录下文件，而 `**` 则匹配多级目录下的文件。 例如： ```lua add_files(\"src/test_*.c\") add_files(\"src/xxx/**.cpp\") add_files(\"src/asm/*.S\", \"src/objc/**/hello.m\") ``` `add_files` 的使用其实是相当灵活方便的，其匹配模式借鉴了 premake 的风格，但是又对其进行了改善和增强。 使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。 例如： ```lua 递归添加 src 下的所有 c 文件，但是不包括 src/impl / 下的所有 c 文件 add_files(\"src/**.cimpl/*.c\") 添加 src 下的所有 cpp 文件，但是不包括 src/test.cpp、src/hello.cpp 以及 src 下所有带 xx_前缀的 cpp 文件 add_files(\"src/*.cpptest.cpphello.cppxx_*.cpp\") ``` 其中分隔符 `` 之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用 `` 分割就行了。。 添加文件的时候支持过滤一些文件的一个好处就是，可以为后续根据不同开关逻辑添加文件提供基础。 <p class \"tip\"> 为了使得描述上更加的精简，`` 之后的过滤描述都是基于起一个模式：`src/*.cpp` 中 `*` 之前的目录为基础的。 所以上面的例子后面过滤的都是在 src 下的文件，这个是要注意的。 </p> xmake 对 `add_files` 进行了改进，支持基于 files 更细粒度的编译选项控制，例如： ```lua target(\"test\", function() add_defines(\"TEST1\") add_files(\"src/*.c\") add_files(\"test/*.c\", \"test2/test2.c\", {defines \"TEST2\", languages \"c99\", includedirs \".\", cflags \" O0\"}) end) ``` 可以在 `add_files` 的最后一个参数，传入一个配置 table，去控制指定 files 的编译选项，里面的配置参数跟 target 的一致，并且这些文件还会继承 target 的通用配置 ` DTEST1`。 xmake 支持添加未知的代码文件，通过设置 rule 自定义规则，实现这些文件的自定义构建，例如： ```lua target(\"test\", function() ... add_files(\"src/test/*.md\", {rule \"markdown\"}) end) ``` 关于自定义构建规则的使用说明，详细见：[构建规则](#构建规则)。 可以通过 force 参数来强制禁用 cxflags,cflags 等编译选项的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置： ```lua add_files(\"src/*.c\", {force {cxflags \" DTEST\", mflags \" framework xxx\"}}) ``` ## target:remove_files ### 从前面的源代码文件列表中删除指定文件 通过此接口，可以从前面 [add_files](targetadd_files) 接口添加的文件列表中，删除指定的文件，例如： ```lua target(\"test\", function() add_files(\"src/*.c\") remove_files(\"src/test.c\") end) ``` 上面的例子，可以从 `src` 目录下添加除 `test.c` 以外的所有文件，当然这个也可以通过 `add_files(\"src/*.ctest.c\")` 来达到相同的目的，但是这种方式更加灵活。 例如，我们可以条件判断来控制删除哪些文件，并且此接口也支持 [add_files](targetadd_files) 的匹配模式，过滤模式，进行批量移除。 ```lua target(\"test\", function() add_files(\"src/**.c\") remove_files(\"src/test*.c\") remove_files(\"src/subdir/*.cxxx.c\") if is_plat(\"iphoneos\") then add_files(\"xxx.m\") end end) ``` 通过上面的例子，我们可以看出 `add_files` 和 `remove_files` 是根据调用顺序，进行顺序添加和删除的，并且通过 `remove_files(\"src/subdir/*.cxxx.c\")` 删除一批文件， 并且排除 `src/subdir/xxx.c`（就是说，不删除这个文件）。 注： 这个接口 v2.6.3 版本才提供，之前的版本是 del_files，已经废弃。 如果向下要兼容以前的版本，可以通过下面的配置解决。 ```lua remove_files remove_files or del_files ``` ## target:remove_headerfiles ### 从前面的头文件列表中删除指定文件 主要用于从 `add_headerfiles` 设置的头文件列表中删除文件，用法与 `remove_files` 类似。 ## target:add_linkdirs ### 添加链接库搜索目录 设置链接库的搜索目录，这个接口的使用方式如下： ```lua target(\"test\", function() add_linkdirs(\"$(buildir)/lib\") end) ``` 此接口相当于 gcc 的 ` Lxxx` 链接选项。 一般他是与 [add_links](#targetadd_links) 配合使用的，当然也可以直接通过 [add_ldflags](#targetadd_ldflags) 或者 [add_shflags](#targetadd_shflags) 接口来添加，也是可以的。 <p class \"tip\"> 如果不想在工程中写死，可以通过：`xmake f linkdirs xxx` 或者 `xmake f ldflags \" L/xxx\"` 的方式来设置，当然这种手动设置的目录搜索优先级更高。 </p> ## target:add_rpathdirs ### 添加程序运行时动态库的加载搜索目录 通过 [add_linkdirs](#targetadd_linkdirs) 设置动态库的链接搜索目录后，程序被正常链接，但是在 linux 平台想要正常运行编译后的程序，会报加载动态库失败。 因为没找到动态库的加载目录，想要正常运行依赖动态库的程序，需要设置 `LD_LIBRARY_PATH` 环境变量，指定需要加载的动态库目录。 但是这种方式是全局的，影响太广，更好的方式是通过 ` rpath xxx` 的链接器选项，在链接程序的时候设置好需要加载的动态库搜索路径，而 xmake 对其进行了封装，通过 `add_rpathdirs` 更好的处理跨平台问题。 具体使用如下： ```lua target(\"test\", function() set_kind(\"binary\") add_linkdirs(\"$(buildir)/lib\") add_rpathdirs(\"$(buildir)/lib\") end) ``` 只需要在链接的时候，在设置下 rpath 目录就好了，虽然也可以通过 `add_ldflags(\" Wl, rpath xxx\")` 达到相同的目的，但是这个接口更加通用。 内部会对不同平台进行处理，像在 macOS 下，是不需要 ` rpath` 设置的，也是可以正常加载运行程序，因此针对这个平台，xmake 内部会直接忽略器设置，避免链接报错。 而在为 dlang 程序进行动态库链接时，xmake 会自动处理成 ` L rpath xxx` 来传入 dlang 的链接器，这样就避免了直接使用 `add_ldflags` 需要自己判断和处理不同平台和编译器问题。 xmake 对这个接口进行了改进，支持：`@loader_path`, `@executable_path` 和 `$ORIGIN` 的内置变量，来指定程序的加载目录，它们的效果基本上是一样的，主要是为了同时兼容 macho, elf。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_linkdirs(\"$(buildir)/lib\") add_rpathdirs(\"@loader_path/lib\") end) ``` 指定 test 程序加载当前执行目录下 `lib/*.[sodylib]` 的动态库文件，这将有助于提升程序的可移植性，不用写死绝对路径和相对路径，导致程序和目录切换引起程序加载动态库失败。 > 需要注意的是，在 macos 下，要想 add_rpathdirs 设置生效，需要对 dylib 做一些预处理，添加 `@rpath/xxx` 路径设置： > `$install_name_tool add_rpath @rpath/libxxx.dylib xxx/libxxx.dylib` > 我们也可以通过 `otool L libxxx.dylib` 查看是否存在带 @rpath 的路径 另外，对于 gcc， `add_rpathdirs` 默认设置的是 runpath，如果想要显式的配置上 ` Wl, enable new dtags`, ` Wl, disable new dtags` 去配置 rpath 还是 runpath 我们可以通过额外的参数指定，`add_rpathdirs(\"xxx\", {runpath true})` 相关背景细节见：[#5109](https://github.com/xmake io/xmake/issues/5109) xmake 新增了 `add_rpathdirs(\"xxx\", {install_only true})` ，可以单独配置安装后的 rpath 路径。 ## target:add_includedirs ### 添加头文件搜索目录 设置头文件的搜索目录，这个接口的使用方式如下： ```lua target(\"test\", function() add_includedirs(\"$(buildir)/include\") end) ``` 当然也可以直接通过 [add_cxflags](#targetadd_cxflags) 或者 [add_mxflags](#targetadd_mxflags) 等接口来设置，也是可以的。 可通过额外的 `{publicinterface true}` 属性设置，将 includedirs 导出给依赖的子 target，例如： ```lua target(\"test\", function() set_kind(\"static\") add_includedirs(\"src/include\") 仅对当前 target 生效 add_includedirs(\"$(buildir)/include\", {public true})，当前 target 和子 target 都会被设置 end) target(\"demo\", function() set_kind(\"binary\") add_deps(\"test\") end) ``` 更多关于这块的说明，见：[add_deps](#targetadd_deps) > 如果不想在工程中写死，可以通过：`xmake f includedirs xxx` 或者 `xmake f cxflags \" I/xxx\"` 的方式来设置，当然这种手动设置的目录搜索优先级更高。 > 头文件默认不支持模式匹配，也不推荐这么做， 容易引入一些不需要的子目录，导致各种头文件引用冲突干扰，出了问题更难查。 > 如果用户非要这么做，可以通过 `add_includedirs(os.dirs(path.join(os.scriptdir(), \"xxx/**\")))` 来实现。 ## target:add_sysincludedirs ### 添加系统头文件搜索目录 `add_includedirs` 通常用于添加工程头文件搜索目录，而一些系统库头文件的引入，有可能会触发一些内部的警告信息，但是这些警告对于用户来讲也许是无法避免，也修复不了的。 那么，每次显示这些警告反而会干扰用户，因此，gcc/clang 提供了 ` isystem` 专门用来设置系统头文件搜索路径，通过此接口设置的头文件，会压制一些警告信息来避免干扰用户。 msvc 也通提供了 `/external:I` 编译选项来设置它，但是需要高版本 msvc 才支持。 因此，xmake 提供了 `add_sysincludedirs` 来抽象适配设置系统库头文件搜索路径，如果当前编译器不支持，会自动切换回 ` I` 编译选项。 ```lua target(\"test\", function() add_sysincludedirs(\"/usr/include\") end) ``` 生成的编译选项如下： ```console isystem /usr/include ``` 如果是 msvc 编译器，则会是： ```console /experimental:external /external:W0 /external:I /usr/include ``` > 另外，使用 `add_requires()` 引入的依赖包，默认也会使用 ` isystem` 作为外部系统头文件。 ## target:add_defines ### 添加宏定义 ```lua add_defines(\"DEBUG\", \"TEST 0\", \"TEST2 \\\"hello\\\"\") ``` 相当于设置了编译选项： ``` DDEBUG DTEST 0 DTEST2 \\\"hello\\\" ``` ## target:add_undefines ### 取消宏定义 ```lua add_undefines(\"DEBUG\") ``` 相当于设置了编译选项：` UDEBUG` 在代码中相当于：`#undef DEBUG` ## target:add_cflags ### 添加 c 编译选项 仅对 c 代码添加编译选项 ```lua add_cflags(\" g\", \" O2\", \" DDEBUG\") ``` > 所有选项值都基于 gcc 的定义为标准，如果其他编译器不兼容（例如：vc），xmake 会自动内部将其转换成对应编译器支持的选项值。 > 用户无需操心其兼容性，如果其他编译器没有对应的匹配值，那么 xmake 会自动忽略器设置。 可以通过 force 参数来强制禁用 flags 的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置： ```lua add_cflags(\" g\", \" O2\", {force true}) ``` ## target:add_cxflags ### 添加 c/c++ 编译选项 同时对 c/c++ 代码添加编译选项，用法跟 add_cflags 一致。 ## target:add_cxxflags ### 添加 c++ 编译选项 仅对 c++ 代码添加编译选项，用法跟 add_cflags 一致。 #### 添加特定编译器 flags 我们改进了所有 flags 添加接口，可以仅仅对特定编译器指定 flags，例如： ```lua add_cxxflags(\"clang:: stdlib libc++\") add_cxxflags(\"gcc:: stdlib libc++\") add_cxxflags(\"cl::/GR \") add_cxxflags(\"clang_cl::/GR \") ``` 或者： ```lua add_cxxflags(\" stdlib libc++\", {tools \"clang\"}) add_cxxflags(\" stdlib libc++\", {tools \"gcc\"}) add_cxxflags(\"/GR \", {tools {\"clang_cl\", \"cl\"}}) ``` > 不仅仅是编译 flags，对 add_ldflags 等链接 flags，也是同样生效的。 ## target:add_mflags ### 添加 objc 编译选项 仅对 objc 代码添加编译选项 ```lua add_mflags(\" g\", \" O2\", \" DDEBUG\") ``` 可以通过 force 参数来强制禁用 flags 的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置： ```lua add_mflags(\" g\", \" O2\", {force true}) ``` ## target:add_mxflags ### 添加 objc/objc++ 编译选项 同时对 objc/objc++ 代码添加编译选项 ```lua add_mxflags(\" framework CoreFoundation\") ``` ## target:add_mxxflags ### 添加 objc++ 编译选项 仅对 objc++ 代码添加编译选项 ```lua add_mxxflags(\" framework CoreFoundation\") ``` ## target:add_scflags ### 添加 swift 编译选项 对 swift 代码添加编译选项 ```lua add_scflags(\"xxx\") ``` ## target:add_asflags ### 添加汇编编译选项 对汇编代码添加编译选项 ```lua add_asflags(\"xxx\") ``` ## target:add_gcflags ### 添加 go 编译选项 对 golang 代码添加编译选项 ```lua add_gcflags(\"xxx\") ``` ## target:add_dcflags ### 添加 dlang 编译选项 对 dlang 代码添加编译选项 ```lua add_dcflags(\"xxx\") ``` ## target:add_rcflags ### 添加 rust 编译选项 对 rust 代码添加编译选项 ```lua add_rcflags(\"xxx\") ``` ## target:add_fcflags ### 添加 fortran 编译选项 对 fortran 代码添加编译选项 ```lua add_fcflags(\"xxx\") ``` ## target:add_zcflags ### 添加 zig 编译选项 对 zig 代码添加编译选项 ```lua add_zcflags(\"xxx\") ``` ## target:add_cuflags ### 添加 cuda 编译选项 对 cuda 代码添加编译选项 ```lua add_cuflags(\" gencode arch compute_30,code sm_30\") ``` ## target:add_culdflags ### 添加 cuda 设备链接选项 cuda 默认构建会使用 device link，这个阶段如果要设置一些链接 flags，则可以通过这个接口来设置。 而最终的程序链接，会使用 ldflags，不会调用 nvcc，直接通过 gcc/clang 等 c/c++ 链接器来链接。 关于 device link 的说明，可以参考：[https://devblogs.nvidia.com/separate compilation linking cuda device code/](https://devblogs.nvidia.com/separate compilation linking cuda device code/) ```lua add_culdflags(\" gencode arch compute_30,code sm_30\") ``` ## target:add_cugencodes ### 添加 cuda 设备的 gencode 设置 `add_cugencodes()` 接口其实就是对 `add_cuflags(\" gencode arch compute_xx,code compute_xx\")` 编译 flags 设置的简化封装，其内部参数值对应的实际 flags 映射关系如下： ```lua compute_xx > ` gencode arch compute_xx,code compute_xx` sm_xx > ` gencode arch compute_xx,code sm_xx` sm_xx,sm_yy > ` gencode arch compute_xx,code [sm_xx,sm_yy]` compute_xx,sm_yy > ` gencode arch compute_xx,code sm_yy` compute_xx,sm_yy,sm_zz > ` gencode arch compute_xx,code [sm_yy,sm_zz]` native > match the fastest cuda device on current host, eg. for a Tesla P100, ` gencode arch compute_60,code sm_60` will be added, if no available device is found, no ` gencode` flags will be added ``` 例如： ```lua add_cugencodes(\"sm_30\") ``` 就等价为 ```lua add_cuflags(\" gencode arch compute_30,code sm_30\") add_culdflags(\" gencode arch compute_30,code sm_30\") ``` 是不是上面的更加精简些，这其实就是个用于简化设置的辅助接口。 而如果我们设置了 native 值，那么 xmake 会自动探测当前主机的 cuda 设备，然后快速匹配到它对应的 gencode 设置，自动追加到整个构建过程中。 例如，如果我们主机目前的 GPU 是 Tesla P100，并且能够被 xmake 自动检测到，那么下面的设置： ```lua add_cugencodes(\"native\") ``` 等价于： ```lua add_cugencodes(\"sm_60\") ``` ## target:add_ldflags ### 添加链接选项 添加静态链接选项 ```lua add_ldflags(\" L/xxx\", \" lxxx\") ``` 在添加链接选项时，默认无法支持参数内有空格，使用 expand false： ```lua add_ldflags(\" L/my lib\") ERROR: Invalid arguments add_ldflags({\" L/my lib\"}, {expand false}) OK ``` ## target:add_arflags ### 添加静态库归档选项 影响对静态库的生成 ```lua add_arflags(\"xxx\") ``` ## target:add_shflags ### 添加动态库链接选项 影响对动态库的生成 ```lua add_shflags(\"xxx\") ``` ## target:add_options ### 添加关联选项 这个接口跟 [set_options](#targetset_options) 类似，唯一的区别就是，此处是追加选项，而 [set_options](#targetset_options) 每次设置会覆盖先前的设置。 ## target:add_packages ### 添加包依赖 在 target 作用域中，添加集成包依赖，例如： ```lua target(\"test\", function() add_packages(\"zlib\", \"polarssl\", \"pcre\", \"mysql\") end) ``` 这样，在编译 test 目标时，如果这个包存在的，将会自动追加包里面的宏定义、头文件搜索路径、链接库目录，也会自动链接包中所有库。 用户不再需要自己单独调用 [add_links](#targetadd_links)，[add_includedirs](#targetadd_includedirs), [add_ldflags](#targetadd_ldflags) 等接口，来配置依赖库链接了。 对于如何设置包搜索目录，可参考：[add_packagedirs](/zh cn/manual/global_interfaces?id add_packagedirs) 接口 此接口也同时支持远程依赖包管理中 [add_requires](/zh cn/manual/global_interfaces?id add_requires) 定义的包。 ```lua add_requires(\"zlib\", \"polarssl\") target(\"test\", function() add_packages(\"zlib\", \"polarssl\") end) ``` 还支持覆写内置的 links，控制实际链接的库： ```lua 默认会有 ncurses, panel, form 等 links add_requires(\"ncurses\") target(\"test\", function() 显示指定，只使用 ncurses 一个链接库 add_packages(\"ncurses\", {links \"ncurses\"}) end) ``` 或者干脆禁用 links，只使用头文件： ```lua add_requires(\"lua\") target(\"test\", function() add_packages(\"lua\", {links {}}) end) ``` ## target:add_languages ### 添加语言标准 与 [set_languages](#targetset_languages) 类似，唯一区别是这个接口不会覆盖掉之前的设置，而是追加设置。 ## target:add_vectorexts ### 添加向量扩展指令 添加扩展指令优化选项，目前支持以下几种扩展指令集： ```lua add_vectorexts(\"mmx\") add_vectorexts(\"neon\") add_vectorexts(\"avx\", \"avx2\", \"avx512\") add_vectorexts(\"sse\", \"sse2\", \"sse3\", \"ssse3\", \"sse4.2\") ``` > 如果当前设置的指令集编译器不支持，xmake 会自动忽略掉，所以不需要用户手动去判断维护，只需要将你需要的指令集全部设置上就行了。 xmake 新增了一个 `all` 配置项，可以用于尽可能的开启所有扩展指令优化。 ```lua add_vectorexts(\"all\") ``` ## target:add_frameworks ### 添加链接框架 目前主要用于 `ios` 和 `macosx` 平台的 `objc` 和 `swift` 程序，例如： ```lua target(\"test\", function() add_frameworks(\"Foundation\", \"CoreFoundation\") end) ``` 当然也可以使用 [add_mxflags](#targetadd_mxflags) 和[add_ldflags](#targetadd_ldflags)来设置，不过比较繁琐，不建议这样设置。 ```lua target(\"test\", function() add_mxflags(\" framework Foundation\", \" framework CoreFoundation\") add_ldflags(\" framework Foundation\", \" framework CoreFoundation\") end) ``` 如果不是这两个平台，这些设置将会被忽略。 ## target:add_frameworkdirs ### 添加链接框架搜索目录 对于一些第三方 framework，那么仅仅通过 [add_frameworks](#targetadd_frameworks) 是没法找到的，还需要通过这个接口来添加搜索目录。 ```lua target(\"test\", function() add_frameworks(\"MyFramework\") add_frameworkdirs(\"/tmp/frameworkdir\", \"/tmp/frameworkdir2\") end) ``` ## target:set_toolset ### 设置工具集 针对特定 target 单独设置切换某个编译器，链接器，不过我们更推荐使用 [set_toolchains](#targetset_toolchains) 对某个 target 进行整体工具链的切换。 与 set_toolchains 相比，此接口只切换工具链某个特定的编译器或者链接器。 对于 `add_files(\"*.c\")` 添加的源码文件，默认都是会调用系统最匹配的编译工具去编译，或者通过 `xmake f cc clang` 命令手动去修改，不过这些都是全局影响所有 target 目标的。 如果有些特殊需求，需要对当前工程下某个特定的 target 目标单独指定不同的编译器、链接器或者特定版本的编译器，这个时候此接口就可以排上用途了，例如： ```lua target(\"test1\", function() add_files(\"*.c\") end) target(\"test2\", function() add_files(\"*.c\") set_toolset(\"cc\", \"$(projectdir)/tools/bin/clang 5.0\") end) ``` 上述描述仅对 test2 目标的编译器进行特殊设置，使用特定的 clang 5.0 编译器来编译 test2，而 test1 还是使用默认设置。 <p class \"tip\"> 每次设置都会覆盖当前 target 目标下之前的那次设置，不同 target 之间不会被覆盖，互相独立，如果在根域设置，会影响所有子 target。 </p> 前一个参数是 key，用于指定工具类型，目前支持的有（编译器、链接器、归档器）： 工具类型 描述 cc c 编译器 cxx c++ 编译器 mm objc 编译器 mxx objc++ 编译器 gc go 编译器 as 汇编器 sc swift 编译器 rc rust 编译器 dc dlang 编译器 fc fortran 编译器 sc swift 编译器 rust rust 编译器 strip strip 程序 ld c/c++/asm/objc 等通用可执行程序链接器 sh c/c++/asm/objc 等通用动态库链接器 ar c/c++/asm/objc 等通用静态库归档器 dcld dlang 可执行链接器, rcld/gcld 等类似 dcsh dlang 动态库链接器, rcsh/gcsh 等类似 对于一些编译器文件名不规则，导致 xmake 无法正常识别处理为已知的编译器名的情况下，我们也可以加一个工具名提示，例如： ```lua set_toolset(\"cc\", \"gcc@$(projectdir)/tools/bin/mipscc.exe\") ``` 上述描述设置 mipscc.exe 作为 c 编译器，并且提示 xmake 作为 gcc 的传参处理方式进行编译。 ## target:set_toolchains ### 设置工具链 这对某个特定的 target 单独切换设置不同的工具链，和 set_toolset 不同的是，此接口是对完整工具链的整体切换，比如 cc/ld/sh 等一系列工具集。 这也是推荐做法，因为像 gcc/clang 等大部分编译工具链，编译器和链接器都是配套使用的，要切就得整体切，单独零散的切换设置会很繁琐。 比如我们切换 test 目标到 clang+yasm 两个工具链： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"clang\", \"yasm\") end) ``` 只需要指定工具链名字即可，具体 xmake 支持哪些工具链，可以通过下面的命令查看： ```bash $ xmake show l toolchains xcode Xcode IDE vs VisualStudio IDE yasm The Yasm Modular Assembler clang A C language family frontend for LLVM go Go Programming Language Compiler dlang D Programming Language Compiler sdcc Small Device C Compiler cuda CUDA Toolkit ndk Android NDK rust Rust Programming Language Compiler llvm A collection of modular and reusable compiler and toolchain technologies cross Common cross compilation toolchain nasm NASM Assembler gcc GNU Compiler Collection mingw Minimalist GNU for Windows gnu rm GNU Arm Embedded Toolchain envs Environment variables toolchain fasm Flat Assembler ``` 当然，我们也可以通过命令行全局切换到其他工具链： ```bash $ xmake f toolchain clang $ xmake ``` 另外，我们也可以在 xmake.lua 中自定义 toolchain，然后通过 `set_toolchains` 指定进去，例如： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") ... end) ``` 关于这块的详情介绍，可以到 [自定义工具链](/zh cn/manual/custom_toolchain) 章节查看 更多详情见：[#780](https://github.com/xmake io/xmake/issues/780) 支持对 toolchains 平台和架构的单独设置和切换，比如： ```lua target(\"test\", function() set_toolchains(\"xcode\", {plat os.host(), arch os.arch()}) end) ``` 如果当前是在交叉编译模式，那么这个 test 还是会强制切到 xcode 的本地编译工具链和对应的 pc 平台上去，这对于想要同时支持部分 target 使用主机工具链，部分 target 使用交叉编译工具链时候，非常有用。 但是，这还不是特别方便，尤其是跨平台编译时候，不同平台的 pc 工具链都是不同的，有 msvc, xcode, clang 等，还需要判断平台来指定。 因此，我们可以直接使用 [set_plat](#targetset_plat) 和[set_arch](#targetset_arch)接口，直接设置特定 target 到主机平台，就可以内部自动选择 host 工具链了，例如： ```lua target(\"test\", function() set_plat(os.host()) set_arch(os.arch()) end) ``` 这块的应用场景和 example 可以看下：[https://github.com/xmake io/xmake repo/blob/dev/packages/l/luajit/port/xmake.lua](https://github.com/xmake io/xmake repo/blob/dev/packages/l/luajit/port/xmake.lua) luajit 里面就需要同时编译 host 平台的 minilua/buildvm 来生成 jit 相关代码，然后开始针对性编译 luajit 自身到不同的交叉工具链。 关于这块详情，可以参考：[https://github.com/xmake io/xmake/pull/857](https://github.com/xmake io/xmake/pull/857) xmake 对 set_toolchains 做了进一步的改进，更好地对特定 target 支持独立工具链切换，比如不同 target 支持切换到不同的 vs 版本，例如： ```lua target(\"test\", function() set_toolchains(\"msvc\", {vs \"2015\"}) end) ``` 默认 xmake 会使用全局 vs 工具链，比如当前检测到 vs2019，但是用户同时还安装了 vs2015，那么可以通过上面的配置将 test 目标切换到 vs2015 来编译。 甚至还可以配合 `set_arch` 来指定特定的架构到 x86，而不是默认的 x64。 ```lua target(\"test\", function() set_arch(\"x86\") set_toolchains(\"msvc\", {vs \"2015\"}) end) ``` 上面的效果跟 `set_toolchains(\"msvc\", {vs \"2015\", arch \"x86\"})` 类似，不过 `set_arch` 是针对 target 粒度的，而 `set_toolchains` 里面的 arch 设置仅仅针对特定工具链粒度。 通常，我们更推荐使用 `set_arch` 来对整个 target 实现架构切换。 ## target:set_plat ### 设置指定目标的编译平台 通常配合 [set_arch](#targetset_arch) 使用，将指定 target 的编译平台切换到指定平台，xmake 会自动根据切换的平台，选择合适的工具链。 一般用于需要同时编译 host 平台目标、交叉编译目标的场景，更多详情见：[set_toolchains](#targetset_toolchains) 例如： ```console $ xmake f p android ndk /xxx ``` 即使正在使用 android ndk 编译 android 平台目标，但是其依赖的 host 目标，还是会切换到主机平台，使用 xcode, msvc 等 host 工具链来编译。 ```lua target(\"host\", function() set_kind(\"binary\") set_plat(os.host()) set_arch(os.arch()) add_files(\"src/host/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"host\") add_files(\"src/test/*.c\") end) ``` ## target:set_arch ### 设置指定目标的编译架构 详情见：[set_plat](#targetset_plat) ## target:set_values ### 设置一些扩展配置值 给 target 设置一些扩展的配置值，这些配置没有像 `set_ldflags` 这种内置的 api 可用，通过第一个参数传入一个配置名，来扩展配置。 一般用于传入配置参数给自定义 rule 中的脚本使用，例如： ```lua rule(\"markdown\", function() on_build_file(function (target, sourcefile, opt) compile .markdown with flags local flags target:values(\"markdown.flags\") if flags then .. end end) end) target(\"test\", function() add_files(\"src/*.md\", {rule \"markdown\"}) set_values(\"markdown.flags\", \"xxx\", \"xxx\") end) ``` 上述代码例子中，可以看出，在 target 应用 markdown 规则的时候，通过 set_values 去设置一些 flags 值，提供给 markdown 规则去处理。 在规则脚本中可以通过 `target:values(\"markdown.flags\")` 获取到 target 中设置的扩展 flags 值。 > 具体扩展配置名，根据不同的 rule，会有所不同，目前有哪些，可以参考相关规则的描述：[内建规则](/zh cn/manual/custom_rule?id 内建规则) 下面是一些 xmake 目前支持的一些内置的扩展配置项列表。 扩展配置名 配置描述 fortran.moduledir 设置 fortran 模块的输出目录 ndk.arm_mode 设置 ndk 的 arm 编译模式（arm/thumb） objc.build.arc 设置启用或禁用 objc 的 arc objc++.build.arc 设置启用或禁用 objc++ 的 arc xcode.bundle_identifier 设置 xcode 工具链的 Bundle Identifier xcode.mobile_provision 设置 xcode 工具链的证书信息 xcode.codesign_identity 设置 xcode 工具链的代码签名标识 wasm.preloadfiles 设置 wasm 打包的预加载文件（preload file） wdk.env.winver 设置 wdk 的 win 支持版本 wdk.umdf.sdkver 设置 wdk 的 umdf sdk 版本 wdk.kmdf.sdkver 设置 wdk 的 kmdf sdk 版本 wdk.sign.mode 设置 wdk 的代码签名模式 wdk.sign.store 设置 wdk 的代码签名 store wdk.sign.certfile 设置 wdk 的代码签名证书文件 wdk.sign.thumbprint 设置 wdk 的代码签名指纹 ## target:add_values ### 添加一些扩展配置值 用法跟 [target:set_values](#targetset_values) 类似，区别就是这个接口是追加设置，而不会每次覆盖设置。 ## target:set_rundir ### 设置运行目录 此接口用于设置默认运行 target 程序的当前运行目录，如果不设置，默认情况下，target 是在可执行文件所在目录加载运行。 如果用户想要修改加载目录，一种是通过 `on_run()` 的方式自定义运行逻辑，里面去做切换，但仅仅为了切个目录就这么做，太过繁琐。 因此可以通过这个接口快速的对默认执行的目录环境做设置切换。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_rundir(\"$(projectdir)/xxx\") end) ``` ## target:set_runargs ### 设置运行参数列表 2.6.9 新增接口，可用于设置 `xmake run` 的默认运行参数，通过它，我们可以避免每次命令行输入运行参数，`xmake run x arg1 val` ```lua set_runargs(\" x\", \" arg1 val\") ``` ## target:add_runenvs ### 添加运行环境变量 此接口用于添加设置默认运行 target 程序的环境变量，跟 [set_runenv](#targetset_runenv) 不同的是，此接口是对已有系统 env 中的值进行追加，并不会覆盖。 所以，对于 PATH 这种，通过此接口追加值是非常方便的，而且此接口支持多值设置，所以通常就是用来设置带有 path sep 的多值 env。。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_runenvs(\"PATH\", \"/tmp/bin\", \"xxx/bin\") add_runenvs(\"LD_LIBRARY_PATH\", \"/tmp/lib\", \"xxx/lib\") end) ``` ## target:set_runenv ### 设置运行环境变量 此接口跟 [add_runenvs](#targetadd_runenvs) 不同的是，`set_runenv` 是对某个环境变量的覆盖设置，会覆盖原有系统环境的 env 值，并且此接口是单数设置，不能传递多参。 所以，如果要覆盖设置 PATH 这中多路径的 env，需要自己去拼接： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_runenv(\"PATH\", path.joinenv(\"/tmp/bin\", \"xxx/bin\")) set_runenv(\"NAME\", \"value\") end) ``` ## target:set_installdir ### 设置安装目录 2.2.5 版本新增接口，用于针对每个 target 设置不同的默认安装目录，一般用于 `xmake install/uninstall` 命令。 默认情况下执行 `xmake install` 会安装到系统 `/usr/local` 目录，我们除了可以通过 `xmake install o /usr/local` 指定其他安装目录外， 还可以在 xmake.lua 中针对 target 设置不同的安装目录来替代默认目录。 除了上述两种方式，我们也可以通过 `INSTALLDIR` 和 `DESTDIR` 环境变量设置默认的安装目录。 ## target:set_prefixdir ### 设置安装前置子目录 尽管通过 `set_installdir` 和 `xmake install o [installdir]` 设置了安装根目录，但是如果我们还想进一步调整 bin, lib 和 include 的子路径。 那么，我们可以使用这个接口，默认情况下，安装目录会按照这个结构： ```bash installdir bin lib include ``` 如果我们配置： ```lua set_prefix(\"prefixdir\") ``` 就是增加一个总的子目录： ```bash installdir prefixdir bin lib include ``` 我们还可以单独配置 bin, lib 和 include 子目录，例如： ```lua set_prefix(\"prefixdir\", {bindir \"mybin\", libdir \"mylib\", includedir \"myinc\"}) ``` ```bash installdir prefixdir mybin mylib myinc ``` 如果，我们不配置 prefixdir，仅仅修改 bin 子目录，可以将 prefixdir 配置成 `/`。 ```lua set_prefix(\"/\", {bindir \"mybin\", libdir \"mylib\", includedir \"myinc\"}) ``` ```bash installdir mybin mylib myinc ``` ## target:add_installfiles ### 添加安装文件 2.2.5 版本新增接口，用于针对每个 target 设置对应需要安装的文件，一般用于 `xmake install/uninstall` 命令。 比如我们可以指定安装各种类型的文件到安装目录： ```lua target(\"test\", function() add_installfiles(\"src/*.h\") add_installfiles(\"doc/*.md\") end) ``` 默认在 linux 等系统上，我们会安装到 `/usr/local/*.h, /usr/local/*.md`，不过我们也可以指定安装到特定子目录： ```lua target(\"test\", function() add_installfiles(\"src/*.h\", {prefixdir \"include\"}) add_installfiles(\"doc/*.md\", {prefixdir \"share/doc\"}) end) ``` 上面的设置，我们会安装到 `/usr/local/include/*.h, /usr/local/share/doc/*.md` 注：默认安装不会保留目录结构，会完全展开，当然我们也可以通过 `()` 去提取源文件中的子目录结构来安装，例如： ```lua target(\"test\", function() add_installfiles(\"src/(tbox/*.h)\", {prefixdir \"include\"}) add_installfiles(\"doc/(tbox/*.md)\", {prefixdir \"share/doc\"}) end) ``` 我们把 `src/tbox/*.h` 中的文件，提取 `tbox/*.h` 子目录结构后，在进行安装：`/usr/local/include/tbox/*.h, /usr/local/share/doc/tbox/*.md` 当然，用户也可以通过 [set_installdir](#targetset_installdir) 接口，来配合使用。 关于此接口的详细说明，见：[https://github.com/xmake io/xmake/issues/318](https://github.com/xmake io/xmake/issues/318) ## target:add_headerfiles ### 添加安装头文件 2.2.5 版本新增接口，用于针对每个 target 设置对应需要安装的头文件，一般用于 `xmake install/uninstall` 命令。 此接口使用方式跟 [add_installfiles](#targetadd_installfiles) 接口几乎完全一样，都可以用来添加安装文件，不过此接口仅用于安装头文件。 因此，使用上比 `add_installfiles` 简化了不少，默认不设置 prefixdir，也会自动将头文件安装到对应的 `include` 子目录中。 并且此接口对于 `xmake project k vs201x` 等插件生成的 IDE 文件，也会添加对应的头文件进去。 我注：默认安装不会保留目录结构，会完全展开，当然们也可以通过 `()` 去提取源文件中的子目录结构来安装，例如： ```lua target(\"test\", function() add_headerfiles(\"src/(tbox/*.h)\", {prefixdir \"include\"}) end) ``` v2.7.1 之后，我们可以通过 `{install false}` 参数，禁用默认的头文件安装行为，仅仅对设置的头文件用于 project generator 的文件列表展示和编辑，例如 vs project。 ```lua add_headerfiles(\"src/foo.h\") add_headerfiles(\"src/test.h\", {install false}) ``` 上面两个头文件，在 vs 工程中都会展示出来，但是仅仅 foo.h 会被发布安装到系统。 ## target:set_configdir ### 设置模板配置文件的输出目录 2.2.5 版本新增接口，主要用于 [add_configfiles](#targetadd_configfiles) 接口设置的模板配置文件的输出目录。 ## target:set_configvar ### 设置模板配置变量 2.2.5 版本新增接口，用于在编译前，添加一些需要预处理的模板配置变量，一般用于 [add_configfiles](#targetadd_configfiles) 接口。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") set_configvar(\"HAS_FOO\", 1) set_configvar(\"HAS_BAR\", \"bar\") set_configvar(\"HAS_ZOO\", \"zoo\", {quote false}) add_configfiles(\"config.h.in\") end) ``` config.h.in ```c ${define HAS_FOO} ${define HAS_BAR} ${define HAS_ZOO} ``` 生成的 config.h 内容如下： ```c #define HAS_FOO 1 #define HAS_BAR \"bar\" #define HAS_ZOO zoo ``` set_configvar 可以设置 number，string 和 boolean 类型值，如果是 string 值，默认生成的宏定义带有引号，如果要去掉引号，可以设置 `{quote false}`。 相关 issues 见：[#1694](https://github.com/xmake io/xmake/issues/1694) 对于，宏定义里面有路径，需要转义处理路径分隔符的，我们也可以配置开启路径字符转义。 ```lua set_configvar(\"TEST\", \"C:\\\\hello\", {escape true}) ``` 它会自动转义成 `#define TEST \"C:\\\\hello\"` ，如果没开启转义，则会变成：`#define TEST \"C:\\hello\"` 相关 issues 见：[#1872](https://github.com/xmake io/xmake/issues/1872) ## target:add_configfiles ### 添加模板配置文件 用于在编译前，添加一些需要预处理的配置文件。 先来一个简单的例子： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_configdir(\"$(buildir)/config\") add_configfiles(\"src/config.h.in\") end) ``` 上面的设置，会在编译前，自动的将 `config.h.in` 这个头文件配置模板，经过预处理后，生成输出到指定的 `build/config/config.h`。 如果 `set_configdir` 不设置，那么默认输出到 `build` 目录下。 其中 `.in` 后缀会被自动识别处理掉，如果想要输出存储为其他文件名，可以通过： ```lua add_configfiles(\"src/config.h\", {filename \"myconfig.h\"}) ``` 的方式，来重命名输出，同样，这个接口跟 [add_installfiles](#targetadd_configfiles) 类似，也是支持 prefixdir 和子目录提取设置： ```lua add_configfiles(\"src/*.h.in\", {prefixdir \"subdir\"}) add_configfiles(\"src/(tbox/config.h)\") ``` #### 变量替换 这个接口的一个最重要的特性就是，可以在预处理的时候，对里面的一些模板变量进行预处理替换，例如： config.h.in ``` #define VAR1 \"${VAR1}\" #define VAR2 \"${VAR2}\" #define HELLO \"${HELLO}\" ``` ```lua set_configvar(\"VAR1\", \"1\") target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") set_configvar(\"VAR2\", 2) add_configfiles(\"config.h.in\", {variables {hello \"xmake\"}}) add_configfiles(\"*.man\", {onlycopy true}) end) ``` 通过 [set_configvar](#targetset_configvar) 接口设置模板变量，裹着通过 `{variables {xxx \"\"}}` 中设置的变量进行替换处理。 预处理后的文件 `config.h` 内容为： ``` #define VAR1 \"1\" #define VAR2 \"2\" #define HELLO \"xmake\" ``` 而 `{onlycopy true}` 设置，会强制将 `*.man` 作为普通文件处理，仅在预处理阶段 copy 文件，不进行变量替换。 默认的模板变量匹配模式为 `${var}`，当然我们也可以设置其他的匹配模式，例如，改为 `@var@` 匹配规则： ```lua target(\"test\", function() add_configfiles(\"config.h.in\", {pattern \"@(. )@\"}) end) ``` #### 内置变量 我们也有提供了一些内置的变量，即使不通过此接口设置，也是可以进行默认变量替换的： ``` ${VERSION} > 1.6.3 ${VERSION_MAJOR} > 1 ${VERSION_MINOR} > 6 ${VERSION_ALTER} > 3 ${VERSION_BUILD} > set_version(\"1.6.3\", {build \"%Y%m%d%H%M\"}) > 201902031421 ${PLAT} and ${plat} > MACOS and macosx ${ARCH} and ${arch} > ARM and arm ${MODE} and ${mode} > DEBUG/RELEASE and debug/release ${DEBUG} and ${debug} > 1 or 0 ${OS} and ${os} > IOS or ios ``` 例如： config.h.in ```c #define CONFIG_VERSION \"${VERSION}\" #define CONFIG_VERSION_MAJOR ${VERSION_MAJOR} #define CONFIG_VERSION_MINOR ${VERSION_MINOR} #define CONFIG_VERSION_ALTER ${VERSION_ALTER} #define CONFIG_VERSION_BUILD ${VERSION_BUILD} ``` config.h ```c #define CONFIG_VERSION \"1.6.3\" #define CONFIG_VERSION_MAJOR 1 #define CONFIG_VERSION_MINOR 6 #define CONFIG_VERSION_ALTER 3 #define CONFIG_VERSION_BUILD 201902031401 ``` v2.5.3 后新增 git 相关内置变量： ```c #define GIT_COMMIT \"${GIT_COMMIT}\" #define GIT_COMMIT_LONG \"${GIT_COMMIT_LONG}\" #define GIT_COMMIT_DATE \"${GIT_COMMIT_DATE}\" #define GIT_BRANCH \"${GIT_BRANCH}\" #define GIT_TAG \"${GIT_TAG}\" #define GIT_TAG_LONG \"${GIT_TAG_LONG}\" #define GIT_CUSTOM \"${GIT_TAG} ${GIT_COMMIT}\" ``` ```c #define GIT_COMMIT \"8c42b2c2\" #define GIT_COMMIT_LONG \"8c42b2c251793861eb85ffdf7e7c2307b129c7ae\" #define GIT_COMMIT_DATE \"20210121225744\" #define GIT_BRANCH \"dev\" #define GIT_TAG \"v1.6.6\" #define GIT_TAG_LONG \"v1.6.6 0 g8c42b2c2\" #define GIT_CUSTOM \"v1.6.6 8c42b2c2\" ``` #### 宏定义 我们还可以对 `#define` 定义进行一些变量状态控制处理： config.h.in ```c ${define FOO_ENABLE} ``` ```lua set_configvar(\"FOO_ENABLE\", 1) or pass true set_configvar(\"FOO_STRING\", \"foo\") ``` 通过上面的变量设置后，`${define xxx}` 就会替换成： ```c #define FOO_ENABLE 1 #define FOO_STRING \"foo\" ``` 或者（设置为 0 禁用的时候） ```c /* #undef FOO_ENABLE */ /* #undef FOO_STRING */ ``` 这种方式，对于一些自动检测生成 config.h 非常有用，比如配合 option 来做自动检测： ```lua option(\"foo\") set_default(true) set_description(\"Enable Foo\") set_configvar(\"FOO_ENABLE\", 1) 或者传递 true，启用 FOO_ENABLE 变量 set_configvar(\"FOO_STRING\", \"foo\") target(\"test\") add_configfiles(\"config.h.in\") 如果启用 foo 选项 > 添加 FOO_ENABLE 和 FOO_STRING 定义 add_options(\"foo\") ``` config.h.in ```c ${define FOO_ENABLE} ${define FOO_STRING} ``` config.h ```c #define FOO_ENABLE 1 #define FOO_STRING \"foo\" ``` 关于 option 选项检测，以及 config.h 的自动生成，有一些辅助函数，可以看下：[https://github.com/xmake io/xmake/issues/342](https://github.com/xmake io/xmake/issues/342) 除了 `#define`，如果想要对其他非 `#define xxx` 也做状态切换处理，可以使用 `${default xxx 0}` 模式，设置默认值，例如： ``` HAVE_SSE2 equ ${default VAR_HAVE_SSE2 0} ``` 通过 `set_configvar(\"HAVE_SSE2\", 1)` 启用变量后，变为 `HAVE_SSE2 equ 1`，如果没有设置变量，则使用默认值：`HAVE_SSE2 equ 0` 关于这个的详细说明，见：[https://github.com/xmake io/xmake/issues/320](https://github.com/xmake io/xmake/issues/320) #### 定义导出宏 v2.9.8 新增的特性，可以生成动态库的导出宏定义，通常用于 windows 下 dll 库的符号导出和导入。 在 config.h.in 中定义： ```c ${define_export MYLIB} ``` 就会生成 ```c #ifdef MYLIB_STATIC # define MYLIB_EXPORT #else # if defined(_WIN32) # define MYLIB_EXPORT __declspec(dllexport) # elif defined(__GNUC__) && ((__GNUC__ > 4) (__GNUC__ 3 && __GNUC_MINOR__ > 3)) # define MYLIB_EXPORT __attribute__((visibility(\"default\"))) # else # define MYLIB_EXPORT # endif #endif ``` 我们在定义动态库导出符号时，可以通过这个宏来控制导入导出。 ```c MYLIB_EXPORT void foo(); ``` 它跟 CMake 的 [GenerateExportHeader](https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html) 的功能类似。 不过，它不会额外生成一个独立的导出头文件，而是直接在 config.h 中去生成它。 更多详情见：[#6088](https://github.com/xmake io/xmake/issues/6088) #### 自定义预处理器 如果 xmake 内置的生成规则不满足需求，也可以自定义处理器去重写生成规则，例如重写 `${define_export XXX}`： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") add_configfiles(\"config.h.in\", { preprocessor function (preprocessor_name, name, value, opt) if preprocessor_name \"define_export\" then value ([[#ifdef %s_STATIC # define %s_EXPORT #else # if defined(_WIN32) # define %s_EXPORT __declspec(dllexport) # elif defined(__GNUC__) && ((__GNUC__ > 4) (__GNUC__ 3 && __GNUC_MINOR__ > 3)) # define %s_EXPORT __attribute__((visibility(\"default\"))) # else # define %s_EXPORT # endif #endif ]]):format(name, name, name, name, name) return value end end}) end) ``` 我们也可以重写对 `${define XXX}` 和 `${default XXX}` 的生成，甚至自定义扩展其他预处理配置。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"main.c\") set_configvar(\"FOO\", \"foo\") add_configfiles(\"config.h.in\", { preprocessor function (preprocessor_name, name, value, opt) local argv opt.argv if preprocessor_name \"define_custom\" then return string.format(\"#define CUSTOM_%s %s\", name, value) end end}) end) ``` 然后我们在 config.h.in 中配置： ```c ${define_custom FOO arg1 arg2} ``` 其中，`define_custom` 是自定义的预处理器名，FOO 是变量名，可以从 `set_configvar` 中获取变量值。 而 arg1, arg2 是可选的预处理参数列表，根据实际的需求来判断是否需要使用，如果想要使用参数，可以通过 `opt.argv` 来获取，它是一个参数列表 table。 在运行 `xmake config` 后，就会在 config.h 中自动生成如下配置： ```c #define CUSTOM_FOO foo ``` ## target:set_policy ### 设置构建行为策略 xmake 有很多的默认行为，比如：自动检测和映射 flags、跨 target 并行构建等，虽然提供了一定的智能化处理，但重口难调，不一定满足所有的用户的使用习惯和需求。 因此，从 v2.3.4 开始，xmake 提供默认构建策略的修改设置，开放给用户一定程度上的可配置性。 使用方式如下： ```lua set_policy(\"check.auto_ignore_flags\", false) ``` 只需要在项目根域设置这个配置，就可以禁用 flags 的自动检测和忽略机制，另外 `set_policy` 也可以针对某个特定的 target 局部生效。 ```lua target(\"test\", function() set_policy(\"check.auto_ignore_flags\", false) end) ``` 完整的 policies 支持列表和使用说明，见：[构建策略](/zh cn/guide/build_policies) ### target:set_runtimes ### 设置编译目标依赖的运行时库 用于抽象化设置编译目标依赖的运行时库，目前仅仅支持对 msvc 运行时库的抽象，但后续也许会扩展对其他编译器运行时库的映射。 目前支持的一些配置值说明如下： 值 描述 MT msvc 运行时库：多线程静态库 MTd msvc 运行时库：多线程静态库（调试） MD msvc 运行时库：多线程动态库 MDd msvc 运行时库：多线程动态库（调试） c++_static clang 的 c++ 运行时库，静态库 c++_shared clang 的 c++ 运行时库，动态库 stdc++_static gcc 的 c++ 运行时库，静态库 stdc++_shared gcc 的 c++ 运行时库，动态库 gnustl_static android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 gnustl_shared android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 stlport_static android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 stlport_static android 的 c++ 运行时库，静态库，高版本 NDK 已废弃 关于 vs 运行时，可以参考：[msvc 运行时说明](https://docs.microsoft.com/en us/cpp/build/reference/md mt ld use run time library?view msvc 160) 而这个接口传入 MT/MTd 参数配置，xmake 会自动配置上 `/MT /nodefaultlib:msvcrt.lib` 参数。 我们可以针对不同的 target 设置不同的运行时。 另外，如果我们将 `set_runtimes` 设置在全局根域，那么所有的 `add_requires(\"xx\")` 包定义也会全局同步切换到对应的 vs runtime 配置 ```lua set_runtimes(\"MD\") add_requires(\"libcurl\", \"fmt\") target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") ``` 当然，我们也可以通过 `add_requires(\"xx\", {configs {vs_runtime \"MD\"}})` 对特定包修改 vs 运行时库。 我们也可以通过 `xmake f vs_runtime 'MD'` 通过参数配置来全局切换它。 与此 api 相关的 issue：[#1071](https://github.com/xmake io/xmake/issues/1071#issuecomment 750817681) ## target:set_group ### 设置目标分组 #### 编译指定一批目标程序 我们可以使用 `set_group()` 将给定的目标标记为 `test/benchmark/...` 并使用 `set_default(false)` 禁用来默认构建它。 然后，通过 `xmake g xxx` 命令就能指定构建一批目标程序了。 比如，我们可以使用此功能来构建所有测试。 ```lua target(\"test1\", function() set_kind(\"binary\") set_default(false) set_group(\"test\") add_files(\"src/*.cpp\") end) target(\"test2\", function() set_kind(\"binary\") set_default(false) set_group(\"test\") add_files(\"src/*.cpp\") end) ``` 编译指定的 group： ```console $ xmake g test $ xmake group test ``` #### 运行指定一批目标程序 我们也可以通过设置分组，来指定运行所有带有 `test` 分组的测试程序。 ```console $ xmake run g test $ xmake run group test ``` 另外，我们还可以支持分组的模式匹配： ``` $ xmake build g test_* $ xmake run g test/foo_* $ xmake build g bench* $ xmake run g bench* ``` 更多信息见：[#1913](https://github.com/xmake io/xmake/issues/1913) ## target:set_exceptions ### 启用或者禁用异常 我们可以通过这个配置，配置启用和禁用 C++/Objc 的异常。 通常，如果我们通过 `add_cxxflags` 接口去配置它们，需要根据不同的平台，编译器分别处理它们，非常繁琐。 例如： ```lua on_config(function (target) if (target:has_tool(\"cxx\", \"cl\")) then target:add(\"cxflags\", \"/EHsc\", {force true}) target:add(\"defines\", \"_HAS_EXCEPTIONS 1\", {force true}) elseif(target:has_tool(\"cxx\", \"clang\") or target:has_tool(\"cxx\", \"clang cl\")) then target:add(\"cxflags\", \" fexceptions\", {force true}) target:add(\"cxflags\", \" fcxx exceptions\", {force true}) end end) ``` 而通过这个接口，我们就可以抽象化成编译器无关的方式去配置它们。 开启 C++ 异常: ```lua set_exceptions(\"cxx\") ``` 禁用 C++ 异常: ```lua set_exceptions(\"no cxx\") ``` 我们也可以同时配置开启 objc 异常。 ```lua set_exceptions(\"cxx\", \"objc\") ``` 或者禁用它们。 ```lua set_exceptions(\"no cxx\", \"no objc\") ``` xmake 会在内部自动根据不同的编译器，去适配对应的 flags。 ## target:set_encodings ### 设置编码 我们可以用这个接口设置源文件、目标执行文件的编码。 目前支持的编码：utf 8, gb2312 (msvc) 默认情况下，我们仅仅指定编码，是会同时对源文件，目标文件生效。 ```lua for all source/target encodings set_encodings(\"utf 8\") msvc: /utf 8 ``` 它等价于： ```lua set_encodings(\"source:utf 8\", \"target:utf 8\") ``` 并且，目前仅仅支持设置成 utf 8 编码，将来会不断扩展。 如果，我们仅仅想单独设置源文件编码，或者目标文件编码，也是可以的。 #### 设置源文件编码 通常指的是编译的代码源文件的编码，我们可以这么设置。 ```lua gcc/clang: finput charset UTF 8, msvc: source charset utf 8 set_encodings(\"source:utf 8\") ``` #### 设置目标文件编码 它通常指的是目标可执行文件的运行输出编码。 ```lua gcc/clang: fexec charset UTF 8, msvc: target charset utf 8 set_encodings(\"target:utf 8\") ``` ## target:add_forceincludes ### 强制添加 includes 用于在配置文件中直接强制添加 `includes` 头文件。 ```lua add_forceincludes(\"config.h\") ``` 它的效果类似于 `#include <config.h>`，但是不需要在源码中显式添加它了。 另外，它的搜索路径也是需要通过 `add_includedirs` 来控制，而不是直接配置文件路径。 ```lua add_forceincludes(\"config.h\") add_includedirs(\"src\") ``` 默认 add_forceincludes 匹配 c/c++/objc。如果仅仅只想匹配 c++ 可以这么配置： ```lua add_forceincludes(\"config.h\", {sourcekinds \"cxx\"}) ``` 如果想同时匹配多个源文件类型，也是可以的： ```lua add_forceincludes(\"config.h\", {sourcekinds {\"cxx\", \"mxx\"}}) ``` ## target:add_tests ### 添加测试用例 我们只需要在需要测试的 target 上通过 add_tests 配置一些测试用例，就可以自动执行测试。 即使当前 target 被设置成了 `set_default(false)`，在执行测试的时候，xmake 也还是会先自动编译它们，然后自动运行所有的测试。 我们可以先看个整体的例子，大概知道下它是怎么样子的。 ```lua add_rules(\"mode.debug\", \"mode.release\") for _, file in ipairs(os.files(\"src/test_*.cpp\")) do local name path.basename(file) target(name, function() set_kind(\"binary\") set_default(false) add_files(\"src/\" .. name .. \".cpp\") add_tests(\"default\") add_tests(\"args\", {runargs {\"foo\", \"bar\"}}) add_tests(\"pass_output\", {trim_output true, runargs \"foo\", pass_outputs \"hello foo\"}) add_tests(\"fail_output\", {fail_outputs {\"hello2 .*\", \"hello xmake\"}}) end) end ``` 这个例子，自动扫描源码目录下的 `test_*.cpp` 源文件，然后每个文件自动创建一个测试目标，它被设置成了 `set_default(false)`，也就是正常情况下，默认不会编译它们。 但是，如果执行 `xmake test` 进行测试，它们就会被自动编译，然后测试运行，运行效果如下： ```bash $ xmake test running tests ... [2%]: test_1/args .................................... passed 7.000s [5%]: test_1/default .................................... passed 5.000s [8%]: test_1/fail_output .................................... passed 5.000s [11%]: test_1/pass_output .................................... passed 6.000s [13%]: test_2/args .................................... passed 7.000s [16%]: test_2/default .................................... passed 6.000s [19%]: test_2/fail_output .................................... passed 6.000s [22%]: test_2/pass_output .................................... passed 6.000s [25%]: test_3/args .................................... passed 7.000s [27%]: test_3/default .................................... passed 7.000s [30%]: test_3/fail_output .................................... passed 6.000s [33%]: test_3/pass_output .................................... passed 6.000s [36%]: test_4/args .................................... passed 6.000s [38%]: test_4/default .................................... passed 6.000s [41%]: test_4/fail_output .................................... passed 5.000s [44%]: test_4/pass_output .................................... passed 6.000s [47%]: test_5/args .................................... passed 5.000s [50%]: test_5/default .................................... passed 6.000s [52%]: test_5/fail_output .................................... failed 6.000s [55%]: test_5/pass_output .................................... failed 5.000s [58%]: test_6/args .................................... passed 7.000s [61%]: test_6/default .................................... passed 6.000s [63%]: test_6/fail_output .................................... passed 6.000s [66%]: test_6/pass_output .................................... passed 6.000s [69%]: test_7/args .................................... failed 6.000s [72%]: test_7/default .................................... failed 7.000s [75%]: test_7/fail_output .................................... failed 6.000s [77%]: test_7/pass_output .................................... failed 5.000s [80%]: test_8/args .................................... passed 7.000s [83%]: test_8/default .................................... passed 6.000s [86%]: test_8/fail_output .................................... passed 6.000s [88%]: test_8/pass_output .................................... failed 5.000s [91%]: test_9/args .................................... passed 6.000s [94%]: test_9/default .................................... passed 6.000s [97%]: test_9/fail_output .................................... passed 6.000s [100%]: test_9/pass_output .................................... passed 6.000s 80% tests passed, 7 tests failed out of 36, spent 0.242s ``` #### 运行指定测试目标 我们也可以指定运行指定 target 的某个测试： ```bash $ xmake test targetname/testname ``` 或者按模式匹配的方式，运行一个 target 的所有测试，或者一批测试： ```bash $ xmake test targetname/* $ xmake test targetname/foo* ``` 也可以运行所有 target 的同名测试： ```bash $ xmake test */testname ``` #### 并行化运行测试 其实，默认就是并行化运行的，但是我们可以通过 ` jN` 调整运行的并行度。 ```bash $ xmake test jN ``` #### 分组运行测试 ```bash $ xmake test g \"foo\" $ xmake test g \"foo*\" ``` #### 添加测试到目标（无参数） 如果没有配置任何参数，仅仅配置了测试名到 `add_tests`，那么仅仅测试这个目标程序的是否会运行失败，根据退出代码来判断是否通过测试。 ``` target(\"test\", function() add_tests(\"testname\") end) ``` #### 配置运行参数 我们也可以通过 `{runargs {\"arg1\", \"arg2\"}}` 的方式，给 `add_tests` 配置指定测试需要运行的参数。 另外，一个 target 可以同时配置多个测试用例，每个测试用例可独立运行，互不冲突。 ```lua target(\"test\", function() add_tests(\"testname\", {runargs \"arg1\"}) add_tests(\"testname\", {runargs {\"arg1\", \"arg2\"}}) end) ``` 如果我们没有配置 runargs 到 `add_tests`，那么我们也会尝试从被绑定的 target 中，获取 `set_runargs` 设置的运行参数。 ```lua target(\"test\", function() add_tests(\"testname\") set_runargs(\"arg1\", \"arg2\") end) ``` #### 配置运行目录 我们也可以通过 rundir 设置测试运行的当前工作目录，例如： ```lua target(\"test\", function() add_tests(\"testname\", {rundir os.projectdir()}) end) ``` 如果我们没有配置 rundir 到 `add_tests`，那么我们也会尝试从被绑定的 target 中，获取 `set_rundir` 设置的运行目录。 ```lua target(\"test\", function() add_tests(\"testname\") set_rundir(\"$(projectdir)\") end) ``` #### 配置运行环境 我们也可以通过 runenvs 设置一些运行时候的环境变量，例如： ```lua target(\"test\", function() add_tests(\"testname\", {runenvs {LD_LIBRARY_PATH \"/lib\"}}) end) ``` 如果我们没有配置 runenvs 到 `add_tests`，那么我们也会尝试从被绑定的 target 中，获取 `add_runenvs` 设置的运行环境。 ```lua target(\"test\", function() add_tests(\"testname\") add_runenvs(\"LD_LIBRARY_PATH\", \"/lib\") end) ``` #### 匹配输出结果 默认情况下，`xmake test` 会根据测试运行的退出代码是否为 0，来判断是否测试通过。 当然，我们也可以通过配置测试运行的输出结果是否满足我们的指定的匹配模式，来判断是否测试通过。 主要通过这两个参数控制： 参数 说明 pass_outputs 如果输出匹配，则测试通过 fail_outputs 如果输出匹配，则测试失败 传入 `pass_outputs` 和 `fail_outputs` 的是一个 lua 匹配模式的列表，但模式稍微做了一些简化，比如对 `*` 的处理。 如果要匹配成功，则测试通过，可以这么配置： ```lua target(\"test\", function() add_tests(\"testname1\", {pass_outputs \"hello\"}) add_tests(\"testname2\", {pass_outputs \"hello *\"}) add_tests(\"testname3\", {pass_outputs {\"hello\", \"hello *\"}}) end) ``` 如果要匹配成功，则测试失败，可以这么配置： ```lua target(\"test\", function() add_tests(\"testname1\", {fail_outputs \"hello\"}) add_tests(\"testname2\", {fail_outputs \"hello *\"}) add_tests(\"testname3\", {fail_outputs {\"hello\", \"hello *\"}}) end) ``` 我们也可以同时配置它们： ```lua target(\"test\", function() add_tests(\"testname\", {pass_outputs \"foo\", fail_outputs \"hello\"}) end) ``` 由于一些测试输出的结果，尾部会有一些换行什么的空白字符，干扰匹配模式，我们可以再配置 `trim_output true`，先截断空白字符后，再做匹配。 ```lua target(\"test\", function() add_tests(\"testname\", {trim_output true, pass_outputs \"foo\", fail_outputs \"hello\"}) end) ``` 我们还可以配置 `{plain true}` 是禁用 lua 模式匹配，仅仅做最基础的平坦文本匹配。 ```lua target(\"test\", function() add_tests(\"testname\", {plain true, pass_outputs \"foo\", fail_outputs \"hello\"}) end) ``` #### 配置测试组 我们也可以通过 `group \"foo\"` 来配置一个测试组，进行分组测试： ```lua target(\"test\", function() add_tests(\"testname1\", {group \"foo\"}) add_tests(\"testname2\", {group \"foo\"}) add_tests(\"testname3\", {group \"bar\"}) add_tests(\"testname4\", {group \"bae\"}) end) ``` 其中 testname1/testname2 是一个组 foo，另外两个是在另外一个组。 然后，我们就可以使用 `xmake test g groupname` 来进行分组测试了。 ```bash $ xmake test g \"foo\" $ xmake test g \"foo*\" ``` > 运行分组，也是支持模式匹配的。 另外，如果没有设置 `group` 参数给 `add_tests`，我们也可以默认获取绑定到 target 的组名。 ```lua target(\"test\", function() add_tests(\"testname\") set_group(\"foo\") end) ``` #### 自定义测试脚本 我们还新增了 `before_test`, `on_test` 和 `after_test` 配置脚本，用户可以在 rule 和 target 域，自定义配置它们实现定制化的测试执行。 ```lua target(\"test\", function()) on_test(function (target, opt) print(opt.name, opt.runenvs, opt.runargs, opt.pass_outputs) do test ... passed return true failied return false, errors end) end) ``` 其中，opt 里面可以获取到所有传入 `add_tests` 的参数，我们在 on_test 里面自定义测试逻辑，然后返回 true 就是测试通过，返回 false 就是测试失败，然后继续返回测试失败的错误信息。 #### 自动化构建 由于测试目标在正常开发构建阶段，通常是不需要被构建的，因此我们会设置 `set_default(false)`。 ```lua target(\"test\", function() add_tests(\"testname\") set_default(false) end) ``` 但是运行 `xmake test` 进行测试时候，这些测试对应的 target 还是会被自动构建，确保能够被运行。 ```bash $ xmake test [25%]: cache compiling.release src/main.cpp [50%]: linking.release test running tests ... [100%]: test/testname .................................... passed 6.000s 100% tests passed, 0 tests failed out of 1, spent 0.006s ``` #### 首次测试失败就终止 默认情况下，`xmake test` 会等到所有测试都运行完，不管里面有多少是没通过的。 而有时候，我们想在第一个测试没通过，就直接中断测试，那么我们可以通过下面的配置启用： ```lua set_policy(\"test.stop_on_first_failure\", true) ``` #### 测试失败返回 0 默认情况下，只要有一个测试没通过，等到 `xmake test` 运行完成，它都会返回非 0 退出代码，这对于一些 CI 环境非常有用，可以中断 CI 的其他脚本继续运行。 然后触发信号告诉 CI，我们需要生成测试报告和告警了。 然后，如果我们想要压制这种行为，可以强制将 `xmake test` 的退出代码总是设置成 0。 ```lua set_policy(\"test.return_zero_on_failure\", true) ``` #### 仅仅测试编译 有时候，我们仅仅想要测试代码是否通过编译，或者没有通过编译，不需要运行它们，那么可以通过配置 `build_should_pass` 和 `build_should_fail` 来实现。 ```lua target(\"test_10\", function() set_kind(\"binary\") set_default(false) add_files(\"src/compile.cpp\") add_tests(\"compile_fail\", {build_should_fail true}) end) target(\"test_11\", function() set_kind(\"binary\") set_default(false) add_files(\"src/compile.cpp\") add_tests(\"compile_pass\", {build_should_pass true}) end) ``` 这通常用于一些测试代码中带有 `static_assert` 的场景，例如： ```c++ template <typename T> bool foo(T val) { if constexpr (std::is_same_v<T, int>) { printf(\"int!\\n\"); } else if constexpr (std::is_same_v<T, float>) { printf(\"float!\\n\"); } else { static_assert(false, \"unsupported type\"); } } int main(int, char**) { foo(\"BAD\"); return 0; } ``` #### 配置额外的代码编译 我们还可以在配置测试用例的时候，对每个测试配置额外需要编译的代码，以及一些宏定义，实现内联测试。 xmake 会为每个测试单独编译一个独立的可执行程序去运行它，但这并不会影响到 target 在生产环境的编译结果。 ```lua target(\"test_13\", function() set_kind(\"binary\") set_default(false) add_files(\"src/test_1.cpp\") add_tests(\"stub_1\", {files \"tests/stub_1.cpp\", defines \"STUB_1\"}) end) target(\"test_14\", function() set_kind(\"binary\") set_default(false) add_files(\"src/test_2.cpp\") add_tests(\"stub_2\", {files \"tests/stub_2.cpp\", defines \"STUB_2\"}) end) target(\"test_15\", function() set_kind(\"binary\") set_default(false) add_files(\"src/test_1.cpp\") add_tests(\"stub_n\", {files \"tests/stub_n*.cpp\", defines \"STUB_N\"}) end) ``` 以 doctest 为例，我们可以在不修改任何 main.cpp 的情况下，外置单元测试： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"doctest\") target(\"doctest\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") for _, testfile in ipairs(os.files(\"tests/*.cpp\")) do add_tests(path.basename(testfile), { files testfile, remove_files \"src/main.cpp\", languages \"c++11\", packages \"doctest\", defines \"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\"}) end end) ``` 定义 `DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN` 会引入额外的 main 入口函数，因此我们需要配置 remove_files 去移除已有的 main.cpp 文件。 运行效果如下： ```bash $ xmake test running tests ... [50%]: doctest/test_1 .................................... failed 0.009s [100%]: doctest/test_2 .................................... passed 0.009s 50% tests passed, 1 tests failed out of 2, spent 0.019s ruki 2:doctest ruki$ xmake test v running tests ... [50%]: doctest/test_1 .................................... failed 0.026s [doctest] doctest version is \"2.4.11\" [doctest] run with \" help\" for options tests/test_1.cpp:7: TEST CASE: testing the factorial function tests/test_1.cpp:8: ERROR: CHECK(factorial(1) 10 ) is NOT correct! values: CHECK(1 10) [doctest] test cases: 1 0 passed 1 failed 0 skipped [doctest] assertions: 4 3 passed 1 failed [doctest] Status: FAILURE! run failed, exit code: 1 [100%]: doctest/test_2 .................................... passed 0.010s 50% tests passed, 1 tests failed out of 2, spent 0.038s ``` #### 测试动态库 通常，`add_tests` 仅用于对可执行程序进行运行测试，运行动态库需要有一个额外的 main 主入口，因此我们需要额外配置一个可执行程序去加载它，例如： ```lua target(\"doctest_shared\", function() set_kind(\"shared\") add_files(\"src/foo.cpp\") for _, testfile in ipairs(os.files(\"tests/*.cpp\")) do add_tests(path.basename(testfile), { kind \"binary\", files testfile, languages \"c++11\", packages \"doctest\", defines \"DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\"}) end end) ``` 通过 `kind \"binary\"` 可以将每个单元测试改为 binary 可执行程序，并通过 `DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN` 引入 main 入口函数。 这样就能实现动态库目标中外置可运行的单元测试。 #### 配置运行超时 如果一些测试程序长时间运行不退出，就会卡住，我们可以通过配置超时时间，强制退出，并返回失败。 ```lua target(\"test_timeout\", function() set_kind(\"binary\") set_default(false) add_files(\"src/run_timeout.cpp\") add_tests(\"run_timeout\", {run_timeout 1000}) end) ``` ```bash $ xmake test [100%]: test_timeout/run_timeout .................................... failed 1.006s run failed, exit code: 1, exit error: wait process timeout ```"},"/get_started/zh/option/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 定义和设置选项开关，每个 `option` 对应一个选项，可用于自定义编译配置选项、开关设置。 > 除了 `target` 以外的所有域接口，例如 `option`，`task` 等的接口，默认不能放置在外面的全局作用域中的（除非部分跟 target 共用的接口除外）。 > 如果要设置值影响所有 `option`，`task` 等选项，可以通过匿名全局域来设置。 > 不过我们不推荐这么使用，后续是会废弃掉 `option_end` 接口以保持 xmake.lua 脚本的易读性。 例如： ```lua 进入 option 的匿名全局域，里面的设置会同时影响 test 和 test2 选项 option() add_defines(\"DEBUG\") option(\"test\") ... 尽量保持缩进，因为这个之后的所有设置，都是针对 test 选项的 option(\"test2\") ... ``` > `option` 域是可以重复进入来实现分离设置的，如果要显示离开当前选项的作用域设置，可以手动调用 [option_end](#option_end) 接口。 ## option 定义和设置选项开关，可用于自定义编译配置选项、开关设置。 例如，定义一个是否启用 test 的选项： ```lua option(\"test\", function() set_default(false) set_showmenu(true) add_defines(\"TEST\") end) ``` 然后关联到指定的 target 中去： ```lua target(\"demo\", function() add_options(\"test\") end) ``` 这样，一个选项就算定义好了，如果这个选项被启用，那么编译这个 target 的时候，就会自动加上 ` DTEST` 的宏定义。 ```lua # 手动启用这个选项 $ xmake f test y $ xmake ``` ## option_end 这是一个可选 api，显示离开选项作用域，用法和 [target_end](/zh cn/manual/project_target?id target_end) 类似。 ## option:add_deps 通过设置依赖，可以调整选项的检测顺序，一般用于 [on_check](#optionon_check) 等检测脚本的调用时机。 ```lua option(\"small\", function() set_default(true) on_check(function (option) ... end) end) option(\"test\", function() add_deps(\"small\") set_default(true) after_check(function (option) if option:dep(\"small\"):enabled() then option:enable(false) end end) end) ``` 当依赖的 small 选项检测完成后，通过判断 small 选项的状态，来控制 test 的选项状态。 > 由于 on_check 只有在没有设置 default 值的情况下才会被执行，因此如果设置了 default 值，那么可以在 after_check 阶段处理自定义逻辑。 ## option:before_check 选项检测之前执行此脚本： ```lua option(\"zlib\", function() before_check(function (option) end) end) ``` ## option:on_check 自定义选项检测脚本，此脚本会覆盖内置的选项检测逻辑。 ```lua option(\"test\", function() add_deps(\"small\") on_check(function (option) option:enable(true) end) end) ``` > 仅仅在 `set_default` 没有被设置的情况下，才会执行 `on_check` 进行自定义的选项检测脚本。 ## option:after_check 在选项检测完成后，执行此脚本做一些后期处理，也可以在此时重新禁用选项： ```lua option(\"test\", function() add_deps(\"small\") add_links(\"pthread\") after_check(function (option) option:enable(false) end) end) ``` ## option:set_values 设置选项值列表，仅用于 `xmake f menu` 的图形菜单配置时，提供选项值列表供用户快速选择使用，例如： ```lua option(\"test\", function() set_default(\"b\") set_showmenu(true) set_values(\"a\", \"b\", \"c\") end) ``` 效果图如下： ![option set values](image/option_set_values.png) ## option:set_default 在没有通过 `xmake f option [yn}` 等命令修改选项值的时候，这个选项本身也是有个默认值的，可以通过这个接口来设置： ```lua option(\"test\", function() 默认禁用这个选项 set_default(false) end) ``` 选项的值不仅支持 boolean 类型，也可以是字符串类型，例如： ```lua option(\"test\", function() set_default(\"value\") end) ``` 值类型 描述 配置 boolean 一般用作参数开关，值范围：`true/false` `xmake f optionname [y/n/yes/no/true/false]` string 可以是任意字符串，一般用于模式判断 `xmake f optionname value` 如果是 `boolean` 值的选项，可以通过 [has_config](/zh cn/manual/conditions?id has_config) 来进行判断，选项是否被启用。 如果是 `string` 类型的选项，可以在内建变量中直接使用，例如： ```lua 定义一个路径配置选项，默认使用临时目录 option(\"rootdir\", function() set_default(\"$(tmpdir)\") set_showmenu(true) end) target(\"test\", function() 添加指定选项目录中的源文件 add_files(\"$(rootdir)/*.c\") end) ``` 其中，`$(rootdir)` 就是自定义的选项内建变量，通过手动配置，可以动态修改它的值： ```bash $ xmake f rootdir ~/projectdir/src $ xmake ``` 给这个 `rootdir` 选项指定一个其他的源码目录路径，然后编译。 选项的检测行为： default 值 检测行为 没有设置 优先手动配置修改，默认禁用，否则会启用自动检测，也会执行 on_check，可根据手动传入的值类型，自动切换 boolean 和 string 类型 false 开关选项，不自动检测，默认禁用，可手动配置修改 true 开关选项，不自动检测，默认启用，可手动配置修改 string 类型 无开关状态，不自动检测，可手动配置修改，一般用于配置变量传递 ## option:set_showmenu 用于设置是否启用菜单显示。 如果设置为 `true`，那么在 `xmake f help` 里面就会出现这个选项，也就能通过 `xmake f optionname xxx` 进行配置，否则只能在 `xmake.lua` 内部使用，无法手动配置修改。 ```lua option(\"test\", function() set_showmenu(true) end) ``` 设置为启用菜单后，执行 `xmake f help` 可以看到，帮助菜单里面多了一项： ``` Options: ... test TEST ``` > 此选项默认改为启用，通常都不需要额外配置它。考虑后面删除这个 api。 ## option:set_category 这个是个可选配置，仅用于在帮助菜单中，进行分类显示选项，同一类别的选项，会在同一个分组里面显示，这样菜单看起来更加的美观。 例如： ```lua option(\"test1\", function() set_showmenu(true) set_category(\"test\") end) option(\"test2\", function() set_showmenu(true) set_category(\"test\") end) option(\"demo1\", function() set_showmenu(true) set_category(\"demo\") end) option(\"demo2\", function() set_showmenu(true) set_category(\"demo\") end) ``` 这里四个选项分别归类于两个分组：`test` 和 `demo`，那么显示的布局类似这样： ```bash Options: ... test1 TEST1 test2 TEST2 demo1 DEMO1 demo2 DEMO2 ``` 这个接口，仅仅是为了调整显示布局，更加美观而已，没其他用途。 还可以通过 category 设置分级路径名 `set_category(\"root/submenu/submenu2\")`，来配置 `xmake f menu` 的图形菜单界面，例如： ```lua 'boolean' option option(\"test1\", function() set_default(true) set_showmenu(true) set_category(\"root menu/test1\") end) 'choice' option with values: \"a\", \"b\", \"c\" option(\"test2\", function() set_default(\"a\") set_values(\"a\", \"b\", \"c\") set_showmenu(true) set_category(\"root menu/test2\") end) 'string' option option(\"test3\", function() set_default(\"xx\") set_showmenu(true) set_category(\"root menu/test3/test3\") end) 'number' option option(\"test4\", function() set_default(6) set_showmenu(true) set_category(\"root menu/test4\") end) ``` 上述配置最后显示的菜单界面路径结构： root menu test1 test2 test3 test3 test4 效果图如下： ![opiton set category](image/option_set_category.gif) ## option:set_description 设置选项菜单显示时，右边的描述信息，用于帮助用户更加清楚的知道这个选项的用途，例如： ```lua option(\"test\", function() set_default(false) set_showmenu(true) set_description(\"Enable or disable test\") end) ``` 生成的菜单内容如下： ``` Options: ... test TEST Enable or disable test (default: false) ``` 这个接口也支持多行显示，输出更加详细的描述信息，例如： ```lua option(\"mode\", function() set_default(\"debug\") set_showmenu(true) set_description(\"Set build mode\", \" debug\", \" release\", \" profile\") end) ``` 生成的菜单内容如下： ``` Options: ... mode MODE Set build mode (default: debug) debug release profile ``` 看到这个菜单，用户就能清楚地知道，定义的这个 `mode` 选项的具体用处，以及如何使用了： ```bash $ xmake f mode release ``` ## option:add_links 添加链接库检测。 如果指定的链接库检测通过，此选项将被启用，并且对应关联的 target 会自动加上此链接，例如： ```lua option(\"pthread\", function() add_links(\"pthread\") add_linkdirs(\"/usr/local/lib\") end) target(\"test\", function() add_options(\"pthread\") end) ``` 如果检测通过，`test` 目标编译的时候就会自动加上：` L/usr/local/lib lpthread` 编译选项 ## option:add_linkdirs 添加链接库检测时候需要的搜索目录。 这个是可选的，一般系统库不需要加这个，也能检测通过，如果确实没找到，可以自己追加搜索目录，提高检测通过率。具体使用见：[add_links](#optionadd_links) ## option:add_rpathdirs 添加程序运行时动态库的加载搜索目录。 在选项通过检测后，会自动添加到对应的 target 上去，具体使用见：[target.add_rpathdirs](/zh cn/manual/project_target?id targetadd_rpathdirs)。 ## option:add_cincludes 添加 c 头文件检测。 如果 c 头文件检测通过，此选项将被启用，例如： ```lua option(\"pthread\", function() add_cincludes(\"pthread.h\") add_defines(\"ENABLE_PTHREAD\") end) target(\"test\", function() add_options(\"pthread\") end) ``` 此选项检测是否存在 `pthread.h` 的头文件，如果检测通过那么 `test` 目标程序将会加上 `ENABLE_PTHREAD` 的宏定义。 如果想要更加灵活的检测，可以通过 [lib.detect.has_cincludes](#detect has_cincludes) 在[option.on_check](#optionon_check)中去实现。 ## option:add_cxxincludes 添加 c++ 头文件检测。 与 [add_cincludes](#optionadd_cincludes) 类似，只是检测的头文件类型是 c++ 头文件。 ## option:add_ctypes 添加 c 类型检测。 如果 c 类型检测通过，此选项将被启用，例如： ```lua option(\"wchar\", function() add_ctypes(\"wchar_t\") add_defines(\"HAVE_WCHAR\") end) target(\"test\", function() add_options(\"wchar\") end) ``` 此选项检测是否存在 `wchar_t` 的类型，如果检测通过那么 `test` 目标程序将会加上 `HAVE_WCHAR` 的宏定义。 如果想要更加灵活的检测，可以通过 [lib.detect.has_ctypes](#detect has_ctypes) 在[option.on_check](#optionon_check)中去实现。 ## option:add_cxxtypes 添加 c++ 类型检测。 与 [add_ctypes](#optionadd_ctypes) 类似，只是检测的类型是 c++ 类型。 ## option:add_csnippets 添加 c 代码片段检测。 如果现有的 [add_ctypes](#optionadd_ctypes), [add_cfuncs](#optionadd_cfuncs) 等不能满足当前的检测需求， 可以用这个接口实现更加定制化检测一些编译器特性检测，具体见: [add_cxxsnippets](#optionadd_cxxsnippets)。 ## option:add_cxxsnippets 添加 c++ 代码片段检测。 可以用这个接口实现更加定制化检测一些编译器特性检测，尤其是 c++ 的各种特性的检测支持，例如： ```lua option(\"constexpr\", function() add_cxxsnippets(\"constexpr\", \"constexpr int f(int x) { int sum 0; for (int i 0; i< x; ++i) sum + i; return sum; } constexpr int x f(5); static_assert(x 15);\") end) ``` 第一个参数设置代码片段的名字作为标示，检测输出信息时候会有显示。 上述代码，实现对 c++ 的 constexpr 特性的检测，如果检测通过，则启用 constexpr 选项，当然这里只是个例子。 对于编译器特性的检测，有更加方便高效的检测模块，提供更强大的检测支持，具体见：[compiler.has_features](#compiler has_features) 和 [detect.check_cxsnippets](#detect check_cxsnippets) 如果想要更加灵活的检测，可以通过 [lib.detect.check_cxsnippets](#detect check_cxsnippets) 在[option.on_check](#optionon_check)中去实现。 另外我们还可以通过 `{tryrun true}` 和 `{output true}` 两个选项用于尝试运行检测和捕获输出。 设置 tryrun 可以尝试运行来检测： ```lua option(\"test\", function() add_cxxsnippets(\"HAS_INT_4\", \"return (sizeof(int) 4)? 0 : 1;\", {tryrun true}) end) ``` 设置 output 也会尝试去检测，并且额外捕获运行的输出内容。 ```lua option(\"test\", function() add_cxxsnippets(\"INT_SIZE\", 'printf(\"%d\", sizeof(int)); return 0;', {output true, number true}) end) ``` > 设置为捕获输出，当前 option 不能再设置其他 snippets。 我们也可以通过 `is_config` 获取绑定到 option 的输出。 ```lua if is_config(\"test\", \"8\") tben xxx end ``` ## option:add_cfuncs 添加 c 库函数检测。 ```lua option(\"setjmp\", function() add_cincludes(\"setjmp.h\") add_cfuncs(\"sigsetjmp\", \"setjmp\") add_defines(\"HAVE_SETJMP\") end) target(\"test\", function() add_options(\"setjmp\") end) ``` 此选项检测是否存在 `setjmp` 的一些接口，如果检测通过那么 `test` 目标程序将会加上 `HAVE_SETJMP` 的宏定义。 里面的函数片段支持下面几种语法格式： ```lua 单纯检测函数地址是否存在，内部会尝试去它的地址来判断 sigsetjmp 如果有些函数是宏定义 wrap 的，可以通过这种方式绕通过检测 sigsetjmp((void*)0, 0) 也可以指定一个完整函数语句，例如：funcname{codebody} sigsetjmp{sigsetjmp((void*)0, 0);} sigsetjmp{int a 0; sigsetjmp((void*)a, a);} ``` 注意，检测的函数通常需要附带 `add_cincludes` 确保函数能够被正常 include 进来，否则检测会失败。 ## option:add_cxxfuncs 添加 c++ 库函数检测。 用法跟 [option:add_cfuncs](#optionadd_cxxfuncs) 一致。"},"/get_started/zh/package/system-package.html":{"title":"","content":" class: heading_no_counter # 使用系统包 ## 查找使用系统包 xmake 对远程包和系统包的使用进行了统一，全部使用 `add_requires(\"zlib\")` 接口来描述集成，而默认的配置方式，它会优先从系统上查找库，如果没有，会自动下载安装集成。 而如果我们仅仅想查找使用系统库，不想远程下载，可以这么配置： ```lua add_requires(\"zlib\", {system true}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") end) ``` 通过 `{system true}` 就可以强制禁用远程下载，这时候，他就等价于 XMake/CMake 的 `find_package`，但是更加简单易用，并且和远程包使用方式完全一致。 默认情况下，如果找不到系统库，就是提示失败，如果这个包是可选的，那么可以额外配置 `{optional true}` 选项。 ```lua add_requires(\"zlib\", {system true, optional true}) ``` ## 查找包快速测试 我们可以使用下面的命令，快速检测系统上指定的包信息： ```console $ xmake l find_package x264 { links { \"x264\" }, linkdirs { \"/usr/local/Cellar/x264/r2699/lib\" }, version \"0.148.2699 a5e06b9\", includedirs { \"/usr/local/Cellar/x264/r2699/include\" } } ``` 我们也可以追加第三方包管理器前缀来测试： ```console xmake l find_package conan::OpenSSL/1.0.2g ``` > 需要注意的是，find_package 命令如果在带有 xmake.lua 的工程目录下执行，是会有缓存的，如果查找失败，下次查找也会使用缓存的结果，如果要每次强制重新检测，请切换到非工程目录下执行上面的命令。"},"/get_started/zh/package/local-package.html":{"title":"","content":" class: heading_no_counter # 使用本地包 ## 默认打包格式 xmake 提供了一种新的本地包打包方案，将会更加无缝的对接 `add_requires` 和 `add_packages`。 我们执行 `xmake package` 命令就能够生成默认的新版打包格式。 ```console $ xmake package package(foo): build/packages/f/foo generated ``` 它将会产生 `build/packages/f/foo/xmake.lua` 文件，内容如下： ```lua package(\"foo\", function() set_description(\"The foo package\") set_license(\"Apache 2.0\") add_deps(\"add\", \"sub\") on_load(function (package) package:set(\"installdir\", path.join(os.scriptdir(), package:plat(), package:arch(), package:mode())) end) on_fetch(function (package) local result {} result.links \"foo\" result.linkdirs package:installdir(\"lib\") result.includedirs package:installdir(\"include\") return result end) end) ``` 其实就是采用 `package()` 来定义描述本地包，就跟远程包一样。 而生成的目录结构如下： ```console $ tree build/packages/f/foo/ build/packages/f/foo/ ├── macosx │   └── x86_64 │   └── release │   ├── include │   │   └── foo.h │   └── lib │   └── libfoo.a └── xmake.lua ``` 我们也能够使用 `add_requires`/`add_repositories` 接口来无缝集成这个包。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_repositories(\"local repo build\") add_requires(\"foo\") target(\"bar\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"foo\") end) ``` 其中，add_repositories 配置指定本地包的仓库根目录，然后就可以通过 `add_requires` 来引用这个包了。 另外，生成的本地包，还有一个特性，就是支持 `target/add_deps`，会自动关联多个包的依赖关系，集成时候，也会自动对接所有依赖链接。 这里有完整的 [测试例子](https://github.com/xmake io/xmake/blob/dev/tests/actions/package/localpkg/test.lua)。 ```bash \"/usr/bin/xcrun sdk macosx clang++\" o build/macosx/x86_64/release/bar build/.objs/bar/macosx/x86_64/release/src/main.cpp.o arch x86_64 mmacosx version min 10.15 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.0.sdk stdlib libc++ L/Users/ruki/projects/personal/xmake/tests/actions/package/localpkg/bar/build/packages/f/foo/macosx/x86_64/release/lib L/Users/ruki/projects/personal/xmake/tests/actions/package/localpkg/bar/build/packages/s/sub/macosx/x86_64/release/lib L/Users/ruki/projects/personal/xmake/tests/actions/package/localpkg/bar/build/packages/a/add/macosx/x86_64/release/lib Wl, x lfoo lsub ladd lz ``` ## 生成远程包 除了本地包格式，`xmake package` 现在也支持生成远程包，便于用户将他们快速提交到远程仓库。 我们只需要在打包时候，修改包格式。 ```console $ xmake package f remote ``` 他也会产生 packages/f/foo/xmake.lua 文件。 ```lua package(\"foo\", function() set_description(\"The foo package\") set_license(\"Apache 2.0\") add_deps(\"add\", \"sub\") add_urls(\"https://github.com/myrepo/foo.git\") add_versions(\"1.0\", \"<shasum256 or gitcommit>\") on_install(function (package) local configs {} if package:config(\"shared\") then configs.kind \"shared\" end import(\"package.tools.xmake\").install(package, configs) end) on_test(function (package) TODO check includes and interfaces assert(package:has_cfuncs(\"foo\", {includes \"foo.h\"}) end) end) ``` 包定义配置相比本地包，多了实际的安装逻辑，以及 urls 和 versions 的设置， 我们也能够通过附加参数，去修改 urls，versions 等配置值，例如： ```console $ xmake package f remote url https://xxxx/xxx.tar.gz shasum xxxxx homepage xxxxx` ``` xmake 也会从 target 的 `set_license` 和 `set_version` 等配置中读取相关配置信息。 ## 从 CMake 中查找包 现在 cmake 已经是事实上的标准，所以 CMake 提供的 find_package 已经可以查找大量的库和模块，我们完全复用 cmake 的这部分生态来扩充 xmake 对包的集成。 我们可以通过 `find_package(\"cmake::xxx\")` 去借助 cmake 来找一些包，xmake 会自动生成一个 cmake 脚本来调用 cmake 的 find_package 去查找一些包，获取里面包信息。 例如： ```console $ xmake l find_package cmake::ZLIB { links { \"z\" }, includedirs { \"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10. 15.sdk/usr/include\" }, linkdirs { \"/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10. 15.sdk/usr/lib\" } } $ xmake l find_package cmake::LibXml2 { links { \"xml2\" }, includedirs { \"/Library/Developer/CommandLineTools/SDKs/MacOSX10.15.sdk/usr/include/libxml2\" }, linkdirs { \"/usr/lib\" } } ``` ### 1. 在项目中集成包 如果我们在 xmake.lua 项目配置中集成查找 cmake 的依赖包，通常不需要直接使用 find_package，我们可以用更加通用、简单的包集成方式。 ```lua add_requires(\"cmake::ZLIB\", {alias \"zlib\", system true}) target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") ``` 我们指定 `system true` 告诉 xmake 强制从系统中调用 cmake 查找包，如果找不到，不再走安装逻辑，因为 cmake 没有提供类似 vcpkg/conan 等包管理器的安装功能，只提供了包查找特性。 ### 2. 指定版本 ```lua add_requires(\"cmake::OpenCV 4.1.1\", {system true}) ``` ### 3. 指定组件 ```lua add_requires(\"cmake::Boost\", {system true, configs {components {\"regex\", \"system\"}}}) ``` ### 4. 预设开关 ```lua add_requires(\"cmake::Boost\", {system true, configs {components {\"regex\", \"system\"}, presets {Boost_USE_STATIC_LIB true}}}) ``` 相当于内部调用 find_package 查找包之前，在 CMakeLists.txt 中预定义一些配置，控制 find_package 的查找策略和状态。 ``` set(Boost_USE_STATIC_LIB ON) will be used in FindBoost.cmake find_package(Boost REQUIRED COMPONENTS regex system) ``` ### 5. 设置环境变量 ```lua add_requires(\"cmake::OpenCV\", {system true, configs {envs {CMAKE_PREFIX_PATH \"xxx\"}}}) ``` ### 6. 指定自定义 FindFoo.cmake 模块脚本目录 mydir/cmake_modules/FindFoo.cmake： ```lua add_requires(\"cmake::Foo\", {system true, configs {moduledirs \"mydir/cmake_modules\"}}) ``` 相关 issues: [#1632](https://github.com/xmake io/xmake/issues/1632) ### 7. 指定链接项 对于 cmake 包，我们新增了 `link_libraries` 配置选项，让用户在查找使用 cmake 包的时候，可以自定义配置包依赖的链接库，甚至对 target 链接的支持。 ```lua add_requires(\"cmake::xxx\", {configs {link_libraries {\"abc::lib1\", \"abc::lib2\"}}}) ``` xmake 在查找 cmake 包的时候，会自动追加下面的配置，改进对 links 库的提取。 ```cmake target_link_libraries(test PRIVATE ABC::lib1 ABC::lib2) ``` ### 8. 指定搜索模式 另外，我们增加的搜索模式配置： ```lua add_requires(\"cmake::xxx\", {configs {search_mode \"config\"}}) add_requires(\"cmake::xxx\", {configs {search_mode \"module\"}}) add_requires(\"cmake::xxx\") both ``` 比如指定 config 搜索模式，告诉 cmake 从 `XXXConfig.cmake` 中查找包。 xmake 在查找 cmake 包的时候，内部会自动追加下面的配置。 ```cmake find_package(ABC CONFIG REQUIRED) ```"},"/get_started/zh/package/remote-package.html":{"title":"","content":" class: heading_no_counter # 使用远程包 ## 前言 远程包在用法上更加的简单，只需要设置对应的依赖包就行了，例如： ```lua add_requires(\"tbox 1.6.*\", \"libpng ~1.16\", \"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"tbox\", \"libpng\", \"zlib\") end) ``` 上面的 `add_requires` 用于描述当前项目需要的依赖包，而 `add_packages` 用于应用依赖包到 test 目标，只有设置这个才会自动追加 links, linkdirs, includedirs 等设置。 然后直接执行编译即可： ```console $ xmake ``` xmake 会去远程拉取相关源码包，然后自动编译安装，最后编译项目，进行依赖包的链接，具体效果见下图： <img src \"/assets/img/index/package_manage.png\" width \"80%\" /> 关于包依赖管理的更多相关信息和进展见相关 issues：[Remote package management](https://github.com/xmake io/xmake/issues/69) ## 目前支持的特性 * 语义版本支持，例如：\"> 1.1.0 < 1.2\", \"~1.6\", \"1.2.x\", \"1.*\" * 提供官方包仓库、自建私有仓库、项目内置仓库等多仓库管理支持 * 跨平台包编译集成支持（不同平台、不同架构的包可同时安装，快速切换使用） * debug 依赖包支持，实现源码调试 ## 依赖包处理机制 这里我们简单介绍下整个依赖包的处理机制： <img src \"/assets/img/index/package_arch.png\" width \"80%\" /> 1. 优先检测当前系统目录、第三方包管理下有没有存在指定的包，如果有匹配的包，那么就不需要下载安装了 （当然也可以设置不使用系统包） 2. 检索匹配对应版本的包，然后下载、编译、安装（注：安装在特定 xmake 目录，不会干扰系统库环境） 3. 编译项目，最后自动链接启用的依赖包 ## 快速上手 新建一个依赖 tbox 库的空工程： ```console $ xmake create t console_tbox test $ cd test ``` 执行编译即可，如果当前没有安装 tbox 库，则会自动下载安装后使用： ```console $ xmake ``` 切换到 iphoneos 平台进行编译，将会重新安装 iphoneos 版本的 tbox 库进行链接使用： ```console $ xmake f p iphoneos $ xmake ``` 切换到 android 平台 arm64 v8a 架构编译： ```console $ xmake f p android [ ndk ~/android ndk r16b] $ xmake ``` ## 语义版本设置 xmake 的依赖包管理是完全支持语义版本选择的，例如：\"~1.6.1\"，对于语义版本的具体描述见：[https://semver.org/](https://semver.org/) 一些语义版本写法： ```lua add_requires(\"tbox 1.6.*\", \"pcre 1.3.x\", \"libpng ^1.18\") add_requires(\"libpng ~1.16\", \"zlib 1.1.2 > 1.2.11 <1.3.0\") ``` 目前 xmake 使用的语义版本解析器是 [uael](https://github.com/uael) 贡献的 [sv](https://github.com/uael/sv) 库，里面也有对版本描述写法的详细说明，可以参考下：[版本描述说明](https://github.com/uael/sv#versions) 当然，如果我们对当前的依赖包的版本没有特殊要求，那么可以直接这么写： ```lua add_requires(\"tbox\", \"libpng\", \"zlib\") ``` 这会使用已知的最新版本包，或者是 master 分支的源码编译的包，如果当前包有 git repo 地址，我们也能指定特定分支版本： ```lua add_requires(\"tbox master\") add_requires(\"tbox dev\") ``` ## 额外的包信息设置 ### 可选包设置 如果指定的依赖包当前平台不支持，或者编译安装失败了，那么 xmake 会编译报错，这对于有些必须要依赖某些包才能工作的项目，这是合理的。 但是如果有些包是可选的依赖，即使没有也可以正常编译使用的话，可以设置为可选包： ```lua add_requires(\"tbox\", {optional true}) ``` ### 禁用系统库 默认的设置，xmake 会去优先检测系统库是否存在（如果没设置版本要求），如果用户完全不想使用系统库以及第三方包管理提供的库，那么可以设置： ```lua add_requires(\"tbox\", {system false}) ``` ### 使用调试版本的包 如果我们想同时源码调试依赖包，那么可以设置为使用 debug 版本的包（当然前提是这个包支持 debug 编译）： ```lua add_requires(\"tbox\", {debug true}) ``` 如果当前包还不支持 debug 编译，可在仓库中提交修改编译规则，对 debug 进行支持，例如： ```lua package(\"openssl\", function() on_install(\"linux\", \"macosx\", function (package) os.vrun(\"./config %s prefix \\\"%s\\\"\", package:debug() and\" debug\"or\"\", package:installdir()) os.vrun(\"make j4\") os.vrun(\"make install\") end) end) ``` ### 传递额外的编译信息到包 某些包在编译时候有各种编译选项，我们也可以传递进来，当然包本身得支持： ```lua add_requires(\"tbox\", {configs {small true}}) ``` 传递 ` small true` 给 tbox 包，使得编译安装的 tbox 包是启用此选项的。 我们可以通过在工程目录中执行：`xmake require info tbox` 来获取指定包所有的可配置参数列表和取值说明。 比如： ```console xmake require info spdlog require(spdlog): > requires: > plat: macosx > arch: x86_64 > configs: > header_only: true > shared: false > vs_runtime: MT > debug: false > fmt_external: true > noexcept: false > configs: > header_only: Use header only (default: true) > fmt_external: Use external fmt library instead of bundled (default: false) > noexcept: Compile with fno exceptions. Call abort() on any spdlog exceptions (default: false) > configs (builtin): > debug: Enable debug symbols. (default: false) > shared: Enable shared library. (default: false) > cflags: Set the C compiler flags. > cxflags: Set the C/C++ compiler flags. > cxxflags: Set the C++ compiler flags. > asflags: Set the assembler flags. > vs_runtime: Set vs compiler runtime. (default: MT) > values: {\"MT\",\"MD\"} ``` 其中，configs 里面就是 spdlog 包自身提供的可配置参数，而下面带有 builtin 的 configs 部分，是所有包都会有的内置配置参数。 最上面 requires 部分，是项目当前配置值。 > `vs_runtime` 是用于 msvc 下 vs runtime 的设置，v2.2.9 版本中，还支持所有 static 依赖包的自动继承，也就是说 spdlog 如果设置了 MD，那么它依赖的 fmt 包也会自动继承设置 MD。 可以看到，我们已经能够很方便的定制化获取需要的包，但是每个包自身也许有很多依赖，如果这些依赖也要各种定制化配置，怎么办？ 可以通过 `add_requireconfs` 去重写内部依赖包的配置参数。 ### 安装任意版本的包 默认情况下，`add_requires(\"zlib>1.2.x\")` 只能选择到 `xmake repo` 仓库中存在的包版本，因为每个版本的包，它们都会有一个 sha256 的校验值，用于包的完整性校验。 因此，未知版本的包不存在校验值，xmake 默认是不让选择使用的，这并不安全。 那如果，我们需要的包版本无法选择使用怎么办呢？有两种方式，一种是提交一个 pr 给 [xmake repo](https://github.com/xmake io/xmake repo)，增加指定包的新版本以及对应的 sha256，例如： ```lua package(\"zlib\", function() add_versions(\"1.2.10\", \"8d7e9f698ce48787b6e1c67e6bff79e487303e66077e25cb9784ac8835978017\") add_versions(\"1.2.11\", \"c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1\") end) ``` 另外，还有一种方式，就是用户传递 `{verify false}` 配置给 `add_requires`，强制忽略包的文件完整性校验，这样就不需要 sha256 值，因此就可以安装任意版本的包。 当然，这也会存在一定的安全性以及包不完整的风险，这就需要用户自己去选择评估了。 ```lua add_requires(\"zlib 1.2.11\", {verify false}) ``` ### 禁用外部头文件搜索路径 默认情况下，通过 `add_requires` 安装的包会采用 ` isystem` 或者 `/external:I` 来引用里面的头文件路径，这通常能够避免一些包头文件引入的不可修改的警告信息， 但是，我们还是可以通过设置 `{external false}` 来禁用外部头文件，切回 ` I` 的使用。 默认启用了 external 外部头文件的编译 flags 如下： ```console isystem /Users/ruki/.xmake/packages/z/zlib/1.2.11/d639b7d6e3244216b403b39df5101abf/include ``` 手动关闭 external 外部头文件的编译 flags 如下： ```lua add_requires(\"zlib 1.x\", {external false}) ``` ```console I /Users/ruki/.xmake/packages/z/zlib/1.2.11/d639b7d6e3244216b403b39df5101abf/include ``` ## 第三方依赖包安装 xmake 支持对对第三方包管理器里面的依赖库安装支持，例如：conan, brew, vcpkg 等 ### 添加 homebrew 的依赖包 ```lua add_requires(\"brew::zlib\", {alias \"zlib\"}) add_requires(\"brew::pcre2/libpcre2 8\", {alias \"pcre2\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"pcre2\", \"zlib\") end) ``` ### 添加 vcpkg 的依赖包 ```lua add_requires(\"vcpkg::zlib\", \"vcpkg::pcre2\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"vcpkg::zlib\", \"vcpkg::pcre2\") end) ``` 我们也可以加个包别名，简化对 `add_packages` 的使用： ```lua add_requires(\"vcpkg::zlib\", {alias \"zlib\"}) add_requires(\"vcpkg::pcre2\", {alias \"pcre2\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\", \"pcre2\") end) ``` 如果 vcpkg 包带有可选特性，我们也可以直接使用 vcpkg 的语法格式 `packagename[feature1,feature2]` 来安装包。 例如： ```lua add_requires(\"vcpkg::boost[core]\") ``` xmake 支持 vcpkg 新的清单模式，通过它，我们就能支持 vcpkg 包的版本选择，例如： ```lua add_requires(\"vcpkg::zlib 1.2.11\") add_requires(\"vcpkg::fmt> 8.0.1\", {configs {baseline \"50fd3d9957195575849a49fa591e645f1d8e7156\"}}) add_requires(\"vcpkg::libpng\", {configs {features {\"apng\"}}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"vcpkg::zlib\", \"vcpkg::fmt\", \"vcpkg::libpng\") end) ``` 还可以额外配置私有仓库，仅清单模式有效。 ```lua local registries { { kind \"git\", repository \"https://github.com/SakuraEngine/vcpkg registry\", baseline \"e0e1e83ec66e3c9b36066f79d133b01eb68049f7\", packages { \"skrgamenetworkingsockets\" } } } add_requires(\"vcpkg::skrgamenetworkingsockets> 1.4.0+1\", {configs {registries registries}}) ``` ### 添加 conan 的依赖包 ```lua add_requires(\"conan::zlib/1.2.11\", {alias \"zlib\", debug true}) add_requires(\"conan::openssl/1.1.1g\", {alias \"openssl\", configs {options \"OpenSSL:shared True\"}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"openssl\", \"zlib\") end) ``` 执行 xmake 进行编译后： ```console ruki:test_package ruki$ xmake checking for the architecture ... x86_64 checking for the Xcode directory ... /Applications/Xcode.app checking for the SDK version of Xcode ... 10.14 note: try installing these packages (pass y to skip confirm)? > conan::zlib/1.2.11 (debug) > conan::openssl/1.1.1g please input: y (y/n) > installing conan::zlib/1.2.11 .. ok > installing conan::openssl/1.1.1g .. ok [0%]: cache compiling.release src/main.c [100%]: linking.release test ``` 自定义 conan/settings 配置： ```lua add_requires(\"conan::poco/1.10.0\", {alias \"poco\", configs {settings {\"compiler gcc\", \"compiler.libcxx libstdc++11\"}}}) ``` 其他一些 conan 相关配置项： ``` { build {description \"use it to choose if you want to build from sources.\", default \"missing\", values {\"all\", \"never\", \"missing\", \"outdated\"}}, remote {description \"Set the conan remote server.\"}, options {description \"Set the options values, e.g. OpenSSL:shared True\"}, imports {description \"Set the imports for conan.\"}, settings {description \"Set the build settings for conan.\"}, build_requires {description \"Set the build requires for conan.\", default \"xmake_generator/0.1.0@bincrafters/testing\"} } ``` ### 添加 conda 的依赖包 ```lua add_requires(\"conda::zlib 1.2.11\", {alias \"zlib\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") end) ``` ### 添加 pacman 的依赖包 我们既支持 archlinux 上的 pacman 包安装和集成，也支持 msys2 上 pacman 的 mingw x86_64/i386 包安装和集成。 ```lua add_requires(\"pacman::zlib\", {alias \"zlib\"}) add_requires(\"pacman::libpng\", {alias \"libpng\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\", \"libpng\") end) ``` archlinux 上只需要： ```console xmake ``` msys2 上安装 mingw 包，需要指定到 mingw 平台： ```console xmake f p mingw a [x86_64i386] xmake ``` ### 添加 clib 的依赖包 clib 是一款基于源码的依赖包管理器，拉取的依赖包是直接下载对应的库源码，集成到项目中编译，而不是二进制库依赖。 其在 xmake 中集成也很方便，唯一需要注意的是，还需要自己添加上对应库的源码到 xmake.lua，例如： ```lua add_requires(\"clib::clibs/bytes@0.0.4\", {alias \"bytes\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"clib/bytes/*.c\") add_files(\"src/*.c\") add_packages(\"bytes\") end) ``` ### 添加 dub/dlang 的依赖包 xmake 也支持 dlang 的 dub 包管理器，集成 dlang 的依赖包来使用。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"dub::log 0.4.3\", {alias \"log\"}) add_requires(\"dub::dateparser\", {alias \"dateparser\"}) add_requires(\"dub::emsi_containers\", {alias \"emsi_containers\"}) add_requires(\"dub::stdx allocator\", {alias \"stdx allocator\"}) add_requires(\"dub::mir core\", {alias \"mir core\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") add_packages(\"log\", \"dateparser\", \"emsi_containers\", \"stdx allocator\", \"mir core\") end) ``` ### 添加 ubuntu/apt 的依赖包 xmake 支持使用 apt 集成依赖包，也会自动查找 ubuntu 系统上已经安装的包。 ```lua add_requires(\"apt::zlib1g dev\", {alias \"zlib\"}) target(\"test\") set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") ``` ### 添加 gentoo/portage 的依赖包 v2.5.4 之后版本支持使用 Portage 集成依赖包，也会自动查找 Gentoo 系统上已经安装的包。 ```lua add_requires(\"portage::libhandy\", {alias \"libhandy\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"libhandy\") end) ``` ### 添加 nimble 的依赖包 xmake 支持集成 nimble 包管理器中的包，但是目前仅用于 nim 项目，因为它并没有提供二进制的包，而是直接安装的 nim 代码包。 ```lua add_requires(\"nimble::zip>1.3\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"nimble::zip\") end) ``` ### 添加 cargo 的依赖包 Cargo 依赖包主要给 rust 项目集成使用，例如： ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::base64 0.13.0\") add_requires(\"cargo::flate2 1.0.17\", {configs {features \"zlib\"}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::base64\", \"cargo::flate2\") end) ``` 不过，我们也可以在 C++ 中通过 cxxbridge 的方式，调用 Rust 库接口，来变相复用所有的 Rust 包。 完整例子见：[Call Rust in C++](https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library) ### 添加 NuGet 的依赖包 xmake 也支持从 dotnet/nuget 中，获取 native 库并快速集成。 ```lua add_requires(\"nuget::zlib_static\", {alias \"zlib\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"zlib\") end) ``` ## 使用自建私有包仓库 如果需要的包不在官方仓库 [xmake repo](https://github.com/xmake io/xmake repo) 中，我们可以提交贡献代码到仓库进行支持。 但如果有些包仅用于个人或者私有项目，我们可以建立一个私有仓库 repo，仓库组织结构可参考：[xmake repo](https://github.com/xmake io/xmake repo) 比如，现在我们有一个一个私有仓库 repo：`git@github.com:myrepo/xmake repo.git` 我们可以通过下面的命令进行仓库添加： ```console $ xmake repo add myrepo git@github.com:myrepo/xmake repo.git [branch] ``` > [branch] 是可选的，我们也可以切换到指定 repo 分支 或者我们直接写在 xmake.lua 中： ```lua add_repositories(\"my repo git@github.com:myrepo/xmake repo.git\") ``` 同样，我们也可以切换到指定 repo 分支 ```lua add_repositories(\"my repo git@github.com:myrepo/xmake repo.git dev\") ``` 如果我们只是想添加一两个私有包，这个时候特定去建立一个 git repo 太小题大做了，我们可以直接把包仓库放置项目里面，例如： ``` projectdir myrepo packages t/tbox/xmake.lua z/zlib/xmake.lua src main.c xmake.lua ``` 上面 myrepo 目录就是自己的私有包仓库，内置在自己的项目里面，然后在 xmake.lua 里面添加一下这个仓库位置： ```lua add_repositories(\"my repo myrepo\") ``` 这个可以参考 [benchbox](https://github.com/xmake io/benchbox) 项目，里面就内置了一个私有仓库。 我们甚至可以连仓库也不用建，直接定义包描述到项目 xmake.lua 中，这对依赖一两个包的情况还是很有用的，例如： ```lua package(\"libjpeg\", function() set_urls(\"http://www.ijg.org/files/jpegsrc.$(version).tar.gz\") add_versions(\"v9c\", \"650250979303a649e21f87b5ccd02672af1ea6954b911342ea491f351ceb7122\") on_install(\"windows\", function (package) os.mv(\"jconfig.vc\", \"jconfig.h\") os.vrun(\"nmake f makefile.vc\") os.cp(\"*.h\", package:installdir(\"include\")) os.cp(\"libjpeg.lib\", package:installdir(\"lib\")) end) on_install(\"macosx\", \"linux\", function (package) import(\"package.tools.autoconf\").install(package) end) end) add_requires(\"libjpeg\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"libjpeg\") end) ``` 关于如何编写自定义包描述规则，详情见：[添加包到仓库](# 添加包到仓库) ## 包管理命令使用 包管理命令 `$ xmake require` 可用于手动显示的下载编译安装、卸载、检索、查看包信息。 ### xrepo 命令 `xmake require` 仅用于当前工程，我们也提供了更加方便的独立 `xrepo` 包管理器命令，来全局对包进行安装，卸载和查找管理。 详细文档见：[Xrepo 命令使用入门](https://xrepo.xmake.io/#/zh cn/getting_started) ### 安装指定包 ```console $ xmake require tbox ``` 安装指定版本包： ```console $ xmake require tbox \"~1.6\" ``` 强制重新下载安装，并且显示详细安装信息： ```console $ xmake require f v tbox \"1.5.x\" ``` 传递额外的设置信息： ```console $ xmake require extra \"{debug true,config {small true}}\" tbox ``` 安装 debug 包，并且传递 `small true` 的编译配置信息到包中去。 ### 卸载指定包 ```console $ xmake require uninstall tbox ``` 这会完全卸载删除包文件。 ### 查看包详细信息 ```console $ xmake require info tbox ``` ### 在当前仓库中搜索包 ```console $ xmake require search tbox ``` 这个是支持模糊搜素以及 lua 模式匹配搜索的： ```console $ xmake require search pcr ``` 会同时搜索到 pcre, pcre2 等包。 ### 列举当前已安装的包 ```console $ xmake require list ``` ## 仓库管理命令使用 上文已经简单讲过，添加私有仓库可以用（支持本地路径添加）： ```console $ xmake repo add myrepo git@github.com:myrepo/xmake repo.git ``` xmake 支持添加指定分支的 repo，例如： ```console $ xmake repo add myrepo git@github.com:myrepo/xmake repo.git dev ``` > 我们也可以添加本地仓库路径，即使没有 git 也是可以支持的，用于在本地快速的调试 repo 中的包。 我们也可以移除已安装的某个仓库： ```console $ xmake repo remove myrepo ``` 或者查看所有已添加的仓库： ```console $ xmake repo list ``` 如果远程仓库有更新，可以手动执行仓库更新，来获取更多、最新的包： ```console $ xmake repo u ``` ## 远程包下载优化 如果由于网络不稳定，导致下载包速度很慢或者下载失败，我们可以通过的下面的一些方式来解决。 ### 手动下载 默认 xmake 会调用 curl, wget 等工具来下载，用户也可以手动用自己的下载器下载（也可以使用代理），把下载后的包放到自己的目录下，比如: `/download/packages/zlib v1.0.tar.gz` 然后使用下面的命令，设置包下载的搜索目录： ```console $ xmake g pkg_searchdirs \"/download/packages\" ``` 然后重新执行 xmake 编译时候，xmake 会优先从 `/download/packages` 找寻源码包，然后直接使用，不再自己下载了。 至于找寻的包名是怎样的呢，可以通过下面的命令查看： ```console $ xmake require info zlib > searchdirs: /download/packages > searchnames: zlib 1.2.11.tar.gz ``` 我们可以看到对应的搜索目录以及搜索的包名。 ### 设置代理 如果觉得手动下载还是麻烦，我们也可以让 xmake 直接走代理。 ```console $ xmake g proxy \"socks5://127.0.0.1:1086\" $ xmake g help x PROXY, proxy PROXY Use proxy on given port. [PROTOCOL://]HOST[:PORT] e.g. xmake g proxy 'http://host:port' xmake g proxy 'https://host:port' xmake g proxy 'socks5://host:port' ``` ` proxy` 参数指定代理协议和地址，具体语法可以参考 curl 的，通常可以支持 http, https, socks5 等协议，但实际支持力度依赖 curl, wget 和 git，比如 wget 就不支持 socks5 协议。 我们可以通过下面的参数指定哪些 host 走代理，如果没设置，默认全局走代理。 ```console proxy_hosts PROXY_HOSTS Only enable proxy for the given hosts list, it will enable all if be unset, and we can pass match pattern to list: e.g. xmake g proxy_hosts 'github.com,gitlab.*,*.xmake.io' ``` 如果设置了 hosts 列表，那么之后这个列表里面匹配的 host 才走代理。。 ` proxy_host` 支持多个 hosts 设置，逗号分隔，并且支持基础的模式匹配 *.github.com， 以及其他 lua 模式匹配规则也支持 如果觉得上面的 hosts 模式配置还不够灵活，我们也可以走 pac 的自动代理配置规则： ```console proxy_pac PROXY_PAC Set the auto proxy configuration file. (default: pac.lua) e.g. xmake g proxy_pac pac.lua (in /Users/ruki/.xmake or absolute path) function main(url, host) if host 'github.com' then return true end end ``` > 如果有 proxy_hosts 优先走 hosts 配置，没有的话才走 pac 配置。 pac 的默认路径：~/.xmake/pac.lua，如果 proxy 被设置，并且这个文件存在，就会自动走 pac，如果不存在，也没 hosts，那就全局生效代理。 也可以手动指定 pac 全路径 ```console $ xmake g proxy_pac /xxxx/xxxxx_pac.lua ``` 配置规则描述： ```lua function main(url, host) if host:find(\"bintray.com\") then return true end end ``` 如果返回 true，那么这个 url 和 host 就是走的代理，不返回或者返回 false，就是不走代理。 这块的具体详情见：<https://github.com/xmake io/xmake/issues/854> > 另外，除了依赖包下载，其他涉及网络下载的命令也都支持代理，比如：`xmake update` #### 镜像代理 v2.5.4 之后，pac.lua 配置里面还可以配置镜像代理规则，比如对所有 github.com 域名的访问切到 hub.fastgit.org 域名，实现加速下载包。 ```lua function mirror(url) return url:gsub(\"github.com\", \"hub.fastgit.org\") end ``` ```console $ xrepo install libpng > curl https://hub.fastgit.org/glennrp/libpng/archive/v1.6.37.zip o v1.6.37.zip ``` ## 添加包到仓库 ### 仓库包结构 在制作自己的包之前，我们需要先了解下一个包仓库的结构，不管是官方包仓库，还是自建私有包仓库，结构都是相同的： ``` xmake repo packages t/tbox/xmake.lua z/zlib/xmake.lua ``` 通过上面的结构，可以看到每个包都会有个 xmake.lua 用于描述它的安装规则，并且根据 `z/zlib` 两级子目录分类存储，方便快速检索。 ### 包描述说明 关于包的描述规则，基本上都是在它的 xmake.lua 里面完成的，这跟项目工程里面的 xmake.lua 描述很类似，不同的是描述域仅支持 `package()`， 不过，在项目 xmake.lua 里面，也是可以直接添加 `package()` 来内置包描述的，连包仓库都省了，有时候这样会更加方便。 首先，我们先拿 zlib 的描述规则，来直观感受下，这个规则可以在 [xmake repo/z/zlib/xmake.lua](https://github.com/xmake io/xmake repo/blob/master/packages/z/zlib/xmake.lua) 下找到。 ```lua package(\"zlib\", function() set_homepage(\"http://www.zlib.net\") set_description(\"A Massively Spiffy Yet Delicately Unobtrusive Compression Library\") set_urls(\"http://zlib.net/zlib $(version).tar.gz\", \"https://downloads.sourceforge.net/project/libpng/zlib/$(version)/zlib $(version).tar.gz\") add_versions(\"1.2.10\", \"8d7e9f698ce48787b6e1c67e6bff79e487303e66077e25cb9784ac8835978017\") add_versions(\"1.2.11\", \"c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1\") on_install(\"windows\", function (package) io.gsub(\"win32/Makefile.msc\", \"% MD\", \" \" .. package:config(\"vs_runtime\")) os.vrun(\"nmake f win32\\\\Makefile.msc zlib.lib\") os.cp(\"zlib.lib\", package:installdir(\"lib\")) os.cp(\"*.h\", package:installdir(\"include\")) end) on_install(\"linux\", \"macosx\", function (package) import(\"package.tools.autoconf\").install(package, {\" static\"}) end) on_install(\"iphoneos\", \"android@linux,macosx\", \"mingw@linux,macosx\", function (package) import(\"package.tools.autoconf\").configure(package, {host \"\",\" static\"}) io.gsub(\"Makefile\", \"\\nAR . \\n\", \"\\nAR \" .. (package:build_getenv(\"ar\") or \"\") ..\"\\n\") io.gsub(\"Makefile\", \"\\nARFLAGS . \\n\", \"\\nARFLAGS cr\\n\") io.gsub(\"Makefile\", \"\\nRANLIB . \\n\", \"\\nRANLIB \\n\") os.vrun(\"make install j4\") end) on_test(function (package) assert(package:has_cfuncs(\"inflate\", {includes \"zlib.h\"})) end) end) ``` 这个包规则对 windows, linux, macosx, iphoneos，mingw 等平台都添加了安装规则，基本上已经做到了全平台覆盖，甚至一些交叉编译平台，算是一个比较典型的例子了。 当然，有些包依赖源码实现力度，并不能完全跨平台，那么只需对它支持的平台设置安装规则即可。 更多详细的包配置 API 说明见：[包接口文档](/zh cn/manual/package_dependencies) ### 扩展配置参数 详情见：[add_configs](/zh cn/manual/package_dependencies?id packageadd_configs) ### 内置配置参数 除了可以通过 [add_configs](/zh cn/manual/package_dependencies?id packageadd_configs) 设置一些扩展的配置参数以外，xmake 还提供了一些内置的配置参数，可以使用 #### 启用调试包 ```lua add_requires(\"xxx\", {debug true}) ``` 包描述里面必须有相关处理才能支持： ```lua on_install(function (package) local configs {} if package:debug() then table.insert(configs, \" enable debug\") end import(\"package.tools.autoconf\").install(package) end) ``` #### 设置 msvc 运行时库 ```lua add_requires(\"xxx\", {configs {vs_runtime \"MT\"}}) ``` 通常情况下，通过 `import(\"package.tools.autoconf\").install` 等内置工具脚本安装的包，内部都对 vs_runtime 自动处理过了。 但是如果是一些特殊的源码包，构建规则比较特殊，那么需要自己处理了： ```lua on_install(function (package) io.gsub(\"build/Makefile.win32.common\", \"% MD\", \" \" .. package:config(\"vs_runtime\")) end) ``` ### 添加环境变量 对于一些库，里面也带了可执行的工具，如果需要在集成包的时候，使用上这些工具，那么也可以设置上对应 PATH 环境变量： ```lua package(\"luajit\", function() on_load(function (package) if is_plat(\"windows\") then package:addenv(\"PATH\", \"lib\") end package:addenv(\"PATH\", \"bin\") end) end) ``` 而在项目工程中，只有通过 `add_packages` 集成对应的包后，对应的环境变量才会生效。 ```lua add_requires(\"luajit\") target(\"test\", function() set_kind(\"binary\") add_packages(\"luajit\") after_run(function (package) os.exec(\"luajit version\") end) end) ``` ### 安装二进制包 xmake 也是支持直接引用二进制版本包，直接安装使用，例如： ```lua if is_plat(\"windows\") then set_urls(\"https://www.libsdl.org/release/SDL2 devel $(version) VC.zip\") add_versions(\"2.0.8\", \"68505e1f7c16d8538e116405411205355a029dcf2df738dbbc768b2fe95d20fd\") end on_install(\"windows\", function (package) os.cp(\"include\", package:installdir()) os.cp(\"lib/$(arch)/*.lib\", package:installdir(\"lib\")) os.cp(\"lib/$(arch)/*.dll\", package:installdir(\"lib\")) end) ``` ### 本地测试 如果在本地 xmake repo 仓库中，已经添加和制作好了新的包，可以在本地运行测试下，是否通过，如果测试通过，即可提交 pr 到官方仓库，请求 merge。 我们可以执行下面的脚本进行测试指定包： ```bash cd xmake repo xmake l scripts/test.lua v D zlib ``` 上面的命令，会强制重新下载和安装 zlib 包，测试整个安装流程是否 ok，加上 ` v D` 是为了可以看到完整详细的日志信息和出错信息，方便调试分析。 如果网络环境不好，不想每次测试都去重新下载所有依赖，可以加上 ` shallow` 参数来执行，这个参数告诉脚本，仅仅重新解压本地缓存的 zlib 源码包，重新执行安装命令，但不会下载各种依赖。 ```bash cd xmake repo xmake l scripts/test.lua v D shallow zlib ``` 如果我们想测试其他平台的包规则是否正常，比如: android, iphoneos 等平台，可以通过 ` p/ plat` 或者 ` a/ arch` 来指定。 ```bash cd xmake repo xmake l scripts/test.lua v D shallow p iphoneos a arm64 zlib xmake l scripts/test.lua v D shallow p android ndk /xxxx zlib ``` ## 提交包到官方仓库 目前这个特性刚完成不久，目前官方仓库的包还不是很多，有些包也许还不支持部分平台，不过这并不是太大问题，后期迭代几个版本后，我会不断扩充完善包仓库。 如果你需要的包，当前的官方仓库还没有收录，可以提交 issues 或者自己可以在本地调通后，贡献提交到官方仓库：[xmake repo](https://github.com/xmake io/xmake repo) 详细的贡献说明，见：[CONTRIBUTING.md](https://github.com/xmake io/xmake repo/blob/master/CONTRIBUTING.md) 关于如何制作自己的包，可以看下上文：[添加包到仓库](# 添加包到仓库)。 ## 依赖包的锁定和升级 xmake 支持依赖包的版本锁定，类似 npm 的 package.lock, cargo 的 cargo.lock。 比如，我们引用一些包，默认情况下，如果不指定版本，那么 xmake 每次都会自动拉取最新版本的包来集成使用，例如： ```lua add_requires(\"zlib\") ``` 但如果上游的包仓库更新改动，比如 zlib 新增了一个 1.2.11 版本，或者安装脚本有了变动，都会导致用户的依赖包发生改变。 这容易导致原本编译通过的一些项目，由于依赖包的变动出现一些不稳定因素，有可能编译失败等等。 为了确保用户的项目每次使用的包都是固定的，我们可以通过下面的配置去启用包依赖锁定。 ```lua set_policy(\"package.requires_lock\", true) ``` 这是一个全局设置，必须设置到全局根作用域，如果启用后，xmake 执行完包拉取，就会自动生成一个 `xmake requires.lock` 的配置文件。 它包含了项目依赖的所有包，以及当前包的版本等信息。 ```lua { __meta__ { version \"1.0\" }, [\"macosxx86_64\"] { [\"cmake#31fecfc4\"] { repo { branch \"master\", commit \"4498f11267de5112199152ab030ed139c985ad5a\", url \"https://github.com/xmake io/xmake repo.git\" }, version \"3.21.0\" }, [\"glfw#31fecfc4\"] { repo { branch \"master\", commit \"eda7adee81bac151f87c507030cc0dd8ab299462\", url \"https://github.com/xmake io/xmake repo.git\" }, version \"3.3.4\" }, [\"opengl#31fecfc4\"] { repo { branch \"master\", commit \"94d2eee1f466092e04c5cf1e4ecc8c8883c1d0eb\", url \"https://github.com/xmake io/xmake repo.git\" } } } } ``` 当然，我们也可以执行下面的命令，强制升级包到最新版本。 ```console $ xmake require upgrade upgrading packages .. zlib: 1.2.10 > 1.2.11 1 package is upgraded! ``` ## 分发和使用自定义包规则 我们可以在包管理仓库中，添加自定义构架规则脚本，实现跟随包进行动态下发和安装。 我们需要将自定义规则放到仓库的 `packages/x/xxx/rules` 目录中，它会跟随包一起被安装。 但是，它也存在一些限制： * 在包中规则，我们不能添加 `on_load`, `after_load` 脚本，但是通常我们可以使用 `on_config` 来代替。 ### 添加包规则 我们需要将规则脚本添加到 rules 固定目录下，例如：packages/z/zlib/rules/foo.lua ```lua rule(\"foo\", function() on_config(function (target) print(\"foo: on_config %s\", target:name()) end) end) ``` ### 应用包规则 使用规则的方式跟之前类似，唯一的区别就是，我们需要通过 `@packagename/` 前缀去指定访问哪个包里面的规则。 具体格式：`add_rules(\"@packagename/rulename\")`，例如：`add_rules(\"@zlib/foo\")`。 ```lua add_requires(\"zlib\", {system false}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"zlib\") add_rules(\"@zlib/foo\") end) ``` ### 通过包别名引用规则 如果存在一个包的别名，xmake 将优先考虑包的别名来获得规则。 ```lua add_requires(\"zlib\", {alias \"zlib2\", system false}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"zlib2\") add_rules(\"@zlib2/foo\") end) ``` ### 添加包规则依赖 我们可以使用 `add_deps(\"@bar\")` 来添加相对于当前包目录的其他规则。 然而，我们不能添加来自其他包的规则依赖，它们是完全隔离的，我们只能参考用户项目中由 `add_requires` 导入的其他包的规则。 packages/z/zlib/rules/foo.lua ```lua rule(\"foo\", function() add_deps(\"@bar\") on_config(function (target) print(\"foo: on_config %s\", target:name()) end) end) ``` packages/z/zlib/rules/bar.lua ```lua rule(\"bar\", function() on_config(function (target) print(\"bar: on_config %s\", target:name()) end) end) ``` ## 在 CMake 中使用 Xrepo 的依赖包管理 我们新增了一个独立项目 [xrepo cmake](https://github.com/xmake io/xrepo cmake)。 它是一个基于 Xrepo/Xmake 的 C/C++ 包管理器的 CMake 包装器。 这允许使用 CMake 来构建您的项目，同时使用 Xrepo 来管理依赖包。这个项目的部分灵感来自 [cmake conan](https://github.com/conan io/cmake conan)。 此项目的示例用例： * 想要使用 Xrepo 管理包的现有 CMake 项目。 * 必须使用 CMake，但想使用 Xrepo 管理的新项目包。 ### Apis #### xrepo_package [xrepo.cmake](https://github.com/xmake io/xrepo cmake/blob/main/xrepo.cmake) 提供 `xrepo_package` 函数来管理包。 ```cmake xrepo_package( \"foo 1.2.3\" [CONFIGS feature1 true,feature2 false] [CONFIGS path/to/script.lua] [DEPS] [MODE debugrelease] [ALIAS aliasname] [OUTPUT verbosediagnosisquiet] [DIRECTORY_SCOPE] ) ``` 一些函数参数直接对应于 Xrepo 命令选项。 `xrepo_package` 将软件包安装目录添加到 `CMAKE_PREFIX_PATH`。所以 `find_package` 可以使用。如果 `CMAKE_MINIMUM_REQUIRED_VERSION` > 3.1，cmake `pkgConfig` 也会搜索 对于软件包安装目录下的 pkgconfig 文件。 调用 `xrepo_package(foo)` 后，有 `foo` 包的三种使用方式： 1. 如果包提供 cmake 配置文件，则调用 `find_package(foo)`。 * 有关详细信息，请参阅 CMake [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html) 文档。 2. 如果包没有提供 cmake 配置文件或者找不到模块 * 以下变量可用于使用 pacakge（cmake 后的变量名 查找模块 [标准变量名称](https://cmake.org/cmake/help/latest/manual/cmake developer.7.html#standard variable names)) * `foo_INCLUDE_DIRS` * `foo_LIBRARY_DIRS` * `foo_LIBRARIES` * `foo_DEFINITIONS` * 如果指定了 `DIRECTORY_SCOPE`，则 `xrepo_package` 将运行以下代码 ```cmake include_directories(${foo_INCLUDE_DIRS}) link_directories(${foo_LIBRARY_DIRS}) ``` 3. 使用 `xrepo_target_packages`。请参阅以下部分。 注意 `CONFIGS path/to/script.lua` 用于对包配置进行精细控制。 例如： * 排除系统上的包。 * 覆盖依赖包的默认配置，例如设置 `shared true`。 如果指定了 `DEPS`，所有依赖库都将添加到 `CMAKE_PREFIX_PATH`，以及 include 和 libraries 那四个变量中。 #### xrepo_target_packages 将包 includedirs 和 links/linkdirs 添加到给定的目标。 ```cmake xrepo_target_packages( target [NO_LINK_LIBRARIES] [PRIVATEPUBLICINTERFACE] package1 package2 ... ) ``` ### 使用来自官方存储库的包 Xrepo 官方仓库：[xmake repo](https://github.com/xmake io/xmake repo) 这是一个使用 `gflags` 包版本 2.2.2 的示例 `CMakeLists.txt` 由 Xrepo 管理。 #### 集成 xrepo.cmake ```cmake cmake_minimum_required(VERSION 3.13.0) project(foo) # Download xrepo.cmake if not exists in build directory. if(NOT EXISTS \"${CMAKE_BINARY_DIR}/xrepo.cmake\") message(STATUS \"Downloading xrepo.cmake from https://github.com/xmake io/xrepo cmake/\") # mirror https://cdn.jsdelivr.net/gh/xmake io/xrepo cmake@main/xrepo.cmake file(DOWNLOAD \"https://raw.githubusercontent.com/xmake io/xrepo cmake/main/xrepo.cmake\" \"${CMAKE_BINARY_DIR}/xrepo.cmake\" TLS_VERIFY ON) endif() # Include xrepo.cmake so we can use xrepo_package function. include(${CMAKE_BINARY_DIR}/xrepo.cmake) ``` #### 添加包 ```cmake xrepo_package(\"zlib\") add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) xrepo_target_packages(example bin zlib) ``` #### 添加带有配置的包 ```cmake xrepo_package(\"gflags 2.2.2\" CONFIGS \"shared true,mt true\") add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) xrepo_target_packages(example bin gflags) ``` #### 添加带有 cmake 导入模块的包 ```cmake xrepo_package(\"gflags 2.2.2\" CONFIGS \"shared true,mt true\") # `xrepo_package` 会将 gflags 安装目录添加到 CMAKE_PREFIX_PATH. # `find_package(gflags)` 会从 CMAKE_PREFIX_PATH 包含的目录中找到 gflags 提供的 # config file 文件。 # 参考 https://cmake.org/cmake/help/latest/command/find_package.html#search modes find_package(gflags CONFIG COMPONENTS shared) add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) target_link_libraries(example bin gflags) ``` #### 添加自定义包 ```cmake set(XREPO_XMAKEFILE ${CMAKE_CURRENT_SOURCE_DIR}/packages/xmake.lua) xrepo_package(\"myzlib\") add_executable(example bin \"\") target_sources(example bin PRIVATE src/main.cpp ) xrepo_target_packages(example bin myzlib) ``` 在 packages/xmake.lua 中定义一个包： ```lua package(\"myzlib\") ... ``` 我们可以自定义一个包，具体定义方式，参考文档：[自定义 Xrepo 包](https://xmake.io/#/zh cn/package/remote_package?id package description)。 ### 使用来自第三个存储库的包 除了从官方维护的存储库安装软件包之外，Xrepo 还可以安装来自第三方包管理器的包，例如 vcpkg/conan/conda/pacman/homebrew/apt/dub/cargo。 关于命令行的使用，我们可以参考文档：[Xrepo 命令用法](https://xrepo.xmake.io/#/getting_started?id install packages from third party package manager) 我们也可以直接在 cmake 中使用它来安装来自第三方仓库的包，只需将仓库名称添加为命名空间即可。例如：`vcpkg::zlib`, `conan::pcre2` #### Conan ```cmake xrepo_package(\"conan::gflags/2.2.2\") ``` #### Conda ```cmake xrepo_package(\"conda::gflags 2.2.2\") ``` #### Vcpkg ```cmake xrepo_package(\"vcpkg::gflags\") ``` #### Homebrew ```cmake xrepo_package(\"brew::gflags\") ```"},"/get_started/zh/package/description-scope.html":{"title":"","content":" class: heading_no_counter # 描述域 ## 仓库依赖包定义描述 可先参考官方仓库中现有包描述：[xmake repo](https://github.com/xmake io/xmake repo) 这里给个比较具有代表性的实例供参考： ```lua package(\"libxml2\", function() set_homepage(\"http://xmlsoft.org/\") set_description(\"The XML C parser and toolkit of Gnome.\") set_urls(\"https://github.com/GNOME/libxml2/archive/$(version).zip\", {excludes {\"*/result/*\", \"*/test/*\"}}) add_versions(\"v2.9.8\", \"c87793e45e66a7aa19200f861873f75195065de786a21c1b469bdb7bfc1230fb\") add_versions(\"v2.9.7\", \"31dd4c0e10fa625b47e27fd6a5295d246c883f214da947b9a4a9e13733905ed9\") if is_plat(\"macosx\", \"linux\") then add_deps(\"autoconf\", \"automake\", \"libtool\", \"pkg config\") end on_load(function (package) package:add(\"includedirs\", \"include/libxml2\") package:add(\"links\", \"xml2\") end) if is_plat(\"windows\") and winos.version():gt(\"winxp\") then on_install(\"windows\", function (package) os.cd(\"win32\") os.vrun(\"cscript configure.js iso8859x yes iconv no compiler msvc cruntime /MT debug %s prefix \\\"%s\\\"\", package:debug() and\"yes\"or\"no\", package:installdir()) os.vrun(\"nmake /f Makefile.msvc\") os.vrun(\"nmake /f Makefile.msvc install\") end) end on_install(\"macosx\", \"linux\", function (package) import(\"package.tools.autoconf\").install(package, {\" disable dependency tracking\", \" without python\", \" without lzma\"}) end) end) ``` ## package:set_homepage 设置包所在项目的官方页面地址。 ## package:set_description 设置包的相关描述信息。 一般通过 `xmake require info zlib` 查看相关包信息时候，会看到。 ## package:set_kind 设置包类型。 对于依赖库，则不用设置，如果是可执行包，需要设置为 binary。 ```lua package(\"cmake\", function() set_kind(\"binary\") set_homepage(\"https://cmake.org\") set_description(\"A cross platform family of tool designed to build, test and package software\") end) ``` ## package:set_urls 设置包源地址。 设置包的源码包或者 git 仓库地址，跟 add_urls 不同的是，此接口是覆盖性设置，而 add_urls 是追加设置，其他使用方式类似，这个根据不同需要来选择。 ## package:add_urls 添加包源地址。 添加包的源码包或者 git 仓库地址，此接口一般跟 add_version 配对使用，用于设置每个源码包的版本和对应的 sha256 值或者 git 的 commit 或者 tag 或者 branch。 > 可以通过添加多个 urls 作为镜像源，xmake 会自动检测优先选用最快的 url 进行下载，如果下载失败则会尝试其他 urls。 ```lua add_urls(\"https://github.com/protobuf c/protobuf c/releases/download/v$(version)/protobuf c $(version).tar.gz\") add_versions(\"1.3.1\", \"51472d3a191d6d7b425e32b612e477c06f73fe23e07f6a6a839b11808e9d2267\") ``` urls 里面的 `$(version)` 内置变量，会根据实际安装时候选择的版本适配进去，而版本号都是从 `add_versions` 中指定的版本列表中选择的。 如果对于 urls 里面带有比较复杂的版本串，没有跟 `add_versions` 有直接对应关系，则需要通过下面的方式定制化转换下： ```lua add_urls(\"https://sqlite.org/2018/sqlite autoconf $(version)000.tar.gz\", {version function (version) return version:gsub(\"%.\", \"\") end}) add_versions(\"3.24.0\", \"d9d14e88c6fb6d68de9ca0d1f9797477d82fc3aed613558f87ffbdbbc5ceb74a\") add_versions(\"3.23.0\", \"b7711a1800a071674c2bf76898ae8584fc6c9643cfe933cfc1bc54361e3a6e49\") ``` 当然，我们也只可以添加 git 源码地址： ```lua add_urls(\"https://gitlab.gnome.org/GNOME/libxml2.git\") ``` 如果设置的多个镜像地址对应的源码包 sha256 是不同的，我们可以通过 alias 的方式来分别设置 ```lua add_urls(\"https://ffmpeg.org/releases/ffmpeg $(version).tar.bz2\", {alias \"home\"}) add_urls(\"https://github.com/FFmpeg/FFmpeg/archive/n$(version).zip\", {alias \"github\"}) add_versions(\"home:4.0.2\", \"346c51735f42c37e0712e0b3d2f6476c86ac15863e4445d9e823fe396420d056\") add_versions(\"github:4.0.2\", \"4df1ef0bf73b7148caea1270539ef7bd06607e0ea8aa2fbf1bb34062a097f026\") ``` 我们也可以设置指定的 urls 的 http headers： ```lua add_urls(\"https://github.com/madler/zlib/archive/$(version).tar.gz\", { http_headers {\"TEST1: foo\", \"TEST2: bar\"} }) ``` ## package:add_versions 设置每个源码包的版本。 它也会设置对应的 sha256 值，具体描述见：[add_urls](#packageadd_urls) ## package:add_versionfiles 添加包版本列表。 通常我们可以通过 `add_versions` 接口添加包版本，但是如果版本越来越多，就会导致包配置太过臃肿，这个时候，我们可以使用 `add_versionfiles` 接口将所有的版本列表，存储到单独的文件中去维护。 例如： ```lua package(\"libcurl\", function() add_versionfiles(\"versions.txt\") end) ``` ```bash 8.5.0 ce4b6a6655431147624aaf582632a36fe1ade262d5fab385c60f78942dd8d87b 8.4.0 e5250581a9c032b1b6ed3cf2f9c114c811fc41881069e9892d115cc73f9e88c6 8.0.1 9b6b1e96b748d04b968786b6bdf407aa5c75ab53a3d37c1c8c81cdb736555ccf 7.87.0 5d6e128761b7110946d1276aff6f0f266f2b726f5e619f7e0a057a474155f307 7.31.0 a73b118eececff5de25111f35d1d0aafe1e71afdbb83082a8e44d847267e3e08 ... ``` ## package:add_patches 设置包补丁。 此接口用于针对源码包，在编译安装前，先打对应设置的补丁包，再对其进行编译，并且可支持同时打多个补丁。 ```lua if is_plat(\"macosx\") then add_patches(\"1.15\", \"https://raw.githubusercontent.com/Homebrew/patches/9be2793af/libiconv/patch utf8mac.diff\", \"e8128732f22f63b5c656659786d2cf76f1450008f36bcf541285268c66cabeab\") end ``` 例如，上面的代码，就是针对 macosx 下编译的时候，打上对应的 patch utf8mac.diff 补丁，并且每个补丁后面也是要设置 sha256 值的，确保完整性。 ## package:add_links 设置库链接。 默认情况下，xmake 会去自动检测安装后的库，设置链接关系，但是有时候并不是很准，如果要自己手动调整链接顺序，以及链接名，则可以通过这个接口来设置。 ```lua add_links(\"mbedtls\", \"mbedx509\", \"mbedcrypto\") ``` ## package:add_syslinks 设置系统库链接。 添加一些系统库链接，有些包集成链接的时候，还需要依赖一些系统库，才能链接通过，这个时候可以在包描述里面都附加上去。 ```lua if is_plat(\"macosx\") then add_frameworks(\"CoreGraphics\", \"CoreFoundation\", \"Foundation\") elseif is_plat(\"windows\") then add_defines(\"CAIRO_WIN32_STATIC_BUILD 1\") add_syslinks(\"gdi32\", \"msimg32\", \"user32\") else add_syslinks(\"pthread\") end ``` ## package:add_linkorders 调整包内部的链接顺序。 具体详情可以看下 target 内部对 `add_linkorders` 的文档说明，[target/add_linkorders](https://xmake.io/#/zh cn/manual/project_target?id targetadd_linkorders)。 ```lua package(\"libpng\", function() add_linkorders(\"png16\", \"png\", \"linkgroup::foo\") add_linkgroups(\"dl\", {name \"foo\", group true}) end) ``` ## package:add_linkgroups 配置包的链接组。 具体详情可以看下 target 内部对 `add_linkgroups` 的文档说明，[target/add_linkgroups](https://xmake.io/#/zh cn/manual/project_target?id targetadd_linkgroups)。 ```lua package(\"libpng\", function() add_linkorders(\"png16\", \"png\", \"linkgroup::foo\") add_linkgroups(\"dl\", {name \"foo\", group true}) end) ``` ## package:add_frameworks 添加依赖的系统 frameworks 链接。 示例见：[add_syslinks](#packageadd_syslinks) ## package:add_linkdirs 添加链接目录。 包的链接库搜索目录也是可以调整的，不过通常都不需要，除非一些库安装完不在 prefix/lib 下面，而在 lib 的子目录下，默认搜索不到的话。 ## package:add_includedirs 添加其他头文件搜索目录。 ## package:add_bindirs 添加可执行文件目录。 默认情况下，如果配置了 `set_kind(\"binary\")` 或者 `set_kind(\"toolchain\")` 作为可执行的包。 那么，它默认会将 bin 目录作为可执行目录，并且自动将它加入到 PATH 环境变量中去。 而如果对应 library 包，想要将里面附带编译的一些可执行工具开放给用户执行，那么需要在包中配置 `package:addenv(\"PATH\", \"bin\")` 中才行。 而通过这个接口去配置 `add_bindirs(\"bin\")` ，那么将会自动将 bin 添加到 PATH，不再需要单独配置 PATH，另外，这也提供了一种可以修改可执行目录的方式。 ## package:add_defines 添加宏定义。 可以对集成的包对外输出一些特定的定义选项。 ## package:add_configs 添加包配置。 我们可以通过此接口添加每个包的对外输出配置参数： ```lua package(\"pcre2\", function() set_homepage(\"https://www.pcre.org/\") set_description(\"A Perl Compatible Regular Expressions Library\") add_configs(\"bitwidth\", {description \"Set the code unit width.\", default \"8\", values {\"8\", \"16\", \"32\"}}) on_load(function (package) local bitwidth package:config(\"bitwidth\") or \"8\" package:add(\"links\", \"pcre2 \" .. bitwidth) package:add(\"defines\", \"PCRE2_CODE_UNIT_WIDTH \" .. bitwidth) end) end) ``` 在工程项目里面，我们也可以查看特定包的可配置参数和值列表： ```bash $ xmake require info pcre2 The package info of project: require(pcre2): > description: A Perl Compatible Regular Expressions Library > version: 10.31 ... > configs: > bitwidth: > description: Set the code unit width. > values: {\"8\",\"16\",\"32\"} > default: 8 ``` 然后在项目里面，启用这些配置，编译集成带有特定配置的包： ```lua add_requires(\"pcre2\", {configs {bitwidth 16}}) ``` ## package:add_extsources 添加扩展的包源。 支持 `add_extsources` 和 `on_fetch` 两个配置接口，可以更好的配置 xmake 在安装 C/C++ 包的过程中，对系统库的查找过程。 至于具体背景，我们可以举个例子，比如我们在 [xmake repo](https://github.com/xmake io/xmake repo) 仓库新增了一个 `package(\"libusb\")` 的包。 那么用户就可以通过下面的方式，直接集成使用它： ```lua add_requires(\"libusb\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"libusb\") end) ``` 如果用户系统上确实没有安装 libusb，那么 xmake 会自动下载 libusb 库源码，自动编译安装集成，没啥问题。 但如果用户通过 `apt install libusb 1.0` 安装了 libusb 库到系统，那么按理 xmake 应该会自动优先查找用户安装到系统环境的 libusb 包，直接使用，避免额外的下载编译安装。 但是问题来了，xmake 内部通过 `find_package(\"libusb\")` 并没有找打它，这是为什么呢？因为通过 apt 安装的 libusb 包名是 `libusb 1.0`, 而不是 libusb。 我们只能通过 `pkg config cflags libusb 1.0` 才能找到它，但是 xmake 内部的默认 find_package 逻辑并不知道 `libusb 1.0` 的存在，所以找不到。 因此为了更好地适配不同系统环境下，系统库的查找，我们可以通过 `add_extsources(\"pkgconfig::libusb 1.0\")` 去让 xmake 改进查找逻辑，例如： ```lua package(\"libusb\", function() add_extsources(\"pkgconfig::libusb 1.0\") on_install(function (package) ... end) end) ``` 另外，我们也可以通过这个方式，改进查找 homebrew/pacman 等其他包管理器安装的包，例如：`add_extsources(\"pacman::libusb 1.0\")`。 ## package:add_deps 添加包依赖接口，通过配置包之间的依赖关系，我们能够在安装包的同时，自动安装它的所有依赖包。 另外，默认情况下，我们只要配置了依赖关系，cmake/autoconf 就能够自动找到所有依赖包的库和头文件。 当然，如果由于一些特殊原因，导致当前包的 cmake 脚本没能够正常找到依赖包，那么我们也可以通过 `{packagedeps \"xxx\"}` 来强行打入依赖包信息。 例如： ```lua package(\"foo\", function() add_deps(\"cmake\", \"bar\") on_install(function (package) local configs {} import(\"package.tools.cmake\").install(package, configs) end) end) ``` foo 包是使用 CMakeLists.txt 维护的，它在安装过程中，依赖 bar 包，因此，xmake 会优先安装 bar，并且让 cmake.install 在调用 cmake 时候，自动找到 bar 安装后的库。 但是，如果 foo 的 CMakeLists.txt 还是无法自动找到 bar，那么我们可以修改成下面的配置，强制将 bar 的 includedirs/links 等信息通过 flags 的方式，传入 foo。 ```lua package(\"foo\", function() add_deps(\"cmake\", \"bar\") on_install(function (package) local configs {} import(\"package.tools.cmake\").install(package, configs, {packages \"bar\"}) end) end) ``` ## package:add_components 用于支持包的组件化配置，详情见：[#2636](https://github.com/xmake io/xmake/issues/2636)。 通过这个接口，我们可以配置当前包实际可以提供的组件列表。 ```lua package(\"sfml\", function() add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") end) ``` 在用户端，我们可以通过下面的方式来使用包的特定组件。 ```lua add_requires(\"sfml\") target(\"test\", function() add_packages(\"sfml\", {components \"graphics\") end) ``` > 注：除了配置可用的组件列表，我们还需要对每个组件进行详细配置，才能正常使用，因此，它通常和 `on_component` 接口配合使用。 一个关于包组件的配置和使用的完整例子见：[components example](https://github.com/xmake io/xmake/blob/master/tests/projects/package/components/xmake.lua) ## package:set_base 继承包配置。 这是 2.6.4 新加的接口，我们可以通过它去继承一个已有的包的全部配置，然后在此基础上重写部分配置。 这通常在用户自己的项目中，修改 xmake repo 官方仓库的内置包比较有用，比如：修复改 urls，修改版本列表，安装逻辑等等。 例如，修改内置 zlib 包的 url，切到自己的 zlib 源码地址。 ```lua package(\"myzlib\", function() set_base(\"zlib\") set_urls(\"https://github.com/madler/zlib.git\") end) add_requires(\"myzlib\", {system false, alias \"zlib\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"zlib\") end) ``` 我们也可以用来单纯添加一个别名包。 ```lua package(\"onetbb\", function() set_base(\"tbb\") end) ``` 我们可以通过 `add_requires(\"onetbb\")` 集成安装 tbb 包，只是包名不同而已。 ## package:on_load 加载包配置。 这是个可选的接口，如果要更加灵活的动态判断各种平台架构，针对性做设置，可以在这个里面完成，例如： ```lua on_load(function (package) local bitwidth package:config(\"bitwidth\") or \"8\" package:add(\"links\", \"pcre\" .. (bitwidth ~ \"8\" and bitwidth or \"\")) if not package:config(\"shared\") then package:add(\"defines\", \"PCRE_STATIC\") end end) ``` pcre 包需要做一些针对 bitwidth 的判断，才能确定对外输出的链接库名字，还需要针对动态库增加一些 defines 导出，这个时候在 on_load 里面设置，就更加灵活了。 ## package:on_fetch 从系统中查找库。 这是个可选配置，2.5.2 之后，如果不同系统下安装的系统库，仅仅只是包名不同，那么使用 `add_extsources` 改进系统库查找已经足够，简单方便。 但是如果有些安装到系统的包，位置更加复杂，想要找到它们，也许需要一些额外的脚本才能实现，例如：windows 下注册表的访问去查找包等等，这个时候，我们就可以通过 `on_fetch` 完全定制化查找系统库逻辑。 还是以 libusb 为例，我们不用 `add_extsources`，可以使用下面的方式，实现相同的效果，当然，我们可以在里面做更多的事情。 ``` package(\"libusb\") on_fetch(\"linux\", function(package, opt) if opt.system then return find_package(\"pkgconfig::libusb 1.0\") end end) ``` ## package:on_check 检测包是否支持当前平台。 有时候，单纯用 `on_install(\"windows\", \"android\", function () end)` 无法很好的限制包对当前平台的支持力度。 例如，同样都是在 windows 上使用 msvc 编译，但是它仅仅只支持使用 vs2022 工具链。那么我们无法简单的去通过禁用 windows 平台，来限制包的安装。 因为每个用户的编译工具链环境都可能是不同的。这个时候，我们可以通过配置 `on_check` 去做更细致的检测，来判断包是否支持当前的工具链环境。 如果包不被支持，那么它会在包被下载安装前，更早的提示用户，也可以在 xmake repo 的 ci 上，规避掉一些不支持的 ci job 测试。 例如，下面的配置，就可以判断当前的 msvc 是否提供了对应的 vs sdk 版本，如果版本不满足，那么这个包就无法被编译安装，用户会看到更加可读的不支持的错误提示。 ```lua package(\"test\", function() on_check(\"windows\", function (package) import(\"core.tool.toolchain\") import(\"core.base.semver\") local msvc toolchain.load(\"msvc\", {plat package:plat(), arch package:arch()}) if msvc then local vs_sdkver msvc:config(\"vs_sdkver\") assert(vs_sdkver and semver.match(vs_sdkver):gt(\"10.0.19041\"), \"package(cglm): need vs_sdkver > 10.0.19041.0\") end end) end)S ``` 例如，我们也可以用它来判断，当前编译器对 c++20 的支持力度，如果不支持 c++20 才有的 std::input_iterator。那么这个包就没必要继续下载编译安装。 用户会看到 `Require at least C++20.` 的错误，来提示用户取升级自己的编译器。 ```lua package(\"test\", function() on_check(function (package) assert(package:check_cxxsnippets({test [[ #include <cstddef> #include <iterator> struct SimpleInputIterator { using difference_type std::ptrdiff_t; using value_type int; int operator*() const; SimpleInputIterator& operator++(); void operator++(int) { ++*this; } }; static_assert(std::input_iterator<SimpleInputIterator>); ]]}, {configs {languages \"c++20\"}}), \"Require at least C++20.\") end) end) ``` ## package:on_install 安装包。 这个接口主要用于添加安装脚本，前面的字符串参数用于设置支持的平台，像 `on_load`, `on_test` 等其他脚本域也是同样支持的。 完整的过滤语法如下：`platarch1,arch2@hostarch1,arch2` 看上去非常的复杂，其实很简单，其中每个阶段都是可选的，可部分省略，对应：` 编译平台 编译架构 @主机平台 主机架构 ` 如果不设置任何平台过滤条件，那么默认全平台支持，里面的脚本对所有平台生效，例如： ```lua on_install(function (package) TODO end) ``` 如果安装脚本对特定平台生效，那么直接指定对应的编译平台，可以同时指定多个： ```lua on_install(\"linux\", \"macosx\", function (package) TODO end) ``` 如果还要细分到指定架构才能生效，可以这么写： ```lua on_install(\"linuxx86_64\", \"iphoneosarm64\", function (package) TODO end) ``` 如果还要限制执行的主机环境平台和架构，可以在后面追加 `@hostarch`，例如： ```lua on_install(\"mingw@windows\", function (package) TODO end) ``` 意思就是仅对 windows 下编译 mingw 平台生效。 我们也可以不指定比那一平台和架构，仅设置主机平台和架构，这通常用于描述一些跟编译工具相关的依赖包，只能在主机环境运行。 例如，我们编译的包，依赖了 cmake，需要添加 cmake 的包描述，那么里面编译安装环境，只能是主机平台： ```lua on_install(\"@windows\", \"@linux\", \"@macosx\", function (package) TODO end) ``` 其他一些例子： ```lua `@linux` `@linuxx86_64` `@macosx,linux` `android@macosx,linux` `androidarmeabi v7a@macosx,linux` `androidarmeabi v7a@macosx,linuxx86_64` `androidarmeabi v7a@linuxx86_64` ``` 在 2.8.7 中，我们改进了模式匹配支持，新增排除指定平台和架构，例如： ``` !plat!arch@!subhost!subarch ``` ```lua @!linux @!linuxx86_64 @!macosx,!linux !android@macosx,!linux android!armeabi v7a@macosx,!linux androidarmeabi v7a,!iphoneos@macosx,!linuxx86_64 !androidarmeabi v7a@!linux!x86_64 !linux* ``` 同时，还提供了一个内置的 `native` 架构，用于匹配当前平台的本地架构，主要用于指定或者排除交叉编译平台。 ```lua on_install(\"macosxnative\", ...) ``` 上面的配置，如果在 macOS x86_64 的设备上，它仅仅只会匹配 `xmake f a x86_64` 的本地架构编译。 如果是 `xmake f a arm64` 交叉编译，就不会被匹配到。 同理，如果只想匹配交叉编译，可以使用 `macosx!native` 进行取反排除就行了。 2.9.1 版本，我们继续对它做了改进，增加了条件逻辑判断的支持： 例如： ```lua on_install(\"!wasm!arm* and !cross!arm*\", function (package) end) ``` 来表述排除 wasm 和 cross 平台之外的 arm 架构。 并且，它也支持通过 `()` 描述的嵌套逻辑，`a and b or (a and (c or d))`。 我们内置了一些安装常用编译工具脚本，用于针对不同源码依赖的构建工具链，进行方便的构架支持，例如：autoconf, cmake, meson 等， 如果是基于 xmake 的依赖包，那么集成起来就非常简单了，xmake 对其做了非常好的内置集成支持，可以直接对其进行跨平台编译支持，一般情况下只需要： ```lua on_install(function (package) import(\"package.tools.xmake\").install(package) end) ``` 如果要传递一些特有的编译配置参数： ```lua on_install(function (package) import(\"package.tools.xmake\").install(package, {\" xxx y\"}) end) ``` 如果是基于 cmake 的包，集成起来也很简答，通常也只需要设置一些配置参数即可，不过还需要先添加上 cmake 的依赖才行： ```lua add_deps(\"cmake\") on_install(function (package) import(\"package.tools.cmake\").install(package, {\" Dxxx ON\"}) end) ``` 如果是基于 autoconf 的包，集成方式跟 cmake 类似，只是传递的配置参数不同而已，不过通常情况下，unix 系统都内置了 autoconf 系列工具，所以不加相关依赖也没事。 ```lua on_install(function (package) import(\"package.tools.autoconf\").install(package, {\" enable shared no\"}) end) ``` 不过，有些源码包用系统内置的 autoconf 可能不能完全满足，那么可以加上 autoconf 系列依赖，对其进行构建： ```lua add_deps(\"autoconf\", \"automake\", \"libtool\", \"pkg config\") on_install(function (package) import(\"package.tools.autoconf\").install(package, {\" enable shared no\"}) end) ``` 如果是 meson，还需要加上 ninja 的依赖来执行构建才行。 ```lua add_deps(\"meson\", \"ninja\") on_install(function (package) import(\"package.tools.meson\").install(package, {\" Dxxx ON\"}) end) ``` ## package:on_test 测试包。 安装后，需要设置对应的测试脚本，执行一些测试，确保安装包的可靠性，如果测试不通过，则会撤销整个安装包。 ```lua on_test(function (package) assert(package:has_cfuncs(\"inflate\", {includes \"zlib.h\"})) end) ``` 上面的脚本调用包内置的 `has_cfuncs` 接口，检测安装后的包是否存在 zlib.h 头文件，以及库和头文件里面是否存在 `inflate` 这个接口函数。 xmake 会去尝试编译链接来做测试，`has_cfuncs` 用于检测 c 函数，而 `has_cxxfuncs` 则可以检测 c++ 库函数。 而 includes 里面可以设置多个头文件，例如：`includes {\"xxx.h\", \"yyy.h\"}` 我们还可以传递一些自己的编译参数进去检测，例如： ```lua on_test(function (package) assert(package:has_cxxfuncs(\"func1\", {includes \"xxx.h\", configs {defines \"c++14\", cxflags \" Dxxx\"}})) end) ``` 我们也可以通过 `check_csnippets` 和 `check_cxxsnippets` 检测一个代码片段： ```lua on_test(function (package) assert(package:check_cxxsnippets({test [[ #include <boost/algorithm/string.hpp> #include <string> #include <vector> #include <assert.h> using namespace boost::algorithm; using namespace std; static void test() { string str(\"a,b\"); vector<string> strVec; split(strVec, str, is_any_of(\",\")); assert(strVec.size() 2); assert(strVec[0] \"a\"); assert(strVec[1] \"b\"); } ]]}, {configs {languages \"c++14\"}})) end) ``` 如果是可执行包，也可以通过尝试运行来检测： ```lua on_test(function (package) os.run(\"xxx help\") end) ``` 如果运行失败，那么测试不会通过。 ## package:on_download 自定义下载包。 自定义包的下载逻辑，这是 2.6.4 新加的接口，通常用不到，使用 Xmake 的内置下载就足够了。 如果用户自建私有仓库，对包的下载有更复杂的鉴权机制，特殊处理逻辑，那么可以重写内部的下载逻辑来实现。 ```lua on_download(function (package, opt) local url opt.url local sourcedir opt.sourcedir download url to the current directory and extract it's source code to sourcedir ... end) ``` opt 参数里面，可以获取到下载包的目的源码目录 `opt.sourcedir`，我们只需要从 `opt.url` 获取到包地址，下载下来就可以了。 然后，根据需要，添加一些自定义的处理逻辑。另外，自己可以添加下载缓存处理等等。 下面是一个自定义下载 tar.gz 文件，并且实现缓存和源文件目录解压的例子，可以参考下： ```lua package(\"zlib\", function() add_urls(\"https://github.com/madler/zlib/archive/$(version).tar.gz\") add_versions(\"v1.2.10\", \"42cd7b2bdaf1c4570e0877e61f2fdc0bce8019492431d054d3d86925e5058dc5\") on_download(function (package, opt) import(\"net.http\") import(\"utils.archive\") local url opt.url local sourcedir opt.sourcedir local packagefile path.filename(url) local sourcehash package:sourcehash(opt.url_alias) local cached true if not os.isfile(packagefile) or sourcehash ~ hash.sha256(packagefile) then cached false attempt to remove package file first os.tryrm(packagefile) http.download(url, packagefile) check hash if sourcehash and sourcehash ~ hash.sha256(packagefile) then raise(\"unmatched checksum, current hash(%s) ! original hash(%s)\", hash.sha256(packagefile):sub(1, 8), sourcehash:sub(1, 8)) end end extract package file local sourcedir_tmp sourcedir .. \".tmp\" os.rm(sourcedir_tmp) if archive.extract(packagefile, sourcedir_tmp) then os.rm(sourcedir) os.mv(sourcedir_tmp, sourcedir) else if it is not archive file, we need only create empty source file and use package:originfile() os.tryrm(sourcedir) os.mkdir(sourcedir) end save original file path package:originfile_set(path.absolute(packagefile)) end) end) ``` 自定义下载需要用户完全自己控制下载逻辑，会比较复杂，除非必要，不推荐这么做。 如果仅仅只是想增加自定义 http headers 去获取下载授权，可以使用 [设置包下载的 http headers](https://xmake.io/#/zh cn/manual/project_target?id %e8%ae%be%e7%bd%ae%e5%8c%85%e4%b8%8b%e8%bd%bd%e7%9a%84 http headers) ## package:on_component 配置包组件。 这是 2.7.3 新加的接口，用于支持包的组件化配置，详情见：[#2636](https://github.com/xmake io/xmake/issues/2636)。 通过这个接口，我们可以配置当前包，指定组件的详细信息，比如组件的链接，依赖等等。 ### 配置组件链接信息 ```lua package(\"sfml\") add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") on_component(\"graphics\", function (package, component) local e package:config(\"shared\") and \"\"or\" s\" component:add(\"links\", \"sfml graphics\" .. e) if package:is_plat(\"windows\", \"mingw\") and not package:config(\"shared\") then component:add(\"links\", \"freetype\") component:add(\"syslinks\", \"opengl32\", \"gdi32\", \"user32\", \"advapi32\") end end) on_component(\"window\", function (package, component) local e package:config(\"shared\") and \"\"or\" s\" component:add(\"links\", \"sfml window\" .. e) if package:is_plat(\"windows\", \"mingw\") and not package:config(\"shared\") then component:add(\"syslinks\", \"opengl32\", \"gdi32\", \"user32\", \"advapi32\") end end) ... ``` 在用户端，我们可以通过下面的方式来使用包的特定组件。 ```lua add_requires(\"sfml\") target(\"test\") add_packages(\"sfml\", {components \"graphics\") ``` > 注：除了配置组件信息，我们还需要配置可用的组件列表，才能正常使用，因此，它通常和 `add_components` 接口配合使用。 一个关于包组件的配置和使用的完整例子见：[components example](https://github.com/xmake io/xmake/blob/master/tests/projects/package/components/xmake.lua) ### 配置组件的编译信息 我们不仅可以配置每个组件的链接信息，还有 includedirs, defines 等等编译信息，我们也可以对每个组件单独配置。 ```lua package(\"sfml\") on_component(\"graphics\", function (package, component) package:add(\"defines\", \"TEST\") end) ``` ### 配置组件依赖 ```lua package(\"sfml\", function() add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") on_component(\"graphics\", function (package, component) component:add(\"deps\", \"window\", \"system\") end) end) ``` 上面的配置，告诉包，我们的 graphics 组件还会额外依赖 `window` 和 `system` 两个组件。 因此，在用户端，我们对 graphics 的组件使用，可以从 ```lua add_packages(\"sfml\", {components {\"graphics\", \"window\", \"system\"}) ``` 简化为： ```lua add_packages(\"sfml\", {components \"graphics\") ``` 因为，只要我们开启了 graphics 组件，它也会自动启用依赖的 window 和 system 组件。 另外，我们也可以通过 `add_components(\"graphics\", {deps {\"window\", \"system\"}})` 来配置组件依赖关系。 ### 从系统库中查找组件 我们知道，在包配置中，配置 `add_extsources` 可以改进包在系统中的查找，比如从 apt/pacman 等系统包管理器中找库。 当然，我们也可以让每个组件也能通过 `extsources` 配置，去优先从系统库中找到它们。 例如，sfml 包，它在 homebrew 中其实也是组件化的，我们完全可以让包从系统库中，找到对应的每个组件，而不需要每次源码安装它们。 ```bash $ ls l /usr/local/opt/sfml/lib/pkgconfig r r r 1 ruki admin 317 10 19 17:52 sfml all.pc r r r 1 ruki admin 534 10 19 17:52 sfml audio.pc r r r 1 ruki admin 609 10 19 17:52 sfml graphics.pc r r r 1 ruki admin 327 10 19 17:52 sfml network.pc r r r 1 ruki admin 302 10 19 17:52 sfml system.pc r r r 1 ruki admin 562 10 19 17:52 sfml window.pc ``` 我们只需要，对每个组件配置它的 extsources： ```lua if is_plat(\"macosx\") then add_extsources(\"brew::sfml/sfml all\") end on_component(\"graphics\", function (package, component) ... component:add(\"extsources\", \"brew::sfml/sfml graphics\") end) ``` ### 默认的全局组件配置 除了通过指定组件名的方式，配置特定组件，如果我们没有指定组件名，默认就是全局配置所有组件。 ```lua package(\"sfml\", function() on_component(function (package, component) configure all components end) end) ``` 当然，我们也可以通过下面的方式，指定配置 graphics 组件，剩下的组件通过默认的全局配置接口进行配置： ```lua package(\"sfml\", function() add_components(\"graphics\") add_components(\"audio\", \"network\", \"window\") add_components(\"system\") on_component(\"graphics\", function (package, component) configure graphics end) on_component(function (package, component) component audio, network, window, system end) end) ```"}}