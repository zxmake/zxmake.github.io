{"/get_started/zh/tutorial/quick-start.html":{"title":"快速开始","content":"# 快速开始 ## 创建工程 创建一个名叫 `hello` 的 `c` 控制台工程： ```bash $ xmake create language c project ./hello # 或 $ xmake create l c P ./hello ``` 执行完后，将会生成一个简单工程结构： ``` ./hello/ ├── src │ └── main.c └── xmake.lua ``` 其中 `xmake.lua` 是工程描述文件，内容非常简单，告诉 xmake 添加 `src` 目录下的所有 `.c` 源文件： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"hello\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 目前支持的语言如下： * c/c++ * objc/c++ * cuda * asm * swift * dlang * golang * rust > 如果你想了解更多参数选项，请运行: `xmake create help`。 ## 构建工程 ```bash $ cd hello $ xmake ``` ## 运行程序 ```bash $ xmake run hello ``` ## 调试程序 首先你需要切换到 debug 模式去重新编译程序。 ```bash $ xmake config m debug $ xmake ``` 然后执行下面的命令去开始调试： ```bash $ xmake run d hello ``` xmake 将会使用调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。 ```bash (gdb) b main Breakpoint 1 at 0x115c: file src/main.c, line 4. (gdb) r Starting program: /tmp/test xmake/hello/build/linux/x86_64/debug/hello [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64 linux gnu/libthread_db.so.1\". Breakpoint 1, main (argc 1, argv 0x7fffffffdac8) at src/main.c:4 4 printf(\"hello world!\\n\"); (gdb) ``` 如果想要使用指定的调试器： ```bash $ xmake f debugger gdb $ xmake run d hello ``` > 你也可以使用简写的命令行选项，例如: `xmake r` 或者 `xmake run`。"},"/get_started/zh/tutorial/build-policies.html":{"title":"构建策略","content":"# 构建策略 xmake 有很多的默认行为，比如：自动检测和映射 flags、跨 target 并行构建等，虽然提供了一定的智能化处理，但众口难调，不一定满足所有的用户的使用习惯和需求。 因此 xmake 提供默认构建策略的修改设置，开放给用户一定程度上的可配置性。 它主要通过 [set_policy](https://xmake.io/#/zh cn/manual/project_target?id targetset_policy) 接口来配置。 我们通常可以用它来配置修改 target，package 以及工程整体的一些行为策略。 使用方式如下： ```lua set_policy(\"check.auto_ignore_flags\", false) ``` 只需要在项目根域设置这个配置，就可以禁用 flags 的自动检测和忽略机制，另外 `set_policy` 也可以针对某个特定的 target 局部生效。 ```lua target(\"test\", function() set_policy(\"check.auto_ignore_flags\", false) end) ``` > 另外，如果设置的策略名是无效的，xmake 也会有警告提示。 如果要获取当前 xmake 支持的所有策略配置列表和描述，可以执行下面的命令： ```bash $ xmake l core.project.policy.policies { \"check.auto_map_flags\" { type \"boolean\", description \"Enable map gcc flags to the current compiler and linker automatically.\", default true }, \"build.across_targets_in_parallel\" { type \"boolean\", description \"Enable compile the source files for each target in parallel.\", default true }, \"check.auto_ignore_flags\" { type \"boolean\", description \"Enable check and ignore unsupported flags automatically.\", default true } } ``` 我们也可以通过命令行的方式去设置修改内部的策略: ```bash $ xmake f policies package.fetch_only ``` 默认设置策略名，就是启用状态，当然我们也可以指定设置其他值，禁用它。 ```bash $ xmake f policies package.precompiled:n ``` 或者同时配置多个策略值，用逗号分割。 ```bash $ xmake f policies package.precompiled:n,package.install_only ``` ### check.auto_ignore_flags xmake 默认会对所有 `add_cxflags`, `add_ldflags` 接口设置的原始 flags 进行自动检测，如果检测当前编译器和链接器不支持它们，就会自动忽略。 这通常是很有用的，像一些可选的编译 flags，即使不支持也能正常编译，但是强行设置上去，其他用户在编译的时候，有可能会因为编译器的支持力度不同，出现一定程度的编译失败。 但由于自动检测并不保证100%可靠，有时候会有一定程度的误判，所以某些用户并不喜欢这个设定（尤其是针对交叉编译工具链，更容易出现失败）。 目前如果检测失败，会有警告提示避免用户莫名躺坑，例如： ```bash warning: add_ldflags(\" static\") is ignored, please pass `{force true}` or call `set_policy(\"check.auto_ignore_flags\", false)` if you want to set it. ``` 根据提示，我们可以自己分析判断，是否需要强制设置这个 flags，一种就是通过： ```lua add_ldflags(\" static\", {force true}) ``` 来显示的强制设置上它，跳过自动检测，这对于偶尔的 flags 失败，是很有效快捷的处理方式，但是对于交叉编译时候，一堆的 flags 设置检测不过的情况下，每个都设置 force 太过于繁琐。 这个时候，我们就可以通过 `set_policy` 来对某个 target 或者整个 project 直接禁用默认的自动检测行为： ```lua set_policy(\"check.auto_ignore_flags\", false) target(\"test\", function() add_ldflags(\" static\") end) ``` 然后我们就可以随意设置各种原始 flags，xmake 不会去自动检测和忽略他们了。 ### check.auto_map_flags 这是 xmake 的另外一个对 flags 的智能分析处理，通常像 `add_links`, `add_defines` 这种 xmake 内置的 api 去设置的配置，是具有跨平台特性的，不同编译器平台会自动处理成对应的原始 flags。 但是，有些情况，用户还是需要自己通过 `add_cxflags`, `add_ldflags` 设置原始的编译链接 flags，这些 flags 并不能很好的跨编译器。 就拿 ` O0` 的编译优化 flags 来说，虽然有 `set_optimize` 来实现跨编译器配置，但如果用户直接设置 `add_cxflags(\" O0\")` 呢？gcc/clang 下可以正常处理，但是 msvc 下就不支持了。 也许我们能通过 `if is_plat() then` 来分平台处理，但很繁琐，因此 xmake 内置了 flags 的自动映射功能。 基于 gcc flags 的普及性，xmake 采用 gcc 的 flags 命名规范，对其根据不同的编译实现自动映射，例如： ```lua add_cxflags(\" O0\") ``` 这一行设置，在 gcc/clang 下还是 ` O0`，但如果当前是 msvc 编译器，那边会自动映射为 msvc 对应 ` Od` 编译选项来禁用优化。 整个过程，用户是完全无感知的，直接执行 xmake 就可以跨编译器完成编译。 > 当然，目前的自动映射实现还不是很成熟，没有 100% 覆盖所有 gcc 的 flags，所以还是有不少 flags 是没去映射的。 也有部分用户并不喜欢这种自动映射行为，那么我们可以通过下面的设置完全禁用这个默认的行为： ```bash set_policy(\"check.auto_map_flags\", false) ``` ### build.across_targets_in_parallel 这个策略也是默认开启的，主要用于跨 target 间执行并行构建，v2.3.3 之前的版本，并行构建只能针对单个 target 内部的所有源文件， 跨 target 的编译，必须要要等先前的 target 完全 link 成功，才能执行下一个 target 的编译，这在一定程度上会影响编译速度。 然而每个 target 的源文件是可以完全并行化处理的，最终在一起执行 link 过程，v2.3.3 之后的版本通过这个优化，构建速度提升了30%。 当然，如果有些特殊的 target 里面的构建源文件要依赖先前的 target（尤其是一些自定义 rules 的情况，虽然很少遇到），我们也可以通过下面的设置禁用这个优化行为： ```bash set_policy(\"build.across_targets_in_parallel\", false) ``` ### build.fence 由于配置 `set_policy(\"build.across_targets_in_parallel\", false)` 存在局限性，它会限制父 target 和它的所有依赖的子 target 之间的并行度，影响的范围有点大。 而我们做 codegen 时候，有时候仅仅只是想对其中某个依赖的 target 限制并行度，作为 codegen 程序，提前让它完成编译。 这个时候，`build.across_targets_in_parallel` 就无法精细控制了，编译速度也无法达到最优。 因此，我们新增了 `build.fence` 策略，它可以仅仅只针对特定的子 target 限制并行编译链接。 相关的背景细节，可以看下：[#5003](https://github.com/xmake io/xmake/issues/5003) 例如： ```lua target(\"autogen\", function() set_default(false) set_kind(\"binary\") set_plat(os.host()) set_arch(os.arch()) add_files(\"src/autogen.cpp\") set_languages(\"c++11\") set_policy(\"build.fence\", true) end) target(\"test\", function() set_kind(\"binary\") add_deps(\"autogen\") add_rules(\"autogen\") add_files(\"src/main.cpp\") add_files(\"src/*.in\") end) ``` 其中 autogen 目标程序需要在 test 程序的源码被编译前，就要完成编译链接，因为 test 目标需要运行 autogen 程序，去动态生成一些源码参与编译。 而针对 autogen 配置 `set_policy(\"build.fence\", true)` 就可以实现这个目的。 ### build.merge_archive 如果设置了这个策略，那么使用 `add_deps()` 依赖的目标库不再作为链接存在，而是直接把它们合并到父目标库中去。 例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"add\", function() set_kind(\"static\") add_files(\"src/add.c\") add_files(\"src/subdir/add.c\") end) target(\"sub\", function() set_kind(\"static\") add_files(\"src/sub.c\") add_files(\"src/subdir/sub.c\") end) target(\"mul\", function() set_kind(\"static\") add_deps(\"add\", \"sub\") add_files(\"src/mul.c\") set_policy(\"build.merge_archive\", true) end) target(\"test\", function() add_deps(\"mul\") add_files(\"src/main.c\") end) ``` libmul.a 静态库会自动合并 libadd.a 和 libsub.a 两个子依赖的静态库。 ### build.ccache Xmake 默认是开启内置的编译缓存的，通过设置这个策略，可以显式禁用缓存。 ```lua set_policy(\"build.ccache\", false) ``` 当然，我们也可以命令行去禁用它。 ```bash $ xmake f ccache n ``` 或者 ```bash $ xmake f policies build.ccache:n ``` ### build.warning 默认编译通常不会实时回显警告输出，我们通常需要使用 `xmake w` 开启，或者通过 `xmake g build_warning y` 来全局开启它。 现在，我们也可以在 xmake.lua 配置中去默认启用警告回显输出。 ```lua set_policy(\"build.warning\", true) set_warnings(\"all\", \"extra\") ``` 这个时候，即使我们执行 `xmake` 命令，也能直接回显警告输出。 ### build.optimization.lto xmake 改进了对 LTO 链接时优化的支持，对 gcc/clang/msvc 等不同平台下都进行了适配，只需要启用这个策略，就能对特定 target 开启 LTO。 ```lua set_policy(\"build.optimization.lto\", true) ``` 我们也可以通过命令行选项快速开启。 ```bash $ xmake f policies build.optimization.lto ``` ### build.cuda.devlink 可以通过这个配置，显示开启对特定目标的设备链接。 这通常用于 Cuda 项目的构建，以及非 Cuda binary/shared 依赖 Cuda static 目标的情况，这个时候，Cuda static 目标就需要显示配置这个，开启设备链接。 ```lua target(\"test\", function() set_kind(\"static\") set_policy(\"build.cuda.devlink\", true) end) ``` 而默认 Cuda binary/shared 是开启 devlink 的，我们也可以通过策略显示禁用它。 关于这个的详细背景说明，见：[#1976](https://github.com/xmake io/xmake/issues/1976) ### build.sanitizer.address Address Sanitizer（ASan）是一个快速的内存错误检测工具，由编译器内置支持，通常我们需要在编译和链接的 flags 中同时配置 ` fsanitize address` 才能正确开启。 而我们可以通过开启这个策略，就可以快速全局启用它，这会使得编译出来的程序，直接支持 ASan 检测。 例如，我们可以通过命令行的方式去启用： ```bash $ xmake f policies build.sanitizer.address ``` 也可以通过接口配置去全局启用： ```lua set_policy(\"build.sanitizer.address\", true) ``` 当然，我们也可以单独对某个特定的 target 去配置开启。 另外，如果全局配置它，我们就可以同时对所有依赖包也生效。 ```lua set_policy(\"build.sanitizer.address\", true) add_requires(\"zlib\") add_requires(\"libpng\") ``` 它等价于，对每个包依次设置 asan 配置。 ```lua add_requires(\"zlib\", {configs {asan true}}) add_requires(\"libpng\", {configs {asan true}}) ``` > `add_rules(\"mode.asan\", \"mode.tsan\", \"mode.ubsan\", \"mode.msan\")` 将被废弃，尽可能使用这些新的策略，因为这些构建模式无法同步对依赖包生效。 另外，我们也可以同时生效多个 sanitizer 检测，例如： ```lua set_policy(\"build.sanitizer.address\", true) set_policy(\"build.sanitizer.undefined\", true) ``` 或者 ``` $ xmake f policies build.sanitizer.address,build.sanitizer.undefined ``` ### build.sanitizer.thread 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测线程安全问题。 ### build.sanitizer.memory 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测内存问题。 ### build.sanitizer.leak 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测内存泄漏问题。 ### build.sanitizer.undefined 与 [build.sanitizer.address](https://xmake.io/#/zh cn/guide/build_policies?id buildsanitizeraddress) 类似，用于检测 undefined 问题。 ### build.always_update_configfiles 这个策略用于对 `add_configfiles` 配置文件的自动生成行为。默认情况下，xmake 仅仅只会在首次 `xmake config` 时候，或者 xmake.lua 配置有改动的是否，才会触发 configfiles 的重新生成。 之后的每次构建，只要配置没有变化，就不会重新生成 configfiles。 但是，如果我们的 configfiles 中有使用 GIT_COMMIT 等变量，想要每次构建时候，总是重新生成最新的配置，那么可以配置它。 具体使用背景，可以看下：[#4747](https://github.com/xmake io/xmake/issues/4747) ### build.intermediate_directory 配置启用或禁用构建的内部子目录。 默认情况下，执行 `xmake` 编译项目会自动在 build 目录下根据平台。架构，编译模式生成子目录，分别存储对象文件，目标文件。例如： ```bash build/ └── macosx └── x86_64 └── release └─test ``` 如果配置禁用此策略，那么生成的产物将会直接生成到 build 根目录下。变成： ```bash build/ └─ test ``` ### build.rpath 配置启用或者禁用构建时的 target rpath 设置。 默认情况下，如果 `target(foo)` 依赖动态库 bar，那么生成的 foo 可执行文件会自动加上 bar 的 rpath，这能保证用户直接执行 foo 程序，也能正确找到 bar。 如果你想禁用这个行为，可以显式配置禁用它。 ### install.rpath 尽管构建后的程序，会被设置 rpath，但是当 `xmake install` 安装后，它构建时候的 rpath 就不一定完全适用了，因此 xmake 会自动修改调整 rpath，使得安装后的程序，同样可以找到它的依赖库。 不过前提是，用户自己先得通过 `add_rpathdirs(\"/xxx\", {installonly true})` 去配置独立的安装 rpath。 而我们也可以通过这个 policy 去禁用默认的安装阶段 rpath 设置行为。 ### run.autobuild 这个策略用于调整 `xmake run` 的行为，默认情况下，执行 `xmake run` 并不会自动构建目标程序，如果程序还没被编译，就是提示用户手动构建一下。 而开启这个策略，我们就可以在运行程序前，先自动构建对应的目标程序。 ```bash $ xmake f policies run.autobuild $ xmake run ``` 如果想要全局生效这个策略，可以全局开启它。 ```bash $ xmake g policies run.autobuild ``` ### preprocessor.linemarkers 通常用户编译缓存中，预处理器的生成策略，默认开启，如果配置关闭这个策略，那么缓存生成的预处理文件内容将不包含 linemarkers 信息，这会极大减少预处理文件大小。 也会提升缓存的处理效率，但是缺点就是会丢失源码行信息，如果遇到编译错误，将无法看到准确的出错代码行。 ### preprocessor.gcc.directives_only 这也是用于预处理器的策略，默认开启，这会提升 gcc 下编译缓存预处理的效率，但是如果源文件中包含 `__DATE__`, `__TIME__` 等宏，就会导致缓存出现不一致。 因此，可以根据自身工程代码，按需关闭此策略，确保生成的结果一致。 ### package.requires_lock 可用于开启 `add_requires()` 引入的依赖包的版本锁定。 具体看下：[依赖包的锁定和升级](https://xmake.io/#/zh cn/package/remote_package?id %e4%be%9d%e8%b5%96%e5%8c%85%e7%9a%84%e9%94%81%e5%ae%9a%e5%92%8c%e5%8d%87%e7%ba%a7) ### package.fetch_only 如果开启这个策略，那么所有的依赖包仅仅只会从系统获取，不会从远程下载安装。 ### package.install_only 如果开启这个策略，那么所有的依赖包仅仅只会走远程下载安装，不会从系统查找获取。 ### package.librarydeps.strict_compatibility 默认禁用，如果启用它，那么当前包和它的所有库依赖包之间会保持严格的兼容性，任何依赖包的版本更新，都会强制触发当前包的重新编译安装。 以确保所有的包都是二进制兼容的，不会因为某个依赖包接口改动，导致和其他已被安装的其他包一起链接时候，发生链接和运行错误。 ```lua package(\"foo\") add_deps(\"bar\", \"zoo\") set_policy(\"package.librarydeps.strict_compatibility\", true) ``` 例如，如果 bar 或者 zoo 的版本有更新，那么 foo 也会重新编译安装。 ### package.strict_compatibility 默认禁用，如果启用它，那么当前包和其他所有依赖它的包之间会保持严格的兼容性，这个包的版本更新，都会强制触发其他父包的重新编译安装。 以确保所有的包都是二进制兼容的，不会因为某个依赖包接口改动，导致和其他已被安装的其他包一起链接时候，发生链接和运行错误。 ```lua package(\"foo\", function() set_policy(\"package.strict_compatibility\", true) end) package(\"bar\", function() add_deps(\"foo\") end) package(\"zoo\", function() add_deps(\"foo\") end) ``` 例如，如果 foo 的版本有更新，那么 bar 和 zoo 都会被强制重新编译安装。 ### package.install_always 每次运行 `xmake f c` 重新配置的时候，总是会重新安装包，这对于本地第三方源码包集成时候比较有用。 因为，用户可能随时需要修改第三方源码，然后重新编译集成它们。 之前只能通过每次修改包版本号，来触发重新编译，但是有了这个策略，就能每次都会触发重编。 ```lua add_rules(\"mode.debug\", \"mode.release\") package(\"foo\", function() add_deps(\"cmake\") set_sourcedir(path.join(os.scriptdir(), \"foo\")) set_policy(\"package.install_always\", true) on_install(function (package) local configs {} table.insert(configs, \" DCMAKE_BUILD_TYPE \" .. (package:debug() and \"Debug\" or \"Release\")) table.insert(configs, \" DBUILD_SHARED_LIBS \" .. (package:config(\"shared\") and \"ON\" or \"OFF\")) import(\"package.tools.cmake\").install(package, configs) end) on_test(function (package) assert(package:has_cfuncs(\"add\", {includes \"foo.h\"})) end) end) add_requires(\"foo\") target(\"demo\", function() set_kind(\"binary\") add_files(\"src/main.c\") add_packages(\"foo\") end) ``` ### package.download.http_headers 设置包下载的 http headers 如果有些包的 url 下载，需要设置特定 http headers，才能通过下载，可以通过这个策略来指定。 ```lua package(\"xxx\") set_policy(\"package.download.http_headers\", \"TEST1: foo\", \"TEST2: bar\") ``` 我们也可以设置指定的 urls 的 http headers： ```lua add_urls(\"https://github.com/madler/zlib/archive/$(version).tar.gz\", { http_headers {\"TEST1: foo\", \"TEST2: bar\"} }) ```"},"/get_started/zh/tutorial/project-examples.html":{"title":"工程例子","content":"# 工程例子 以下是一些常用的工程例子，更多的 examples 可以到 [project examples](https://github.com/TOMO CAT/xmake/tree/master/tests/projects) 中查看。 我们也可以通过 `xmake create` 命令创建各种常用的空工程来快速开始，具体对于这个命令的介绍以及支持的工程模板可以敲下面的命令查看： ```bash xmake create help ``` ## 可执行程序 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") end) ``` 完整例子请执行下面的命令来创建： ```bash xmake create l c t console test ``` ## 静态库程序 ```lua target(\"library\", function() set_kind(\"static\") add_files(\"src/library/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") add_deps(\"library\") end) ``` 通过 `add_deps` 将一个静态库自动链接到 test 可执行程序。 完整例子请执行下面的命令来创建： ```bash xmake create l c t static test ``` ## 动态库程序 ```lua target(\"library\", function() set_kind(\"shared\") add_files(\"src/library/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*c\") add_deps(\"library\") end) ``` 通过 `add_deps` 将一个动态库自动链接到 test 可执行程序。 完整例子请执行下面的命令来创建： ```bash xmake create l c t shared test ``` ## Wasm 程序 所有 c/c++ 程序，我们都可以编译成 Wasm，无需任何 xmake.lua 配置改动，只需要切换到 wasm 编译平台进行编译。 ```bash $ xmake f p wasm $ xmake ``` 详细的 Wasm 编译配置见：[Wasm 配置](/zh cn/guide/configuration?id wasm) 另外，在编译带有 ` preload file assets/xxx.md` 设置的文件时候，我们也可以通过配置，简化对它的设置。 ```lua target(\"test5\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_values(\"wasm.preloadfiles\", \"src/xxx.md\") add_values(\"wasm.preloadfiles\", \"src/xxx2.md\") end) ``` ## Qt 程序 创建一个空工程： ```bash $ xmake create t qt.console test $ xmake create t qt.static test $ xmake create t qt.shared test $ xmake create t qt.quickapp test $ xmake create t qt.widgetapp test ``` 更多工程模板见：`xmake create help`。 默认会自动探测 Qt 环境，当然也可以指定 Qt SDK 环境目录： ```bash $ xmake f qt ~/Qt/Qt5.9.1 ``` 上述指定的 MingW SDK 用的是 Qt 下 Tools 目录自带的环境，当然如果有其他第三方 MingW 编译环境，也可以手动指定, 具体可以参考：[MingW 编译配置](/zh cn/guide/configuration?id mingw)。 更多详情可以参考：[#160](https://github.com/xmake io/xmake/issues/160) 另外，当前 xmake 也支持 Qt/Wasm，详情见：[Wasm 配置](/zh cn/guide/configuration?id wasm) ```bash $ xmake f p wasm ``` ### 静态库程序 ```lua target(\"qt_static_library\", function() add_rules(\"qt.static\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ### 动态库程序 ```lua target(\"qt_shared_library\", function() add_rules(\"qt.shared\") add_files(\"src/*.cpp\") add_frameworks(\"QtNetwork\", \"QtGui\") end) ``` ### 控制台程序 ```lua target(\"qt_console\", function() add_rules(\"qt.console\") add_files(\"src/*.cpp\") end) ``` ### Quick 应用程序 ```lua target(\"qt_quickapp\", function() add_rules(\"qt.quickapp\") add_files(\"src/*.cpp\") add_files(\"src/qml.qrc\") end) ``` > 如果使用的自己编译的 static 版本 QT SDK，那么需要切换到 `add_rules(\"qt.quickapp_static\")` 静态规则才行，因为链接的库是不同的，需要做静态链接。 ### Quick Plugin 程序 完整例子见：[quickplugin example](https://github.com/xmake io/xmake/tree/master/tests/projects/qt/quickplugin) ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"demo\", function() add_rules(\"qt.qmlplugin\") add_headerfiles(\"src/*.h\") add_files(\"src/*.cpp\") set_values(\"qt.qmlplugin.import_name\", \"My.Plugin\") end) ``` ### Widgets 应用程序 ```lua target(\"qt_widgetapp\", function() add_rules(\"qt.widgetapp\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add_files(\"src/mainwindow.h\") 添加带有 Q_OBJECT 的meta头文件 end) ``` ### Android 应用程序 可以直接切到 android 平台编译 Quick/Widgets 应用程序，生成 apk 包，并且可通过 `xmake install` 命令安装到设备： ```bash $ xmake create t quickapp_qt l c++ appdemo $ cd appdemo $ xmake f p android ndk ~/Downloads/android ndk r19c/ android_sdk ~/Library/Android/sdk/ c $ xmake [ 0%]: compiling.qt.qrc src/qml.qrc [ 50%]: cache compiling.release src/main.cpp [100%]: linking.release libappdemo.so [100%]: generating.qt.app appdemo.apk ``` 然后安装到设备： ```bash $ xmake install installing appdemo ... installing build/android/release/appdemo.apk .. Success install ok!👌 ``` ### 目前支持的 Qt SDK #### 来自 Qt 官方提供的 SDK 安装包 在 macos 上通常能自动探测到，但是也可以手动指定 Qt SDK 路径。 ```bash $ xmake f qt [qt sdk path] ``` #### 来自 Ubuntu Apt 安装包 使用 apt 安装完 Qt SDK，xmake 也能够自动检测到。 ```bash $ sudo apt install y qtcreator qtbase5 dev $ xmake ``` #### 来自 msys2/pacman 的 Qt Mingw 安装包 xmake 也支持从 pacman 安装的 Qt Mingw SDK ```bash $ pacman S mingw w64 x86_64 qt5 mingw w64 x86_64 qt creator $ xmake ``` #### 来自 aqtinstall 脚本的 Qt SDK 包 [aqtinstall](https://github.com/miurahr/aqtinstall) 安装的 Qt SDK 是完全基于官方 SDK 结构的，所以 xmake 也完全支持。 但是，通常需要自己指定 SDK 路径。 ```bash $ xmake f qt [Qt SDK] ``` #### 跨平台 Qt 交叉编译 对于跨平台 Qt 开发，xmake 支持为主机工具和目标平台使用单独的 SDK。这在为不同于开发机器的平台构建 Qt 应用程序时特别有用。 ` qt_host` 选项允许您指定与构建机器兼容的 Qt 工具的位置，而 ` qt` 指向目标平台的 SDK： ```bash $ xmake f qt [target Qt sdk] qt_host [host Qt sdk] ``` **重要注意事项**： * 确保主机和目标 Qt 版本匹配，否则可能会导致构建问题。 * 本机部署工具（如 `windeployqt` 和 `macdeployqt`）必须在各自的平台上运行，因此跨平台任务（如 `xmake install`）可能会失败。 #### 来自 xmake repo 仓库的 Qt 包 xmake 现在官方提供了 Qt5 SDK 的各种模块包，可以自动集成使用，无需任何手动安装。 只需要配置集成包就行了，xmake 会自动处理 Qt 的安装集成，并且自动编译项目。 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"qt5widgets\") target(\"test\", function() add_rules(\"qt.widgetapp\") add_packages(\"qt5widgets\") add_headerfiles(\"src/*.h\") add_files(\"src/*.cpp\") add_files(\"src/mainwindow.ui\") add files with Q_OBJECT meta (only for qt.moc) add_files(\"src/mainwindow.h\") end) ``` 除了 `qt5widgets` 包，仓库还提供了 `qt5gui`, `qt5network` 等包，可以使用。 配置完，只需要执行： ```bash $ xmake ``` #### 来自 vcpkg/conan 的 Qt 包 暂时还没时间支持，请尽量使用上面的方式集成 Qt SDK。 ## umdf 驱动程序 ```lua target(\"echo\", function() add_rules(\"wdk.driver\", \"wdk.env.umdf\") add_files(\"driver/*.c\") add_files(\"driver/*.inx\") add_includedirs(\"exe\") end) target(\"app\", function() add_rules(\"wdk.binary\", \"wdk.env.umdf\") add_files(\"exe/*.cpp\") end) ``` ### wdm 驱动程序 ```lua target(\"kcs\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") add_values(\"wdk.man.flags\", \" prefix Kcs\") add_values(\"wdk.man.resource\", \"kcsCounters.rc\") add_values(\"wdk.man.header\", \"kcsCounters.h\") add_values(\"wdk.man.counter_header\", \"kcsCounters_counters.h\") add_files(\"*.c\", \"*.rc\", \"*.man\") end) ``` ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") add_values(\"wdk.tracewpp.flags\", \" func:TracePrint((LEVEL,FLAGS,MSG,...))\") add_files(\"*.c\", {rule \"wdk.tracewpp\"}) add_files(\"*.rc\", \"*.inf\") add_files(\"*.mofmsdsm.mof\") add_files(\"msdsm.mof\", {values {wdk_mof_header \"msdsmwmi.h\"}}) end) ``` ### 生成驱动包 可以通过以下命令生成 .cab 驱动包： ```bash $ xmake [ppackage] $ xmake [ppackage] o outputdir ``` 输出的目录结构如下： ``` drivers sampledsm debug/x86/sampledsm.cab release/x64/sampledsm.cab debug/x86/sampledsm.cab release/x64/sampledsm.cab ``` ### 驱动签名 默认编译禁用签名，可以通过 `set_values(\"wdk.sign.mode\", ...)` 设置签名模式来启用签名。 #### 测试签名 测试签名一般本机调试时候用，可以使用 xmake 自带的 test 证书来进行签名，例如： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") end) ``` 不过这种情况下，需要用户手动在管理员模式下，执行一遍：`$xmake l utils.wdk.testcert install`，来生成和注册 test 证书到本机环境。 这个只需要执行一次就行了，后续就可以正常编译和签名了。 当然也可以使用本机已有的有效证书去签名。 从 sha1 来选择合适的证书进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") set_values(\"wdk.sign.thumbprint\", \"032122545DCAA6167B1ADBE5F7FDF07AE2234AAA\") end) ``` 从 store/company 来选择合适的证书进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"test\") set_values(\"wdk.sign.store\", \"PrivateCertStore\") set_values(\"wdk.sign.company\", \"tboox.org(test)\") end) ``` #### 正式签名 通过指定对应的正式签名证书文件进行签名： ```lua target(\"msdsm\", function() add_rules(\"wdk.driver\", \"wdk.env.wdm\") set_values(\"wdk.sign.mode\", \"release\") set_values(\"wdk.sign.company\", \"xxxx\") set_values(\"wdk.sign.certfile\", path.join(os.projectdir(), \"xxxx.cer\")) end) ``` ### 生成低版本驱动 如果想在 wdk10 环境编译生成 win7, win8 等低版本系统支持的驱动，可以通过设置 `wdk.env.winver` 来切换系统版本： ```lua set_values(\"wdk.env.winver\", \"win10\") set_values(\"wdk.env.winver\", \"win10_rs3\") set_values(\"wdk.env.winver\", \"win81\") set_values(\"wdk.env.winver\", \"win8\") set_values(\"wdk.env.winver\", \"win7\") set_values(\"wdk.env.winver\", \"win7_sp1\") set_values(\"wdk.env.winver\", \"win7_sp2\") set_values(\"wdk.env.winver\", \"win7_sp3\") ``` 我们也可以手动指定编译的目标程序支持的 windows 版本： ```bash $ xmake f wdk_winver [win10_rs3win8win7win7_sp1] $ xmake ``` ## iOS/MacOS 程序 ### App 应用程序 用于生成 `*.app/*.ipa` 应用程序，同时支持 iOS/MacOS。 ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") end) ``` > 可以支持直接添加 `*.metal` 文件，xmake 会自动生成 default.metallib 提供给应用程序加载使用。 #### 创建工程 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.macapp l objc test $ xmake create t xcode.iosapp l objc test ``` #### 编译 ```bash $ xmake f p [iphoneosmacosx] $ xmake [ 18%]: compiling.xcode.release src/Assets.xcassets [ 27%]: processing.xcode.release src/Info.plist [ 72%]: compiling.xcode.release src/Base.lproj/Main.storyboard [ 81%]: compiling.xcode.release src/Base.lproj/LaunchScreen.storyboard [ 45%]: cache compiling.release src/ViewController.m [ 63%]: cache compiling.release src/AppDelegate.m [ 54%]: cache compiling.release src/SceneDelegate.m [ 36%]: cache compiling.release src/main.m [ 90%]: linking.release test [100%]: generating.xcode.release test.app [100%]: build ok! ``` #### 配置签名 对于 iOS 程序，默认会检测系统先用可用签名来签名 app，当然我们也可以手动指定其他签名证书： ```bash $ xmake f p iphoneos xcode_codesign_identity 'Apple Development: xxx@gmail.com (T3NA4MRVPU)' xcode_mobile_provision 'iOS Team Provisioning Profile: org.tboox.test xcode_bundle_identifier org.tboox.test' $ xmake ``` 如果每次这么配置签名觉得繁琐的话，可以设置到 `xmake global` 全局配置中，也可以在 xmake.lua 中对每个 target 单独设置： ```lua target(\"test\", function() add_rules(\"xcode.application\") add_files(\"src/*.m\", \"src/**.storyboard\", \"src/*.xcassets\") add_files(\"src/Info.plist\") add_values(\"xcode.bundle_identifier\", \"org.tboox.test\") add_values(\"xcode.codesign_identity\", \"Apple Development: xxx@gmail.com (T3NA4MRVPU)\") add_values(\"xcode.mobile_provision\", \"iOS Team Provisioning Profile: org.tboox.test\") end) ``` 那如何知道我们需要的签名配置呢？一种就是在 xcode 里面查看，另外 xmake 也提供了一些辅助工具可以 dump 出当前可用的所有签名配置： ```bash $ xmake l private.tools.codesign.dump codesign identities { \"Apple Development: waruqi@gmail.com (T3NA4MRVPU)\" \"AF73C231A0C35335B72761BD3759694739D34EB1\" } mobile provisions { \"iOS Team Provisioning Profile: org.xmake.test\" \"<?xml version \"1.0\" encoding \"UTF 8\"?> <!DOCTYPE plist PUBLIC \" //Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList 1.0.dtd\"> <plist version \"1.0\"> <dict> \t<key>AppIDName</key> \t<string>XC org xmake test5</string> \t<key>ApplicationIdentifierPrefix</key> \t<array> \t<string>43AAQM58X3</string> ... ``` 我们也提供了其他辅助工具来对已有的 ipa/app 程序进行重签名，例如： ```bash $ xmake l utils.ipa.resign test.ipatest.app [codesign_identity] [mobile_provision] [bundle_identifier] ``` 其中，后面的签名参数都是可选的，如果没设置，那么默认会探测使用一个有效的签名： ```bash $ xmake l utils.ipa.resign test.ipa $ xmake l utils.ipa.resign test.app \"Apple Development: cat@gmail.com (T3NA4MRVPU)\" $ xmake l utils.ipa.resign test.ipa \"Apple Development: cat@gmail.com (T3NA4MRVPU)\" iOS Team Provisioning Profile: org.xmake.test\" org.xmake.test ``` #### 运行应用程序 目前仅支持运行macos程序： ```bash $ xmake run ``` 效果如下： ![](/assets/img/guide/macapp.png) #### 生成程序包 如果是 iOS 程序会生成 ipa 安装包，如果是 macos 会生成 dmg （dmg 包生成暂时还在开发中）。 ```bash $ xmake package output: build/iphoneos/release/arm64/test.ipa package ok! ``` 我们也提供了辅助工具，来对指定 app 程序进行打包： ```bash $ xmake l utils.ipa.package test.app output.ipa [iconfile.png] ``` #### 安装 如果是 iOS 程序会安装 ipa 到设备，如果是 macos 会安装 app 到 /Applications 目录。 ```bash $ xmake install ``` 我们也提供了辅助工具，来对指定ipa/app程序安装到设备： ```bash $ xmake l utils.ipa.install test.app $ xmake l utils.ipa.install test.ipa ``` #### 卸载 > 目前仅支持 macos 程序卸载 ```bash $ xmake uninstall ``` ### Framework 库程序 ```lua target(\"test\", function() add_rules(\"xcode.framework\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.framework l objc test ``` 另外，xmake 还提供了带有 framework 库使用的完整 iosapp/macapp 空工程模板，可以完整体验 framework 的编译，依赖使用以及集成到 app 应用程序中。 同时，如果我们开启了模拟器，xmake 可以支持直接 `xmake install` 和 `xmake run` 将 app 安装到模拟器并加载运行。 ```bash $ xmake create t xcode.iosapp_with_framework l objc testapp $ cd testapp $ xmake f p iphoneos a x86_64 $ xmake $ xmake install $ xmake run ``` ### Bundle程序 ```lua target(\"test\", function() add_rules(\"xcode.bundle\") add_files(\"src/*.m\") add_files(\"src/Info.plist\") end) ``` 我们也可以通过模板工程快速创建： ```bash $ xmake create t xcode.bundle l objc test ``` ## Protobuf程序 ### 使用c库 ```lua add_requires(\"protobuf c\") target(\"console_c\", function() set_kind(\"binary\") add_packages(\"protobuf c\") add_rules(\"protobuf.c\") add_files(\"src/*.c\") add_files(\"src/*.proto\") end) ``` 我们还可以设置 `proto_public true` 来导出 proto 的头文件搜索目录，开放给其他父 target 继承使用。 ```lua add_packages(\"protobuf c\", {public true}) add_files(\"src/**.proto\", {proto_public true}) ``` 注：由于 protobuf 生成的头文件引用了 protobuf c 包的头文件，因此，我们也需要将包的头文件标记为 `{public true}` 对外导出它。 ### 使用c++库 ```lua add_requires(\"protobuf cpp\") target(\"console_c++\", function() set_kind(\"binary\") set_languages(\"c++11\") add_packages(\"protobuf cpp\") add_rules(\"protobuf.cpp\") add_files(\"src/*.cpp\") add_files(\"src/*.proto\") end) ``` 我们还可以设置 `proto_public true` 来导出 proto 的头文件搜索目录，开放给其他父 target 继承使用。 ```lua add_packages(\"protobuf cpp\", {public true}) add_files(\"src/**.proto\", {proto_public true}) ``` 注：由于 protobuf 生成的头文件引用了 protobuf cpp 包的头文件，因此，我们也需要将包的头文件标记为 `{public true}` 对外导出它。 ## Cuda程序 创建一个空工程： ```bash $ xmake create P test l cuda $ cd test $ xmake ``` ```lua define target target(\"cuda_console\", function() set_kind(\"binary\") add_files(\"src/*.cu\") generate SASS code for SM architecture of current host add_cugencodes(\"native\") generate PTX code for the virtual architecture to guarantee compatibility add_cugencodes(\"compute_30\") end) ``` > 默认构建会启用 device link。（参见 [Separate Compilation and Linking of CUDA C++ Device Code](https://devblogs.nvidia.com/separate compilation linking cuda device code/)） 如果要显式禁用 device link，可以通过 `set_policy(\"build.cuda.devlink\", false)` 来设置。 > cuda 源文件中的 device 函数需要被 device link 且只 device link 一次。在 `shared` 或 `binary` 的 target 上 xmake 会自动进行 device link ，这时它们依赖的 `static` target 也会同时被 device link ，因此默认情况下 `static` target 不会被 device link。然而，如果最终的 `shared` 或 `binary` 的 target 不包含任何 cuda 源文件，则不会发生 device link 阶段，导致出现 undefined reference 错误。这种情况下，需要手动为 `static` target 指定 `add_values(\"cuda.build.devlink\", true)`. 默认会自动探测 cuda 环境，当然也可以指定 Cuda SDK 环境目录，或者指定 cuda 版本（此时将在默认安装目录进行查找）： ```bash $ xmake f cuda /usr/local/cuda 9.1/ $ xmake f cuda 9.1 $ xmake ``` 更多详情可以参考：[#158](https://github.com/xmake io/xmake/issues/158) ## Lex & Yacc程序 ```lua target(\"calc\", function() set_kind(\"binary\") add_rules(\"lex\", \"yacc\") add_files(\"src/*.l\", \"src/*.y\") end) ``` ## OpenMP 程序 我们不需要额外配置 rules，仅仅通过一个通用的 openmp 包就可以实现相同的效果。 ```lua add_requires(\"openmp\") target(\"loop\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"openmp\") end) ``` ## Fortran 程序 我们可以通过下面的命令，快速创建一个基于 fortran 的空工程： ```bash $ xmake create l fortran t console test ``` 它的xmake.lua内容如下： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.f90\") end) ``` 更多代码例子可以到这里查看：[Fortran Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/fortran) ## Go 程序 xmake 也支持 go 程序的构建，也提供了空工程的创建命令支持: ```bash $ xmake create l go t console test ``` xmake.lua 内容如下: ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.go\") end) ``` 更多例子见：[Go Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/go) ## Dlang 程序 创建空工程： ```bash $ xmake create l dlang t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") end) ``` xmake 也提供对 dub 包管理的支持，可以快速集成 dlang 的第三方依赖包： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"dub::log 0.4.3\", {alias \"log\"}) add_requires(\"dub::dateparser\", {alias \"dateparser\"}) add_requires(\"dub::emsi_containers\", {alias \"emsi_containers\"}) add_requires(\"dub::stdx allocator\", {alias \"stdx allocator\"}) add_requires(\"dub::mir core\", {alias \"mir core\"}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.d\") add_packages(\"log\", \"dateparser\", \"emsi_containers\", \"stdx allocator\", \"mir core\") end) ``` 不过还有一些不完善的地方，比如目前必须手动配置所有级联依赖包，会稍微繁琐些，后续有待改进。 更多例子见：[Dlang Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/dlang) ## Rust程序 创建空工程： ```bash $ xmake create l rust t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") end) ``` 更多例子见：[Rust Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/rust) ### 添加 Cargo 包依赖 例子: https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cargo_deps ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::base64 0.13.0\") add_requires(\"cargo::flate2 1.0.17\", {configs {features \"zlib\"}}) target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::base64\", \"cargo::flate2\") end) ``` ### 集成 Cargo.toml 的依赖包 上面直接使用 `add_requires(\"cargo::base64 0.13.0\")` 的方式集成依赖，会有一个问题： 如果依赖很多，并且有几个依赖都共同依赖了相同的子依赖，那么会出现重定义问题，因此如果我们使用完整的 Cargo.toml 去管理依赖就不会存在这个问题。 例如： ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"cargo::test\", {configs {cargo_toml path.join(os.projectdir(), \"Cargo.toml\")}}) target(\"test\") set_kind(\"binary\") add_files(\"src/main.rs\") add_packages(\"cargo::test\") ``` 完整例子见：[cargo_deps_with_toml](https://github.com/xmake io/xmake/blob/dev/tests/projects/rust/cargo_deps_with_toml/xmake.lua) ### 使用 cxxbridge 在 c++ 中调用 rust 例子: <https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/cxx_call_rust_library> ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cargo::cxx 1.0\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.rs\") set_values(\"rust.cratetype\", \"staticlib\") add_packages(\"cargo::cxx\") end) target(\"test\", function() set_kind(\"binary\") add_rules(\"rust.cxxbridge\") add_deps(\"foo\") add_files(\"src/main.cc\") add_files(\"src/bridge.rsx\") end) ``` foo.rs ```rust #[cxx::bridge] mod foo { extern \"Rust\" { fn add(a: i32, b: i32) > i32; } } pub fn add(a: i32, b: i32) > i32 { return a + b; } ``` 我们还需要在 c++ 项目中添加桥接文件 bridge.rsx ```rust #[cxx::bridge] mod foo { extern \"Rust\" { fn add(a: i32, b: i32) > i32; } } ``` main.cc ```c++ #include <stdio.h> #include \"bridge.rs.h\" int main(int argc, char** argv) { printf(\"add(1, 2) %d\\n\", add(1, 2)); return 0; } ``` ### 在 Rust 中调用 C++ 例子: <https://github.com/xmake io/xmake/tree/dev/tests/projects/rust/rust_call_cxx_library> ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.cc\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.rs\") end) ``` main.rs ```rust extern \"C\" { \tfn add(a: i32, b: i32) > i32; } fn main() { unsafe { \t println!(\"add(1, 2) {}\", add(1, 2)); } } ``` foo.cc ```c++ extern \"C\" int add(int a, int b) { return a + b; } ``` ## Swift 程序 创建空工程： ```bash $ xmake create l swift t console test ``` xmake.lua内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.swift\") end) ``` 更多例子见：[Swift Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/swift) ## Objc 程序 创建空工程： ```bash $ xmake create l objc t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.m\") end) ``` 更多例子见：[Objc Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/objc++) ## Objc 程序 创建空工程： ```bash $ xmake create l objc t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.m\") end) ``` 更多例子见：[Objc Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/objc++) ## Zig 程序 创建空工程： ```bash $ xmake create l zig t console test ``` xmake.lua 内容： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.zig\") end) ``` 更多例子见：[Zig Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/zig) ## Linux Bpf 程序 xmake 支持 bpf 程序构建，同时支持 linux 以及 android 平台，能够自动拉取 llvm 和 android ndk 工具链。 更多详情见：[#1274](https://github.com/xmake io/xmake/issues/1274) ```lua add_rules(\"mode.release\", \"mode.debug\") add_rules(\"platform.linux.bpf\") add_requires(\"linux tools\", {configs {bpftool true}}) add_requires(\"libbpf\") if is_plat(\"android\") then add_requires(\"ndk > 22.x\") set_toolchains(\"@ndk\", {sdkver \"23\"}) else add_requires(\"llvm > 10.x\") set_toolchains(\"@llvm\") add_requires(\"linux headers\") end target(\"minimal\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_packages(\"linux tools\", \"linux headers\", \"libbpf\") set_license(\"GPL 2.0\") end) ``` ## Vala 程序 xmake 支持构建 Vala 程序，我们需要应用 `add_rules(\"vala\")` 规则，并且 glib 包是必须的。 相关 issues: [#1618](https://github.com/xmake io/xmake/issues/1618) `add_values(\"vala.packages\")` 用于告诉 valac，项目需要哪些包，它会引入相关包的 vala api，但是包的依赖集成，还是需要通过 `add_requires(\"lua\")` 下载集成。 ### 控制台程序 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"lua\", \"glib\") target(\"test\", function() set_kind(\"binary\") add_rules(\"vala\") add_files(\"src/*.vala\") add_packages(\"lua\", \"glib\") add_values(\"vala.packages\", \"lua\") end) ``` ### 静态库程序 我们能够通过 `add_values(\"vala.header\", \"mymath.h\")` 设置导出的接口头文件名，通过 `add_values(\"vala.vapi\", \"mymath 1.0.vapi\")` 设置导出的 vapi 文件名。 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"glib\") target(\"mymath\", function() set_kind(\"static\") add_rules(\"vala\") add_files(\"src/mymath.vala\") add_values(\"vala.header\", \"mymath.h\") add_values(\"vala.vapi\", \"mymath 1.0.vapi\") add_packages(\"glib\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"mymath\") add_rules(\"vala\") add_files(\"src/main.vala\") add_packages(\"glib\") end) ``` ### 动态库程序 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"glib\") target(\"mymath\", function() set_kind(\"shared\") add_rules(\"vala\") add_files(\"src/mymath.vala\") add_values(\"vala.header\", \"mymath.h\") add_values(\"vala.vapi\", \"mymath 1.0.vapi\") add_packages(\"glib\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"mymath\") add_rules(\"vala\") add_files(\"src/main.vala\") add_packages(\"glib\") end) ``` 更多例子：[Vala examples](https://github.com/xmake io/xmake/tree/master/tests/projects/vala) ## Pascal 程序 我们能够支持构建 Pascal 程序，相关 issues 见：[#388](https://github.com/xmake io/xmake/issues/388) ### 控制台程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.pas\") end) ``` ### 动态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.pas\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.pas\") end) ``` 更多例子：[Pascal examples](https://github.com/xmake io/xmake/tree/master/tests/projects/pascal) ## Swig 模块 xmake 支持构建 Swig 模块，我们提供了 `swig.c` 和 `swig.cpp` 规则，分别对应支持生成 c/c++ 模块接口代码，配合 xmake 的包管理系统实现完全自动化的模块和依赖包整合。 相关 issues: [#1622](https://github.com/xmake io/xmake/issues/1622) ### Lua/C 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"lua\") target(\"example\", function() add_rules(\"swig.c\", {moduletype \"lua\"}) add_files(\"src/example.i\", {swigflags \" no old metatable bindings\"}) add_files(\"src/example.c\") add_packages(\"lua\") end) ``` ### Python/C 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"python 3.x\") target(\"example\", function() add_rules(\"swig.c\", {moduletype \"python\"}) add_files(\"src/example.i\", {scriptdir \"share\"}) add_files(\"src/example.c\") add_packages(\"python\") end) ``` ### Python/C++ 模块 ```lua add_rules(\"mode.release\", \"mode.debug\") add_requires(\"python 3.x\") target(\"example\", function() add_rules(\"swig.cpp\", {moduletype \"python\"}) add_files(\"src/example.i\", {scriptdir \"share\"}) add_files(\"src/example.cpp\") add_packages(\"python\") end) ``` ### Java/C 模块 [完整例子](https://github.com/xmake io/xmake/blob/dev/tests/projects/swig/java_c) ```lua make sure you config to an enviroment with jni.h for example: xmake f c p android target(\"example\", function() set_kind('shared') set moduletype to java add_rules(\"swig.c\", {moduletype \"java\"}) test jar build add_rules(\"swig.c\", {moduletype \"java\" , buildjar true}) use swigflags to provider package name and output path of java files add_files(\"src/example.i\", {swigflags { \" package\", \"com.example\", \" outdir\", \"build/java/com/example/\" }}) add_files(\"src/example.c\") add_includedirs(\"src\") before_build(function() ensure output path exists before running swig os.mkdir(\"build/java/com/example/\") end) end) ``` 我们也可以配置 ```lua add_rules(\"swig.c\", {moduletype \"java\", buildjar true}) ``` 去同时构建 jar 包，方便直接使用。 ## C++20 模块 ### 快速开始 xmake 采用 `.mpp` 作为默认的模块扩展名，但是也同时支持 `.ixx`, `.cppm`, `.mxx` 等扩展名。 目前 xmake 已经完整支持 gcc11/clang/msvc 的 C++20 Modules 构建支持，并且能够自动分析模块间的依赖关系，实现最大化并行编译。 ```lua set_languages(\"c++20\") target(\"class\", function() set_kind(\"binary\") add_files(\"src/*.cpp\", \"src/*.mpp\") end) ``` 更多例子见：[C++ Modules](https://github.com/xmake io/xmake/tree/master/tests/projects/c%2B%2B/modules) ### Cpp Only 工程 xmake 对 C++20 模块的实现进行了重构和升级，新增了对 Headerunits 的支持，我们可以在模块中引入 Stl 和 用户头文件模块。 相关的补丁见：[#2641](https://github.com/xmake io/xmake/pull/2641)。 注：通常我们至少需要添加一个 `.mpp` 文件，才能开启 C++20 modules 编译，如果只有 cpp 文件，默认是不会开启模块编译的。 但是，如果我们仅仅只是想在 cpp 文件中使用模块的 Headerunits 特性，比如引入一些 stl Headerunits 在 cpp 中使用， 那么我们也可以通过设置 `set_policy(\"build.c++.modules\", true)` 来强行开启 C++ Modules 编译，例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") set_languages(\"c++20\") set_policy(\"build.c++.modules\", true) end) ``` ### 模块的分发和集成 #### 分发 C++ Modules 包 我们先使用 xmake.lua 维护模块的构建，并通过指定 `{install true}`，来告诉 xmake 哪些模块文件需要安装对外分发。 ```lua add_rules(\"mode.release\", \"mode.debug\") set_languages(\"c++20\") target(\"foo\", function() set_kind(\"static\") add_files(\"*.cpp\") add_files(\"*.mpp\", { install true }) end) ``` 然后，我们把它做成包，可以提交到 [xmake repo](https://github.com/xmake io/xmake repo) 仓库，当然也可以直接做成本地包，或者私有仓库包。 这里，为了方便测试验证，我们仅仅通过 `set_sourcedir` 将它做成本地包。 ```lua package(\"foo\", function() set_sourcedir(path.join(os.scriptdir(), \"src\")) on_install(function(package) import(\"package.tools.xmake\").install(package, {}) end) end) ``` #### 集成 C++ Modules 包 然后，我们通过 `add_requires(\"foo\")` 的包集成接口，对 C++ Modules 包进行快速集成使用。 由于 foo 的模块包，我们放在私有仓库中定义，所以我们通过 `add_repositories(\"my repo my repo\")` 引入自己的包仓库。 如果，包已经提交到 xmake repo 官方仓库，就不需要额外配置它。 ```lua add_rules(\"mode.release\", \"mode.debug\") set_languages(\"c++20\") add_repositories(\"my repo my repo\") add_requires(\"foo\", \"bar\") target(\"packages\", function() set_kind(\"binary\") add_files(\"src/*.cpp\") add_packages(\"foo\", \"bar\") set_policy(\"build.c++.modules\", true) end) ``` 集成好包后，我们就可以执行 `xmake` 命令，一键下载、编译、集成 C++ Modules 包来使用。 ```bash $ xmake checking for platform ... linux checking for architecture ... x86_64 note: install or modify (m) these packages (pass y to skip confirm)? in my repo: > foo latest > bar latest please input: y (y/n/m) > install bar latest .. ok > install foo latest .. ok [ 0%]: generating.module.deps src/main.cpp [ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/b/bar/latest/4e0143c97b65425b855ad5fd03038b6a/modules/bar/bar.mpp [ 0%]: generating.module.deps /mnt/xmake/tests/projects/c++/modules/packages/build/.packages/f/foo/latest/4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp [ 14%]: compiling.module.release bar [ 14%]: compiling.module.release foo [ 57%]: compiling.release src/main.cpp [ 71%]: linking.release packages [100%]: build ok! ``` 注：每个包安装后，会在包路径下，存储维护模块的 meta info 文件，这是 `p2473r1.pdf` 中约定的一种格式规范，也许它不是最终的标准，但这并不影响我们现在去使用模块的分发。 ```bash $ cat ./build/.packages/f/foo/latest/4e0143c97b65425b855ad5fd03038b6a/modules/foo/foo.mpp.meta info {\"_VENDOR_extension\":{\"xmake\":{\"name\":\"foo\",\"file\":\"foo.mpp\"}},\"definitions\":{},\"include_paths\":{}} ``` 完整的例子工程见：[C++ Modules 包分发例子工程](https://github.com/xmake io/xmake/tree/master/tests/projects/c%2B%2B/modules/packages) ### 支持 C++23 Std Modules [Arthapz](https://github.com/Arthapz) 也帮忙改进了对 C++23 Std Modules 的支持。 目前三个编译器对它的支持进展： #### Clang 目前最新的 clang 似乎也还没完全支持 C++23 std modules，当前还是 draft patch 状态，[#D135507](https://reviews.llvm.org/D135507)。 但是，Xmake 也对它进行了支持，如果大家想要尝鲜，可以自行合入这个 patch，然后使用 xmake 来测试。 另外，低版本的 clang 也有对非标准的 std modules 做了实验性支持。 我们还是可以在低版本 clang 中尝试性使用 xmake 来构建 std modules，尽管它可能还只是个玩具（会遇到很多问题）。 相关讨论见：[#3255](https://github.com/xmake io/xmake/pull/3255) #### Gcc 目前还不支持。 ## 合并静态库 ### 自动合并 target 库 我们可以通过设置 `build.merge_archive` 策略，启用自动合并依赖的所有静态库，例如： ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"add\", function() set_kind(\"static\") add_files(\"src/add.c\") add_files(\"src/subdir/add.c\") end) target(\"sub\", function() set_kind(\"static\") add_files(\"src/sub.c\") add_files(\"src/subdir/sub.c\") end) target(\"mul\", function() set_kind(\"static\") add_deps(\"add\", \"sub\") add_files(\"src/mul.c\") set_policy(\"build.merge_archive\", true) end) ``` mul 静态库自动合并了 add 和 sub 静态库，生成一个包含 add/sub 代码的完整 libmul.a 库。 这个合并相对比较稳定完善，支持 ar 和 msvc/lib.exe，也支持交叉编译工具链生成的静态库合并，也支持带有重名 obj 文件的静态库。 ### 合并指定的静态库文件 如果自动合并不满足需求，我们也可以主动调用 `utils.archive.merge_archive` 模块在 `after_link` 阶段合并指定的静态库列表。 ```lua target(\"test\", function() after_link(function (target) import(\"utils.archive.merge_staticlib\") merge_staticlib(target, \"libout.a\", {\"libfoo.a\", \"libbar.a\"}) end) end) ``` ### 使用 add_files 合并静态库 其实，我们之前的版本已经支持通过 `add_files(\"*.a\")` 来合并静态库。 ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"*.a\") add_files(\"*.c\") end) ``` 但是它有一些缺陷：如果使用 ar，可能会存在 .obj 对象文件同名冲突导致合并失败，因此推荐使用上文介绍的合并方式，更加的稳定可靠，也更加的简单。 相关 issues: [#1638](https://github.com/xmake io/xmake/issues/1638) ## Nim 程序 xmake 支持 Nimlang 项目，相关 issues 见：[#1756](https://github.com/xmake io/xmake/issues/1756) ### 创建空工程 我们可以使用 `xmake create` 命令创建空工程。 ```bash xmake create l nim t console test xmake create l nim t static test xmake create l nim t shared test ``` ### 控制台程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake v [ 33%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache o:b uild/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### 静态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/foo.nim\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake v [ 33%]: linking.release libfoo.a /usr/local/bin/nim c opt:speed nimcache:build/.gens/foo/macosx/x86_64/release/nimcache app :staticlib noMain passC: DNimMain NimMain_B6D5BD02 passC: DNimMainInner NimMainInner_B6D5B D02 passC: DNimMainModule NimMainModule_B6D5BD02 passC: DPreMain PreMain_B6D5BD02 passC: D PreMainInner PreMainInner_B6D5BD02 o:build/macosx/x86_64/release/libfoo.a src/foo.nim [ 66%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache pa ssL: Lbuild/macosx/x86_64/release passL: lfoo o:build/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### 动态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"shared\") add_files(\"src/foo.nim\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ```bash $ xmake rv [ 33%]: linking.release libfoo.dylib /usr/local/bin/nim c opt:speed nimcache:build/.gens/foo/macosx/x86_64/release/nimcache app :lib noMain o:build/macosx/x86_64/release/libfoo.dylib src/foo.nim [ 66%]: linking.release test /usr/local/bin/nim c opt:speed nimcache:build/.gens/test/macosx/x86_64/release/nimcache pa ssL: Lbuild/macosx/x86_64/release passL: lfoo o:build/macosx/x86_64/release/test src/main.nim [100%]: build ok! ``` ### C 代码混合编译 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() set_kind(\"static\") add_files(\"src/*.c\") end) target(\"test\", function() set_kind(\"binary\") add_deps(\"foo\") add_files(\"src/main.nim\") end) ``` ### Nimble 依赖包集成 完整例子见：[Nimble Package Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/nim/nimble_package) ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"nimble::zip >0.3\") target(\"test, function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"nimble::zip\") end) ``` main.nim ```nim import zip/zlib echo zlibVersion() ``` ### Native 依赖包集成 完整例子见：[Native Package Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/nim/native_package) ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"zlib\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/main.nim\") add_packages(\"zlib\") end) ``` main.nim ```nim proc zlibVersion(): cstring {.cdecl, importc} echo zlibVersion() ``` ## Keil/MDK 嵌入式程序 相关例子工程：[Example](https://github.com/xmake io/xmake/tree/dev/tests/projects/embed/mdk/hello) xmake 会自动探测 Keil/MDK 安装的编译器，相关 issues [#1753](https://github.com/xmake io/xmake/issues/1753)。 使用 armcc 编译 ```bash $ xmake f p cross a cortex m3 toolchain armcc c $ xmake ``` 使用 armclang 编译 ```bash $ xmake f p cross a cortex m3 toolchain armclang c $ xmake ``` ### 可执行程序 ```lua target(\"hello\", function() add_deps(\"foo\") add_rules(\"mdk.binary\") add_files(\"src/*.c\", \"src/*.s\") add_includedirs(\"src/lib/cmsis\") set_runtimes(\"microlib\") end) ``` 需要注意的是，目前一些 mdk 程序都使用了 microlib 库运行时，它需要编译器加上 `__MICROLIB` 宏定义，链接器加上 ` library_type microlib` 等各种配置。 我们可以通过 `set_runtimes(\"microlib\")` 直接设置到 microlib 运行时库，可以自动设置上所有相关选项。 ### 静态库程序 ```lua add_rules(\"mode.debug\", \"mode.release\") target(\"foo\", function() add_rules(\"mdk.static\") add_files(\"src/foo/*.c\") set_runtimes(\"microlib\") end) ``` ## Keil/C51 嵌入式程序 ### 可执行程序 ```lua target(\"hello\", function() add_rules(\"c51.binary\") set_toolchains(\"c51\") add_files(\"src/main.c\") end) ``` ## Lua 模块 参考 <https://github.com/xmake io/luarocks build xmake> 如果你的 lua 模块含有 C 代码，你可以使用 [LuaNativeObjects](https://github.com/Neopallium/LuaNativeObjects) 去从 lua 代码生成 C 代码。 参考[例子](https://github.com/Freed Wu/rime.nvim/blob/main/xmake.lua)。 ## Nodejs 模块 参考[例子](https://github.com/tonyfettes/coc rime/blob/master/xmake.lua)。 ## Linux 内核驱动模块 xmake 完整支持了 Linux 内核驱动模块的构建，这也许首个也是唯一一个支持编译 Linux 内核驱动的第三方构建工具了。 ### Hello world 模块 完整例子：[Linux Kernel Driver Modules](https://github.com/xmake io/xmake/tree/master/tests/projects/linux/driver/hello) 它的配置非常简单，只需要配置上支持模块的 linux headers 包，然后应用 `platform.linux.module` 构建规则就行了。 ```lua add_requires(\"linux headers\", {configs {driver_modules true}}) target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") add_packages(\"linux headers\") set_license(\"GPL 2.0\") end) ``` 然后直接执行 xmake 命令，一键编译，生成内核驱动模块 hello.ko。 ```bash $ xmake [ 20%]: cache compiling.release src/add.c [ 20%]: cache compiling.release src/hello.c [ 60%]: linking.release build/linux/x86_64/release/hello.ko [100%]: build ok! ``` 我们也可以看完整构建命令参数。 ```bash $ xmake v [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/linux/x86_64/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/linux/x86_64/release/src/hello.c.o src/hello.c [ 60%]: linking.release build/linux/x86_64/release/hello.ko /usr/bin/ld m elf_x86_64 r o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/release/src/add.c.o build/.objs/hello/linux/x86_64/release/src/hello.c.o /usr/src/linux headers 5.11.0 41 generic/scripts/mod/modpost m a o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /usr/bin/gcc c m64 O2 std gnu89 I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated I/usr/src/linux headers 5.11.0 41 generic/include I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/uapi I/usr/src/linux headers 5.11.0 41 generic/arch/x86/include/generated/uapi I/usr/src/linux headers 5.11.0 41 generic/include/uapi I/usr/src/linux headers 5.11.0 41 generic/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" DCONFIG_X86_X32_ABI isystem /usr/lib/gcc/x86_64 linux gnu/10/include include /usr/src/linux headers 5.11.0 41 generic/include/linux/kconfig.h include /usr/src/linux headers 5.11.0 41 generic/include/linux/compiler_types.h nostdinc mno sse mno mmx mno sse2 mno 3dnow mno avx mno 80387 mno fp ret in 387 mpreferred stack boundary 3 mskip rax setup mtune generic mno red zone mcmodel kernel mindirect branch thunk extern mindirect branch register mrecord mcount fmacro prefix map ./ fno strict aliasing fno common fshort wchar fno PIE fcf protection none falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno allow store data races fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.c /usr/bin/ld m elf_x86_64 r build id sha1 T /usr/src/linux headers 5.11.0 41 generic/scripts/module.lds o build/linux/x86_64/release/hello.ko build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.o build/.objs/hello/linux/x86_64/release/build/linux/x86_64/release/hello.ko.mod.o ``` 通过 `add_requires(\"linux headers\", {configs {driver_modules true}})` 配置包，xmake 会自动优先从系统中查找对应的 linux headers 包。 如果没找到，xmake 也会自动下载它，然后自动配置构建带有 driver modules 的内核源码后，使用它继续构建内核模块。 ### 自定义 linux headers 路径 有很多用户反馈，大多数情况下，linux 内核驱动构建都是基于定制版的 linux kernel，因此需要能够自定义配置 linux headers 路径，而不是走远程依赖包模式。 其实，我们通过自己重写 linux headers 包，也是可以做到这一点的。 ```lua package(\"linux headers\") on_fetch(function (package, opt) return {includedirs \"/usr/src/linux headers 5.0/include\"} end) package_end() add_requires(\"linux headers\") target(\"test\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") add_packages(\"linux headers\") end) ``` 不过这样，也许还有点繁琐，因此我们支持更加方便的设置 linux headers 路径。 ```lua target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") set_values(\"linux.driver.linux headers\", \"/usr/src/linux headers 5.11.0 41 generic\") end) ``` 我们也可以通过定义 option 选项，将 linux headers 路径作为 `xmake f linux headers /usr/src/linux headers` 的方式传入。 ```lua option(\"linux headers\", {showmenu true, description \"Set linux headers path.\"}) target(\"hello\", function() add_rules(\"platform.linux.module\") add_files(\"src/*.c\") set_values(\"linux.driver.linux headers\", \"$(linux headers)\") end) ``` 更多详情见：[#1923](https://github.com/xmake io/xmake/issues/1923) ### 交叉编译 我们也支持内核驱动模块的交叉编译，比如在 Linux x86_64 上使用交叉编译工具链来构建 Linux Arm/Arm64 的驱动模块。 我们只需要准备好自己的交叉编译工具链，通过 ` sdk ` 指定它的根目录，然后配置切换到 ` p cross` 平台， 最后指定需要构建的架构 arm/arm64 即可。 这里用到的交叉工具链，可以从这里下载: [Download toolchains](https://releases.linaro.org/components/toolchain/binaries/latest 7/aarch64 linux gnu/) 更多，交叉编译配置文档，见：[配置交叉编译](/zh cn/guide/configuration?id common cross compilation configuration) > 目前仅仅支持 arm/arm64 交叉编译架构，后续会支持更多的平台架构。 #### 构建 Arm 驱动模块 ```bash $ xmake f p cross a arm sdk /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf c $ xmake v checking for arm linux gnueabihf g++ ... /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf g++ checking for the linker (ld) ... arm linux gnueabihf g++ checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf g++ ... ok checking for flags ( fPIC) ... ok checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc ... ok checking for flags ( fPIC) ... ok checking for flags ( O2) ... ok checking for ccache ... /usr/bin/ccache [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/cross/arm/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/cross/arm/release/src/hello.c.o src/hello.c checking for flags ( MMD MF) ... ok checking for flags ( fdiagnostics color always) ... ok [ 60%]: linking.release build/cross/arm/release/hello.ko /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf ld EB r o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.o build/.objs/hello/cross/arm/release/src/add.c.o build/.objs/hello/cross/arm/release/src/hello.c.o /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/mod/modpost m a o build/.objs/hello/cross/arm/release/build/cross/arm/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/arch/arm/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" D__LINUX_ARM_ARCH__ 6 isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/../lib/gcc/arm linux gnueabihf/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack mbig endian mabi aapcs linux mfpu vfp marm march armv6k mtune arm1136j s msoft float Uarm o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.c /mnt/gcc linaro 7.5.0 2019.12 x86_64_arm linux gnueabihf/bin/arm linux gnueabihf ld EB be8 r build id sha1 T /home/ruki/.xmake/packages/l/linux headers/5.10.46/7695a30b7add4d3aa4685cbac6815805/scripts/module.lds o build/cross/arm/release/hello.ko build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.o build/.objs/hello/cross/arm/release/build/cross/arm/release/hello.ko.mod.o [100%]: build ok! ``` #### 构建 Arm64 驱动模块 ```bash $ xmake f p cross a arm64 sdk /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu c checking for aarch64 linux gnu g++ ... /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++ checking for the linker (ld) ... aarch64 linux gnu g++ checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++ ... ok checking for flags ( fPIC) ... ok checking for /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc ... ok checking for flags ( fPIC) ... ok checking for flags ( O2) ... ok checking for ccache ... /usr/bin/ccache [ 20%]: cache compiling.release src/add.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"add\\\" o build/.objs/hello/cross/arm64/release/src/add.c.o src/add.c [ 20%]: cache compiling.release src/hello.c /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack DKBUILD_BASENAME \\\"hello\\\" o build/.objs/hello/cross/arm64/release/src/hello.c.o src/hello.c checking for flags ( MMD MF) ... ok checking for flags ( fdiagnostics color always) ... ok [ 60%]: linking.release build/cross/arm64/release/hello.ko /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu ld EL maarch64elf r o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/src/add.c.o build/.objs/hello/cross/arm64/release/src/hello.c.o /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/mod/modpost m a o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/Module.symvers e N T WARNING: modpost: Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped. /usr/bin/ccache /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc c O2 std gnu89 I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/arch/arm64/include/generated/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/uapi I/home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/generated/uapi D__KERNEL__ DMODULE DKBUILD_MODNAME \\\"hello\\\" isystem /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/../lib/gcc/aarch64 linux gnu/7.5.0/include include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/kconfig.h include /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/include/linux/compiler_types.h nostdinc fno strict aliasing fno common fshort wchar fno PIE falign jumps 1 falign loops 1 fno asynchronous unwind tables fno jump tables fno delete null pointer checks fno reorder blocks fno ipa cp clone fno partial inlining fstack protector strong fno inline functions called once falign functions 32 fno strict overflow fno stack check fconserve stack o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.c /mnt/gcc linaro 7.5.0 2019.12 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu ld EL maarch64elf r build id sha1 T /home/ruki/.xmake/packages/l/linux headers/5.10.46/8f80101835834bc2866f3a827836b5de/scripts/module.lds o build/cross/arm64/release/hello.ko build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.o build/.objs/hello/cross/arm64/release/build/cross/arm64/release/hello.ko.mod.o [100%]: build ok! ``` ## ASN.1 程序 ASN.1 程序，需要借助 [ASN.1 Compiler](https://github.com/vlm/asn1c) 去生成相关的 .c 文件参与项目编译。 而 Xmake 内置提供了 `add_rules(\"asn1c\")` 规则去处理 `.c` 文件生成，`add_requires(\"asn1c\")` 自动拉取集成 ASN.1 编译器工具。 下面是一个基础的配置例子： ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"asn1c\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_files(\"src/*.asn1\") add_rules(\"asn1c\") add_packages(\"asn1c\") end) ``` 具体见 [完整例子工程](https://github.com/xmake io/xmake/tree/master/tests/projects/c/asn1c)。 ## Verilog 仿真程序 ### iVerilog 仿真器 通过 `add_requires(\"iverilog\")` 配置，我们能够自动拉取 iverilog 工具链包，然后使用 `set_toolchains(\"@iverilog\")` 自动绑定工具链来编译工程。 ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") end) ``` #### 设置抽象配置 ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") add_defines(\"TEST\") add_includedirs(\"inc\") set_languages(\"v1800 2009\") end) ``` 我们可以通过 `set_languages(\"v1800 2009\")` 来设置切换 Verilog 的语言标准。 目前支持的一些取值和映射关系如下： ```lua [\"v1364 1995\"] \" g1995\" [\"v1364 2001\"] \" g2001\" [\"v1364 2005\"] \" g2005\" [\"v1800 2005\"] \" g2005 sv\" [\"v1800 2009\"] \" g2009\" [\"v1800 2012\"] \" g2012\" ``` #### 设置自定义 flags ```lua add_requires(\"iverilog\") target(\"hello\", function() add_rules(\"iverilog.binary\") set_toolchains(\"@iverilog\") add_files(\"src/*.v\") add_values(\"iverilogs.flags\", \" DTEST\") end) ``` #### 构建工程 ```bash $ xmake checking for iverilog ... iverilog checking for vvp ... vvp [ 50%]: linking.iverilog hello.vvp [100%]: build ok! ``` #### 运行程序 ```bash $ xmake run hello world! LXT2 info: dumpfile hello.vcd opened for output. src/main.v:6: $finish called at 0 (1s) ``` 更多完整例子：[iVerilog Examples](https://github.com/xmake io/xmake/tree/master/tests/projects/embed/iverilog) ### Verilator 仿真器 通过 `add_requires(\"verilator\")` 配置，我们能够自动拉取 verilator 工具链包，然后使用 `set_toolchains(\"@verilator\")` 自动绑定到工具链来编译工程。 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_files(\"src/*.cpp\") end) ``` verilator 工程，我们需要一个额外的 `sim_main.cpp` 文件参与编译，作为程序的入口代码。 ``` #include \"hello.h\" #include \"verilated.h\" int main(int argc, char** argv) { VerilatedContext* contextp new VerilatedContext; contextp >commandArgs(argc, argv); hello* top new hello{contextp}; while (!contextp >gotFinish()) { top >eval(); } delete top; delete contextp; return 0; } ``` #### 设置抽象配置 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_defines(\"TEST\") add_includedirs(\"inc\") set_languages(\"v1800 2009\") end) ``` 我们可以通过 `set_languages(\"v1800 2009\")` 来设置切换 Verilog 的语言标准。 目前支持的一些取值和映射关系如下： ```lua Verilog [\"v1364 1995\"] \"+1364 1995ext+v\", [\"v1364 2001\"] \"+1364 2001ext+v\", [\"v1364 2005\"] \"+1364 2005ext+v\", SystemVerilog [\"v1800 2005\"] \"+1800 2005ext+v\", [\"v1800 2009\"] \"+1800 2009ext+v\", [\"v1800 2012\"] \"+1800 2012ext+v\", [\"v1800 2017\"] \"+1800 2017ext+v\", ``` #### 设置自定义 flags ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.binary\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") add_files(\"src/*.cpp\") add_values(\"verilator.flags\", \" trace\", \" timing\") end) ``` #### 构建工程 ```bash $ xmake [ 0%]: compiling.verilog src/main.v [ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__Slow.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0__Slow.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello.cpp [ 15%]: cache compiling.release /Users/ruki/.xmake/packages/v/verilator/2023.1.10/cd2268409c1d44799288c7759b3cbd56/share/verilator/include/verilated_threads.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello__Syms.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h07139e86__0.cpp [ 15%]: cache compiling.release src/sim_main.cpp [ 15%]: cache compiling.release build/.gens/hello/macosx/x86_64/release/rules/verilator/hello___024root__DepSet_h9053a130__0.cpp [ 84%]: linking.release hello [100%]: build ok! ``` #### 运行程序 ```bash $ xmake run ruki 2:hello ruki$ xmake run hello world! src/main.v:4: Verilog $finish ``` 更多完整例子：[Verilator](https://github.com/xmake io/xmake/tree/master/tests/projects/embed/verilator) #### 编译静态库 我们也提供了 `verilator.static` 规则来编译生成 verilator 静态库。 ```lua add_requires(\"verilator\") target(\"hello\", function() add_rules(\"verilator.static\") set_toolchains(\"@verilator\") add_files(\"src/*.v\") end) target(\"test\", function() add_deps(\"hello\") add_files(\"src/*.cpp\") end) ``` ## Cppfront 程序 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cppfront\") target(\"test\", function() add_rules(\"cppfront\") set_kind(\"binary\") add_files(\"src/*.cpp2\") add_packages(\"cppfront\") end) ``` ## Cosmocc 程序 ```lua add_rules(\"mode.debug\", \"mode.release\") add_requires(\"cosmocc\") target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"@cosmocc\") end) ```"},"/get_started/zh/tutorial/environment-variables.html":{"title":"环境变量","content":"# 环境变量 我们可以执行下面的命令，获取所有 xmake 用到的环境变量，以及当前被设置的值。 ```bash $ xmake show l envs XMAKE_RAMDIR Set the ramdisk directory. <empty> XMAKE_GLOBALDIR Set the global config directory of xmake. /Users/ruki/.xmake XMAKE_ROOT Allow xmake to run under root. <empty> XMAKE_COLORTERM Set the color terminal environment. <empty> XMAKE_PKG_INSTALLDIR Set the install directory of packages. <empty> XMAKE_TMPDIR Set the temporary directory. /var/folders/vn/ppcrrcm911v8b4510klg9xw80000gn/T/.xmake501/211104 XMAKE_PKG_CACHEDIR Set the cache directory of packages. <empty> XMAKE_PROGRAM_DIR Set the program scripts directory of xmake. /Users/ruki/.local/share/xmake XMAKE_PROFILE Start profiler, e.g. perf, trace. <empty> XMAKE_RCFILES Set the runtime configuration files. XMAKE_CONFIGDIR Set the local config directory of project. /Users/ruki/projects/personal/xmake docs/.xmake/macosx/x86_64 XMAKE_LOGFILE Set the log output file path. <empty> ``` ## XMAKE_RAMDIR 设置 ramdisk 目录路径 ramdisk 目录是内存文件系统的目录位置，通常 `os.tmpdir()` 接口会用到，xmake 内部使用的临时文件，如果用户设置 ramdisk 路径，则会优先存储在这个上面，提升整体编译速度。 ## XMAKE_TMPDIR 设置用户的临时目录 默认 xmake 会使用 `/tmp/.xmake`，当然用户可以通过这个变量去修改默认路径。 ## XMAKE_CONFIGDIR 设置本地工程配置目录 每个项目的本地编译配置，默认会存储在当前项目根目录的 `.xmake` 路径下，然后根据不同的平台，架构区分，例如： ```bash .xmake/macosx/x86_64 ``` 我们如果不想存储在项目根目录，也可以自己设置到其他路径，比如 build 目录下等等。 ## XMAKE_GLOBALDIR 设置全局配置文件根目录 也就是 `xmake g/global` 全局配置的存储目录，还有安装包，缓存等其他全局文件，默认都会存储在这个目录下。 默认路径为：`~/.xmake`。 ## XMAKE_ROOT 允许用户在 root 模式下运行 通常 xmake 是默认禁止在 root 下运行，这非常不安全。但是如果用户非要在 root 下运行，也可以设置这个变量，强制开启。 ```bash export XMAKE_ROOT y ``` ## XMAKE_COLORTERM 设置 Terminal 的色彩输出 目前可以设置这几个值： 值 描述 nocolor 禁用彩色输出 color8 8 色输出支持 color256 256 色输出支持 truecolor 真彩色输出支持 通常，用户不需要设置它们，xmake 会自动探测用户终端支持的色彩范围，如果用户不想输出色彩，可以设置 nocolor 来全局禁用。 或者用 `xmake g theme plain` 也可以全局禁用。 ## XMAKE_PKG_INSTALLDIR 设置依赖包的安装根目录 xmake 的远程包安装的全局目录默认是 `~/.xmake/packages`，但是用户也可以设置这个变量，去单独修改它。 我们也可以使用 `xmake g pkg_installdir /xxx` 去设置它，效果是一样的。 ## XMAKE_PKG_CACHEDIR 设置依赖包的缓存目录 默认路径在 `~/.xmake/cache` 目录，存储包安装过程中的各种缓存文件，比较占存储空间，用户也可以单独设置它。 当然，xmake 在每个月都会自动清理上个月的所有缓存文件。 ## XMAKE_PROGRAM_DIR 设置 xmake 的脚本目录 xmake 的所有 lua 脚本随安装程序一起安装，默认都在安装目录下，但是如果想要切到自己下载的脚本目录下，方便本地修改调试，可以设置此变量。 如果要查看当前 xmake 在使用的脚本目录，可以执行： ```bash $ xmake l os.programdir /Users/ruki/.local/share/xmake ``` ## XMAKE_PROFILE 开启性能分析 这仅仅对 xmake 的开发者开放，用于分析 xmake 运行过程中的耗时情况，追踪调用过程。 ### 分析函数调用耗时 ```bash $ XMAKE_PROFILE perf:call xmake [ 25%]: cache compiling.release src/main.cpp [ 50%]: linking.release test [100%]: build ok! 0.238, 97.93%, 1, runloop : @programdir/core/base/scheduler.lua: 805 0.180, 74.04%, 25, _resume : [C]: 1 0.015, 6.34%, 50, _co_groups_resume : @programdir/core/base/scheduler.lua: 299 0.011, 4.37%, 48, wait : @programdir/core/base/poller.lua: 111 0.004, 1.70%, 62, status : @programdir/core/base/scheduler.lua: 71 0.004, 1.53%, 38, is_dead : @programdir/core/base/scheduler.lua: 76 0.003, 1.44%, 50, next : @programdir/core/base/timer.lua: 74 0.003, 1.33%, 48, delay : @programdir/core/base/timer.lua: 60 0.002, 1.02%, 24, is_suspended : @programdir/core/base/scheduler.lua: 86 ``` ### 分析进程耗时 可以用于分析每个文件的编译耗时，以及一些运行瓶颈。 ```bash $ XMAKE_PROFILE perf:process xmake r [ 7%]: compiling.release src/header.h [ 23%]: compiling.release src/test.cpp [ 30%]: compiling.release src/test8.cpp [ 38%]: compiling.release src/test4.cpp [ 46%]: compiling.release src/test5.cpp [ 53%]: compiling.release src/test7.cpp [ 61%]: compiling.release src/test6.cpp [ 69%]: compiling.release src/test2.cpp [ 76%]: compiling.release src/main.cpp [ 84%]: compiling.release test3.cpp [ 84%]: compiling.release src/test.c [ 92%]: linking.release main [100%]: build ok, spent 2.754s 1411.000, 22.19%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_37317EEDB62F4F3088AF6A2E2A649460 fdiagnostics color always x c++ header o build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch src/header.h 508.000, 7.99%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_1ABAE1FAD68D45008DC76A3A00697820 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/main.cpp.o src/main.cpp 473.000, 7.44%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_1C0BE5280C6F4E208F919577A48AAA40 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/test3.cpp.o test3.cpp 451.000, 7.09%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_877D3D9B6BBA4D308BFB5E4EBD751340 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test6.cpp.o src/test6.cpp 404.000, 6.35%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C9968E2873B648208A8C3F2BA7573640 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test7.cpp.o src/test7.cpp 402.000, 6.32%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_7F6DFA37FF494D208EADF9737484EC40 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test2.cpp.o src/test2.cpp 383.000, 6.02%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_63C9E23AE7E047308F762C7C02A56B50 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test4.cpp.o src/test4.cpp 374.000, 5.88%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C3A0EF96A7C14D00879BFAEFD26E9D20 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test8.cpp.o src/test8.cpp 368.000, 5.79%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_BADB46AF75CB4610857EF5083BD54D30 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test.cpp.o src/test.cpp 363.000, 5.71%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden fvisibility inlines hidden O3 std c++11 include src/header.h include pch build/.objs/main/macosx/x86_64/release/src/cxx/header.h.pch DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_0247BDB87DD14500816471184D4E8140 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test5.cpp.o src/test5.cpp 156.000, 2.45%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fPIC Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F0FF8220B33B46208D39A98937D55E50 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 133.000, 2.09%, 3, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang version 107.000, 1.68%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang O3 Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_C8A96266E0034C20898C147FC52F3A40 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 105.000, 1.65%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fdiagnostics color always Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_48A2FA7BE7AB44008B60558E412A9D30 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.c 105.000, 1.65%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ fPIC target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F510FB15C9A647108111A7010EFED240 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 91.000, 1.43%, 3, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ version 74.000, 1.16%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang c Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk fvisibility hidden O3 DNDEBUG MMD MF /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_BF6B4B6DACB843008E822CEFDC711230 fdiagnostics color always o build/.objs/main/macosx/x86_64/release/src/test.c.o src/test.c 73.000, 1.15%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ o build/macosx/x86_64/release/main build/.objs/main/macosx/x86_64/release/src/test.cpp.o build/.objs/main/macosx/x86_64/release/src/test8.cpp.o build/.objs/main/macosx/x86_64/release/src/test4.cpp.o build/.objs/main/macosx/x86_64/release/src/test5.cpp.o build/.objs/main/macosx/x86_64/release/src/test7.cpp.o build/.objs/main/macosx/x86_64/release/src/test6.cpp.o build/.objs/main/macosx/x86_64/release/src/test2.cpp.o build/.objs/main/macosx/x86_64/release/src/main.cpp.o build/.objs/main/macosx/x86_64/release/test3.cpp.o build/.objs/main/macosx/x86_64/release/src/test.c.o target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk lz Wl, x Wl, dead_strip 70.000, 1.10%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fPIC Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_6D0B6327841A47208939EEF194F38B50 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 68.000, 1.07%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang O3 Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_8AB279F8450D4D108E92951CC9C1C650 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp 65.000, 1.02%, 1, /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang fdiagnostics color always Qunused arguments target x86_64 apple macos15.1 isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX15.1.sdk S o /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_D25F0DB04D6D430084C098F1E1F76C00 /var/folders/32/w9cz0y_14hs19lkbs6v6_fm80000gn/T/.xmake501/241220/_F3443E45635A466AA3BEAE9DE99B4339.cpp ``` ### 追踪 xmake 的运行过程 ```bash $ XMAKE_PROFILE trace xmake func : @programdir/core/base/scheduler.lua: 457 is_suspended : @programdir/core/base/scheduler.lua: 86 status : @programdir/core/base/scheduler.lua: 71 thread : @programdir/core/base/scheduler.lua: 66 thread : @programdir/core/base/scheduler.lua: 66 length : @programdir/core/base/heap.lua: 120 ``` ### 分析运行卡死问题 可以用于获取 xmake 运行卡死时的栈。启用此特性后，通过 Ctrl+C 中断后就能获取栈。 ```bash $ XMAKE_PROFILE stuck xmake l test.lua <Ctrl+C> stack traceback: [C]: in function 'base/io.file_read' @programdir/core/base/io.lua:177: in method '_read' @programdir/core/sandbox/modules/io.lua:90: in function <@programdir/core/sandbox/module s/io.lua:89> (...tail calls...) /Users/ruki/share/test.lua:2: in function </Users/ruki/share/test.lua:1> (...tail calls...) @programdir/plugins/lua/main.lua:123: in function <@programdir/plugins/lua/main.lua:79> (...tail calls...) [C]: in function 'xpcall' @programdir/core/base/utils.lua:280: in function 'sandbox/modules/utils.trycall' (...tail calls...) @programdir/core/base/task.lua:519: in function 'base/task.run' @programdir/core/main.lua:278: in upvalue 'cotask' @programdir/core/base/scheduler.lua:371: in function <@programdir/core/base/scheduler.lu a:368> ``` ## XMAKE_RCFILES 设置全局配置文件 我们可以设置一些 xmakerc.lua 全局配置文件，在用户编译项目的时候，全局引入它们，比如全局引入一些用户自定义的帮助脚本，工具链什么的。 ```bash $ export XMAKE_RCFILES xmakerc.lua $ xmake ``` 如果不设置，默认路径为：`~/.xmake/xmakerc.lua`。 ## XMAKE_LOGFILE 设置日志文件路径 默认 xmake 会回显输出到终端，我们在可以通过设置这个路径，开启日志自动存储到指定文件，但它不会影响终端的正常回显输出。 ## XMAKE_MAIN_REPO 设置官方包主仓库地址 xmake 默认内置了三个主仓库地址，它们是完全相同的，xmake 会根据当前网络状态选择最优的地址来使用。 ``` https://github.com/xmake io/xmake repo.git https://gitlab.com/tboox/xmake repo.git https://gitee.com/tboox/xmake repo.git ``` 但如果 xmake 选择错误，可能会导致仓库下载失败，而通过这个环境变量，我们可以自己设置固定使用指定的仓库地址，不再进行自动选择。 ```bash $ export XMAKE_MAIN_REPO https://github.com/xmake io/xmake repo.git ``` ## XMAKE_BINARY_REPO 设置官方包预编译仓库地址 类似 `XMAKE_MAIN_REPO`，唯一的区别是，这个用于切换预编译仓库的地址。 ```bash $ export XMAKE_BINARY_REPO https://github.com/xmake mirror/build artifacts.git ``` ## XMAKE_THEME 设置主题 通常我们可以通过 `xmake g theme plain` 来设置颜色主题，但是它是全局的，如果想单独对当前终端会话设置，我们就可以使用这个环境变量来设置。 ```bash $ export XMAKE_THEME plain ``` ## XMAKE_STATS 开启或禁用用户量统计 由于目前 xmake 还在发展初期，我们需要知道大概的用户量增长情况，以便于提供我们持续更新 xmake 的动力。 因此 xmake 默认每天的第一次项目构建，会在后台进程自动 git clone 一个空仓库：<https://github.com/xmake io/xmake stats> 然后借用 github 自身提供的 Traffic 统计图表来获取大概的用户量。 对于每个项目，每天只会统计一次，并且不会泄露任何用户隐私，因为仅仅只是多了一次额外的 git clone 操作，另外我们 clone 的是一个空仓库，不会耗费用户多少流量。 当然，并不是每个用户都希望这么做，用户完全有权利去禁用这个行为，我们只需要设置： ```bash export XMAKE_STATS n ``` 就可以完全禁用它，另外我们也会在 ci 上自动禁用这个行为。 什么时候移除它？ 这个行为并不会永久存在，等到 xmake 有了足够多的用户量，或者有了其他更好的统计方式，我们会考虑移除相关统计代码。 当然，如果有非常多的用户反馈不愿意接受它，我们也会考虑移除它。 关于这个的相关 issues 见：[#1795](https://github.com/xmake io/xmake/issues/1795)"},"/get_started/zh/tutorial/install.html":{"title":"安装","content":"# 安装 ## 源码编译安装 ### 安装 > 切记，xmake 不建议在 root 下安装和使用，所以尽量不要在 root 下拉取源码编译安装。 ```bash git clone https://github.com/TOMO CAT/xmake.git cd ./xmake bash scripts/install.sh ``` 如果没有外网环境，可以通过 gitee 镜像拉取（xmake repo 也会自动切到 gitee 源）： ```bash git clone https://gitee.com/tomocat/xmake.git ``` 安装完后检查是否安装完成： ```bash xmake version ``` ### 启用 Luajit 对于一些大型项目（比如包含 300+ targets），我们可以启用 Luajit 加速构建，提升构建速度。 ```bash bash scripts/install.sh runtime luajit ``` ### 仅更新 lua 脚本 这个开发者本地调试 xmake 源码才需要： ```bash ./scripts/get.sh __local__ __install_only__ ``` ### 编译 xmake bundle 包 默认编译方式会安装 xmake 二进制和 Lua 脚本，这样做的好处是方便源码调试 Lua 脚本，但是不方便发布和迁移，可以只编译 xmake 二进制： ```bash # TODO: ``` ### root 下安装 xmake 不推荐 root 下安装使用，因为这很不安全。因此以 root 用户运行 xmake 会打印一条 warning 日志，用户可以设置环境变量 `XMAKE_ROOT y` 屏蔽相关的报警，用户需要随时注意root下误操作系统文件文件的风险。 ### 启用 ccache 默认情况下 xmake 用的是内部的 xcache，但可能会出现一些非预期的 bug。如果需要启用 ccache，可以手动安装 ccache，xmake会自动检测并使用。 ## 更新升级 我们可以通过 `xmake update` 命令来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个 tag 版本： ```bash # 如果不是 force 的话, xmake 版本一样就会跳过安装, 不会精确到 git tag / branch # 例如 xmake v3.0.4+dev.39db22335 版本也会跳过 xmake update force diagnosis verbose v3.0.4 ``` 我们也可以指定更新到 master/dev 分支版本： ```bash xmake update master xmake update dev ``` 从指定 git 源更新： ```bash # 指定 github 源 xmake update github:TOMO CAT/xmake#master # 指定 gitee 源 xmake update gitee:tomocat/xmake#dev ``` 如果 xmake/core 没动过，仅仅更新 xmake 的 lua 脚本改动，可以加 ` s/ scriptonly` 快速更新 lua 脚本： ```bash xmake update scriptonly force dev ``` ## 卸载 最后，我们如果要卸载 xmake，也是支持的： ```bash rm rf /usr/local/share/xmake rm /usr/local/bin/xrepo rm /usr/local/bin/xmake ```"},"/get_started/zh/tutorial/syntax-description.html":{"title":"语法描述","content":"# 语法描述 xmake 的工程描述文件 xmake.lua 虽然基于 lua 语法，但是为了使得更加方便简洁得编写项目构建逻辑，xmake 对其进行了一层封装，使得编写 xmake.lua 不会像写 makefile 那样繁琐 基本上写个简单的工程构建描述，只需四行就能搞定，例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` ## 域配置语法 我们默认约定的域配置语法，尽管非常简洁，但是对自动格式化缩进和 IDE 不是很友好。 ```lua target(\"foo\") set_kind(\"binary\") add_files(\"src/*.cpp\") target_end() ``` 另外，它不能自动结束当前 target 作用域，用户需要显式调用 `target_end()`。 虽然，上面我们提到，可以使用 `do end` 模式来解决自动缩进问题，但是需要 `target_end()` 的问题还是存在。 ```lua target(\"bar\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end target_end() ``` 我们提供了一种更好的可选域配置语法，来解决自动缩进，target 域隔离问题，例如： ```lua add_defines(\"ROOT\") target(\"foo\", function () set_kind(\"binary\") add_files(\"src/*.cpp\") add_defines(\"FOO\") end) target(\"bar\", function () set_kind(\"binary\") add_files(\"src/*.cpp\") add_defines(\"BAR\") end) ``` foo 和 bar 两个域是完全隔离的，我们即使在它们中间配置其他设置，也不会影响它们，另外，它还对 LSP 非常友好。 > 因此我们约定，xmake.lua 的域配置语法，默认采用可选的 `function () end` 模式，其他模式后续可能会被移除。 ## 配置分离 xmake.lua 采用二八原则实现了描述域、脚本域两层分离式配置。 什么是二八原则呢，简单来说，大部分项目的配置，80% 的情况下，都是些基础的常规配置，比如：`add_cxflags`, `add_links`等， 只有剩下不到 20% 的地方才需要额外做些复杂来满足一些特殊的配置需求。 而这剩余的 20% 的配置通常比较复杂，如果直接充斥在整个 xmake.lua 里面，会把整个项目的配置整个很混乱，非常不可读。 因此，xmake 通过描述域、脚本域两种不同的配置方式，来隔离 80% 的简单配置以及 20% 的复杂配置，使得整个 xmake.lua 看起来非常的清晰直观，可读性和可维护性都达到最佳。 ### 描述域 对于刚入门的新手用户，或者仅仅是维护一些简单的小项目，通过完全在描述配置就已经完全满足需求了，那什么是描述域呢？它长这样： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") add_syslinks(\"pthread\") end) ``` 一眼望去，其实就是个 `set_xxx`/`add_xxx` 的配置集，对于新手，完全可以不把它当做 lua 脚本，仅仅作为普通的，但有一些基础规则的配置文件就行了。 如果因为，看着有括号，还是像脚本语言的函数调用，那我们也可以这么写（是否带括号看个人喜好）： ```lua target \"test\"     set_kind \"binary\"     add_files \"src/*.c\"     add_defines \"DEBUG\"     add_syslinks \"pthread\" ``` 这是不是看着更像配置文件了？其实描述域就是配置文件，类似像 json 等 key/values 的配置而已，所以即使完全不会 lua 的新手，也是能很快上手的。 而且，对于通常的项目，仅通过 `set_xxx/add_xxx` 去配置各种项目设置，已经完全满足需求了。 这也就是开头说的：80% 的情况下，可以用最简单的配置规则去简化项目的配置，提高可读性和可维护性，这样对用户和开发者都会非常的友好，也更加直观。 如果我们要针对不同平台，架构做一些条件判断怎么办？没关系，描述域除了基础配置，也是支持条件判断，以及 for 循环的： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") if is_plat(\"linux\", \"macosx\") then add_links(\"pthread\", \"m\", \"dl\") end end) ``` ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"DEBUG\") for _, name in ipairs({\"pthread\", \"m\", \"dl\"}) do add_links(name) end end) ``` 这是不是看着有点像 lua 了？虽说，平常可以把它当做普通配置问题，但是 xmake 毕竟基于 lua，所以描述域还是支持 lua 的基础语言特性的。 > 不过需要注意的是，描述域虽然支持 lua 的脚本语法，但在描述域尽量不要写太复杂的 lua 脚本，比如一些耗时的函数调用和 for 循环 并且在描述域，主要目的是为了设置配置项，因此 xmake 并没有完全开放所有的模块接口，很多接口在描述域是被禁止调用的， 即使开放出来的一些可调用接口，也是完全只读的，不耗时的安全接口，比如：`os.getenv()` 等读取一些常规的系统信息，用于配置逻辑的控制。 > 另外需要注意一点，xmake.lua 是会被多次解析的，用于在不同阶段解析不同的配置域：比如：`option()`, `target()` 等域。 因此，不要想着在 xmake.lua 的描述域，写复杂的 lua 脚本，也**不要在描述域调用 print 去显示信息，因为会被执行多遍**。 ### 脚本域 限制描述域写复杂的 lua，各种 lua 模块和接口都用不了？怎么办？这个时候就是脚本域出场的时候了。 如果用户已经完全熟悉了 xmake 的描述域配置，并且感觉有些满足不了项目上的一些特殊配置维护了，那么我们可以在脚本域做更加复杂的配置逻辑： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_load(function (target) if is_plat(\"linux\", \"macosx\") then target:add(\"links\", \"pthread\", \"m\", \"dl\") end end) after_build(function (target) import(\"core.project.config\") local targetfile target:targetfile() os.cp(targetfile, path.join(config.buildir(), path.filename(targetfile))) print(\"build %s\", targetfile) end) end) ``` 只要是类似：`on_xxx`, `after_xxx`, `before_xxx` 等字样的 function body 内部的脚本，都属于脚本域。 在脚本域中，用户可以干任何事，xmake 提供了 import 接口可以导入 xmake 内置的各种 lua 模块，也可以导入用户提供的 lua 脚本。 我们可以在脚本域实现你想实现的任意功能，甚至写个独立项目出来都是可以的。 对于一些脚本片段，不是很臃肿的话，像上面这么内置写写就足够了，如果需要实现更加复杂的脚本，不想充斥在一个 xmake.lua 里面，可以把脚本分离到独立的 lua 文件中去维护。 例如： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") on_load(\"modules.test.load\") on_install(\"modules.test.install\") end) ``` 我们可以把自定义的脚本放置到 xmake.lua 对应目录下，`modules/test/load.lua` 和 `modules/test/install.lua` 中独立维护。 这些独立的 lua 脚本里面，我们还可以通过[import](/zh cn/manual/builtin_modules?id import)导入各种内置模块和自定义模块进来使用，就跟平常写lua, java 没啥区别。 而对于脚本的域的不同阶段，`on_load` 主要用于 target 加载时候，做一些动态化的配置（注意这里不像描述域，只会执行一遍）。 其他阶段，还有很多，比如：`on/after/before`_`build/install/package/run` 等，具体看下后面的 target api 手册部分吧，这里就不细说了。 ## 配置类型 在描述域配置中，分配置域和配置项，配置域里面可以通过 `set_xxx`/`add_xxx` 的接口，配置各种配置项。 ```lua target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 像上述配置中，target 就属于配置域，它下面的所有 `set_xx`/`add_xxx` 接口配置都属于配置项，对这个 target 局部生效。 我们可以把它理解成局部作用域，类似 c 里面的 block 块： ``` target(\"test1\") { set_kind(\"binary\") add_files(\"src/*.c\") } target(\"test2\") { set_kind(\"binary\") add_files(\"src/*.c\") } ``` 不过，为了简化写法，xmake 约定每个新定义的 target 域开始，上一个配置域就自动结束了，当然，如果这样用户觉得有困扰，也可以手动配置离开域： ```lua target(\"test1\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() target(\"test2\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() ``` ### 配置域 目前提供的配置域有：`target()`, `option()`, `task()`, `package()` 每个域的详细说明，见：[API手册](/zh cn/manual/project_target) ### 配置项 只要是带有 `set_xxx` 和 `add_xxx` 字样的配置，都属于配置项，一个配置域里面可以设置多个配置项。 关于配置项的规范说明，见：[接口规范](/zh cn/manual/specification) ## 作用域 xmake 的描述语法是按作用域划分的，主要分为： 外部作用域 内部作用域 接口作用域 那哪些属于外部，哪些又属于内部呢，看看下面的注释，就知道个大概了： ```lua 外部作用域 target(\"test\", function() 外部作用域 set_kind(\"binary\") add_files(\"src/*.c\") on_run(function () 内部作用域 end) after_package(function () 内部作用域 end) end) 外部作用域 task(\"hello\", function() 外部作用域 on_run(function () 内部作用域 end) end) ``` 简单的说，就是在自定义脚本 `function () end` 之内的都属于内部作用域，也就是脚本作用域，其他地方都是都属于于外部作用域。。 ### 外部作用域 对于大部分工程来说，并不需要很复杂的工程描述，也不需要自定义脚本支持，只需要简单的 `set_xxx` 或者 `add_xxx` 就能满足需求了 那么根据二八定律，80% 的情况下，我们只需要这么写： ```lua target(\"test\", function() set_kind(\"static\") add_files(\"src/test/*.c\") end) target(\"demo\", function() add_deps(\"test\") set_kind(\"binary\") add_links(\"test\") add_files(\"src/demo/*.c\") end) ``` 不需要复杂的 api 调用，也不需要各种繁琐的变量定义，以及 if 判断 和 for 循环，要的就是简洁可读，一眼看过去，就算不懂 lua 语法也没关系 就当做简单的描述语法，看上去有点像函数调用而已，会点编程的基本一看就知道怎么配置。 为了做到简洁、安全，在这个作用域内，很多 lua 内置 api 是不开放出来的，尤其是跟写文件、修改操作环境相关的，仅仅提供一些基本的只读接口，和逻辑操作 目前外部作用域开放的 lua 内置 api 有： table string pairs ipairs print os 当然虽然内置 lua api 提供不多，但 xmake 还提供了很多扩展 api，像描述 api 就不多说，详细可参考：[API手册](/zh cn/manual/builtin_modules) 还有些辅助 api，例如： dirs：扫描获取当前指定路径中的所有目录 files：扫描获取当前指定路径中的所有文件 format: 格式化字符串，string.format 的简写版本 还有变量定义、逻辑操作也是可以使用的，毕竟是基于 lua 的，该有的基础语法，还是要有的，我们可以通过 if 来切换编译文件： ```lua target(\"test\", function() set_kind(\"static\") if is_plat(\"iphoneos\") then add_files(\"src/test/ios/*.c\") else add_files(\"src/test/*.c\") end end) ``` 需要注意的是，变量定义分全局变量和局部变量，局部变量只对当前 xmake.lua 有效，不影响子 xmake.lua ```lua 局部变量，只对当前xmake.lua有效 local var1 0 全局变量，影响所有之后 includes() 包含的子 xmake.lua var2 1 includes(\"src\") ``` ### 内部作用域 也称插件、脚本作用域，提供更加复杂、灵活的脚本支持，一般用于编写一些自定义脚本、插件开发、自定义 task 任务、自定义模块等等 一般通过 `function () end` 包含，并且被传入到 `on_xxx`, `before_xxx` 和 `after_xxx` 接口内的，都属于自作用域。 例如： ```lua 自定义脚本 target(\"hello\", function() after_build(function () 内部作用域 end) end) 自定义任务、插件 task(\"hello\", function() on_run(function () 内部作用域 end) end) ``` 在此作用域中，不仅可以使用大部分 lua 的 api，还可以使用很多 xmake 提供的扩展模块，所有扩展模块，通过 import 来导入 具体可参考：[import模块导入文档](/zh cn/manual/builtin_modules?id import) 这里我们给个简单的例子，在编译完成后，对 ios 目标程序进行 ldid 签名： ```lua target(\"iosdemo\", function() set_kind(\"binary\") add_files(\"*.m\") after_build(function (target) 执行签名，如果失败，自动中断，给出高亮错误信息 os.run(\"ldid S$(projectdir)/entitlements.plist %s\", target:targetfile()) end) end) ``` 需要注意的是，在内部作用域中，所有的调用都是启用异常捕获机制的，如果运行出错，会自动中断 xmake，并给出错误提示信息 因此，脚本写起来，不需要繁琐的 `if retval then` 判断，脚本逻辑更加一目了然 ### 接口作用域 在外部作用域中的所有描述api设置，本身也是有作用域之分的，在不同地方调用，影响范围也不相同，例如： ```lua 全局根作用域，影响所有 target，包括 includes() 中的子工程 target 设置 add_defines(\"DEBUG\") 定义或者进入 demo 目标作用域（支持多次进入来追加设置） target(\"demo\", function() set_kind(\"shared\") add_files(\"src/*.c\") 当前 target 作用域，仅仅影响当前 target add_defines(\"DEBUG2\") end) 选项设置，仅支持局部设置，不受全局 api 设置所影响 option(\"test\", function() 当前选项的局部作用域 set_default(false) end) 其他target设置， DDEBUG 也会被设置上 target(\"demo2\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) 重新进入demo目标作用域 target(\"demo\", function() 追加宏定义，只对当前demo目标有效 add_defines(\"DEBUG3\") end) ``` 通常情况下，进入另一个 target/option 域设置，会自动离开上个 target/option 域，但是有时候为了比较一些作用域污染情况，我们可以显示离开某个域，例如： ```lua option(\"test\") set_default(false) option_end() target(\"demo\") set_kind(\"binary\") add_files(\"src/*.c\") target_end() ``` 调用 `option_end()`, `target_end()` 即可显式的离开当前 target/option 域设置。 ### 代码格式化 由于默认的描述域配置语法的缩进并不符合 lua 格式规范，因此 lua language server 是不支持对它进行格式化处理的。 如果想要让 IDE，编辑器更好的对配置进行格式化缩进支持，我么可以通过 `do end` 的写法来处理： ```lua target(\"bar\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end target(\"foo\") do set_kind(\"binary\") add_files(\"src/*.cpp\") end ``` 这样，Lua LSP 就能把它作为标准的 lua 代码进行正确的格式化，是否需要这么做，看用户自己的需求。 如果没有代码自动格式化的使用习惯，那就不需要这么做。 ## 多级配置 在脚本域我们可以通过 import 导入各种丰富的扩展模块来使用，而在描述域我们可以通过[includes](/#/zh cn/manual/global_interfaces?id includes)接口，来引入项目子目录下的 xmake.lua 配置。 记住：xmake 的 includes 是按照 tree 结构来处理配置关系的，子目录下的 xmake.lua 里面的 target 配置会继承父 xmake.lua 中的根域配置，例如： 目前有如下项目结构： ``` projectdir xmake.lua src xmake.lua ``` `projectdir/xmake.lua` 是项目的根 xmake.lua 配置，而 `src/xmake.lua` 是项目的子配置。 `projectdir/xmake.lua` 内容： ```lua add_defines(\"ROOT\") target(\"test1\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST1\") end) target(\"test2\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST2\") end) includes(\"src\") ``` 里面全局根域配置了 `add_defines(\"ROOT\")`，会影响下面的所有 target 配置，包括 includes 里面子 xmake.lua 中的所有 target 配置，所以这个是全局总配置。 而在 test1/test2 里面的 `add_defines(\"TEST1\")` 和 `add_defines(\"TEST2\")` 属于局部配置，只对当前 target 生效。 `src/xmake.lua` 内容： ```lua add_defines(\"ROOT2\") target(\"test3\", function() set_kind(\"binary\") add_files(\"src/*.c\") add_defines(\"TEST3\") end) ``` 在 `src/xmake.lua` 子配置中，也有个全局根域，配置了 `add_defines(\"ROOT2\")`，这个属于子配置根域，只对当前子 xmake.lua 里面所有 target 生效，也会对下级 includes 里面的子 xmake.lua 中 target 生效，因为之前说了，xmake 是 tree 状结构的配置继承关系。 所以，这几个 target 的最终配置结果依次是： ``` target(\"test1\"): DROOT DTEST1 target(\"test2\"): DROOT DTEST2 target(\"test3\"): DROOT DROOT2 DTEST3 ``` ## 语法简化 xmake.lua 的配置域语法，非常灵活，可以在相关域做各种复杂灵活的配置，但是对于许多精简的小块配置，这个时候就稍显冗余了： ```lua option(\"test1\", function() set_default(true) set_showmenu(true) set_description(\"test1 option\") end) option(\"test2\", function() set_default(true) set_showmeu(true) end) option(\"test3\", function() set_default(\"hello\") end) ``` 对于上面的这些小块 option 域设置，我们可以简化下成单行描述： ```lua option(\"test1\", {default true, showmenu true, description \"test1 option\"}) option(\"test2\", {default true, showmenu true}) option(\"test3\", {default \"hello\"}) ``` 除了 option 域，对于其他域也是支持这种简化写法的，例如： ```lua target(\"demo\", function() set_kind(\"binary\") add_files(\"src/*.c\") end) ``` 简化为： ```lua target(\"demo\", {kind \"binary\", files \"src/*.c\"}) ``` 或者 ```lua target(\"demo\", { kind \"binary\", files \"src/*.c\" }) ``` 当然，如果配置需求比较复杂的，还是原有的多行设置方式更加方便，这个就看自己的需求来评估到底使用哪种方式了。"},"/get_started/zh/tutorial/FAQ.html":{"title":"FAQ","content":"# FAQ ## 怎样获取更多参数选项信息？ 获取主菜单的帮助信息，里面有所有 action 和 plugin 的列表描述。 ```bash $ xmake [ h help] ``` 获取配置菜单的帮助信息，里面有所有配置选项的描述信息，以及支持平台、架构列表。 ```bash $ xmake f [ h help] ``` 获取 action 和 plugin 命令菜单的帮助信息，里面有所有内置命令和插件任务的参数使用信息。 ```bash $ xmake [actionplugin] [ h help] ``` 例如，获取 `run` 命令的参数信息 : ```bash $ xmake run help ``` ## 怎样实现静默构建，不输出任何信息？ ```bash $ xmake [ q quiet] ``` ## 如果 xmake 运行失败了怎么办？ 可以先尝试清除下配置，重新构建下： ```bash $ xmake f c $ xmake ``` 如果还是失败了，请加上 ` v` 或者 ` verbose` 选项重新执行 xmake 后，获取更加详细的输出信息 例如： ```hash $ xmake [ v verbose] ``` 并且可以加上 ` D` 选项获取出错时的 xmake 的调试栈信息和其他更详细的诊断信息 , 然后你可以提交这些信息到 [issues](https://github.com/TOMO CAT/xmake/issues)。 ```bash $ xmake v D ``` ## 怎样看实时编译警告信息 ? 为了避免刷屏，在构建时候，默认是不实时输出警告信息的，如果想要看的话可以加上 ` w` 选项启用编译警告输出就行了。 ```bash $ xmake [ w warning] ``` ## 怎样基于源码自动生成 xmake.lua？ 如果你想临时写一两个测试代码、或者手上有一些移植过来的零散源码想要快速编译运行，可以不用专门写 xmake.lua，直接运行： ```bash $ xmake ``` xmake 会自动扫描分析当前的源码目录，识别程序结构和类型，生成一个 xmake.lua，并且会尝试直接构建它。 如果编译成功，可以直接运行： ```bash $ xmake run ``` 当然，如果仅仅只是想要生成 xmake.lua，默认不去构建，可以执行： ```bash $ xmake f y ``` 更多相关介绍，请参考文章：[xmake 新增智能代码扫描编译模式，无需手写任何 make 文件](https://tboox.org/cn/2017/01/07/build without makefile/) ## 为什么 xmake.lua 会被执行多遍？ xmake.lua 里面分描述域和脚本域，在描述域里面会对各种配置域进行分阶段多次解析，有可能会执行多遍，因此不要在描述域写复杂的脚本。 如果要写各种复杂脚本，请在脚本域内进行配置，`target/on_load` 的脚本域里面同样可以灵活配置各种 target 相关设置，并且提供更强大的 lua 脚本模块支持。 更多细节见：[描述语法说明](/zh cn/guide/syntax_description) ## 如何调试 Xmake 源码? ### 下载源码 由于 xmake 使用了 git submodules 维护子模块，因此我们可以通过下面几种方式拉取完整源码。 #### 使用 git 拉取 ```bash $ git clone recursive https://github.com/TOMO CAT/xmake.git ``` 或者 ```bash $ git clone https://github.com/TOMO CAT/xmake.git $ git submodule update init ``` #### 从 Github Releases 下载源码包 由于 github 本身的 downloads 附件下载不支持归档 submodules，因此 Xmake 每次发版都会完整打包一份额外的 tar 包源码上传到 Releases 上。 因此，不要下载错误的链接地址 不完整源码：<https://github.com/TOMO CAT/xmake/archive/refs/tags/v3.0.4.tar.gz> 完整源码包：<https://github.com/TOMO CAT/xmake/releases/download/v3.0.4/xmake v3.0.4.tar.gz> ```bash wget https://github.com/TOMO CAT/xmake/releases/download/v3.0.4/xmake v3.0.4.tar.gz tar xvf xmake v3.0.4.tar.gz C xmake cd xmake ``` > Xmake 的 tar 源码包没有顶层 xmake 根目录，因此解压时候最好带上 ` C xmake` 指定下输出目录。 ### 编译源码 类 unix 平台环境编译 Xmake，我们只需要在源码根目录执行 make 就行了。 ```bash $ cd xmake $ ./configure $ make ``` ### 加载调试 如果编译完成，我们就可以加载刚刚编译好的 Xmake 二进制 core 程序，然后运行本地的 Lua 脚本了。 在 Linux/macOS/FreeBSD 上只需要运行： ```bash $ cd xmake $ source scripts/srcenv.profile ``` 就能进入本地源码调试环境。 我们也可以运行： ```bash $ xmake l os.programdir ``` 来验证我们是否真的加载了本地的 Lua 脚本环境。 ### 调试 core 二进制 通常调试 Xmake 的 Lua 脚本，只需要直接修改当前源码目录的 Lua 脚本就行了，实时生效的，我们并不需要重复编译 core 二进制。 但是如果是 Xmake 的 C 端 core 程序有问题，需要调试或者加模块，那么就需要重复编译了。 编译完成，也是实时生效的，我们可以在 C 代码里通过： ```c xu_trace_i(\"hello %s\", \"xmake\"); ``` 来格式化打印各种输出。 如果是 sv 等 Xmake 依赖的各种 submodules 子模块有问题，需要调试。 我们也可以直接进入子模块源码，修改后重新编译执行。 但是，如果需要贡献修复补丁，我们需要提交 pr 给子模块的仓库才行，补丁合并后，作者会在特定时间同步到到 xmake 源码仓库。 ### 断点调试 xmake 也支持 Lua 断点调试支持，配合 [VSCode EmmyLua](https://github.com/EmmyLua/VSCode EmmyLua) 插件，我们可以很方便的在 VSCode 中断点调试 xmake 自身源码。 首先，我们需要在 VSCode 的插件市场安装 VSCode EmmyLua 插件，然后执行下面的命令更新下 xmake repo 仓库保持最新。 ```bash xrepo update repo ``` > Xmake 也需要保持最新版本。 然后，在自己的工程目录下执行以下命令： ```bash $ xrepo env b emmylua_debugger xmake build ``` 其中 `xrepo env b emmylua_debugger` 用于绑定 EmmyLua 调试器插件环境，而 ` ` 后面的参数，就是我们实际需要被调试的 xmake 命令。 通常我们仅仅调试 `xmake build` 构建，如果想要调试其他命令，可以自己调整，比如想要调试 `xmake install o /tmp` 安装命令，那么可以改成： ```bash $ xrepo env b emmylua_debugger xmake install o /tmp ``` 执行完上面的命令后，它不会立即退出，会一直处于等待调试状态，有可能没有任何输出。 这个时候，我们不要急着退出它，继续打开 VSCode，并在 VSCode 中打开 Xmake 的 Lua 脚本源码目录。 也就是这个目录：[Xmake Lua Scripts](https://github.com/xmake io/xmake/tree/master/xmake)，我们可以下载的本地，也可以直接打开 Xmake 安装目录中的 lua 脚本目录。 然后切换到 VSCode 的调试 Tab 页，点击 `RunDebug` > `Emmylua New Debug` 就能连接到我们的 `xmake build` 命令调试端，开启调试。 如下图所示，默认的起始断点会自动中断到 `debugger:_start_emmylua_debugger` 内部，我们可以点击单步跳出当前函数，就能进入 main 入口。 ![](./image/xmake debug.png) 然后设置自己的断点，点击继续运行，就能中断到自己想要调试的代码位置。 我们也可以在项目工程的配置脚本中设置断点，也可以实现快速调试自己的配置脚本，而不仅仅是 xmake 自身源码。 ![](./image/xmake debug2.png) ### 远程调试 xmake 也能支持远程调试，在虚拟机中调试往往体验不佳，因此通常会远程连到其他主机上去调试 xmake 源码。 我们先在远程机器上开启远程编译服务： ```bash $ xmake service ``` 然后本机打开需要构建的工程目录，执行远程连接，然后执行 `xmake service sync xmakesrc ` 去同步本地源码： ```bash $ xmake service connect $ xmake service sync xmakesrc ~/projects/personal/xmake/xmake/ $ xmake build $ xmake run ``` 这样，我们就能本地修改 xmake 脚本源码，然后同步到远程机器上，再远程执行 xmake 构建命令获取对应的调试输出，以及分析构建行为。 我们也能够通过 `xmake service pull ` 命令，回拉远程的文件到本地，进行分析。 > 注：详细的远程编译特性说明，见 [远程编译文档](http://xmake.io/#/zh cn/features/remote_build)。 ![](./image/xmake remote.png) ## 如何调试仓库包? 调试的方式有很多种，这里我主要介绍最常使用的调试方式，那就是直接拉取 xmake repo 仓库来调试。 ```bash $ git clone https://github.com/xmake io/xmake repo.git $ xmake l scripts/test.lua vD shallow zlib ``` 使用上面 test.lua 脚本命令来调试包，我们可以重复安装测试指定的包，` shallow` 告诉 xmake 每次测试不去重复完整安装它的所有依赖包，仅仅测试按照当前包。 我们也可以测试指定的平台，架构，编译模式， vs_runtime 和动态库，静态库等等。 ```bash $ xmake l scripts/test.lua vD shallow p mingw mingw /xxx/sdk zlib $ xmake l scripts/test.lua vD shallow p iphoneos a arm64 zlib $ xmake l scripts/test.lua vD shallow k shared vs_runtime MD zlib $ xmake l scripts/test.lua vD shallow m debug zlib ``` ### 调试本地包源码 有时候，由于包的源码和构建脚本有问题，我们需要修改一些代码才能继续测试安装，如果通过 add_patches/io.replace 的方式在 on_install 里面去修改调试，非常繁琐。 因此，我们可以通过指定 ` d package_sourcedir` 方式，直接让测试脚本进入我们预先下载好的包源码目录，测试编译安装，我们每次的代码修改不会被重置。 ```bash $ xmake l scripts/test.lua vD shallow d /tmp/zlib 1.2.11 zlib ``` 等修改调试通过后，我们再根据改动，通过 `git diff > fix.patch` 生成补丁文件，通过 `add_patches` 配置应用补丁包，来修复包的安装。 ### 远程调试包源码 我们也可以远程调试包，先开启远程服务： ```bash $ xmake service ``` 然后传入 ` remote` 参数，即可实现远程包编译测试。 ```bash $ xmake l scripts/test.lua vD shallow remote /tmp/zlib 1.2.11 zlib ``` ## 下载包提示证书校验失败怎么办？ ```bash curl: (60) SSL certificate problem: unable to get local issuer certificate More details here: https://curl.se/docs/sslcerts.html curl failed to verify the legitimacy of the server and therefore could not establish a secure connection to it. To learn more about this situation and how to fix it, please visit the web page mentioned above. ``` 如果你在使用 Xmake 安装依赖包时候，遇到上面的证书验证问题，你可以尝试更新 curl 证书去修复它，或者直接全局配置禁用证书验证来绕过它。 ```bash $ xmake g insecure ssl y ``` 当然，禁用证书验证会带来一定的安全性风险，不过好在 xmake repo 仓库中的包，有严格的 sha256 校验，即使下载被劫持，最终也会 xmake 的 sha256 校验检测到，作为无效下载。"},"/get_started/zh/tutorial/configuration.html":{"title":"配置说明","content":"# 配置说明 通过 `xmake fconfig` 配置命令，设置构建前的相关配置信息，详细参数选项，请运行: `xmake f help`。 > **Tips**: > 你可以使用命令行缩写来简化输入，也可以使用全名，例如: > > * `xmake f` 或者 `xmake config` > * `xmake f p linux` 或者 `xmake config plat linux` ## 目标平台 ### 主机平台 ```bash $ xmake ``` > xmake将会自动探测当前主机平台，默认自动生成对应的目标程序。 ### Linux ```bash $ xmake f p linux [ a i386x86_64] $ xmake ``` ### Android ```bash $ xmake f p android ndk ~/files/android ndk r10e/ [ a armeabi v7aarm64 v8a] $ xmake ``` 如果要手动指定 ndk 中具体某个工具链，而不是使用默认检测的配置，可以通过[ bin](# bin)来设置，例如： ```bash $ xmake f p android ndk ~/files/android ndk r10e/ a arm64 v8a bin ~/files/android ndk r10e/toolchains/aarch64 linux android 4.9/prebuilt/darwin x86_64/bin ``` [ bin](# bin)主要用于设置选择编译工具的具体 bin 目录，这个的使用跟[交叉编译](#交叉编译配置)中的[ bin](# bin)的行为是一致的。 > 如果手动设置了 bin 目录，没有通过检测，可以看下是否 ` arch ` 参数没有匹配对。 ### iPhoneOS ```bash $ xmake f p iphoneos [ a armv7armv7sarm64i386x86_64] $ xmake ``` 由于 m1 设备上模拟器也支持 arm64 架构，因此之前单纯从 arch 去区分是否为模拟器，已无法满足需求。 因此我们新增了一个参数配置去区分是否为模拟器目标。 ```bash $ xmake f p iphoneos appledev simulator $ xmake f p watchos appledev simulator $ xmake f p appletvos appledev simulator ``` ### Mac Catalyst 我们也可以指定构建 Mac Catalyst 程序。 ```bash $ xmake f appledev catalyst ``` ### Apple WatchOS ```bash $ xmake f p watchos [ a i386armv7k] $ xmake ``` ### Wasm (WebAssembly) 此平台用于编译 WebAssembly 程序（内部会使用 emcc 工具链），在切换此平台之前，我们需要先进入 Emscripten 工具链环境，确保 emcc 等编译器可用。 ```bash $ xmake f p wasm $ xmake ``` xmake 也支持 Qt for wasm 编译，只需要： ```bash $ xmake f p wasm [ qt ~/Qt] $ xmake ``` 其中 ` qt` 参数设置是可选的，通常 xmake 都能检测到 qt 的 sdk 路径。 需要注意的一点是，Emscripten 和 Qt SDK 的版本是有对应关系的，不匹配的版本，可能会有 Qt/Wasm 之间的兼容问题。 关于版本对应关系，可以看下：[https://wiki.qt.io/Qt_for_WebAssembly](https://wiki.qt.io/Qt_for_WebAssembly) 更多详情见：[https://github.com/xmake io/xmake/issues/956](https://github.com/xmake io/xmake/issues/956) 除了 emscripten 以外，还有一个常用的 wasm 工具链 wasi sdk，用于构建基于 wasi 的程序，我们仅仅只需要切换工具链即可。 ```bash $ xmake f p wasm toolchain wasi $ xmake ``` ### HarmonyOS (鸿蒙) xmake 也提供了鸿蒙 OS 平台的 native 工具链编译支持： ```bash $ xmake f p harmony ``` xmake 会自动探测默认的 SDK 路径，当然我们也可以指定 Harmony SDK 路径。 ```bash $ xmake f p Harmony sdk /Users/ruki/Library/Huawei/Sdk/openharmony/10/native ``` ## 交叉编译配置 通常，如果我们需要在当前 pc 环境编译生成其他设备上才能运行的目标文件时候，就需要通过对应的交叉编译工具链来编译生成它们，比如在 macos 上编译 linux 的程序，或者在 linux 上编译其他嵌入式设备的目标文件等。 通常的交叉编译工具链都是基于 gcc/clang 的，大都具有类似如下的结构： ``` /home/toolchains_sdkdir bin arm linux armeabi gcc arm linux armeabi ld ... lib libxxx.a include xxx.h ``` 每个工具链都有对应的 include/lib 目录，用于放置一些系统库和头文件，例如 libc, stdc++ 等，而 bin 目录下放置的就是编译工具链一系列工具。例如： ``` arm linux armeabi ar arm linux armeabi as arm linux armeabi c++ arm linux armeabi cpp arm linux armeabi g++ arm linux armeabi gcc arm linux armeabi ld arm linux armeabi nm arm linux armeabi strip ``` 其中 `arm linux armeabi ` 前缀就是 cross，通过用来标示目标平台和架构，主要用于跟主机自身的 gcc/clang 进行区分。 里面的 gcc/g++ 就是 c/c++ 的编译器，通常也可以作为链接器使用，链接的时候内部会去调用 ld 来链接，并且自动追加一些 c++ 库。 cpp 是预处理器，as 是汇编器，ar 用于生成静态库，strip 用于裁剪掉一些符号信息，使得目标程序会更加的小。nm 用于查看导出符号列表。 ### 自动探测和编译 如果我们的交叉编译工具链是上文的结构，xmake 会自动检测识别这个 sdk 的结构，提取里面的 cross，以及 include/lib 路径位置，用户通常不需要做额外的参数设置，只需要配置好 sdk 根目录就可以编译了，例如： ```bash $ xmake f p cross sdk /home/toolchains_sdkdir $ xmake ``` 其中，` p cross` 用于指定当前的平台是交叉编译平台，` sdk ` 用于指定交叉工具链的根目录。 > 注：我们也可以指定 ` p linux` 平台来配置交叉编译，效果是一样的，唯一的区别是额外标识了 linux 平台名，方便 xmake.lua 里面通过 `is_plat(\"linux\")` 来判断平台。 这个时候，xmake 会去自动探测 gcc 等编译器的前缀名 cross：`arm linux armeabi `，并且编译的时候，也会自动加上**链接库**和**头文件**的搜索选项，例如： ``` I/home/toolchains_sdkdir/include L/home/toolchains_sdkdir/lib ``` 这些都是 xmake 自动处理的，不需要手动配置他们。 ### 手动配置编译 如果上面的自动检测对某些工具链，还无法完全通过编译，就需要用户自己手动设置一些交叉编译相关的配置参数，来调整适应这些特殊的工具链了，下面我会逐一讲解如何配置。 ### 设置工具链 bin 目录 对于不规则工具链目录结构，靠单纯地[ sdk](# sdk)选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的 bin 目录位置。 例如：一些特殊的交叉工具链的，编译器bin目录，并不在 `/home/toolchains_sdkdir/bin` 这个位置，而是独立到了 `/usr/opt/bin`。 这个时候，我们可以在设置了 sdk 参数的基础上追加 bin 目录的参数设置，来调整工具链的 bin 目录。 ```bash $ xmake f p cross sdk /home/toolchains_sdkdir bin /usr/opt/bin $ xmake ``` ### 设置交叉工具链工具前缀 像 `aarch64 linux android ` 这种，通常如果你配置了` sdk` 或者 ` bin` 的情况下，xmake 会去自动检测的，不需要自己手动设置。 但是对于一些极特殊的工具链，一个目录下同时有多个 cross 前缀的工具 bin 混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个 bin。 例如，toolchains 的 bin 目录下同时存在两个不同的编译器： ``` /opt/bin armv7 linux gcc aarch64 linux gcc ``` 我们现在想要选用 armv7 的版本，那么我们可以追加 ` cross ` 配置编译工具前缀名，例如： ```bash $ xmake f p cross sdk /usr/toolsdk bin /opt/bin cross armv7 linux ``` ### 设置 c/c++ 编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p cross sdk /user/toolsdk cc armv7 linux clang cxx armv7 linux clang++ ``` 当然，我们也可以指定编译器全路径。 ` cc` 用于指定 c 编译器名，` cxx` 用于指定 c++ 编译器名。 > 注：如果存在 CC/CXX 环境变量的话，会优先使用当前环境变量中指定的值。 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 这个时候我们可以通过： ```bash xmake f cxx clang++@/home/xxx/c++mips.exe ``` 设置 c++mips.exe 编译器作为类 clang++ 的使用方式来编译。 也就是说，在指定编译器为 `c++mips.exe` 的同时，告诉 xmake，它跟 clang++ 用法和参数选项基本相同。 ### 设置 c/c++ 链接器 如果还要继续细分选择链接器，则继续追加相关链接器选项，例如： ```bash $ xmake f p cross sdk /user/toolsdk ld armv7 linux clang++ sh armv7 linux clang++ ar armv7 linux ar ``` ld 指定可执行程序链接器，sh 指定共享库程序链接器，ar 指定生成静态库的归档器。 注：如果存在 LD/SH/AR 环境变量的话，会优先使用当前环境变量中指定的值。 ### 设置头文件和库搜索目录 如果 sdk 里面还有额外的其他 include/lib 目录不在标准的结构中，导致交叉编译找不到库和头文件，那么我们可以通过 ` includedirs` 和 ` linkdirs` 来追加搜索路径，然后通过 ` links` 添加额外的链接库。 ```bash $ xmake f p cross sdk /usr/toolsdk includedirs /usr/toolsdk/xxx/include linkdirs /usr/toolsdk/xxx/lib links pthread ``` > 注：如果要指定多个搜索目录，可以通过 `:` 或者 `;` 来分割，也就是不同主机平台的路径分隔符，linux/macos下用`:`，win下用`;`。 ### 设置编译和链接选项 我们也可以根据实际情况通过 ` cflags`, ` cxxflags`，` ldflags`，` shflags` 和 ` arflags` 额外配置一些编译和链接选项。 * cflags: 指定c编译参数 * cxxflags：指定c++编译参数 * cxflags: 指定c/c++编译参数 * asflags: 指定汇编器编译参数 * ldflags: 指定可执行程序链接参数 * shflags: 指定动态库程序链接参数 * arflags: 指定静态库的生成参数 例如： ```bash $ xmake f p cross sdk /usr/toolsdk cflags \" DTEST I/xxx/xxx\" ldflags \" lpthread\" ``` ### 项目描述设置 #### set_toolchains 这对某个特定的 target 单独切换设置不同的工具链，和 set_toolset 不同的是，此接口是对完整工具链的整体切换，比如 cc/ld/sh 等一系列工具集。 这也是推荐做法，因为像 gcc/clang 等大部分编译工具链，编译器和链接器都是配套使用的，要切就得整体切，单独零散的切换设置会很繁琐。 比如我们切换 test 目标到 clang+yasm 两个工具链： ```lua target(\"test\", function() set_kind(\"binary\") add_files(\"src/*.c\") set_toolchains(\"clang\", \"yasm\") end) ``` #### set_toolset 如果觉得每次通过命令行配置比较繁琐，有些配置可以通过在 xmake.lua 预先配置好，来简化命令配置，比如编译器的指定，就可以通过 `set_toolset` 来对每个 target 单独设置。 ```lua target(\"test\", function() set_kind(\"binary\") set_toolset(\"cxx\", \"clang\") set_toolset(\"ld\", \"clang++\") end) ``` 强制 test 目标的编译器和链接器使用 clang 编译器，或者指定交叉编译工具链中的编译器名或者路径。 #### set_config 我们也可以通过 `set_config` 来设置在 `xmake f/config` 命令中的每个配置参数的默认值，这是个全局 api，对每个 target 都会生效。 ```lua set_config(\"cflags\", \" DTEST\") set_config(\"sdk\", \"/home/xxx/tooksdk\") set_config(\"cc\", \"gcc\") set_config(\"ld\", \"g++\") ``` 不过，我们还是可以通过 `xmake f name value` 的方式，去修改 xmake.lua 中的默认配置。 ### 自定义编译平台 如果某个交叉工具链编译后目标程序有对应的平台需要指定，并且需要在 xmake.lua 里面根据不同的交叉编译平台，还需要配置一些额外的编译参数，那么上文的 ` p cross` 设置就不能满足需求了。 其实，` p/ plat ` 参数也可以设置为其他自定义的值，只需要跟 `is_plat` 保持对应关系就可以，所有非内置平台名，都会默认采用交叉编译模式，例如： ```bash $ xmake f p myplat sdk /usr/local/arm xxx gcc/ $ xmake ``` 我们传入了 myplat 自定义平台名，作为当前交叉工具链的编译平台，然后 xmake.lua 里面我们对这个平台，配置下对应的设置： ```lua if is_plat(\"myplat\") then add_defines(\"TEST\") end ``` 通过这种方式，xmake 就可以很方便的扩展处理各种编译平台，用户可以自己扩展支持 freebsd, netbsd, sunos 等其他各种平台的交叉编译。 我摘录一段之前移植 libuv 写的交叉编译的配置，直观感受下： ```lua for dragonfly/freebsd/netbsd/openbsd platform if is_plat(\"dragonfly\", \"freebsd\", \"netbsd\", \"openbsd\") then add_files(\"src/unix/bsd ifaddrs.c\") add_files(\"src/unix/freebsd.c\") add_files(\"src/unix/kqueue.c\") add_files(\"src/unix/posix hrtime.c\") add_headerfiles(\"(include/uv bsd.h)\") end for sunos platform if is_plat(\"sunos\") then add_files(\"src/unix/no proctitle.c\") add_files(\"src/unix/sunos.c\") add_defines(\"__EXTENSIONS_\", \"_XOPEN_SOURCE 600\") add_headerfiles(\"(include/uv sunos.h)\") end ``` 然后，我们就可以切换这些平台来编译： ```bash $ xmake f p [dragonflyfreebsdnetbsdopenbsdsunos] sdk /home/arm xxx gcc/ $ xmake ``` 另外，内置的 linux 平台也是支持交叉编译的，如果不想配置其他平台名，统一作为 linux 平台来交叉编译，也是可以的。 ```bash $ xmake f p linux sdk /usr/local/arm xxx gcc/ $ xmake ``` 只要设置了 ` sdk ` 等参数，就会启用linux平台的交叉编译模式。 ### 常用工具链配置 完整的工具链列表，请执行下面的命令查看： ```bash $ xmake show l toolchains ``` 上文讲述的是通用的交叉编译工具链配置，如果一些特定的工具链需要额外传入 ` ldflags/ includedirs` 等场景就比较繁琐了, 因此 xmake 也内置了一些常用工具链，可以省去交叉编译工具链复杂的配置过程，只需要执行： ```bash $ xmake f toolchain gnu rm sdk /xxx/ $ xmake ``` 就可以快速切换的指定的交叉编译工具链，如果这个工具链需要追加一些特定的 flags 设置，也会自动设置好，简化配置。 其中，gnu rm 就是内置的 GNU Arm Embedded Toolchain。 比如，我们也可以快速从 gcc 工具链整体切换到 clang 或者 llvm 工具链，不再需要 `xmake f cc clang cxx clang ld clang++` 等挨个配置了。 ```bash $ xmake f toolchain clang $ xmake ``` 或者 ```bash $ xmake f toolchain llvm sdk /xxx/llvm $ xmake ``` 具体 xmake 持哪些工具链，可以通过下面的命令查看： ```bash $ xmake show l toolchains xcode Xcode IDE vs VisualStudio IDE yasm The Yasm Modular Assembler clang A C language family frontend for LLVM go Go Programming Language Compiler dlang D Programming Language Compiler sdcc Small Device C Compiler cuda CUDA Toolkit ndk Android NDK rust Rust Programming Language Compiler llvm A collection of modular and reusable compiler and toolchain technologies cross Common cross compilation toolchain nasm NASM Assembler gcc GNU Compiler Collection mingw Minimalist GNU for Windows gnu rm GNU Arm Embedded Toolchain envs Environment variables toolchain fasm Flat Assembler ``` #### 自定义工具链 另外，我们也可以在 xmake.lua 中自定义 toolchain，然后通过 `xmake f toolchain myclang` 指定切换，例如： ```lua toolchain(\"myclang\", function() set_kind(\"standalone\") set_toolset(\"cc\", \"clang\") set_toolset(\"cxx\", \"clang\", \"clang++\") set_toolset(\"ld\", \"clang++\", \"clang\") set_toolset(\"sh\", \"clang++\", \"clang\") set_toolset(\"ar\", \"ar\") set_toolset(\"ex\", \"ar\") set_toolset(\"strip\", \"strip\") set_toolset(\"mm\", \"clang\") set_toolset(\"mxx\", \"clang\", \"clang++\") set_toolset(\"as\", \"clang\") ... end) ``` 关于这块的详情介绍，可以到[自定义工具链](/zh cn/manual/custom_toolchain)章节查看 更多详情见：[#780](https://github.com/xmake io/xmake/issues/780) #### LLVM 工具链 llvm 工具链下载地址：<https://releases.llvm.org/> ```bash $ xmake f p cross toolchain llvm sdk \"C:\\Program Files\\LLVM\" $ xmake ``` #### GNU RM 工具链 工具链地址：<https://developer.arm.com/tools and software/open source software/developer tools/gnu toolchain/gnu rm/downloads#> ```bash $ xmake f p cross toolchain gnu rm sdk /xxx/cc arm none eabi 9 2019 q4 major $ xmake ``` #### TinyC 工具链 ```bash $ xmake f toolchain tinyc $ xmake ``` > Releases 目录下，我们还提供了特殊的 xmake tinyc vX.X.X.win32.exe 安装包，内置 tinyc 工具链，无需依赖 msvc，也可以编译 c 代码，开箱即用无依赖。 #### Emcc 工具链 通常只需要切换到 Wasm 平台，里面内置了 emcc 工具链，还会额外调整目标程序的扩展名为 `*.html` 以及输出 `*.wasm`。 ```bash $ xmake f p wasm $ xmake ``` 不过我们也能够直接切换到 emcc 工具链，但是后缀名不会被修改。 ```bash $ xmake f toolchain emcc $ xmake ``` #### Intel C++ 编译工具链 ```bash $ xmake f toolchain icc $ xmake ``` #### Intel Fortran 编译工具链 ```bash $ xmake f toolchain ifort $ xmake ``` ### 通用交叉编译配置 参数名 描述 [ sdk](# sdk) 设置交叉工具链的sdk根目录 [ bin](# bin) 设置工具链bin目录 [ cross](# cross) 设置交叉工具链工具前缀 [ as](# as) 设置`asm`汇编器 [ cc](# cc) 设置`c`编译器 [ cxx](# cxx) 设置`c++`编译器 [ mm](# mm) 设置`objc`编译器 [ mxx](# mxx) 设置`objc++`编译器 [ sc](# sc) 设置`swift`编译器 [ gc](# gc) 设置`golang`编译器 [ dc](# dc) 设置`dlang`编译器 [ rc](# rc) 设置`rust`编译器 [ cu](# cu) 设置`cuda`编译器 [ ld](# ld) 设置`c/c++/objc/asm`链接器 [ sh](# sh) 设置`c/c++/objc/asm`共享库链接器 [ ar](# ar) 设置`c/c++/objc/asm`静态库归档器 [ scld](# scld) 设置`swift`链接器 [ scsh](# scsh) 设置`swift`共享库链接器 [ gcld](# gcld) 设置`golang`链接器 [ gcar](# gcar) 设置`golang`静态库归档器 [ dcld](# dcld) 设置`dlang`链接器 [ dcsh](# dcsh) 设置`dlang`共享库链接器 [ dcar](# dcar) 设置`dlang`静态库归档器 [ rcld](# rcld) 设置`rust`链接器 [ rcsh](# rcsh) 设置`rust`共享库链接器 [ rcar](# rcar) 设置`rust`静态库归档器 [ cu ccbin](# cu ccbin) 设置`cuda` host编译器 [ culd](# culd) 设置`cuda`链接器 [ asflags](# asflags) 设置`asm`汇编编译选项 [ cflags](# cflags) 设置`c`编译选项 [ cxflags](# cxflags) 设置`c/c++`编译选项 [ cxxflags](# cxxflags) 设置`c++`编译选项 [ mflags](# mflags) 设置`objc`编译选项 [ mxflags](# mxflags) 设置`objc/c++`编译选项 [ mxxflags](# mxxflags) 设置`objc++`编译选项 [ scflags](# scflags) 设置`swift`编译选项 [ gcflags](# gcflags) 设置`golang`编译选项 [ dcflags](# dcflags) 设置`dlang`编译选项 [ rcflags](# rcflags) 设置`rust`编译选项 [ cuflags](# cuflags) 设置`cuda`编译选项 [ ldflags](# ldflags) 设置链接选项 [ shflags](# shflags) 设置共享库链接选项 [ arflags](# arflags) 设置静态库归档选项 > 如果你想要了解更多参数选项，请运行: `xmake f help`。 #### sdk * 设置交叉工具链的sdk根目录 大部分情况下，都不需要配置很复杂的 toolchains 前缀，例如：`arm linux ` 什么的 只要这个工具链的 sdk 目录满足如下结构（大部分的交叉工具链都是这个结构）： ``` /home/toolchains_sdkdir bin arm linux gcc arm linux ld ... lib libxxx.a include xxx.h ``` 那么，使用 xmake 进行交叉编译的时候，只需要进行如下配置和编译： ```bash $ xmake f p linux sdk /home/toolchains_sdkdir $ xmake ``` 这个时候，xmake 会去自动探测，gcc 等编译器的前缀名：`arm linux `，并且编译的时候，也会自动加上**链接库**和**头文件**的搜索选项，例如： ``` I/home/toolchains_sdkdir/include L/home/toolchains_sdkdir/lib ``` 这些都是xmake自动处理的，不需要手动配置他们。。 #### bin * 设置工具链bin目录 对于不规则工具链目录结构，靠单纯地[ sdk]( sdk)选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的 bin 目录位置。 例如：一些特殊的交叉工具链的，编译器 bin 目录，并不在 `/home/toolchains_sdkdir/bin` 这个位置，而是独立到了 `/usr/opt/bin`。 ```bash $ xmake f p linux sdk /home/toolchains_sdkdir bin /usr/opt/bin $ xmake ``` #### cross * 设置交叉工具链工具前缀 像 `aarch64 linux android ` 这种，通常如果你配置了[ sdk](# sdk)或者[ bin](# bin)的情况下，xmake 会去自动检测的，不需要自己手动设置。 但是对于一些极特殊的工具链，一个目录下同时有多个 cross 前缀的工具 bin 混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个 bin。 例如，toolchains 的 bin 目录下同时存在两个不同的编译器： ``` /opt/bin armv7 linux gcc aarch64 linux gcc ``` 我们现在想要选用 armv7 的版本，则配置如下： ```bash $ xmake f p linux sdk /usr/toolsdk bin /opt/bin cross armv7 linux ``` #### as * 设置 `asm` 汇编器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk as armv7 linux as ``` 如果存在 `AS` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f as gcc@/home/xxx/asmips.exe` 设置ccmips.exe编译器作为类 gcc 的使用方式来编译。 > 也就是说，在指定编译器为 `asmips.exe` 的同时，告诉 xmake，它跟 gcc 用法和参数选项基本相同。 #### cc * 设置c编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk cc armv7 linux clang ``` 如果存在 `CC` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f cc gcc@/home/xxx/ccmips.exe` 设置 ccmips.exe 编译器作为类 gcc 的使用方式来编译。 > 也就是说，在指定编译器为 `ccmips.exe` 的同时，告诉 xmake，它跟 gcc 用法和参数选项基本相同。 #### cxx * 设置 `c++` 编译器 如果还要继续细分选择编译器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk cxx armv7 linux clang++ ``` 如果存在 `CXX` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么编译器工具检测就会失败。 > 这个时候我们可以通过：`xmake f cxx clang++@/home/xxx/c++mips.exe` 设置 c++mips.exe 编译器作为类 clang++ 的使用方式来编译。 > 也就是说，在指定编译器为 `c++mips.exe` 的同时，告诉 xmake，它跟 clang++ 用法和参数选项基本相同。 #### ld * 设置 `c/c++/objc/asm` 链接器 如果还要继续细分选择链接器，则继续追加相关编译器选项，例如： ```bash $ xmake f p linux sdk /user/toolsdk ld armv7 linux clang++ ``` 如果存在 `LD` 环境变量的话，会优先使用当前环境变量中指定的值。 > 如果指定的编译器名不是那些 xmake 内置可识别的名字（带有 gcc, clang 等字样），那么链接器工具检测就会失败。 > 这个时候我们可以通过：`xmake f ld g++@/home/xxx/c++mips.exe` 设置 c++mips.exe 链接器作为类 g++ 的使用方式来编译。 > 也就是说，在指定链接器为 `c++mips.exe` 的同时，告诉 xmake，它跟 g++ 用法和参数选项基本相同。 #### sh * 设置 `c/c++/objc/asm` 共享库链接器 ```bash $ xmake f p linux sdk /user/toolsdk sh armv7 linux clang++ ``` 如果存在 `SH` 环境变量的话，会优先使用当前环境变量中指定的值。 #### ar * 设置 `c/c++/objc/asm` 静态库归档器 ```bash $ xmake f p linux sdk /user/toolsdk ar armv7 linux ar ``` 如果存在`AR`环境变量的话，会优先使用当前环境变量中指定的值。 ## 全局配置 我们也可以将一些常用配置保存到全局配置中，来简化频繁地输入： 例如: ```bash $ xmake g ndk ~/files/android ndk r10e/ ``` 现在，我们重新配置和编译 `android` 程序： ```bash $ xmake f p android $ xmake ``` 以后，就不需要每次重复配置 ` ndk 参数了。 > 每个命令都有其简写，例如: `xmake g` 或者 `xmake global`。 ## 清除配置 有时候，配置出了问题编译不过，或者需要重新检测各种依赖库和接口，可以加上 ` c` 参数，清除缓存的配置，强制重新检测和配置： ```bash $ xmake f c $ xmake ``` 或者： ```bash $ xmake f p iphoneos c $ xmake ``` ## 导入导出配置 我们还可以导入导出已经配置好的配置集，方便配置的快速迁移。 ### 导出配置 ```bash $ xmake f export /tmp/config.txt $ xmake f m debug xxx y export /tmp/config.txt ``` ### 导入配置 ```bash $ xmake f import /tmp/config.txt $ xmake f m debug xxx y import /tmp/config.txt ``` ### 导出配置（带菜单） ```bash $ xmake f menu export /tmp/config.txt $ xmake f menu m debug xxx y export /tmp/config.txt ``` ### 导入配置（带菜单） ```bash $ xmake f menu import /tmp/config.txt $ xmake f menu m debug xxx y import /tmp/config.txt ```"}}