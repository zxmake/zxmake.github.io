<!DOCTYPE html>

<html lang="zh-CN"  class=" language_zh  heading_no_counter ">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <script src="/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/static/css/search/style.css" type="text/css"/>
        
        <meta name="blog-generator" content="teedoc-plugin-blog">
        
        <link rel="stylesheet" href="/static/css/custom.css" type="text/css"/>
        
    
    
    <title>xmake-docs</title>
    
    <script type="text/javascript">js_vars = {}</script>
    <script type="text/javascript">metadata = {"tags": [], "date": false, "update": [], "ts": 0, "author": "", "brief": "", "cover": "", "class": "heading_no_counter"}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/">
                
                    <img class="site_logo" src="/static/image/logo-1600.png" alt="logo">
                
                
                    <h2>xmake</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/get_started/zh/tutorial/quick-start.html">安装使用</a></li>
<li class=""><a  href="/dev/">开发文档</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/zxmake/zxmake.github.io">github</a></li>
</ul>

                <ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">搜索</span>
                            <div id="search_hints">
                                <span id="search_input_hint">输入关键词，多关键词空格隔开</span>
                                <span id="search_loading_hint">正在加载，请稍候。。。</span>
                                <span id="search_download_err_hint">下载文件失败，请刷新重试或检查网络</span>
                                <span id="search_other_docs_result_hint">来自其它文档的结果</span>
                                <span id="search_curr_doc_result_hint">当前文档搜索结果</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active no_link sidebar_category"><span class="label">新手教程</span></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/install.html"><span class="label">安装</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/quick-start.html"><span class="label">快速入门</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/tutorial/syntax-description.html"><span class="label">语法描述</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/tutorial/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/project-examples.html"><span class="label">工程例子</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/configuration.html"><span class="label">配置说明</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/environment-variables.html"><span class="label">环境变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/build-policies.html"><span class="label">构建策略</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/builtin-variables.html"><span class="label">内置变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/FAQ.html"><span class="label">FAQ</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">target 编译目标</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/target/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/target/script-scope.html"><span class="label">脚本域</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">option 选项</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/option/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/option/script-scope.html"><span class="label">脚本域</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">package 包管理</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/package/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/script-scope.html"><span class="label">脚本域</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/local-package.html"><span class="label">使用本地包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/remote-package.html"><span class="label">使用远程包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/system-package.html"><span class="label">使用系统包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/local-3rd-source-package.html"><span class="label">继承本地第三方源码库</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/get_started/zh/rule/index.html"><span class="label">rule 规则</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/rule/builtin-rules.html"><span class="label">内建规则</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/rule/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">toolchain 工具链</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/toolchain/builtin-toolchains.html"><span class="label">内置工具链</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/toolchain/custom-toolchains.html"><span class="label">自定义工具链</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/toolchain/remote-toolchains.html"><span class="label">远程工具链</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">task 插件任务</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/task/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/task/plugin-development.html"><span class="label">插件开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/task/builtin-plugins.html"><span class="label">内置插件</span><span class=""></span></a></li>
</ul>
</li>
<li class="active_parent no_link"><a><span class="label">module 模块</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/module/builtin-modules.html"><span class="label">内置模块</span><span class=""></span></a></li>
<li class="active with_link"><a href="/get_started/zh/module/extension-modules.html"><span class="label">扩展模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/module/native-modules.html"><span class="label">Lua 原生模块</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">theme 主题风格</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/theme/switch-themes.html"><span class="label">切换主题</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/theme/builtin-themes.html"><span class="label">内置主题</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">其他特性</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/features/remote-build.html"><span class="label">远程编译</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/features/distcc-build.html"><span class="label">分布式编译</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/features/build-cache.html"><span class="label">编译缓存</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/features/unity-build.html"><span class="label">Unity 编译加速</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/features/autogen.html"><span class="label">自动扫描源码生成工程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/features/try-build.html"><span class="label">尝试使用其他构建系统</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/get_started/zh/xrepo/usage.html"><span class="label">xrepo 包管理器</span><span class=""></span></a></li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1></h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/TOMO-CAT/xmake-teedoc/docs/get_started/zh/module/extension-modules.md" target="_blank">
                                    编辑本页
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <h1 id="%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97">扩展模块</h1>
<p>所有扩展模块的使用，都需要通过 <a href="/zh-cn/manual/builtin_modules?id=import"  >import</a> 接口，进行导入后才能使用。</p>
<h2 id="core.base.option">core.base.option</h2>
<p>一般用于获取 xmake 命令参数选项的值，常用于插件开发。</p>
<h3 id="option.get">option.get</h3>
<ul>
<li>获取参数选项值</li>
</ul>
<p>在插件开发中用于获取参数选项值，例如：</p>

<pre class="language-lua"><code class="language-lua">-- 导入选项模块
import(&quot;core.base.option&quot;)

-- 插件入口函数
function main(...)
    print(option.get(&quot;info&quot;))
end
</code></pre>
<p>上面的代码获取 hello 插件，执行：<code>xmake hello --info=xxxx</code> 命令时候传入的 <code>--info=</code> 选项的值，并显示：<code>xxxx</code></p>
<p>对于非 main 入口的 task 任务或插件，可以这么使用：</p>

<pre class="language-lua"><code class="language-lua">task(&quot;hello&quot;, function()
    on_run(function ()
        import(&quot;core.base.option&quot;)
        print(option.get(&quot;info&quot;))
    end)
end)
</code></pre>
<h2 id="core.base.global">core.base.global</h2>
<p>用于获取 xmake 全局的配置信息，也就是 <code>xmake g|global --xxx=val</code> 传入的参数选项值。</p>
<h3 id="global.get">global.get</h3>
<p>获取指定配置值。</p>
<p>类似 <a href="#configget"  >config.get</a>，唯一的区别就是这个是从全局配置中获取。</p>
<h3 id="global.load">global.load</h3>
<p>加载配置。</p>
<p>类似 <a href="#globalget"  >global.get</a>，唯一的区别就是这个是从全局配置中加载。</p>
<h3 id="global.directory">global.directory</h3>
<p>获取全局配置信息目录。</p>
<p>默认为 <code>~/.config</code> 目录。</p>
<h3 id="global.dump">global.dump</h3>
<p>打印输出所有全局配置信息。</p>
<p>输出结果如下：</p>

<pre class="language-lua"><code class="language-lua">{
    clean = true
,   ccache = &quot;ccache&quot;
,   xcode_dir = &quot;/Applications/Xcode.app&quot;
}
</code></pre>
<h2 id="core.base.task">core.base.task</h2>
<p>用于任务操作，一般用于在自定义脚本中、插件任务中，调用运行其他 task 任务。</p>
<h3 id="task.run">task.run</h3>
<p>运行指定任务。</p>
<p>用于在自定义脚本、插件任务中运行 <a href="#task"  >task</a> 定义的任务或插件，例如：</p>

<pre class="language-lua"><code class="language-lua">task(&quot;hello&quot;, function()
    on_run(function ()
        print(&quot;hello xmake!&quot;)
    end)
end)

target(&quot;demo&quot;, function()
    on_clean(function(target)

        -- 导入 task 模块
        import(&quot;core.base.task&quot;)

        -- 运行这个 hello task
        task.run(&quot;hello&quot;)
    end)
end)
</code></pre>
<p>我们还可以在运行任务时，增加参数传递，例如：</p>

<pre class="language-lua"><code class="language-lua">task(&quot;hello&quot;, function()
    on_run(function (arg1, arg2)
        print(&quot;hello xmake: %s %s!&quot;, arg1, arg2)
    end)
end)

target(&quot;demo&quot;, function()
    on_clean(function(target)

        -- 导入 task
        import(&quot;core.base.task&quot;)

        -- {} 这个是给第一种选项传参使用，这里置空，这里在最后面传入了两个参数：arg1, arg2
        task.run(&quot;hello&quot;, {}, &quot;arg1&quot;, &quot;arg2&quot;)
    end)
end)
</code></pre>
<p>对于 <code>task.run</code> 的第二个参数，用于传递命令行菜单中的选项，而不是直接传入 <code>function (arg, ...)</code> 函数入口中，例如：</p>

<pre class="language-lua"><code class="language-lua">-- 导入 task
import(&quot;core.base.task&quot;)

-- 插件入口
function main(...)

    -- 运行内置的 xmake 配置任务，相当于：xmake f|config --plat=iphoneos --arch=armv7
    task.run(&quot;config&quot;, {plat=&quot;iphoneos&quot;, arch=&quot;armv7&quot;})
end
</code></pre>
<h2 id="core.base.json">core.base.json</h2>
<p>xmake 提供了内置的 json 模块，基于 lua_cjson 实现，我们可以用它实现快速的在 json 和 lua table 直接相互操作。</p>
<p>我们可以通过 <code>import(&quot;core.base.json&quot;)</code> 直接导入使用。</p>
<p>这里也有一些例子：<a href="https://github.com/xmake-io/xmake/blob/master/tests/modules/json/test.lua"  target="_blank">Jsom Examples</a></p>
<h3 id="json.decode">json.decode</h3>
<p>直接从字符串解码 json 获取 lua table.</p>

<pre class="language-lua"><code class="language-lua">import(&quot;core.base.json&quot;)
local luatable = json.decode('[1,&quot;2&quot;, {&quot;a&quot;:1,&quot;b&quot;:true}]')
print(luatable)
</code></pre>

<pre class="language-none"><code class="language-none">{
    1.0,
    &quot;2&quot;,
    {
      b = true,
      a = 1.0
    }
  }
</code></pre>
<blockquote>
<p>如果里面有 null，可以用 <code>json.null</code> 来判断</p>
</blockquote>
<h3 id="json.encode">json.encode</h3>
<p>我们也可以直接对一个 lua table 进行编码。</p>

<pre class="language-lua"><code class="language-lua">local jsonstr = json.encode({1, &quot;2&quot;, {a = 1}})
</code></pre>
<p>需要注意的是，如果需要编码 null，需要使用 <code>json.null</code>，例如</p>

<pre class="language-lua"><code class="language-lua">local jsonstr = json.encode({json.null, 1, &quot;2&quot;, false, true})
</code></pre>
<h3 id="json.loadfile">json.loadfile</h3>
<p>直接加载 json 文件，并解析成 lua table。</p>

<pre class="language-lua"><code class="language-lua">local luatable = json.loadfile(&quot;/tmp/xxx.json&quot;)
</code></pre>
<h3 id="json.savefile">json.savefile</h3>
<p>保存 lua table 到指定 json 文件。</p>

<pre class="language-lua"><code class="language-lua">json.savefile(&quot;/tmp/xxx.json&quot;, {1, {a = 1}})
</code></pre>
<h2 id="core.tool.linker">core.tool.linker</h2>
<p>链接器相关操作，常用于插件开发。</p>
<h3 id="linker.link">linker.link</h3>
<p>执行链接。</p>
<p>针对 target，链接指定对象文件列表，生成对应的目标文件，例如：</p>

<pre class="language-lua"><code class="language-lua">linker.link(&quot;binary&quot;, &quot;cc&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {target = target})
</code></pre>
<p>其中 <a href="#target"  >target</a>，为工程目标，这里传入，主要用于获取 target 特定的链接选项，具体如果获取工程目标对象，见：<a href="#core-project-project"  >core.project.project</a></p>
<p>当然也可以不指定 target，例如：</p>

<pre class="language-lua"><code class="language-lua">linker.link(&quot;binary&quot;, &quot;cc&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, &quot;/tmp/targetfile&quot;)
</code></pre>
<p>第一个参数指定链接类型，目前支持：binary, static, shared<br />
第二个参数告诉链接器，应该作为那种源文件对象进行链接，这些对象源文件使用什么编译器编译的，例如：</p>
<table>
<thead>
<tr>
  <th>第二个参数值</th>
  <th>描述</th>
</tr>
</thead>
<tbody>
<tr>
  <td>cc</td>
  <td>c 编译器</td>
</tr>
<tr>
  <td>cxx</td>
  <td>c++ 编译器</td>
</tr>
<tr>
  <td>mm</td>
  <td>objc 编译器</td>
</tr>
<tr>
  <td>mxx</td>
  <td>objc++ 编译器</td>
</tr>
<tr>
  <td>gc</td>
  <td>go 编译器</td>
</tr>
<tr>
  <td>as</td>
  <td>汇编器</td>
</tr>
<tr>
  <td>sc</td>
  <td>swift 编译器</td>
</tr>
<tr>
  <td>rc</td>
  <td>rust 编译器</td>
</tr>
<tr>
  <td>dc</td>
  <td>dlang 编译器</td>
</tr>
</tbody>
</table>
<p>指定不同的编译器类型，链接器会适配最合适的链接器来处理链接，并且如果几种支持混合编译的语言，那么可以同时传入多个编译器类型，指定链接器选择支持这些混合编译语言的链接器进行链接处理：</p>

<pre class="language-lua"><code class="language-lua">linker.link(&quot;binary&quot;, {&quot;cc&quot;, &quot;mxx&quot;, &quot;sc&quot;}, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, &quot;/tmp/targetfile&quot;)
</code></pre>
<p>上述代码告诉链接器，a, b, c 三个对象文件有可能分别是 c, objc++, swift 代码编译出来的，链接器会从当前系统和工具链中选择最合适的链接器去处理这个链接过程。</p>
<h3 id="linker.linkcmd">linker.linkcmd</h3>
<p>获取链接命令行字符串。</p>
<p>直接获取 <a href="#linkerlink"  >linker.link</a> 中执行的命令行字符串，相当于：</p>

<pre class="language-lua"><code class="language-lua">local cmdstr = linker.linkcmd(&quot;static&quot;, &quot;cxx&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {target = target})
</code></pre>
<p>注：后面 <code>{target = target}</code> 扩展参数部分是可选的，如果传递了 target 对象，那么生成的链接命令，会加上这个 target 配置对应的链接选项。</p>
<p>并且还可以自己传递各种配置，例如：</p>

<pre class="language-lua"><code class="language-lua">local cmdstr = linker.linkcmd(&quot;static&quot;, &quot;cxx&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {configs = {linkdirs = &quot;/usr/lib&quot;}})
</code></pre>
<h3 id="linker.linkargv">linker.linkargv</h3>
<p>获取链接命令行参数列表。</p>
<p>跟 <a href="#linkerlinkchtml"  >linker.linkcmd</a> 稍微有点区别的是，此接口返回的是参数列表，table 表示，更加方便操作：</p>

<pre class="language-lua"><code class="language-lua">local program, argv = linker.linkargv(&quot;static&quot;, &quot;cxx&quot;, {&quot;a.o&quot;, &quot;b.o&quot;, &quot;c.o&quot;}, target:targetfile(), {target = target})
</code></pre>
<p>其中返回的第一个值是主程序名，后面是参数列表，而 <code>os.args(table.join(program, argv))</code> 等价于 <code>linker.linkcmd</code>。</p>
<p>我们也可以通过传入返回值给 <a href="#os-runv"  >os.runv</a> 来直接运行它：<code>os.runv(linker.linkargv(..))</code></p>
<h3 id="linker.linkflags">linker.linkflags</h3>
<p>获取链接选项。</p>
<p>获取 <a href="#linkerlinkchtml"  >linker.linkcmd</a> 中的链接选项字符串部分，不带 shellname 和对象文件列表，并且是按数组返回，例如：</p>

<pre class="language-lua"><code class="language-lua">local flags = linker.linkflags(&quot;shared&quot;, &quot;cc&quot;, {target = target})
for _, flag in ipairs(flags) do
    print(flag)
end
</code></pre>
<p>返回的是 flags 的列表数组。</p>
<h3 id="linker.has_flags">linker.has_flags</h3>
<p>判断指定链接选项是否支持。</p>
<p>虽然通过 <a href="detect-has_flags"  >lib.detect.has_flags</a> 也能判断，但是那个接口更加底层，需要指定链接器名称<br />
而此接口只需要指定 target 的目标类型，源文件类型，它会自动切换选择当前支持的链接器。</p>

<pre class="language-lua"><code class="language-lua">if linker.has_flags(target:targetkind(), target:sourcekinds(), &quot;-L/usr/lib -lpthread&quot;) then
    -- ok
end
</code></pre>
<h2 id="core.tool.compiler">core.tool.compiler</h2>
<p>编译器相关操作，常用于插件开发。</p>
<h3 id="compiler.compile">compiler.compile</h3>
<p>执行编译。</p>
<p>针对 target，链接指定对象文件列表，生成对应的目标文件，例如：</p>

<pre class="language-lua"><code class="language-lua">compiler.compile(&quot;xxx.c&quot;, &quot;xxx.o&quot;, &quot;xxx.h.d&quot;, {target = target})
</code></pre>
<p>其中 <a href="#target"  >target</a>，为工程目标，这里传入主要用于获取 taeget 的特定编译选项，具体如果获取工程目标对象，见：<a href="#core-project-project"  >core.project.project</a></p>
<p>而 <code>xxx.h.d</code> 文件用于存储为此源文件的头文件依赖文件列表，最后这两个参数都是可选的，编译的时候可以不传他们：</p>

<pre class="language-lua"><code class="language-lua">compiler.compile(&quot;xxx.c&quot;, &quot;xxx.o&quot;)
</code></pre>
<p>来单纯编译一个源文件。</p>
<h3 id="compiler.compcmd">compiler.compcmd</h3>
<p>获取编译命令行。</p>
<p>直接获取 <a href="#compilercompile"  >compiler.compile</a> 中执行的命令行字符串，相当于：</p>

<pre class="language-lua"><code class="language-lua">local cmdstr = compiler.compcmd(&quot;xxx.c&quot;, &quot;xxx.o&quot;, {target = target})
</code></pre>
<p>注：后面 <code>{target = target}</code> 扩展参数部分是可选的，如果传递了 target 对象，那么生成的编译命令，会加上这个 target 配置对应的链接选项。</p>
<p>并且还可以自己传递各种配置，例如：</p>

<pre class="language-lua"><code class="language-lua">local cmdstr = compiler.compcmd(&quot;xxx.c&quot;, &quot;xxx.o&quot;, {configs = {includedirs = &quot;/usr/include&quot;, defines = &quot;DEBUG&quot;}})
</code></pre>
<p>通过 target，我们可以导出指定目标的所有源文件编译命令：</p>

<pre class="language-lua"><code class="language-lua">import(&quot;core.project.project&quot;)

for _, target in pairs(project.targets()) do
    for sourcekind, sourcebatch in pairs(target:sourcebatches()) do
        for index, objectfile in ipairs(sourcebatch.objectfiles) do
            local cmdstr = compiler.compcmd(sourcebatch.sourcefiles[index], objectfile, {target = target})
        end
    end
end
</code></pre>
<h3 id="compiler.compargv">compiler.compargv</h3>
<p>获取编译命令行列表。</p>
<p>跟 <a href="#compilercompchtml"  >compiler.compcmd</a> 稍微有点区别的是，此接口返回的是参数列表，table 表示，更加方便操作：</p>

<pre class="language-lua"><code class="language-lua">local program, argv = compiler.compargv(&quot;xxx.c&quot;, &quot;xxx.o&quot;)
</code></pre>
<h3 id="compiler.compflags">compiler.compflags</h3>
<p>获取编译选项。</p>
<p>获取 <a href="#compilercompchtml"  >compiler.compcmd</a> 中的编译选项字符串部分，不带 shellname 和文件列表，例如：</p>

<pre class="language-lua"><code class="language-lua">local flags = compiler.compflags(sourcefile, {target = target})
for _, flag in ipairs(flags) do
    print(flag)
end
</code></pre>
<p>返回的是 flags 的列表数组。</p>
<h3 id="compiler.has_flags">compiler.has_flags</h3>
<ul>
<li>判断指定编译选项是否支持</li>
</ul>
<p>虽然通过 <a href="detect-has_flags"  >lib.detect.has_flags</a> 也能判断，但是那个接口更加底层，需要指定编译器名称。<br />
而此接口只需要指定语言类型，它会自动切换选择当前支持的编译器。</p>

<pre class="language-lua"><code class="language-lua">-- 判断 c 语言编译器是否支持选项: -g
if compiler.has_flags(&quot;c&quot;, &quot;-g&quot;) then
    -- ok
end

-- 判断 c++ 语言编译器是否支持选项: -g
if compiler.has_flags(&quot;cxx&quot;, &quot;-g&quot;) then
    -- ok
end
</code></pre>
<h3 id="compiler.features">compiler.features</h3>
<ul>
<li>获取所有编译器特性</li>
</ul>
<p>虽然通过 <a href="detect-features"  >lib.detect.features</a> 也能获取，但是那个接口更加底层，需要指定编译器名称。<br />
而此接口只需要指定语言类型，它会自动切换选择当前支持的编译器，然后获取当前的编译器特性列表。</p>

<pre class="language-lua"><code class="language-lua">-- 获取当前 c 语言编译器的所有特性
local features = compiler.features(&quot;c&quot;)

-- 获取当前 c++ 语言编译器的所有特性，启用 c++11 标准，否则获取不到新标准的特性
local features = compiler.features(&quot;cxx&quot;, {configs = {cxxflags = &quot;-std=c++11&quot;}})

-- 获取当前 c++ 语言编译器的所有特性，传递工程 target 的所有配置信息
local features = compiler.features(&quot;cxx&quot;, {target = target, configs = {defines = &quot;..&quot;, includedirs = &quot;..&quot;}})
</code></pre>
<p>所有 c 编译器特性列表：</p>
<table>
<thead>
<tr>
  <th>特性名</th>
</tr>
</thead>
<tbody>
<tr>
  <td>c_static_assert</td>
</tr>
<tr>
  <td>c_restrict</td>
</tr>
<tr>
  <td>c_variadic_macros</td>
</tr>
<tr>
  <td>c_function_prototypes</td>
</tr>
</tbody>
</table>
<p>所有 c++ 编译器特性列表：</p>
<table>
<thead>
<tr>
  <th>特性名</th>
</tr>
</thead>
<tbody>
<tr>
  <td>cxx_variable_templates</td>
</tr>
<tr>
  <td>cxx_relaxed_constexpr</td>
</tr>
<tr>
  <td>cxx_aggregate_default_initializers</td>
</tr>
<tr>
  <td>cxx_contextual_conversions</td>
</tr>
<tr>
  <td>cxx_attribute_deprecated</td>
</tr>
<tr>
  <td>cxx_decltype_auto</td>
</tr>
<tr>
  <td>cxx_digit_separators</td>
</tr>
<tr>
  <td>cxx_generic_lambdas</td>
</tr>
<tr>
  <td>cxx_lambda_init_captures</td>
</tr>
<tr>
  <td>cxx_binary_literals</td>
</tr>
<tr>
  <td>cxx_return_type_deduction</td>
</tr>
<tr>
  <td>cxx_decltype_incomplete_return_types</td>
</tr>
<tr>
  <td>cxx_reference_qualified_functions</td>
</tr>
<tr>
  <td>cxx_alignof</td>
</tr>
<tr>
  <td>cxx_attributes</td>
</tr>
<tr>
  <td>cxx_inheriting_constructors</td>
</tr>
<tr>
  <td>cxx_thread_local</td>
</tr>
<tr>
  <td>cxx_alias_templates</td>
</tr>
<tr>
  <td>cxx_delegating_constructors</td>
</tr>
<tr>
  <td>cxx_extended_friend_declarations</td>
</tr>
<tr>
  <td>cxx_final</td>
</tr>
<tr>
  <td>cxx_nonstatic_member_init</td>
</tr>
<tr>
  <td>cxx_override</td>
</tr>
<tr>
  <td>cxx_user_literals</td>
</tr>
<tr>
  <td>cxx_constexpr</td>
</tr>
<tr>
  <td>cxx_defaulted_move_initializers</td>
</tr>
<tr>
  <td>cxx_enum_forward_declarations</td>
</tr>
<tr>
  <td>cxx_noexcept</td>
</tr>
<tr>
  <td>cxx_nullptr</td>
</tr>
<tr>
  <td>cxx_range_for</td>
</tr>
<tr>
  <td>cxx_unrestricted_unions</td>
</tr>
<tr>
  <td>cxx_explicit_conversions</td>
</tr>
<tr>
  <td>cxx_lambdas</td>
</tr>
<tr>
  <td>cxx_local_type_template_args</td>
</tr>
<tr>
  <td>cxx_raw_string_literals</td>
</tr>
<tr>
  <td>cxx_auto_type</td>
</tr>
<tr>
  <td>cxx_defaulted_functions</td>
</tr>
<tr>
  <td>cxx_deleted_functions</td>
</tr>
<tr>
  <td>cxx_generalized_initializers</td>
</tr>
<tr>
  <td>cxx_inline_namespaces</td>
</tr>
<tr>
  <td>cxx_sizeof_member</td>
</tr>
<tr>
  <td>cxx_strong_enums</td>
</tr>
<tr>
  <td>cxx_trailing_return_types</td>
</tr>
<tr>
  <td>cxx_unicode_literals</td>
</tr>
<tr>
  <td>cxx_uniform_initialization</td>
</tr>
<tr>
  <td>cxx_variadic_templates</td>
</tr>
<tr>
  <td>cxx_decltype</td>
</tr>
<tr>
  <td>cxx_default_function_template_args</td>
</tr>
<tr>
  <td>cxx_long_long_type</td>
</tr>
<tr>
  <td>cxx_right_angle_brackets</td>
</tr>
<tr>
  <td>cxx_rvalue_references</td>
</tr>
<tr>
  <td>cxx_static_assert</td>
</tr>
<tr>
  <td>cxx_extern_templates</td>
</tr>
<tr>
  <td>cxx_func_identifier</td>
</tr>
<tr>
  <td>cxx_variadic_macros</td>
</tr>
<tr>
  <td>cxx_template_template_parameters</td>
</tr>
</tbody>
</table>
<h3 id="compiler.has_features">compiler.has_features</h3>
<p>判断指定的编译器特性是否支持。</p>
<p>虽然通过 <a href="detect-has-features"  >lib.detect.has_features</a> 也能获取，但是那个接口更加底层，需要指定编译器名称。<br />
而此接口只需要指定需要检测的特姓名称列表，就能自动切换选择当前支持的编译器，然后判断指定特性在当前的编译器中是否支持。</p>

<pre class="language-lua"><code class="language-lua">if compiler.has_features(&quot;c_static_assert&quot;) then
    -- ok
end

if compiler.has_features({&quot;c_static_assert&quot;, &quot;cxx_constexpr&quot;}, {languages = &quot;cxx11&quot;}) then
    -- ok
end

if compiler.has_features(&quot;cxx_constexpr&quot;, {target = target, defines = &quot;..&quot;, includedirs = &quot;..&quot;}) then
    -- ok
end
</code></pre>
<p>具体特性名有哪些，可以参考：<a href="#compilerfeatures"  >compiler.features</a>。</p>
<h2 id="core.project.config">core.project.config</h2>
<p>用于获取工程编译时候的配置信息，也就是 <code>xmake f|config --xxx=val</code> 传入的参数选项值。</p>
<h3 id="config.get">config.get</h3>
<p>获取指定配置值。</p>
<p>用于获取 <code>xmake f|config --xxx=val</code> 的配置值，例如：</p>

<pre class="language-lua"><code class="language-lua">target(&quot;test&quot;)
    on_run(function (target)

        -- 导入配置模块
        import(&quot;core.project.config&quot;)

        -- 获取配置值
        print(config.get(&quot;xxx&quot;))
    end)
</code></pre>
<h3 id="config.load">config.load</h3>
<p>加载配置。</p>
<p>一般用于插件开发中，插件任务中不像工程的自定义脚本，环境需要自己初始化加载，默认工程配置是没有被加载的，如果要用 <a href="#configget"  >config.get</a> 接口获取工程配置，那么需要先：</p>

<pre class="language-lua"><code class="language-lua">
-- 导入配置模块
import(&quot;core.project.config&quot;)

function main(...)

    -- 先加载工程配置
    config.load()

    -- 获取配置值
    print(config.get(&quot;xxx&quot;))
end
</code></pre>
<h3 id="config.arch">config.arch</h3>
<p>获取当前工程的架构配置。</p>
<p>也就是获取 <code>xmake f|config --arch=armv7</code> 的平台配置，相当于 <code>config.get(&quot;arch&quot;)</code>。</p>
<h3 id="config.plat">config.plat</h3>
<p>获取当前工程的平台配置。</p>
<p>也就是获取 <code>xmake f|config --plat=iphoneos</code> 的平台配置，相当于 <code>config.get(&quot;plat&quot;)</code>。</p>
<h3 id="config.mode">config.mode</h3>
<p>获取当前工程的编译模式配置。</p>
<p>也就是获取 <code>xmake f|config --mode=debug</code> 的平台配置，相当于 <code>config.get(&quot;mode&quot;)</code>。</p>
<h3 id="config.buildir">config.buildir</h3>
<p>获取当前工程的输出目录配置。</p>
<p>也就是获取 <code>xmake f|config -o /tmp/output</code> 的平台配置，相当于 <code>config.get(&quot;buildir&quot;)</code>。</p>
<h3 id="config.directory">config.directory</h3>
<p>获取当前工程的配置信息目录。</p>
<p>获取工程配置的存储目录，默认为：<code>projectdir/.config</code></p>
<h3 id="config.dump">config.dump</h3>
<p>打印输出当前工程的所有配置信息。</p>
<p>输出结果例如：</p>

<pre class="language-lua"><code class="language-lua">{
    sh = &quot;xcrun -sdk macosx clang++&quot;
,   xcode_dir = &quot;/Applications/Xcode.app&quot;
,   ar = &quot;xcrun -sdk macosx ar&quot;
,   small = true
,   object = false
,   arch = &quot;x86_64&quot;
,   xcode_sdkver = &quot;10.12&quot;
,   ex = &quot;xcrun -sdk macosx ar&quot;
,   cc = &quot;xcrun -sdk macosx clang&quot;
,   rc = &quot;rustc&quot;
,   plat = &quot;macosx&quot;
,   micro = false
,   host = &quot;macosx&quot;
,   as = &quot;xcrun -sdk macosx clang&quot;
,   dc = &quot;dmd&quot;
,   gc = &quot;go&quot;
,   openssl = false
,   ccache = &quot;ccache&quot;
,   cxx = &quot;xcrun -sdk macosx clang&quot;
,   sc = &quot;xcrun -sdk macosx swiftc&quot;
,   mm = &quot;xcrun -sdk macosx clang&quot;
,   buildir = &quot;build&quot;
,   mxx = &quot;xcrun -sdk macosx clang++&quot;
,   ld = &quot;xcrun -sdk macosx clang++&quot;
,   mode = &quot;release&quot;
,   kind = &quot;static&quot;
}
</code></pre>
<h2 id="core.project.project">core.project.project</h2>
<p>用于获取当前工程的一些描述信息，也就是在 <code>xmake.lua</code> 工程描述文件中定义的配置信息，例如：<a href="#target"  >target</a>、<a href="#option"  >option</a> 等。</p>
<h3 id="project.load">project.load</h3>
<p>加载工程描述配置。</p>
<p>仅在插件中使用，因为这个时候还没有加载工程配置信息，在工程目标的自定义脚本中，不需要执行此操作，就可以直接访问工程配置。</p>

<pre class="language-lua"><code class="language-lua">-- 导入工程模块
import(&quot;core.project.project&quot;)

-- 插件入口
function main(...)

    -- 加载工程描述配置
    project.load()

    -- 访问工程描述，例如获取指定工程目标
    local target = project.target(&quot;test&quot;)
end
</code></pre>
<h3 id="project.directory">project.directory</h3>
<p>获取工程目录</p>
<p>获取当前工程目录，也就是 <code>xmake -P xxx</code> 中指定的目录，否则为默认当前 <code>xmake</code> 命令执行目录。</p>
<blockquote>
<p>建议使用 <a href="#os-projectdir"  >os.projectdir</a> 来获取。</p>
</blockquote>
<h3 id="project.target">project.target</h3>
<p>获取指定工程目标对象。</p>
<p>获取和访问指定工程目标配置，例如：</p>

<pre class="language-lua"><code class="language-lua">local target = project.target(&quot;test&quot;)
if target then

    -- 获取目标名
    print(target:name())

    -- 获取目标目录, 2.1.9 版本之后才有
    print(target:targetdir())

    -- 获取目标文件名
    print(target:targetfile())

    -- 获取目标类型，也就是：binary, static, shared
    print(target:targetkind())

    -- 获取目标名
    print(target:name())

    -- 获取目标源文件
    local sourcefiles = target:sourcefiles()

    -- 获取目标安装头文件列表
    local srcheaders, dstheaders = target:headerfiles()

    -- 获取目标依赖
    print(target:get(&quot;deps&quot;))
end
</code></pre>
<h3 id="project.targets">project.targets</h3>
<p>获取工程目标对象列表。</p>
<p>返回当前工程的所有编译目标，例如：</p>

<pre class="language-lua"><code class="language-lua">for targetname, target in pairs(project.targets())
    print(target:targetfile())
end
</code></pre>
<h3 id="project.option">project.option</h3>
<p>获取指定选项对象。</p>
<p>获取和访问工程中指定的选项对象，例如：</p>

<pre class="language-lua"><code class="language-lua">local option = project.option(&quot;test&quot;)
if option:enabled() then
    option:enable(false)
end
</code></pre>
<h3 id="project.options">project.options</h3>
<p>获取工程所有选项对象。</p>
<p>返回当前工程的所有编译目标，例如：</p>

<pre class="language-lua"><code class="language-lua">for optionname, option in pairs(project.options())
    print(option:enabled())
end
</code></pre>
<h3 id="project.name">project.name</h3>
<p>获取当前工程名。</p>
<p>也就是获取 <a href="#set_project"  >set_project</a> 的工程名配置。</p>

<pre class="language-lua"><code class="language-lua">print(project.name())
</code></pre>
<h3 id="project.version">project.version</h3>
<p>获取当前工程版本号。</p>
<p>也就是获取 <a href="#set_version"  >set_version</a> 的工程版本配置。</p>

<pre class="language-lua"><code class="language-lua">print(project.version())
</code></pre>
<h2 id="core.language.language">core.language.language</h2>
<p>用于获取编译语言相关信息，一般用于代码文件的操作。</p>
<h3 id="language.extensions">language.extensions</h3>
<p>获取所有语言的代码后缀名列表。</p>
<p>获取结果如下：</p>

<pre class="language-lua"><code class="language-lua">{
     [&quot;.c&quot;]      = cc
,    [&quot;.cc&quot;]     = cxx
,    [&quot;.cpp&quot;]    = cxx
,    [&quot;.m&quot;]      = mm
,    [&quot;.mm&quot;]     = mxx
,    [&quot;.swift&quot;]  = sc
,    [&quot;.go&quot;]     = gc
}
</code></pre>
<h3 id="language.targetkinds">language.targetkinds</h3>
<p>获取所有语言的目标类型列表。</p>
<p>获取结果如下：</p>

<pre class="language-lua"><code class="language-lua">{
     binary = {&quot;ld&quot;, &quot;gcld&quot;, &quot;dcld&quot;}
,    static = {&quot;ar&quot;, &quot;gcar&quot;, &quot;dcar&quot;}
,    shared = {&quot;sh&quot;, &quot;dcsh&quot;}
}
</code></pre>
<h3 id="language.sourcekinds">language.sourcekinds</h3>
<p>获取所有语言的源文件类型列表。</p>
<p>获取结果如下：</p>

<pre class="language-lua"><code class="language-lua">{
     cc  = &quot;.c&quot;
,    cxx = {&quot;.cc&quot;, &quot;.cpp&quot;, &quot;.cxx&quot;}
,    mm  = &quot;.m&quot;
,    mxx = &quot;.mm&quot;
,    sc  = &quot;.swift&quot;
,    gc  = &quot;.go&quot;
,    rc  = &quot;.rs&quot;
,    dc  = &quot;.d&quot;
,    as  = {&quot;.s&quot;, &quot;.S&quot;, &quot;.asm&quot;}
}
</code></pre>
<h3 id="language.sourceflags">language.sourceflags</h3>
<p>加载所有语言的源文件编译选项名列表。</p>
<p>获取结果如下：</p>

<pre class="language-lua"><code class="language-lua">{
     cc  = {&quot;cflags&quot;, &quot;cxflags&quot;}
,    cxx = {&quot;cxxflags&quot;, &quot;cxflags&quot;}
,    ...
}
</code></pre>
<h3 id="language.load">language.load</h3>
<p>加载指定语言。</p>
<p>从语言名称加载具体语言对象，例如：</p>

<pre class="language-lua"><code class="language-lua">local lang = language.load(&quot;c++&quot;)
if lang then
    print(lang:name())
end
</code></pre>
<h3 id="language.load_sk">language.load_sk</h3>
<p>从源文件类型加载指定语言。</p>
<p>从源文件类型：<code>cc, cxx, mm, mxx, sc, gc, as ..</code> 加载具体语言对象，例如：</p>

<pre class="language-lua"><code class="language-lua">local lang = language.load_sk(&quot;cxx&quot;)
if lang then
    print(lang:name())
end
</code></pre>
<h3 id="language.load_ex">language.load_ex</h3>
<p>从源文件后缀名加载指定语言。</p>
<p>从源文件后缀名：<code>.cc, .c, .cpp, .mm, .swift, .go ..</code> 加载具体语言对象，例如：</p>

<pre class="language-lua"><code class="language-lua">local lang = language.load_sk(&quot;.cpp&quot;)
if lang then
    print(lang:name())
end
</code></pre>
<h3 id="language.sourcekind_of">language.sourcekind_of</h3>
<p>获取指定源文件的源文件类型。</p>
<p>也就是从给定的一个源文件路径，获取它是属于那种源文件类型，例如：</p>

<pre class="language-lua"><code class="language-lua">print(language.sourcekind_of(&quot;/xxxx/test.cpp&quot;))
</code></pre>
<p>显示结果为：<code>cxx</code>，也就是 <code>c++</code> 类型，具体对应列表见：<a href="#languagesourcekinds"  >language.sourcekinds</a></p>
<h2 id="lib.detect">lib.detect</h2>
<p>此模块提供了非常强大的探测功能，用于探测程序、编译器、语言特性、依赖包等。</p>
<blockquote>
<p>此模块的接口分散在多个模块目录中，尽量通过导入单个接口来使用，这样效率更高。</p>
</blockquote>
<h3 id="detect.find_file">detect.find_file</h3>
<p>查找文件。</p>
<p>这个接口提供了比 <a href="#os-files"  >os.files</a> 更加强大的工程， 可以同时指定多个搜索目录，并且还能对每个目录指定附加的子目录，来模式匹配查找，相当于是 <a href="#os-files"  >os.files</a> 的增强版。</p>
<p>例如：</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_file&quot;)

local file = find_file(&quot;ccache&quot;, { &quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;})
</code></pre>
<p>如果找到，返回的结果是：<code>/usr/bin/ccache</code></p>
<p>它同时也支持模式匹配路径，进行递归查找，类似 <code>os.files</code>：</p>

<pre class="language-lua"><code class="language-lua">local file = find_file(&quot;test.h&quot;, { &quot;/usr/include&quot;, &quot;/usr/local/include/**&quot;})
</code></pre>
<p>不仅如此，里面的路径也支持内建变量，来从环境变量和注册表中获取路径进行查找：</p>

<pre class="language-lua"><code class="language-lua">local file = find_file(&quot;xxx.h&quot;, { &quot;$(env PATH)&quot;, &quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name)&quot;})
</code></pre>
<p>如果路径规则比较复杂多变，还可以通过自定义脚本来动态生成路径传入：</p>

<pre class="language-lua"><code class="language-lua">local file = find_file(&quot;xxx.h&quot;, { &quot;$(env PATH)&quot;, function () return val(&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name&quot;):match(&quot;\&quot;(.-)\&quot;&quot;) end})
</code></pre>
<p>大部分场合下，上面的使用已经满足各种需求了，如果还需要一些扩展功能，可以通过传入第三个参数，自定义一些可选配置，例如：</p>

<pre class="language-lua"><code class="language-lua">local file = find_file(&quot;test.h&quot;, { &quot;/usr&quot;, &quot;/usr/local&quot;}, {suffixes = {&quot;/include&quot;, &quot;/lib&quot;}})
</code></pre>
<p>通过指定 suffixes 子目录列表，可以扩展路径列表（第二个参数），使得实际的搜索目录扩展为：</p>

<pre class="language-none"><code class="language-none">/usr/include
/usr/lib
/usr/local/include
/usr/local/lib
</code></pre>
<p>并且不用改变路径列表，就能动态切换子目录来搜索文件。</p>
<blockquote>
<p>我们也可以通过 <code>xmake lua</code> 插件来快速调用和测试此接口：<code>xmake lua lib.detect.find_file test.h /usr/local</code></p>
</blockquote>
<h3 id="detect.find_path">detect.find_path</h3>
<p>查找路径。</p>
<p>这个接口的用法跟 <a href="#detectfind_file"  >lib.detect.find_file</a> 类似，唯一的区别是返回的结果不同。<br />
此接口查找到传入的文件路径后，返回的是对应的搜索路径，而不是文件路径本身，一般用于查找文件对应的父目录位置。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_path&quot;)

local p = find_path(&quot;include/test.h&quot;, { &quot;/usr&quot;, &quot;/usr/local&quot;})
</code></pre>
<p>上述代码如果查找成功，则返回：<code>/usr/local</code>，如果 <code>test.h</code> 在 <code>/usr/local/include/test.h</code> 的话。</p>
<p>还有一个区别就是，这个接口传入不只是文件路径，还可以传入目录路径来查找：</p>

<pre class="language-lua"><code class="language-lua">local p = find_path(&quot;lib/xxx&quot;, { &quot;$(env PATH)&quot;, &quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\XXXX;Name)&quot;})
</code></pre>
<p>同样，此接口也支持模式匹配和后缀子目录：</p>

<pre class="language-lua"><code class="language-lua">local p = find_path(&quot;include/*.h&quot;, { &quot;/usr&quot;, &quot;/usr/local/**&quot;}, {suffixes = &quot;/subdir&quot;})
</code></pre>
<h3 id="detect.find_library">detect.find_library</h3>
<p>查找库文件。</p>
<p>此接口用于指定的搜索目录中查找库文件（静态库，动态库），例如：</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_library&quot;)

local library = find_library(&quot;crypto&quot;, {&quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;})
</code></pre>
<p>在 macosx 上运行，返回的结果如下：</p>

<pre class="language-lua"><code class="language-lua">{
    filename = libcrypto.dylib
,   linkdir = /usr/lib
,   link = crypto
,   kind = shared
}
</code></pre>
<p>如果不指定是否需要静态库还是动态库，那么此接口会自动选择一个存在的库（有可能是静态库、也有可能是动态库）进行返回。</p>
<p>如果需要强制指定需要查找的库类型，可以指定 kind 参数为（<code>static/shared</code>）：</p>

<pre class="language-lua"><code class="language-lua">local library = find_library(&quot;crypto&quot;, {&quot;/usr/lib&quot;, &quot;/usr/local/lib&quot;}, {kind = &quot;static&quot;})
</code></pre>
<p>此接口也支持 suffixes 后缀子目录搜索和模式匹配操作：</p>

<pre class="language-lua"><code class="language-lua">local library = find_library(&quot;cryp*&quot;, {&quot;/usr&quot;, &quot;/usr/local&quot;}, {suffixes = &quot;/lib&quot;})
</code></pre>
<h3 id="detect.find_program">detect.find_program</h3>
<p>查找可执行程序。</p>
<p>这个接口比 <a href="#detectfind_tool"  >lib.detect.find_tool</a> 较为原始底层，通过指定的参数目录来查找可执行程序。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_program&quot;)

local program = find_program(&quot;ccache&quot;)
</code></pre>
<p>上述代码犹如没有传递搜索目录，所以它会尝试直接执行指定程序，如果运行 ok，那么直接返回：<code>ccache</code>，表示查找成功。</p>
<p>指定搜索目录，修改尝试运行的检测命令参数（默认是：<code>ccache --version</code>）：</p>

<pre class="language-lua"><code class="language-lua">local program = find_program(&quot;ccache&quot;, {paths = {&quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;}, check = &quot;--help&quot;})
</code></pre>
<p>上述代码会尝试运行：<code>/usr/bin/ccache --help</code>，如果运行成功，则返回：<code>/usr/bin/ccache</code>。</p>
<p>如果 <code>--help</code> 也没法满足需求，有些程序没有 <code>--version/--help</code> 参数，那么可以自定义运行脚本，来运行检测：</p>

<pre class="language-lua"><code class="language-lua">local program = find_program(&quot;ccache&quot;, {paths = {&quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;}, check = function (program) os.run(&quot;%s -h&quot;, program) end})
</code></pre>
<p>同样，搜索路径列表支持内建变量和自定义脚本：</p>

<pre class="language-lua"><code class="language-lua">local program = find_program(&quot;ccache&quot;, {paths = {&quot;$(env PATH)&quot;, &quot;$(reg HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug;Debugger)&quot;}})
local program = find_program(&quot;ccache&quot;, {paths = {&quot;$(env PATH)&quot;, function () return &quot;/usr/local/bin&quot; end}})
</code></pre>
<p class="tip">
为了加速频发查找的效率，此接口是默认自带 cache 的，所以就算频繁查找相同的程序，也不会花太多时间。
如果要禁用 cache，可以在工程目录执行 `xmake f -c` 清除本地 cache。
</p>
<p>我们也可以通过 <code>xmake lua lib.detect.find_program ccache</code> 来快速测试。</p>
<h3 id="detect.find_programver">detect.find_programver</h3>
<p>查找可执行程序版本号。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_programver&quot;)

local programver = find_programver(&quot;ccache&quot;)
</code></pre>
<p>返回结果为：3.2.2</p>
<p>默认它会通过 <code>ccache --version</code> 尝试获取版本，如果不存在此参数，可以自己指定其他参数：</p>

<pre class="language-lua"><code class="language-lua">local version = find_programver(&quot;ccache&quot;, {command = &quot;-v&quot;})
</code></pre>
<p>甚至自定义版本获取脚本：</p>

<pre class="language-lua"><code class="language-lua">local version = find_programver(&quot;ccache&quot;, {command = function () return os.iorun(&quot;ccache --version&quot;) end})
</code></pre>
<p>对于版本号的提取规则，如果内置的匹配模式不满足要求，也可以自定义：</p>

<pre class="language-lua"><code class="language-lua">local version = find_programver(&quot;ccache&quot;, {command = &quot;--version&quot;, parse = &quot;(%d+%.?%d*%.?%d*.-)%s&quot;})
local version = find_programver(&quot;ccache&quot;, {command = &quot;--version&quot;, parse = function (output) return output:match(&quot;(%d+%.?%d*%.?%d*.-)%s&quot;) end})
</code></pre>
<blockquote>
<p>为了加速频发查找的效率，此接口是默认自带 cache 的，如果要禁用 cache，可以在工程目录执行 <code>xmake f -c</code> 清除本地 cache。</p>
</blockquote>
<p>我们也可以通过 <code>xmake lua lib.detect.find_programver ccache</code> 来快速测试。</p>
<h3 id="detect.find_package">detect.find_package</h3>
<p>查找包文件。</p>
<p>这个接口不推荐直接使用（仅供内部使用），库集成，请尽量使用 <code>add_requires()</code> 和 <code>add_packages()</code>。</p>
<h3 id="detect.find_tool">detect.find_tool</h3>
<p>查找工具。</p>
<p>此接口也是用于查找可执行程序，不过比 <a href="#detectfind_program"  >lib.detect.find_program</a> 更加的高级，功能也更加强大，它对可执行程序进行了封装，提供了工具这个概念：</p>
<ul>
<li>toolname: 工具名，可执行程序的简称，用于标示某个工具，例如：<code>gcc</code>, <code>clang</code> 等</li>
<li>program: 可执行程序命令，例如：<code>xcrun -sdk macosx clang</code></li>
</ul>
<p>其对应关系如下：</p>
<table>
<thead>
<tr>
  <th>toolname</th>
  <th>program</th>
</tr>
</thead>
<tbody>
<tr>
  <td>clang</td>
  <td><code>xcrun -sdk macosx clang</code></td>
</tr>
<tr>
  <td>gcc</td>
  <td><code>/usr/toolchains/bin/arm-linux-gcc</code></td>
</tr>
<tr>
  <td>link</td>
  <td><code>link.exe -lib</code></td>
</tr>
</tbody>
</table>
<p><a href="#detectfind_program"  >lib.detect.find_program</a> 只能通过传入的原始 program 命令或路径，去判断该程序是否存在。<br />
而 <code>find_tool</code> 则可以通过更加一致的 toolname 去查找工具，并且返回对应的 program 完整命令路径，例如：</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_tool&quot;)

local tool = find_tool(&quot;clang&quot;)
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;clang&quot;}</code>，这个时候还看不出区别，我们可以手动指定可执行的命令：</p>

<pre class="language-lua"><code class="language-lua">local tool = find_tool(&quot;clang&quot;, {program = &quot;xcrun -sdk macosx clang&quot;})
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;xcrun -sdk macosx clang&quot;}</code></p>
<p>而在 macosx 下，gcc 就是 clang，如果我们执行 <code>gcc --version</code> 可以看到就是 clang 的一个马甲，我们可以通过 <code>find_tool</code> 接口进行智能识别：</p>

<pre class="language-lua"><code class="language-lua">local tool = find_tool(&quot;gcc&quot;)
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;gcc&quot;}</code></p>
<p>通过这个结果就可以看的区别来了，工具名实际会被标示为 clang，但是可执行的命令用的是 gcc。</p>
<p>我们也可以指定 <code>{version = true}</code> 参数去获取工具的版本，并且指定一个自定义的搜索路径，也支持内建变量和自定义脚本哦：</p>

<pre class="language-lua"><code class="language-lua">local tool = find_tool(&quot;clang&quot;, {version = true, paths = {&quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;, &quot;$(env PATH)&quot;, function () return &quot;/usr/xxx/bin&quot; end}})
</code></pre>
<p>返回的结果为：<code>{name = &quot;clang&quot;, program = &quot;/usr/bin/clang&quot;, version = &quot;4.0&quot;}</code></p>
<p>这个接口是对 <code>find_program</code> 的上层封装，因此也支持自定义脚本检测：</p>

<pre class="language-lua"><code class="language-lua">local tool = find_tool(&quot;clang&quot;, {check = &quot;--help&quot;})
local tool = find_tool(&quot;clang&quot;, {check = function (tool) os.run(&quot;%s -h&quot;, tool) end})
</code></pre>
<p>最后总结下，<code>find_tool</code> 的查找流程：</p>
<ol>
<li>优先通过 <code>{program = &quot;xxx&quot;}</code> 的参数来尝试运行和检测。</li>
<li>如果在 <code>xmake/modules/detect/tools</code> 下存在 <code>detect.tools.find_xxx</code> 脚本，则调用此脚本进行更加精准的检测。</li>
<li>尝试从 <code>/usr/bin</code>，<code>/usr/local/bin</code> 等系统目录进行检测。</li>
</ol>
<p>我们也可以在工程 <code>xmake.lua</code> 中 <code>add_moduledirs</code> 指定的模块目录中，添加自定义查找脚本，来改进检测机制：</p>

<pre class="language-none"><code class="language-none">projectdir
  - xmake/modules
    - detect/tools/find_xxx.lua
</code></pre>
<p>例如我们自定义一个 <code>find_7z.lua</code> 的查找脚本：</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_program&quot;)
import(&quot;lib.detect.find_programver&quot;)

function main(opt)

    -- init options
    opt = opt or {}

    -- find program
    local program = find_program(opt.program or &quot;7z&quot;, opt.pathes, opt.check or &quot;--help&quot;)

    -- find program version
    local version = nil
    if program and opt and opt.version then
        version = find_programver(program, &quot;--help&quot;, &quot;(%d+%.?%d*)%s&quot;)
    end

    -- ok?
    return program, version
end
</code></pre>
<p>将它放置到工程的模块目录下后，执行：<code>xmake l lib.detect.find_tool 7z</code> 就可以查找到了。</p>
<blockquote>
<p>为了加速频发查找的效率，此接口是默认自带 cache 的，如果要禁用 cache，可以在工程目录执行 <code>xmake f -c</code> 清除本地 cache。</p>
</blockquote>
<p>我们也可以通过 <code>xmake lua lib.detect.find_tool clang</code> 来快速测试。</p>
<h3 id="detect.find_toolname">detect.find_toolname</h3>
<p>查找工具名。</p>
<p>通过 program 命令匹配对应的工具名，例如：</p>
<table>
<thead>
<tr>
  <th>program</th>
  <th>toolname</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>xcrun -sdk macosx clang</code></td>
  <td>clang</td>
</tr>
<tr>
  <td><code>/usr/bin/arm-linux-gcc</code></td>
  <td>gcc</td>
</tr>
<tr>
  <td><code>link.exe -lib</code></td>
  <td>link</td>
</tr>
<tr>
  <td><code>gcc-5</code></td>
  <td>gcc</td>
</tr>
<tr>
  <td><code>arm-android-clang++</code></td>
  <td>clangxx</td>
</tr>
<tr>
  <td><code>pkg-config</code></td>
  <td>pkg_config</td>
</tr>
</tbody>
</table>
<p>toolname 相比 program，更能唯一标示某个工具，也方便查找和加载对应的脚本 <code>find_xxx.lua</code>。</p>
<h3 id="detect.find_cudadevices">detect.find_cudadevices</h3>
<p>查找本机的 CUDA 设备。</p>
<p>通过 CUDA Runtime API 枚举本机的 CUDA 设备，并查询其属性。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.find_cudadevices&quot;)

local devices = find_cudadevices({skip_compute_mode_prohibited = true})
local devices = find_cudadevices({min_sm_arch = 35, order_by_flops = true})
</code></pre>
<p>返回的结果为：<code>{{ ['$id'] = 0, name = &quot;GeForce GTX 960M&quot;, major = 5, minor = 0, ... }, ... }</code></p>
<p>包含的属性依据当前 CUDA 版本会有所不同，可以参考 <a href="https://docs.nvidia.com/cuda/cuda-runtime-api/structcudaDeviceProp.html#structcudaDeviceProp"  target="_blank">CUDA 官方文档</a> 及其历史版本。</p>
<h3 id="detect.features">detect.features</h3>
<p>获取指定工具的所有特性。</p>
<p>此接口跟 <a href="#compilerfeatures"  >compiler.features</a> 类似，区别就是此接口更加的原始，传入的参数是实际的工具名 toolname。</p>
<p>并且此接口不仅能够获取编译器的特性，任何工具的特性都可以获取，因此更加通用。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.features&quot;)

local features = features(&quot;clang&quot;)
local features = features(&quot;clang&quot;, {flags = &quot;-O0&quot;, program = &quot;xcrun -sdk macosx clang&quot;})
local features = features(&quot;clang&quot;, {flags = {&quot;-g&quot;, &quot;-O0&quot;, &quot;-std=c++11&quot;}})
</code></pre>
<p>通过传入 flags，可以改变特性的获取结果，例如一些 c++11 的特性，默认情况下获取不到，通过启用 <code>-std=c++11</code> 后，就可以获取到了。</p>
<p>所有编译器的特性列表，可以见：<a href="#compilerfeatures"  >compiler.features</a>。</p>
<h3 id="detect.has_features">detect.has_features</h3>
<p>判断指定特性是否支持。</p>
<p>此接口跟 <a href="#compilerhas_features"  >compiler.has_features</a> 类似，但是更加原始，传入的参数是实际的工具名 toolname。</p>
<p>并且此接口不仅能够判断编译器的特性，任何工具的特性都可以判断，因此更加通用。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.has_features&quot;)

local features = has_features(&quot;clang&quot;, &quot;cxx_constexpr&quot;)
local features = has_features(&quot;clang&quot;, {&quot;cxx_constexpr&quot;, &quot;c_static_assert&quot;}, {flags = {&quot;-g&quot;, &quot;-O0&quot;}, program = &quot;xcrun -sdk macosx clang&quot;})
local features = has_features(&quot;clang&quot;, {&quot;cxx_constexpr&quot;, &quot;c_static_assert&quot;}, {flags = &quot;-g&quot;})
</code></pre>
<p>如果指定的特性列表存在，则返回实际支持的特性子列表，如果都不支持，则返回 nil，我们也可以通过指定 flags 去改变特性的获取规则。</p>
<p>所有编译器的特性列表，可以见：<a href="#compilerfeatures"  >compiler.features</a>。</p>
<h3 id="detect.has_flags">detect.has_flags</h3>
<p>判断指定参数选项是否支持。</p>
<p>此接口跟 <a href="#compilerhas_flags"  >compiler.has_flags</a> 类似，但是更加原始，传入的参数是实际的工具名 toolname。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.has_flags&quot;)

local ok = has_flags(&quot;clang&quot;, &quot;-g&quot;)
local ok = has_flags(&quot;clang&quot;, {&quot;-g&quot;, &quot;-O0&quot;}, {program = &quot;xcrun -sdk macosx clang&quot;})
local ok = has_flags(&quot;clang&quot;, &quot;-g -O0&quot;, {toolkind = &quot;cxx&quot;})
</code></pre>
<p>如果检测通过，则返回 true。</p>
<p>此接口的检测做了一些优化，除了 cache 机制外，大部分场合下，会去拉取工具的选项列表（<code>--help</code>）直接判断，如果选项列表里获取不到的话，才会通过尝试运行的方式来检测。</p>
<h3 id="detect.has_cfuncs">detect.has_cfuncs</h3>
<p>判断指定 c 函数是否存在。</p>
<p>此接口是 <a href="#detectcheck_cxsnippets"  >lib.detect.check_cxsnippets</a> 的简化版本，仅用于检测函数。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.has_cfuncs&quot;)

local ok = has_cfuncs(&quot;setjmp&quot;)
local ok = has_cfuncs({&quot;sigsetjmp((void*)0, 0)&quot;, &quot;setjmp&quot;}, {includes = &quot;setjmp.h&quot;})
</code></pre>
<p>对于函数的描述规则如下：</p>
<table>
<thead>
<tr>
  <th>函数描述</th>
  <th>说明</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>sigsetjmp</code></td>
  <td>纯函数名</td>
</tr>
<tr>
  <td><code>sigsetjmp((void*)0, 0)</code></td>
  <td>函数调用</td>
</tr>
<tr>
  <td><code>sigsetjmp{int a = 0; sigsetjmp((void*)a, a);}</code></td>
  <td>函数名 + {} 块</td>
</tr>
</tbody>
</table>
<p>在最后的可选参数中，除了可以指定 <code>includes</code> 外，还可以指定其他的一些参数用于控制编译检测的选项条件：</p>

<pre class="language-lua"><code class="language-lua">{verbose = false, target = [target|option], includes = .., configs = {linkdirs = .., links = .., defines = ..}}
</code></pre>
<p>其中 verbose 用于回显检测信息，target 用于在检测前追加 target 中的配置信息, 而 config 用于自定义配置跟 target 相关的编译选项。</p>
<h3 id="detect.has_cxxfuncs">detect.has_cxxfuncs</h3>
<p>判断指定 c++ 函数是否存在。</p>
<p>此接口跟 <a href="#detecthas_cfuncs"  >lib.detect.has_cfuncs</a> 类似，请直接参考它的使用说明，唯一区别是这个接口用于检测 c++ 函数。</p>
<h3 id="detect.has_cincludes">detect.has_cincludes</h3>
<p>判断指定 c 头文件是否存在。</p>
<p>此接口是 <a href="#detectcheck_cxsnippets"  >lib.detect.check_cxsnippets</a> 的简化版本，仅用于检测头文件。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.has_cincludes&quot;)

local ok = has_cincludes(&quot;stdio.h&quot;)
local ok = has_cincludes({&quot;stdio.h&quot;, &quot;stdlib.h&quot;}, {target = target})
local ok = has_cincludes({&quot;stdio.h&quot;, &quot;stdlib.h&quot;}, {configs = {defines = &quot;_GNU_SOURCE=1&quot;, languages = &quot;cxx11&quot;}})
</code></pre>
<h3 id="detect.has_cxxincludes">detect.has_cxxincludes</h3>
<p>判断指定 c++ 头文件是否存在。</p>
<p>此接口跟 <a href="#detecthas_cincludes"  >lib.detect.has_cincludess</a> 类似，请直接参考它的使用说明，唯一区别是这个接口用于检测 c++ 头文件。</p>
<h3 id="detect.has_ctypes">detect.has_ctypes</h3>
<p>判断指定 c 类型是否存在。</p>
<p>此接口是 <a href="#detectcheck_cxsnippets"  >lib.detect.check_cxsnippets</a> 的简化版本，仅用于检测函数。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.has_ctypes&quot;)

local ok = has_ctypes(&quot;wchar_t&quot;)
local ok = has_ctypes({&quot;char&quot;, &quot;wchar_t&quot;}, {includes = &quot;stdio.h&quot;})
local ok = has_ctypes(&quot;wchar_t&quot;, {includes = {&quot;stdio.h&quot;, &quot;stdlib.h&quot;}, configs = {&quot;defines =&quot;_GNU_SOURCE=1&quot;, languages =&quot;cxx11&quot;}})
</code></pre>
<h3 id="detect.has_cxxtypes">detect.has_cxxtypes</h3>
<p>判断指定 c++ 类型是否存在。</p>
<p>此接口跟 <a href="#detecthas_ctypes"  >lib.detect.has_ctypess</a> 类似，请直接参考它的使用说明，唯一区别是这个接口用于检测 c++ 类型。</p>
<h3 id="detect.check_cxsnippets">detect.check_cxsnippets</h3>
<p>检测 c/c++ 代码片段是否能够编译通过。</p>
<p>通用的 c/c++ 代码片段检测接口，通过传入多个代码片段列表，它会自动生成一个编译文件，然后常识对它进行编译，如果编译通过返回 true。</p>
<p>对于一些复杂的编译器特性，连 <a href="#compilerhas_features"  >compiler.has_features</a> 都无法检测到的时候，可以通过此接口通过尝试编译来检测它。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;lib.detect.check_cxsnippets&quot;)

local ok = check_cxsnippets(&quot;void test() {}&quot;)
local ok = check_cxsnippets({&quot;void test(){}&quot;, &quot;#define TEST 1&quot;}, {types = &quot;wchar_t&quot;, includes = &quot;stdio.h&quot;})
</code></pre>
<p>此接口是 <a href="#detecthas_cfuncs"  >detect.has_cfuncs</a>, <a href="#detecthas_cincludes"  >detect.has_cincludes</a> 和<a href="detect-has_ctypes"  >detect.has_ctypes</a>等接口的通用版本，也更加底层。</p>
<p>因此我们可以用它来检测：types, functions, includes 还有 links，或者是组合起来一起检测。</p>
<p>第一个参数为代码片段列表，一般用于一些自定义特性的检测，如果为空，则可以仅仅检测可选参数中条件，例如：</p>

<pre class="language-lua"><code class="language-lua">local ok = check_cxsnippets({}, {types = {&quot;wchar_t&quot;, &quot;char*&quot;}, includes = &quot;stdio.h&quot;, funcs = {&quot;sigsetjmp&quot;, &quot;sigsetjmp((void*)0, 0)&quot;}})
</code></pre>
<p>上面那个调用，会去同时检测 types, includes 和 funcs 是否都满足，如果通过返回 true。</p>
<p>还有其他一些可选参数：</p>

<pre class="language-lua"><code class="language-lua">{verbose = false, target = [target|option], sourcekind = &quot;[cc|cxx]&quot;}
</code></pre>
<p>其中 verbose 用于回显检测信息，target 用于在检测前追加 target 中的配置信息, sourcekind 用于指定编译器等工具类型，例如传入 <code>cxx</code> 强制作为 c++ 代码来检测。</p>
<h2 id="net.http">net.http</h2>
<p>此模块提供 http 的各种操作支持，目前提供的接口如下：</p>
<h3 id="http.download">http.download</h3>
<p>下载 http 文件。</p>
<p>这个接口比较简单，就是单纯的下载文件。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;net.http&quot;)

http.download(&quot;https://xmake.io&quot;, &quot;/tmp/index.html&quot;)
</code></pre>
<h2 id="privilege.sudo">privilege.sudo</h2>
<p>此接口用于通过 <code>sudo</code> 来运行命令，并且提供了平台一致性处理，对于一些需要 root 权限运行的脚本，可以使用此接口。</p>
<blockquote>
<p>为了保证安全性，除非必须使用的场合，其他情况下尽量不要使用此接口。</p>
</blockquote>
<h3 id="sudo.has">sudo.has</h3>
<p>判断 sudo 是否支持。</p>
<p>目前仅在 <code>macosx/linux</code> 下支持 sudo，windows 上的管理员权限运行暂时还不支持，因此建议使用前可以通过此接口判断支持情况后，针对性处理。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;privilege.sudo&quot;)

if sudo.has() then
    sudo.run(&quot;rm /system/file&quot;)
end
</code></pre>
<h3 id="sudo.run">sudo.run</h3>
<p>安静运行原生 shell 命令。</p>
<p>具体用法可参考：<a href="#os-run"  >os.run</a>。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;privilege.sudo&quot;)

sudo.run(&quot;rm /system/file&quot;)
</code></pre>
<h3 id="sudo.runv">sudo.runv</h3>
<p>安静运行原生 shell 命令，带参数列表。</p>
<p>具体用法可参考：<a href="#os-runv"  >os.runv</a>。</p>
<h3 id="sudo.exec">sudo.exec</h3>
<p>回显运行原生 shell 命令。</p>
<p>具体用法可参考：<a href="#os-exec"  >os.exec</a>。</p>
<h3 id="sudo.execv">sudo.execv</h3>
<p>回显运行原生 shell 命令，带参数列表。</p>
<p>具体用法可参考：<a href="#os-execv"  >os.execv</a>。</p>
<h3 id="sudo.iorun">sudo.iorun</h3>
<p>安静运行原生 shell 命令并获取输出内容。</p>
<p>具体用法可参考：<a href="#os-iorun"  >os.iorun</a>。</p>
<h3 id="sudo.iorunv">sudo.iorunv</h3>
<p>安静运行原生 shell 命令并获取输出内容，带参数列表。</p>
<p>具体用法可参考：<a href="#os-iorunv"  >os.iorunv</a>。</p>
<h2 id="devel.git">devel.git</h2>
<p>此接口提供了 git 各种命令的访问接口，相对于直接调用 git 命令，此模块提供了更加上层易用的封装接口，并且提供对 git 的自动检测和跨平台处理。</p>
<h3 id="git.clone">git.clone</h3>
<p>clone 代码库。</p>
<p>此接口对应 <code>git clone</code> 命令</p>

<pre class="language-lua"><code class="language-lua">import(&quot;devel.git&quot;)

git.clone(&quot;git@github.com:tboox/xmake.git&quot;)
git.clone(&quot;git@github.com:tboox/xmake.git&quot;, {depth = 1, branch = &quot;master&quot;, outputdir = &quot;/tmp/xmake&quot;})
</code></pre>
<h3 id="git.pull">git.pull</h3>
<p>拉取代码库最新提交。</p>
<p>此接口对应 <code>git pull</code> 命令</p>

<pre class="language-lua"><code class="language-lua">import(&quot;devel.git&quot;)

git.pull()
git.pull({remote = &quot;origin&quot;, tags = true, branch = &quot;master&quot;, repodir = &quot;/tmp/xmake&quot;})
</code></pre>
<h3 id="git.clean">git.clean</h3>
<p>清理代码库文件。</p>
<p>此接口对应 <code>git clean</code> 命令</p>

<pre class="language-lua"><code class="language-lua">import(&quot;devel.git&quot;)

git.clean()
git.clean({repodir = &quot;/tmp/xmake&quot;, force = true})
</code></pre>
<h3 id="git.checkout">git.checkout</h3>
<p>签出指定分支版本。</p>
<p>此接口对应 <code>git checkout</code> 命令</p>

<pre class="language-lua"><code class="language-lua">import(&quot;devel.git&quot;)

git.checkout(&quot;master&quot;, {repodir = &quot;/tmp/xmake&quot;})
git.checkout(&quot;v1.0.1&quot;, {repodir = &quot;/tmp/xmake&quot;})
</code></pre>
<h3 id="git.refs">git.refs</h3>
<p>获取所有引用列表。</p>
<p>此接口对应 <code>git ls-remote --refs</code> 命令</p>

<pre class="language-lua"><code class="language-lua">import(&quot;devel.git&quot;)

local refs = git.refs(url)
</code></pre>
<h3 id="git.tags">git.tags</h3>
<p>获取所有标记列表。</p>
<p>此接口对应 <code>git ls-remote --tags</code> 命令</p>

<pre class="language-lua"><code class="language-lua">import(&quot;devel.git&quot;)

local tags = git.tags(url)
</code></pre>
<h3 id="git.branches">git.branches</h3>
<p>获取所有分支列表。</p>
<p>此接口对应 <code>git ls-remote --heads</code> 命令</p>

<pre class="language-lua"><code class="language-lua">import(&quot;devel.git&quot;)

local branches = git.branches(url)
</code></pre>
<h2 id="utils.archive">utils.archive</h2>
<p>此模块用于压缩和解压文件。支持大部分常用压缩格式的解压缩，它会自动检测系统提供了哪些压缩工具，然后会使用最合适的压缩工具进行操作。</p>
<h3 id="archive.archive">archive.archive</h3>
<ul>
<li>压缩文件</li>
</ul>

<pre class="language-lua"><code class="language-lua">import(&quot;utils.archive&quot;)

archive.archive(&quot;/tmp/a.zip&quot;, &quot;/tmp/outputdir&quot;)
archive.archive(&quot;/tmp/a.7z&quot;, &quot;/tmp/outputdir&quot;)
archive.archive(&quot;/tmp/a.gzip&quot;, &quot;/tmp/outputdir&quot;)
archive.archive(&quot;/tmp/a.tar.bz2&quot;, &quot;/tmp/outputdir&quot;)
</code></pre>
<p>还可以添加一些配置选项，如递归目录，压缩质量，排除文件等。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;utils.archive&quot;)

local options = {}
options.curdir = &quot;/tmp&quot;
options.recurse = true
options.compress = &quot;fastest|faster|default|better|best&quot;
options.excludes = {&quot;*/dir/*&quot;, &quot;dir/*&quot;}
archive.archive(&quot;/tmp/a.zip&quot;, &quot;/tmp/outputdir&quot;, options)
</code></pre>
<h3 id="archive.extract">archive.extract</h3>
<p>解压文件。</p>

<pre class="language-lua"><code class="language-lua">import(&quot;utils.archive&quot;)

archive.extract(&quot;/tmp/a.zip&quot;, &quot;/tmp/outputdir&quot;)
archive.extract(&quot;/tmp/a.7z&quot;, &quot;/tmp/outputdir&quot;)
archive.extract(&quot;/tmp/a.gzip&quot;, &quot;/tmp/outputdir&quot;)
archive.extract(&quot;/tmp/a.tar.bz2&quot;, &quot;/tmp/outputdir&quot;)
</code></pre>
<h2 id="utils.platform">utils.platform</h2>
<p>此模块用于一些平台相关的辅助操作接口</p>
<h2 id="cli">cli</h2>
<h3 id="cli.amalgamate">cli.amalgamate</h3>
<p>合并成单源码文件。</p>
<p>这是一个小工具模块，主要用于快速合并指定 target 里面的所有 c/c++ 和 头文件源码到单个源文件。</p>
<p>合并会将内部 includes 头文件全部展开，并生成 DAG，通过拓扑排序引入。</p>
<p>默认它会处理所有 target 的合并，例如：</p>

<pre class="language-bash"><code class="language-bash">$ xmake l cli.amalgamate
build/tbox.c generated!
build/tbox.h generated!
</code></pre>
<p>我们也可以指定合并需要的目标：</p>

<pre class="language-bash"><code class="language-bash">$ xmake l cli.amalgamate tbox
build/tbox.c generated!
build/tbox.h generated!
</code></pre>
<p>也可以在合并每个源文件时候，指定一个自定义的 unique ID 的宏定义，来处理符号冲突问题。</p>

<pre class="language-bash"><code class="language-bash">$ xmake l cli.amalgamate -u MY_UNIQUEU_ID
build/tbox.c generated!
build/tbox.h generated!
</code></pre>
<p>如果多个源文件内部有重名符号，就可以判断这个 <code>MY_UNIQUEU_ID</code> 宏是否被定义，如果定义了，说明是在单文件中，就自己在源码中处理下重名符号。</p>

<pre class="language-c"><code class="language-c">#ifdef MY_UNIQUEU_ID
    // do some thing
#endif
</code></pre>
<p>我们也可以指定输出位置：</p>

<pre class="language-bash"><code class="language-bash">$ xmake l cli.amalgamate -o /xxx
/xxx/tbox.c generated!
/xxx/tbox.h generated!
</code></pre>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/get_started/zh/module/builtin-modules.html">
                            <span class="icon"></span>
                            <span class="label">内置模块</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/get_started/zh/module/native-modules.html">
                            <span class="label">Lua 原生模块</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>链接</a><ul><li><a target="_blank" href="https://teedoc.neucrack.com">使用 teedoc 构建</a></li>
<li><a  href="/sitemap.xml">网站地图</a></li>
</ul>
</li>
<li><a>源码</a><ul><li><a target="_blank" href="https://github.com/zxmake/zxmake.github.io">github</a></li>
<li><a target="_blank" href="https://github.com/zxmake/zxmake.github.io">gitee</a></li>
<li><a target="_blank" href="https://github.com/zxmake/zxmake.github.io">本网站源文件</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://beian.miit.gov.cn">*ICP备********号</a></li>
<li><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=****************">*公网安备***********号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script src="/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/static/js/theme_default/main.js"></script>
    
        <script src="/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/static/css/theme_default/prism.min.js"></script>
    
        <script src="/static/js/search/search_main.js"></script>
    
        <script src="/static/js/plugin_blog/main.js"></script>
    
        <script src="/static/js/custom.js"></script>
    
</body>

</html>