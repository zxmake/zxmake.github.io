<!DOCTYPE html>

<html lang="zh-CN"  class=" language_zh  heading_no_counter ">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <script src="/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/static/css/search/style.css" type="text/css"/>
        
        <meta name="blog-generator" content="teedoc-plugin-blog">
        
        <link rel="stylesheet" href="/static/css/custom.css" type="text/css"/>
        
    
    
    <title>xmake-docs</title>
    
    <script type="text/javascript">js_vars = {}</script>
    <script type="text/javascript">metadata = {"tags": [], "date": false, "update": [], "ts": 0, "author": "", "brief": "", "cover": "", "class": "heading_no_counter"}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/">
                
                    <img class="site_logo" src="/static/image/logo-1600.png" alt="logo">
                
                
                    <h2>xmake</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/get_started/zh/tutorial/quick-start.md">安装使用</a></li>
<li class=""><a  href="/dev/">开发文档</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/neutree/teedoc">github</a></li>
<li class="sub_items "><a  >Language: 中文 简体</a><ul><li class=""><a  href="/get_started/en/package/description-scope.html">English</a></li>
<li class="active"><a  href="/get_started/zh/package/description-scope.html">中文 简体</a></li>
</ul></li>
</ul>

                <ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">搜索</span>
                            <div id="search_hints">
                                <span id="search_input_hint">输入关键词，多关键词空格隔开</span>
                                <span id="search_loading_hint">正在加载，请稍候。。。</span>
                                <span id="search_download_err_hint">下载文件失败，请刷新重试或检查网络</span>
                                <span id="search_other_docs_result_hint">来自其它文档的结果</span>
                                <span id="search_curr_doc_result_hint">当前文档搜索结果</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active no_link sidebar_category"><span class="label">新手教程</span></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/install.html"><span class="label">安装</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/quick-start.html"><span class="label">快速入门</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/tutorial/syntax-description.html"><span class="label">语法描述</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/tutorial/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/project-examples.html"><span class="label">工程例子</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/configuration.html"><span class="label">配置说明</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/environment-variables.html"><span class="label">环境变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/build-policies.html"><span class="label">构建策略</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/builtin-variables.html"><span class="label">内置变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/tutorial/FAQ.html"><span class="label">FAQ</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">target 编译目标</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/target/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">option 选项</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/get_started/zh/option/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
</ul>
</li>
<li class="active_parent no_link"><a><span class="label">package 包管理</span><span class="sub_indicator"></span></a><ul class="show">
<li class="active with_link"><a href="/get_started/zh/package/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/local-package.html"><span class="label">使用本地包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/remote-package.html"><span class="label">使用远程包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/system-package.html"><span class="label">使用系统包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/package/local-3rd-source-package.html"><span class="label">继承本地第三方源码库</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/get_started/zh/rule/index.html"><span class="label">rule 规则</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/rule/builtin-rules.html"><span class="label">内建规则</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/rule/description-scope.html"><span class="label">描述域</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">toolchain 工具链</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/get_started/zh/toolchain/builtin-toolchains.html"><span class="label">内置工具链</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/toolchain/custom-toolchains.html"><span class="label">自定义工具链</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/get_started/zh/toolchain/remote-toolchains.html"><span class="label">远程工具链</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active with_link"><a href="/get_started/zh/no_translate.html?ref=plugin/index.html&from=/get_started/zh/plugin/index.html"><span class="label">plugin 插件</span><span class=""></span></a></li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1></h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/TOMO-CAT/xmake-teedoc/docs/get_started/zh/package/description-scope.md" target="_blank">
                                    编辑本页
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <h1 id="%E6%8F%8F%E8%BF%B0%E5%9F%9F">描述域</h1>
<h2 id="%E4%BB%93%E5%BA%93%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%9A%E4%B9%89%E6%8F%8F%E8%BF%B0">仓库依赖包定义描述</h2>
<p>可先参考官方仓库中现有包描述：<a href="https://github.com/xmake-io/xmake-repo"  target="_blank">xmake-repo</a></p>
<p>这里给个比较具有代表性的实例供参考：</p>

<pre class="language-lua"><code class="language-lua">package(&quot;libxml2&quot;, function()
    set_homepage(&quot;http://xmlsoft.org/&quot;)
    set_description(&quot;The XML C parser and toolkit of Gnome.&quot;)

    set_urls(&quot;https://github.com/GNOME/libxml2/archive/$(version).zip&quot;, {excludes = {&quot;*/result/*&quot;, &quot;*/test/*&quot;}})

    add_versions(&quot;v2.9.8&quot;, &quot;c87793e45e66a7aa19200f861873f75195065de786a21c1b469bdb7bfc1230fb&quot;)
    add_versions(&quot;v2.9.7&quot;, &quot;31dd4c0e10fa625b47e27fd6a5295d246c883f214da947b9a4a9e13733905ed9&quot;)

    if is_plat(&quot;macosx&quot;, &quot;linux&quot;) then
        add_deps(&quot;autoconf&quot;, &quot;automake&quot;, &quot;libtool&quot;, &quot;pkg-config&quot;)
    end

    on_load(function (package)
        package:add(&quot;includedirs&quot;, &quot;include/libxml2&quot;)
        package:add(&quot;links&quot;, &quot;xml2&quot;)
    end)

    if is_plat(&quot;windows&quot;) and winos.version():gt(&quot;winxp&quot;) then
        on_install(&quot;windows&quot;, function (package)
            os.cd(&quot;win32&quot;)
            os.vrun(&quot;cscript configure.js iso8859x=yes iconv=no compiler=msvc cruntime=/MT debug=%s prefix=\&quot;%s\&quot;&quot;, package:debug() and&quot;yes&quot;or&quot;no&quot;, package:installdir())
            os.vrun(&quot;nmake /f Makefile.msvc&quot;)
            os.vrun(&quot;nmake /f Makefile.msvc install&quot;)
        end)
    end

    on_install(&quot;macosx&quot;, &quot;linux&quot;, function (package)
        import(&quot;package.tools.autoconf&quot;).install(package, {&quot;--disable-dependency-tracking&quot;, &quot;--without-python&quot;, &quot;--without-lzma&quot;})
    end)
end)
</code></pre>
<h2 id="package%3Aset_homepage">package:set_homepage</h2>
<p>设置包所在项目的官方页面地址。</p>
<h2 id="package%3Aset_description">package:set_description</h2>
<p>设置包的相关描述信息。</p>
<p>一般通过 <code>xmake require --info zlib</code> 查看相关包信息时候，会看到。</p>
<h2 id="package%3Aset_kind">package:set_kind</h2>
<p>设置包类型。</p>
<p>对于依赖库，则不用设置，如果是可执行包，需要设置为 binary。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;cmake&quot;, function()
    set_kind(&quot;binary&quot;)
    set_homepage(&quot;https://cmake.org&quot;)
    set_description(&quot;A cross-platform family of tool designed to build, test and package software&quot;)
end)
</code></pre>
<h2 id="package%3Aset_urls">package:set_urls</h2>
<p>设置包源地址。</p>
<p>设置包的源码包或者 git 仓库地址，跟 add_urls 不同的是，此接口是覆盖性设置，而 add_urls 是追加设置，其他使用方式类似，这个根据不同需要来选择。</p>
<h2 id="package%3Aadd_urls">package:add_urls</h2>
<p>添加包源地址。</p>
<p>添加包的源码包或者 git 仓库地址，此接口一般跟 add_version 配对使用，用于设置每个源码包的版本和对应的 sha256 值或者 git 的 commit 或者 tag 或者 branch。</p>
<blockquote>
<p>可以通过添加多个 urls 作为镜像源，xmake 会自动检测优先选用最快的 url 进行下载，如果下载失败则会尝试其他 urls。</p>
</blockquote>

<pre class="language-lua"><code class="language-lua">add_urls(&quot;https://github.com/protobuf-c/protobuf-c/releases/download/v$(version)/protobuf-c-$(version).tar.gz&quot;)
add_versions(&quot;1.3.1&quot;, &quot;51472d3a191d6d7b425e32b612e477c06f73fe23e07f6a6a839b11808e9d2267&quot;)
</code></pre>
<p>urls 里面的 <code>$(version)</code> 内置变量，会根据实际安装时候选择的版本适配进去，而版本号都是从 <code>add_versions</code> 中指定的版本列表中选择的。</p>
<p>如果对于 urls 里面带有比较复杂的版本串，没有跟 <code>add_versions</code> 有直接对应关系，则需要通过下面的方式定制化转换下：</p>

<pre class="language-lua"><code class="language-lua">add_urls(&quot;https://sqlite.org/2018/sqlite-autoconf-$(version)000.tar.gz&quot;,
         {version = function (version) return version:gsub(&quot;%.&quot;, &quot;&quot;) end})

add_versions(&quot;3.24.0&quot;, &quot;d9d14e88c6fb6d68de9ca0d1f9797477d82fc3aed613558f87ffbdbbc5ceb74a&quot;)
add_versions(&quot;3.23.0&quot;, &quot;b7711a1800a071674c2bf76898ae8584fc6c9643cfe933cfc1bc54361e3a6e49&quot;)
</code></pre>
<p>当然，我们也只可以添加 git 源码地址：</p>

<pre class="language-lua"><code class="language-lua">add_urls(&quot;https://gitlab.gnome.org/GNOME/libxml2.git&quot;)
</code></pre>
<p>如果设置的多个镜像地址对应的源码包 sha256 是不同的，我们可以通过 alias 的方式来分别设置</p>

<pre class="language-lua"><code class="language-lua">add_urls(&quot;https://ffmpeg.org/releases/ffmpeg-$(version).tar.bz2&quot;, {alias = &quot;home&quot;})
add_urls(&quot;https://github.com/FFmpeg/FFmpeg/archive/n$(version).zip&quot;, {alias = &quot;github&quot;})
add_versions(&quot;home:4.0.2&quot;, &quot;346c51735f42c37e0712e0b3d2f6476c86ac15863e4445d9e823fe396420d056&quot;)
add_versions(&quot;github:4.0.2&quot;, &quot;4df1ef0bf73b7148caea1270539ef7bd06607e0ea8aa2fbf1bb34062a097f026&quot;)
</code></pre>
<p>我们也可以设置指定的 urls 的 http headers：</p>

<pre class="language-lua"><code class="language-lua">add_urls(&quot;https://github.com/madler/zlib/archive/$(version).tar.gz&quot;, {
    http_headers = {&quot;TEST1: foo&quot;, &quot;TEST2: bar&quot;}
})
</code></pre>
<h2 id="package%3Aadd_versions">package:add_versions</h2>
<p>设置每个源码包的版本。</p>
<p>它也会设置对应的 sha256 值，具体描述见：<a href="#packageadd_urls"  >add_urls</a></p>
<h2 id="package%3Aadd_versionfiles">package:add_versionfiles</h2>
<p>添加包版本列表。</p>
<p>通常我们可以通过 <code>add_versions</code> 接口添加包版本，但是如果版本越来越多，就会导致包配置太过臃肿，这个时候，我们可以使用 <code>add_versionfiles</code> 接口将所有的版本列表，存储到单独的文件中去维护。</p>
<p>例如：</p>

<pre class="language-lua"><code class="language-lua">package(&quot;libcurl&quot;, function()
    add_versionfiles(&quot;versions.txt&quot;)
end)
</code></pre>

<pre class="language-bash"><code class="language-bash">8.5.0 ce4b6a6655431147624aaf582632a36fe1ade262d5fab385c60f78942dd8d87b
8.4.0 e5250581a9c032b1b6ed3cf2f9c114c811fc41881069e9892d115cc73f9e88c6
8.0.1 9b6b1e96b748d04b968786b6bdf407aa5c75ab53a3d37c1c8c81cdb736555ccf
7.87.0 5d6e128761b7110946d1276aff6f0f266f2b726f5e619f7e0a057a474155f307
7.31.0 a73b118eececff5de25111f35d1d0aafe1e71afdbb83082a8e44d847267e3e08
...
</code></pre>
<h2 id="package%3Aadd_patches">package:add_patches</h2>
<p>设置包补丁。</p>
<p>此接口用于针对源码包，在编译安装前，先打对应设置的补丁包，再对其进行编译，并且可支持同时打多个补丁。</p>

<pre class="language-lua"><code class="language-lua">if is_plat(&quot;macosx&quot;) then
    add_patches(&quot;1.15&quot;, &quot;https://raw.githubusercontent.com/Homebrew/patches/9be2793af/libiconv/patch-utf8mac.diff&quot;,
                        &quot;e8128732f22f63b5c656659786d2cf76f1450008f36bcf541285268c66cabeab&quot;)
end
</code></pre>
<p>例如，上面的代码，就是针对 macosx 下编译的时候，打上对应的 patch-utf8mac.diff 补丁，并且每个补丁后面也是要设置 sha256 值的，确保完整性。</p>
<h2 id="package%3Aadd_links">package:add_links</h2>
<p>设置库链接。</p>
<p>默认情况下，xmake 会去自动检测安装后的库，设置链接关系，但是有时候并不是很准，如果要自己手动调整链接顺序，以及链接名，则可以通过这个接口来设置。</p>

<pre class="language-lua"><code class="language-lua">add_links(&quot;mbedtls&quot;, &quot;mbedx509&quot;, &quot;mbedcrypto&quot;)
</code></pre>
<h2 id="package%3Aadd_syslinks">package:add_syslinks</h2>
<p>设置系统库链接。</p>
<p>添加一些系统库链接，有些包集成链接的时候，还需要依赖一些系统库，才能链接通过，这个时候可以在包描述里面都附加上去。</p>

<pre class="language-lua"><code class="language-lua">if is_plat(&quot;macosx&quot;) then
    add_frameworks(&quot;CoreGraphics&quot;, &quot;CoreFoundation&quot;, &quot;Foundation&quot;)
elseif is_plat(&quot;windows&quot;) then
    add_defines(&quot;CAIRO_WIN32_STATIC_BUILD=1&quot;)
    add_syslinks(&quot;gdi32&quot;, &quot;msimg32&quot;, &quot;user32&quot;)
else
    add_syslinks(&quot;pthread&quot;)
end
</code></pre>
<h2 id="package%3Aadd_linkorders">package:add_linkorders</h2>
<p>调整包内部的链接顺序。</p>
<p>具体详情可以看下 target 内部对 <code>add_linkorders</code> 的文档说明，<a href="https://xmake.io/#/zh-cn/manual/project_target?id=targetadd_linkorders"  target="_blank">target/add_linkorders</a>。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;libpng&quot;, function()
    add_linkorders(&quot;png16&quot;, &quot;png&quot;, &quot;linkgroup::foo&quot;)
    add_linkgroups(&quot;dl&quot;, {name = &quot;foo&quot;, group = true})
end)
</code></pre>
<h2 id="package%3Aadd_linkgroups">package:add_linkgroups</h2>
<p>配置包的链接组。</p>
<p>具体详情可以看下 target 内部对 <code>add_linkgroups</code> 的文档说明，<a href="https://xmake.io/#/zh-cn/manual/project_target?id=targetadd_linkgroups"  target="_blank">target/add_linkgroups</a>。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;libpng&quot;, function()
    add_linkorders(&quot;png16&quot;, &quot;png&quot;, &quot;linkgroup::foo&quot;)
    add_linkgroups(&quot;dl&quot;, {name = &quot;foo&quot;, group = true})
end)
</code></pre>
<h2 id="package%3Aadd_frameworks">package:add_frameworks</h2>
<p>添加依赖的系统 frameworks 链接。</p>
<p>示例见：<a href="#packageadd_syslinks"  >add_syslinks</a></p>
<h2 id="package%3Aadd_linkdirs">package:add_linkdirs</h2>
<p>添加链接目录。</p>
<p>包的链接库搜索目录也是可以调整的，不过通常都不需要，除非一些库安装完不在 prefix/lib 下面，而在 lib 的子目录下，默认搜索不到的话。</p>
<h2 id="package%3Aadd_includedirs">package:add_includedirs</h2>
<p>添加其他头文件搜索目录。</p>
<h2 id="package%3Aadd_bindirs">package:add_bindirs</h2>
<p>添加可执行文件目录。</p>
<p>默认情况下，如果配置了 <code>set_kind(&quot;binary&quot;)</code> 或者 <code>set_kind(&quot;toolchain&quot;)</code> 作为可执行的包。</p>
<p>那么，它默认会将 bin 目录作为可执行目录，并且自动将它加入到 PATH 环境变量中去。</p>
<p>而如果对应 library 包，想要将里面附带编译的一些可执行工具开放给用户执行，那么需要在包中配置 <code>package:addenv(&quot;PATH&quot;, &quot;bin&quot;)</code> 中才行。</p>
<p>而通过这个接口去配置 <code>add_bindirs(&quot;bin&quot;)</code> ，那么将会自动将 bin 添加到 PATH，不再需要单独配置 PATH，另外，这也提供了一种可以修改可执行目录的方式。</p>
<h2 id="package%3Aadd_defines">package:add_defines</h2>
<p>添加宏定义。</p>
<p>可以对集成的包对外输出一些特定的定义选项。</p>
<h2 id="package%3Aadd_configs">package:add_configs</h2>
<p>添加包配置。</p>
<p>我们可以通过此接口添加每个包的对外输出配置参数：</p>

<pre class="language-lua"><code class="language-lua">package(&quot;pcre2&quot;, function()
    set_homepage(&quot;https://www.pcre.org/&quot;)
    set_description(&quot;A Perl Compatible Regular Expressions Library&quot;)

    add_configs(&quot;bitwidth&quot;, {description = &quot;Set the code unit width.&quot;, default = &quot;8&quot;, values = {&quot;8&quot;, &quot;16&quot;, &quot;32&quot;}})

    on_load(function (package)
        local bitwidth = package:config(&quot;bitwidth&quot;) or &quot;8&quot;
        package:add(&quot;links&quot;, &quot;pcre2-&quot; .. bitwidth)
        package:add(&quot;defines&quot;, &quot;PCRE2_CODE_UNIT_WIDTH=&quot; .. bitwidth)
    end)
end)
</code></pre>
<p>在工程项目里面，我们也可以查看特定包的可配置参数和值列表：</p>

<pre class="language-bash"><code class="language-bash">$ xmake require --info pcre2
The package info of project:
    require(pcre2):
      -&gt; description: A Perl Compatible Regular Expressions Library
      -&gt; version: 10.31
      ...
      -&gt; configs:
         -&gt; bitwidth:
            -&gt; description: Set the code unit width.
            -&gt; values: {&quot;8&quot;,&quot;16&quot;,&quot;32&quot;}
            -&gt; default: 8
</code></pre>
<p>然后在项目里面，启用这些配置，编译集成带有特定配置的包：</p>

<pre class="language-lua"><code class="language-lua">add_requires(&quot;pcre2&quot;, {configs = {bitwidth = 16}})
</code></pre>
<h2 id="package%3Aadd_extsources">package:add_extsources</h2>
<p>添加扩展的包源。</p>
<p>支持 <code>add_extsources</code> 和 <code>on_fetch</code> 两个配置接口，可以更好的配置 xmake 在安装 C/C++ 包的过程中，对系统库的查找过程。</p>
<p>至于具体背景，我们可以举个例子，比如我们在 <a href="https://github.com/xmake-io/xmake-repo"  target="_blank">xmake-repo</a> 仓库新增了一个 <code>package(&quot;libusb&quot;)</code> 的包。</p>
<p>那么用户就可以通过下面的方式，直接集成使用它：</p>

<pre class="language-lua"><code class="language-lua">add_requires(&quot;libusb&quot;)
target(&quot;test&quot;, function()
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_packages(&quot;libusb&quot;)
end)
</code></pre>
<p>如果用户系统上确实没有安装 libusb，那么 xmake 会自动下载 libusb 库源码，自动编译安装集成，没啥问题。</p>
<p>但如果用户通过 <code>apt install libusb-1.0</code> 安装了 libusb 库到系统，那么按理 xmake 应该会自动优先查找用户安装到系统环境的 libusb 包，直接使用，避免额外的下载编译安装。</p>
<p>但是问题来了，xmake 内部通过 <code>find_package(&quot;libusb&quot;)</code> 并没有找打它，这是为什么呢？因为通过 apt 安装的 libusb 包名是 <code>libusb-1.0</code>, 而不是 libusb。</p>
<p>我们只能通过 <code>pkg-config --cflags libusb-1.0</code> 才能找到它，但是 xmake 内部的默认 find_package 逻辑并不知道 <code>libusb-1.0</code> 的存在，所以找不到。</p>
<p>因此为了更好地适配不同系统环境下，系统库的查找，我们可以通过 <code>add_extsources(&quot;pkgconfig::libusb-1.0&quot;)</code> 去让 xmake 改进查找逻辑，例如：</p>

<pre class="language-lua"><code class="language-lua">package(&quot;libusb&quot;, function()
    add_extsources(&quot;pkgconfig::libusb-1.0&quot;)
    on_install(function (package)
        -- ...
    end)
end)
</code></pre>
<p>另外，我们也可以通过这个方式，改进查找 homebrew/pacman 等其他包管理器安装的包，例如：<code>add_extsources(&quot;pacman::libusb-1.0&quot;)</code>。</p>
<h2 id="package%3Aadd_deps">package:add_deps</h2>
<p>添加包依赖接口，通过配置包之间的依赖关系，我们能够在安装包的同时，自动安装它的所有依赖包。</p>
<p>另外，默认情况下，我们只要配置了依赖关系，cmake/autoconf 就能够自动找到所有依赖包的库和头文件。</p>
<p>当然，如果由于一些特殊原因，导致当前包的 cmake 脚本没能够正常找到依赖包，那么我们也可以通过 <code>{packagedeps = &quot;xxx&quot;}</code> 来强行打入依赖包信息。</p>
<p>例如：</p>

<pre class="language-lua"><code class="language-lua">package(&quot;foo&quot;, function()
    add_deps(&quot;cmake&quot;, &quot;bar&quot;)
    on_install(function (package)
        local configs = {}
        import(&quot;package.tools.cmake&quot;).install(package, configs)
    end)
end)
</code></pre>
<p>foo 包是使用 CMakeLists.txt 维护的，它在安装过程中，依赖 bar 包，因此，xmake 会优先安装 bar，并且让 cmake.install 在调用 cmake 时候，自动找到 bar 安装后的库。</p>
<p>但是，如果 foo 的 CMakeLists.txt 还是无法自动找到 bar，那么我们可以修改成下面的配置，强制将 bar 的 includedirs/links 等信息通过 flags 的方式，传入 foo。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;foo&quot;, function()
    add_deps(&quot;cmake&quot;, &quot;bar&quot;)
    on_install(function (package)
        local configs = {}
        import(&quot;package.tools.cmake&quot;).install(package, configs, {packages = &quot;bar&quot;})
    end)
end)
</code></pre>
<h2 id="package%3Aadd_components">package:add_components</h2>
<p>用于支持包的组件化配置，详情见：<a href="https://github.com/xmake-io/xmake/issues/2636"  target="_blank">#2636</a>。</p>
<p>通过这个接口，我们可以配置当前包实际可以提供的组件列表。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;sfml&quot;, function()
    add_components(&quot;graphics&quot;)
    add_components(&quot;audio&quot;, &quot;network&quot;, &quot;window&quot;)
    add_components(&quot;system&quot;)
end)
</code></pre>
<p>在用户端，我们可以通过下面的方式来使用包的特定组件。</p>

<pre class="language-lua"><code class="language-lua">add_requires(&quot;sfml&quot;)

target(&quot;test&quot;, function()
    add_packages(&quot;sfml&quot;, {components = &quot;graphics&quot;)
end)
</code></pre>
<blockquote>
<p>注：除了配置可用的组件列表，我们还需要对每个组件进行详细配置，才能正常使用，因此，它通常和 <code>on_component</code> 接口配合使用。</p>
</blockquote>
<p>一个关于包组件的配置和使用的完整例子见：<a href="https://github.com/xmake-io/xmake/blob/master/tests/projects/package/components/xmake.lua"  target="_blank">components example</a></p>
<h2 id="package%3Aset_base">package:set_base</h2>
<p>继承包配置。</p>
<p>这是 2.6.4 新加的接口，我们可以通过它去继承一个已有的包的全部配置，然后在此基础上重写部分配置。</p>
<p>这通常在用户自己的项目中，修改 xmake-repo 官方仓库的内置包比较有用，比如：修复改 urls，修改版本列表，安装逻辑等等。</p>
<p>例如，修改内置 zlib 包的 url，切到自己的 zlib 源码地址。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;myzlib&quot;, function()
    set_base(&quot;zlib&quot;)
    set_urls(&quot;https://github.com/madler/zlib.git&quot;)
end)

add_requires(&quot;myzlib&quot;, {system = false, alias = &quot;zlib&quot;})

target(&quot;test&quot;, function()
    set_kind(&quot;binary&quot;)
    add_files(&quot;src/*.c&quot;)
    add_packages(&quot;zlib&quot;)
end)
</code></pre>
<p>我们也可以用来单纯添加一个别名包。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;onetbb&quot;, function()
    set_base(&quot;tbb&quot;)
end)
</code></pre>
<p>我们可以通过 <code>add_requires(&quot;onetbb&quot;)</code> 集成安装 tbb 包，只是包名不同而已。</p>
<h2 id="package%3Aon_load">package:on_load</h2>
<p>加载包配置。</p>
<p>这是个可选的接口，如果要更加灵活的动态判断各种平台架构，针对性做设置，可以在这个里面完成，例如：</p>

<pre class="language-lua"><code class="language-lua">on_load(function (package)
    local bitwidth = package:config(&quot;bitwidth&quot;) or &quot;8&quot;
    package:add(&quot;links&quot;, &quot;pcre&quot; .. (bitwidth ~= &quot;8&quot; and bitwidth or &quot;&quot;))
    if not package:config(&quot;shared&quot;) then
        package:add(&quot;defines&quot;, &quot;PCRE_STATIC&quot;)
    end
end)
</code></pre>
<p>pcre 包需要做一些针对 bitwidth 的判断，才能确定对外输出的链接库名字，还需要针对动态库增加一些 defines 导出，这个时候在 on_load 里面设置，就更加灵活了。</p>
<h2 id="package%3Aon_fetch">package:on_fetch</h2>
<p>从系统中查找库。</p>
<p>这是个可选配置，2.5.2 之后，如果不同系统下安装的系统库，仅仅只是包名不同，那么使用 <code>add_extsources</code> 改进系统库查找已经足够，简单方便。</p>
<p>但是如果有些安装到系统的包，位置更加复杂，想要找到它们，也许需要一些额外的脚本才能实现，例如：windows 下注册表的访问去查找包等等，这个时候，我们就可以通过 <code>on_fetch</code> 完全定制化查找系统库逻辑。</p>
<p>还是以 libusb 为例，我们不用 <code>add_extsources</code>，可以使用下面的方式，实现相同的效果，当然，我们可以在里面做更多的事情。</p>

<pre class="language-none"><code class="language-none">package(&quot;libusb&quot;)
    on_fetch(&quot;linux&quot;, function(package, opt)
        if opt.system then
            return find_package(&quot;pkgconfig::libusb-1.0&quot;)
        end
    end)
</code></pre>
<h2 id="package%3Aon_check">package:on_check</h2>
<p>检测包是否支持当前平台。</p>
<p>有时候，单纯用 <code>on_install(&quot;windows&quot;, &quot;android&quot;, function () end)</code> 无法很好的限制包对当前平台的支持力度。</p>
<p>例如，同样都是在 windows 上使用 msvc 编译，但是它仅仅只支持使用 vs2022 工具链。那么我们无法简单的去通过禁用 windows 平台，来限制包的安装。</p>
<p>因为每个用户的编译工具链环境都可能是不同的。这个时候，我们可以通过配置 <code>on_check</code> 去做更细致的检测，来判断包是否支持当前的工具链环境。</p>
<p>如果包不被支持，那么它会在包被下载安装前，更早的提示用户，也可以在 xmake-repo 的 ci 上，规避掉一些不支持的 ci job 测试。</p>
<p>例如，下面的配置，就可以判断当前的 msvc 是否提供了对应的 vs sdk 版本，如果版本不满足，那么这个包就无法被编译安装，用户会看到更加可读的不支持的错误提示。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;test&quot;, function()
    on_check(&quot;windows&quot;, function (package)
        import(&quot;core.tool.toolchain&quot;)
        import(&quot;core.base.semver&quot;)
        local msvc = toolchain.load(&quot;msvc&quot;, {plat = package:plat(), arch = package:arch()})
        if msvc then
            local vs_sdkver = msvc:config(&quot;vs_sdkver&quot;)
            assert(vs_sdkver and semver.match(vs_sdkver):gt(&quot;10.0.19041&quot;), &quot;package(cglm): need vs_sdkver &gt; 10.0.19041.0&quot;)
        end
    end)
end)S
</code></pre>
<p>例如，我们也可以用它来判断，当前编译器对 c++20 的支持力度，如果不支持 c++20 才有的 std::input_iterator。那么这个包就没必要继续下载编译安装。</p>
<p>用户会看到 <code>Require at least C++20.</code> 的错误，来提示用户取升级自己的编译器。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;test&quot;, function()
    on_check(function (package)
        assert(package:check_cxxsnippets({test = [[
            #include &lt;cstddef&gt;
            #include &lt;iterator&gt;
            struct SimpleInputIterator {
                using difference_type = std::ptrdiff_t;
                using value_type = int;
                int operator*() const;
                SimpleInputIterator&amp; operator++();
                void operator++(int) { ++*this; }
            };
            static_assert(std::input_iterator&lt;SimpleInputIterator&gt;);
        ]]}, {configs = {languages = &quot;c++20&quot;}}), &quot;Require at least C++20.&quot;)
    end)
end)
</code></pre>
<h2 id="package%3Aon_install">package:on_install</h2>
<p>安装包。</p>
<p>这个接口主要用于添加安装脚本，前面的字符串参数用于设置支持的平台，像 <code>on_load</code>, <code>on_test</code> 等其他脚本域也是同样支持的。</p>
<p>完整的过滤语法如下：<code>plat|arch1,arch2@host|arch1,arch2</code></p>
<p>看上去非常的复杂，其实很简单，其中每个阶段都是可选的，可部分省略，对应：<code>编译平台 | 编译架构 @主机平台 | 主机架构</code></p>
<p>如果不设置任何平台过滤条件，那么默认全平台支持，里面的脚本对所有平台生效，例如：</p>

<pre class="language-lua"><code class="language-lua">on_install(function (package)
    -- TODO
end)
</code></pre>
<p>如果安装脚本对特定平台生效，那么直接指定对应的编译平台，可以同时指定多个：</p>

<pre class="language-lua"><code class="language-lua">on_install(&quot;linux&quot;, &quot;macosx&quot;, function (package)
    -- TODO
end)
</code></pre>
<p>如果还要细分到指定架构才能生效，可以这么写：</p>

<pre class="language-lua"><code class="language-lua">on_install(&quot;linux|x86_64&quot;, &quot;iphoneos|arm64&quot;, function (package)
    -- TODO
end)
</code></pre>
<p>如果还要限制执行的主机环境平台和架构，可以在后面追加 <code>@host|arch</code>，例如：</p>

<pre class="language-lua"><code class="language-lua">on_install(&quot;mingw@windows&quot;, function (package)
    -- TODO
end)
</code></pre>
<p>意思就是仅对 windows 下编译 mingw 平台生效。</p>
<p>我们也可以不指定比那一平台和架构，仅设置主机平台和架构，这通常用于描述一些跟编译工具相关的依赖包，只能在主机环境运行。</p>
<p>例如，我们编译的包，依赖了 cmake，需要添加 cmake 的包描述，那么里面编译安装环境，只能是主机平台：</p>

<pre class="language-lua"><code class="language-lua">on_install(&quot;@windows&quot;, &quot;@linux&quot;, &quot;@macosx&quot;, function (package)
    -- TODO
end)
</code></pre>
<p>其他一些例子：</p>

<pre class="language-lua"><code class="language-lua">-- `@linux`
-- `@linux|x86_64`
-- `@macosx,linux`
-- `android@macosx,linux`
-- `android|armeabi-v7a@macosx,linux`
-- `android|armeabi-v7a@macosx,linux|x86_64`
-- `android|armeabi-v7a@linux|x86_64`
</code></pre>
<p>在 2.8.7 中，我们改进了模式匹配支持，新增排除指定平台和架构，例如：</p>

<pre class="language-none"><code class="language-none">!plat|!arch@!subhost|!subarch
</code></pre>

<pre class="language-lua"><code class="language-lua">@!linux
@!linux|x86_64
@!macosx,!linux
!android@macosx,!linux
android|!armeabi-v7a@macosx,!linux
android|armeabi-v7a,!iphoneos@macosx,!linux|x86_64
!android|armeabi-v7a@!linux|!x86_64
!linux|*
</code></pre>
<p>同时，还提供了一个内置的 <code>native</code> 架构，用于匹配当前平台的本地架构，主要用于指定或者排除交叉编译平台。</p>

<pre class="language-lua"><code class="language-lua">on_install(&quot;macosx|native&quot;, ...)
</code></pre>
<p>上面的配置，如果在 macOS x86_64 的设备上，它仅仅只会匹配 <code>xmake f -a x86_64</code> 的本地架构编译。</p>
<p>如果是 <code>xmake f -a arm64</code> 交叉编译，就不会被匹配到。</p>
<p>同理，如果只想匹配交叉编译，可以使用 <code>macosx|!native</code> 进行取反排除就行了。</p>
<p>2.9.1 版本，我们继续对它做了改进，增加了条件逻辑判断的支持：</p>
<p>例如：</p>

<pre class="language-lua"><code class="language-lua">on_install(&quot;!wasm|!arm* and !cross|!arm*&quot;, function (package)
end)
</code></pre>
<p>来表述排除 wasm 和 cross 平台之外的 arm 架构。</p>
<p>并且，它也支持通过 <code>()</code> 描述的嵌套逻辑，<code>a and b or (a and (c or d))</code>。</p>
<p>我们内置了一些安装常用编译工具脚本，用于针对不同源码依赖的构建工具链，进行方便的构架支持，例如：autoconf, cmake, meson 等，</p>
<p>如果是基于 xmake 的依赖包，那么集成起来就非常简单了，xmake 对其做了非常好的内置集成支持，可以直接对其进行跨平台编译支持，一般情况下只需要：</p>

<pre class="language-lua"><code class="language-lua">on_install(function (package)
    import(&quot;package.tools.xmake&quot;).install(package)
end)
</code></pre>
<p>如果要传递一些特有的编译配置参数：</p>

<pre class="language-lua"><code class="language-lua">on_install(function (package)
    import(&quot;package.tools.xmake&quot;).install(package, {&quot;--xxx=y&quot;})
end)
</code></pre>
<p>如果是基于 cmake 的包，集成起来也很简答，通常也只需要设置一些配置参数即可，不过还需要先添加上 cmake 的依赖才行：</p>

<pre class="language-lua"><code class="language-lua">add_deps(&quot;cmake&quot;)
on_install(function (package)
    import(&quot;package.tools.cmake&quot;).install(package, {&quot;-Dxxx=ON&quot;})
end)
</code></pre>
<p>如果是基于 autoconf 的包，集成方式跟 cmake 类似，只是传递的配置参数不同而已，不过通常情况下，unix 系统都内置了 autoconf 系列工具，所以不加相关依赖也没事。</p>

<pre class="language-lua"><code class="language-lua">on_install(function (package)
    import(&quot;package.tools.autoconf&quot;).install(package, {&quot;--enable-shared=no&quot;})
end)
</code></pre>
<p>不过，有些源码包用系统内置的 autoconf 可能不能完全满足，那么可以加上 autoconf 系列依赖，对其进行构建：</p>

<pre class="language-lua"><code class="language-lua">add_deps(&quot;autoconf&quot;, &quot;automake&quot;, &quot;libtool&quot;, &quot;pkg-config&quot;)
on_install(function (package)
    import(&quot;package.tools.autoconf&quot;).install(package, {&quot;--enable-shared=no&quot;})
end)
</code></pre>
<p>如果是 meson，还需要加上 ninja 的依赖来执行构建才行。</p>

<pre class="language-lua"><code class="language-lua">add_deps(&quot;meson&quot;, &quot;ninja&quot;)
on_install(function (package)
    import(&quot;package.tools.meson&quot;).install(package, {&quot;-Dxxx=ON&quot;})
end)
</code></pre>
<h2 id="package%3Aon_test">package:on_test</h2>
<p>测试包。</p>
<p>安装后，需要设置对应的测试脚本，执行一些测试，确保安装包的可靠性，如果测试不通过，则会撤销整个安装包。</p>

<pre class="language-lua"><code class="language-lua">on_test(function (package)
    assert(package:has_cfuncs(&quot;inflate&quot;, {includes = &quot;zlib.h&quot;}))
end)
</code></pre>
<p>上面的脚本调用包内置的 <code>has_cfuncs</code> 接口，检测安装后的包是否存在 zlib.h 头文件，以及库和头文件里面是否存在 <code>inflate</code> 这个接口函数。</p>
<p>xmake 会去尝试编译链接来做测试，<code>has_cfuncs</code> 用于检测 c 函数，而 <code>has_cxxfuncs</code> 则可以检测 c++ 库函数。</p>
<p>而 includes 里面可以设置多个头文件，例如：<code>includes = {&quot;xxx.h&quot;, &quot;yyy.h&quot;}</code></p>
<p>我们还可以传递一些自己的编译参数进去检测，例如：</p>

<pre class="language-lua"><code class="language-lua">on_test(function (package)
    assert(package:has_cxxfuncs(&quot;func1&quot;, {includes = &quot;xxx.h&quot;, configs = {defines = &quot;c++14&quot;, cxflags = &quot;-Dxxx&quot;}}))
end)
</code></pre>
<p>我们也可以通过 <code>check_csnippets</code> 和 <code>check_cxxsnippets</code> 检测一个代码片段：</p>

<pre class="language-lua"><code class="language-lua">on_test(function (package)
    assert(package:check_cxxsnippets({test = [[
        #include &lt;boost/algorithm/string.hpp&gt;
        #include &lt;string&gt;
        #include &lt;vector&gt;
        #include &lt;assert.h&gt;
        using namespace boost::algorithm;
        using namespace std;
        static void test() {
            string str(&quot;a,b&quot;);
            vector&lt;string&gt; strVec;
            split(strVec, str, is_any_of(&quot;,&quot;));
            assert(strVec.size()==2);
            assert(strVec[0]==&quot;a&quot;);
            assert(strVec[1]==&quot;b&quot;);
        }
    ]]}, {configs = {languages = &quot;c++14&quot;}}))
end)
</code></pre>
<p>如果是可执行包，也可以通过尝试运行来检测：</p>

<pre class="language-lua"><code class="language-lua">on_test(function (package)
    os.run(&quot;xxx --help&quot;)
end)
</code></pre>
<p>如果运行失败，那么测试不会通过。</p>
<h2 id="package%3Aon_download">package:on_download</h2>
<p>自定义下载包。</p>
<p>自定义包的下载逻辑，这是 2.6.4 新加的接口，通常用不到，使用 Xmake 的内置下载就足够了。</p>
<p>如果用户自建私有仓库，对包的下载有更复杂的鉴权机制，特殊处理逻辑，那么可以重写内部的下载逻辑来实现。</p>

<pre class="language-lua"><code class="language-lua">on_download(function (package, opt)
    local url = opt.url
    local sourcedir = opt.sourcedir

    -- download url to the current directory
    -- and extract it's source code to sourcedir
    -- ...
end)
</code></pre>
<p>opt 参数里面，可以获取到下载包的目的源码目录 <code>opt.sourcedir</code>，我们只需要从 <code>opt.url</code> 获取到包地址，下载下来就可以了。</p>
<p>然后，根据需要，添加一些自定义的处理逻辑。另外，自己可以添加下载缓存处理等等。</p>
<p>下面是一个自定义下载 tar.gz 文件，并且实现缓存和源文件目录解压的例子，可以参考下：</p>

<pre class="language-lua"><code class="language-lua">package(&quot;zlib&quot;, function()
    add_urls(&quot;https://github.com/madler/zlib/archive/$(version).tar.gz&quot;)
    add_versions(&quot;v1.2.10&quot;, &quot;42cd7b2bdaf1c4570e0877e61f2fdc0bce8019492431d054d3d86925e5058dc5&quot;)

    on_download(function (package, opt)
        import(&quot;net.http&quot;)
        import(&quot;utils.archive&quot;)

        local url = opt.url
        local sourcedir = opt.sourcedir
        local packagefile = path.filename(url)
        local sourcehash = package:sourcehash(opt.url_alias)

        local cached = true
        if not os.isfile(packagefile) or sourcehash ~= hash.sha256(packagefile) then
            cached = false

            -- attempt to remove package file first
            os.tryrm(packagefile)
            http.download(url, packagefile)

            -- check hash
            if sourcehash and sourcehash ~= hash.sha256(packagefile) then
                raise(&quot;unmatched checksum, current hash(%s) != original hash(%s)&quot;, hash.sha256(packagefile):sub(1, 8), sourcehash:sub(1, 8))
            end
        end

        -- extract package file
        local sourcedir_tmp = sourcedir .. &quot;.tmp&quot;
        os.rm(sourcedir_tmp)
        if archive.extract(packagefile, sourcedir_tmp) then
            os.rm(sourcedir)
            os.mv(sourcedir_tmp, sourcedir)
        else
            -- if it is not archive file, we need only create empty source file and use package:originfile()
            os.tryrm(sourcedir)
            os.mkdir(sourcedir)
        end

        -- save original file path
        package:originfile_set(path.absolute(packagefile))
    end)
end)
</code></pre>
<p>自定义下载需要用户完全自己控制下载逻辑，会比较复杂，除非必要，不推荐这么做。</p>
<p>如果仅仅只是想增加自定义 http headers 去获取下载授权，可以使用 <a href="https://xmake.io/#/zh-cn/manual/project_target?id=%e8%ae%be%e7%bd%ae%e5%8c%85%e4%b8%8b%e8%bd%bd%e7%9a%84-http-headers"  target="_blank">设置包下载的 http headers</a></p>
<h2 id="package%3Aon_component">package:on_component</h2>
<p>配置包组件。</p>
<p>这是 2.7.3 新加的接口，用于支持包的组件化配置，详情见：<a href="https://github.com/xmake-io/xmake/issues/2636"  target="_blank">#2636</a>。</p>
<p>通过这个接口，我们可以配置当前包，指定组件的详细信息，比如组件的链接，依赖等等。</p>
<h3 id="%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6%E9%93%BE%E6%8E%A5%E4%BF%A1%E6%81%AF">配置组件链接信息</h3>

<pre class="language-lua"><code class="language-lua">package(&quot;sfml&quot;)
    add_components(&quot;graphics&quot;)
    add_components(&quot;audio&quot;, &quot;network&quot;, &quot;window&quot;)
    add_components(&quot;system&quot;)

    on_component(&quot;graphics&quot;, function (package, component)
        local e = package:config(&quot;shared&quot;) and &quot;&quot;or&quot;-s&quot;
        component:add(&quot;links&quot;, &quot;sfml-graphics&quot; .. e)
        if package:is_plat(&quot;windows&quot;, &quot;mingw&quot;) and not package:config(&quot;shared&quot;) then
            component:add(&quot;links&quot;, &quot;freetype&quot;)
            component:add(&quot;syslinks&quot;, &quot;opengl32&quot;, &quot;gdi32&quot;, &quot;user32&quot;, &quot;advapi32&quot;)
        end
    end)

    on_component(&quot;window&quot;, function (package, component)
        local e = package:config(&quot;shared&quot;) and &quot;&quot;or&quot;-s&quot;
        component:add(&quot;links&quot;, &quot;sfml-window&quot; .. e)
        if package:is_plat(&quot;windows&quot;, &quot;mingw&quot;) and not package:config(&quot;shared&quot;) then
            component:add(&quot;syslinks&quot;, &quot;opengl32&quot;, &quot;gdi32&quot;, &quot;user32&quot;, &quot;advapi32&quot;)
        end
    end)

    ...
</code></pre>
<p>在用户端，我们可以通过下面的方式来使用包的特定组件。</p>

<pre class="language-lua"><code class="language-lua">add_requires(&quot;sfml&quot;)

target(&quot;test&quot;)
    add_packages(&quot;sfml&quot;, {components = &quot;graphics&quot;)
</code></pre>
<blockquote>
<p>注：除了配置组件信息，我们还需要配置可用的组件列表，才能正常使用，因此，它通常和 <code>add_components</code> 接口配合使用。</p>
</blockquote>
<p>一个关于包组件的配置和使用的完整例子见：<a href="https://github.com/xmake-io/xmake/blob/master/tests/projects/package/components/xmake.lua"  target="_blank">components example</a></p>
<h3 id="%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%BF%A1%E6%81%AF">配置组件的编译信息</h3>
<p>我们不仅可以配置每个组件的链接信息，还有 includedirs, defines 等等编译信息，我们也可以对每个组件单独配置。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;sfml&quot;)
    on_component(&quot;graphics&quot;, function (package, component)
        package:add(&quot;defines&quot;, &quot;TEST&quot;)
    end)
</code></pre>
<h3 id="%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6%E4%BE%9D%E8%B5%96">配置组件依赖</h3>

<pre class="language-lua"><code class="language-lua">package(&quot;sfml&quot;, function()
    add_components(&quot;graphics&quot;)
    add_components(&quot;audio&quot;, &quot;network&quot;, &quot;window&quot;)
    add_components(&quot;system&quot;)

    on_component(&quot;graphics&quot;, function (package, component)
          component:add(&quot;deps&quot;, &quot;window&quot;, &quot;system&quot;)
    end)
end)
</code></pre>
<p>上面的配置，告诉包，我们的 graphics 组件还会额外依赖 <code>window</code> 和 <code>system</code> 两个组件。</p>
<p>因此，在用户端，我们对 graphics 的组件使用，可以从</p>

<pre class="language-lua"><code class="language-lua">    add_packages(&quot;sfml&quot;, {components = {&quot;graphics&quot;, &quot;window&quot;, &quot;system&quot;})
</code></pre>
<p>简化为：</p>

<pre class="language-lua"><code class="language-lua">    add_packages(&quot;sfml&quot;, {components = &quot;graphics&quot;)
</code></pre>
<p>因为，只要我们开启了 graphics 组件，它也会自动启用依赖的 window 和 system 组件。</p>
<p>另外，我们也可以通过 <code>add_components(&quot;graphics&quot;, {deps = {&quot;window&quot;, &quot;system&quot;}})</code> 来配置组件依赖关系。</p>
<h3 id="%E4%BB%8E%E7%B3%BB%E7%BB%9F%E5%BA%93%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%BB%84%E4%BB%B6">从系统库中查找组件</h3>
<p>我们知道，在包配置中，配置 <code>add_extsources</code> 可以改进包在系统中的查找，比如从 apt/pacman 等系统包管理器中找库。</p>
<p>当然，我们也可以让每个组件也能通过 <code>extsources</code> 配置，去优先从系统库中找到它们。</p>
<p>例如，sfml 包，它在 homebrew 中其实也是组件化的，我们完全可以让包从系统库中，找到对应的每个组件，而不需要每次源码安装它们。</p>

<pre class="language-bash"><code class="language-bash">$ ls -l /usr/local/opt/sfml/lib/pkgconfig
-r--r--r--  1 ruki  admin  317 10 19 17:52 sfml-all.pc
-r--r--r--  1 ruki  admin  534 10 19 17:52 sfml-audio.pc
-r--r--r--  1 ruki  admin  609 10 19 17:52 sfml-graphics.pc
-r--r--r--  1 ruki  admin  327 10 19 17:52 sfml-network.pc
-r--r--r--  1 ruki  admin  302 10 19 17:52 sfml-system.pc
-r--r--r--  1 ruki  admin  562 10 19 17:52 sfml-window.pc
</code></pre>
<p>我们只需要，对每个组件配置它的 extsources：</p>

<pre class="language-lua"><code class="language-lua">    if is_plat(&quot;macosx&quot;) then
        add_extsources(&quot;brew::sfml/sfml-all&quot;)
    end

    on_component(&quot;graphics&quot;, function (package, component)
        -- ...
        component:add(&quot;extsources&quot;, &quot;brew::sfml/sfml-graphics&quot;)
    end)
</code></pre>
<h3 id="%E9%BB%98%E8%AE%A4%E7%9A%84%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E9%85%8D%E7%BD%AE">默认的全局组件配置</h3>
<p>除了通过指定组件名的方式，配置特定组件，如果我们没有指定组件名，默认就是全局配置所有组件。</p>

<pre class="language-lua"><code class="language-lua">package(&quot;sfml&quot;, function()
    on_component(function (package, component)
        -- configure all components
    end)
end)
</code></pre>
<p>当然，我们也可以通过下面的方式，指定配置 graphics 组件，剩下的组件通过默认的全局配置接口进行配置：</p>

<pre class="language-lua"><code class="language-lua">package(&quot;sfml&quot;, function()
    add_components(&quot;graphics&quot;)
    add_components(&quot;audio&quot;, &quot;network&quot;, &quot;window&quot;)
    add_components(&quot;system&quot;)

    on_component(&quot;graphics&quot;, function (package, component)
        -- configure graphics
    end)

    on_component(function (package, component)
        -- component audio, network, window, system
    end)
end)
</code></pre>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/get_started/zh/option/description-scope.html">
                            <span class="icon"></span>
                            <span class="label">描述域</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/get_started/zh/package/local-package.html">
                            <span class="label">使用本地包</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>链接</a><ul><li><a target="_blank" href="https://teedoc.neucrack.com">使用 teedoc 构建</a></li>
<li><a  href="/sitemap.xml">网站地图</a></li>
</ul>
</li>
<li><a>源码</a><ul><li><a target="_blank" href="https://github.com/neutree/teedoc">github</a></li>
<li><a target="_blank" href="https://gitee.com/teedoc/teedoc">gitee</a></li>
<li><a target="_blank" href="https://github.com/teedoc/teedoc.github.io">本网站源文件</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://beian.miit.gov.cn">*ICP备********号</a></li>
<li><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=****************">*公网安备***********号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script src="/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/static/js/theme_default/main.js"></script>
    
        <script src="/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/static/css/theme_default/prism.min.js"></script>
    
        <script src="/static/js/search/search_main.js"></script>
    
        <script src="/static/js/plugin_blog/main.js"></script>
    
        <script src="/static/js/custom.js"></script>
    
</body>

</html>